"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/vis-network";
exports.ids = ["vendor-chunks/vis-network"];
exports.modules = {

/***/ "(ssr)/./node_modules/vis-network/peer/esm/vis-network.js":
/*!**********************************************************!*\
  !*** ./node_modules/vis-network/peer/esm/vis-network.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Network: () => (/* binding */ Network),\n/* harmony export */   NetworkImages: () => (/* binding */ Images),\n/* harmony export */   networkDOTParser: () => (/* binding */ dotparser),\n/* harmony export */   networkGephiParser: () => (/* binding */ gephiParser),\n/* harmony export */   networkOptions: () => (/* binding */ options),\n/* harmony export */   parseDOTNetwork: () => (/* binding */ parseDOTNetwork),\n/* harmony export */   parseGephiNetwork: () => (/* binding */ parseGephi)\n/* harmony export */ });\n/* harmony import */ var vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vis-data/peer/esm/vis-data.js */ \"(ssr)/./node_modules/vis-data/peer/esm/vis-data.js\");\n/**\n * vis-network\n * https://visjs.github.io/vis-network/\n *\n * A dynamic, browser-based visualization library.\n *\n * @version 9.1.9\n * @date    2023-11-03T01:42:27.418Z\n *\n * @copyright (c) 2011-2017 Almende B.V, http://almende.com\n * @copyright (c) 2017-2019 visjs contributors, https://github.com/visjs\n *\n * @license\n * vis.js is dual licensed under both\n *\n *   1. The Apache 2.0 License\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *   and\n *\n *   2. The MIT License\n *      http://opensource.org/licenses/MIT\n *\n * vis.js may be distributed under either license.\n */\n\n\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar check = function (it) {\n  return it && it.Math === Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global$n =\n  // eslint-disable-next-line es/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || commonjsGlobal || Function('return this')();\n\nvar fails$w = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n\nvar fails$v = fails$w;\n\nvar functionBindNative = !fails$v(function () {\n  // eslint-disable-next-line es/no-function-prototype-bind -- safe\n  var test = (function () { /* empty */ }).bind();\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\nvar NATIVE_BIND$4 = functionBindNative;\n\nvar FunctionPrototype$4 = Function.prototype;\nvar apply$5 = FunctionPrototype$4.apply;\nvar call$f = FunctionPrototype$4.call;\n\n// eslint-disable-next-line es/no-reflect -- safe\nvar functionApply = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND$4 ? call$f.bind(apply$5) : function () {\n  return call$f.apply(apply$5, arguments);\n});\n\nvar NATIVE_BIND$3 = functionBindNative;\n\nvar FunctionPrototype$3 = Function.prototype;\nvar call$e = FunctionPrototype$3.call;\nvar uncurryThisWithBind = NATIVE_BIND$3 && FunctionPrototype$3.bind.bind(call$e, call$e);\n\nvar functionUncurryThis = NATIVE_BIND$3 ? uncurryThisWithBind : function (fn) {\n  return function () {\n    return call$e.apply(fn, arguments);\n  };\n};\n\nvar uncurryThis$x = functionUncurryThis;\n\nvar toString$c = uncurryThis$x({}.toString);\nvar stringSlice$1 = uncurryThis$x(''.slice);\n\nvar classofRaw$2 = function (it) {\n  return stringSlice$1(toString$c(it), 8, -1);\n};\n\nvar classofRaw$1 = classofRaw$2;\nvar uncurryThis$w = functionUncurryThis;\n\nvar functionUncurryThisClause = function (fn) {\n  // Nashorn bug:\n  //   https://github.com/zloirock/core-js/issues/1128\n  //   https://github.com/zloirock/core-js/issues/1130\n  if (classofRaw$1(fn) === 'Function') return uncurryThis$w(fn);\n};\n\nvar documentAll$2 = typeof document == 'object' && document.all;\n\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\n// eslint-disable-next-line unicorn/no-typeof-undefined -- required for testing\nvar IS_HTMLDDA = typeof documentAll$2 == 'undefined' && documentAll$2 !== undefined;\n\nvar documentAll_1 = {\n  all: documentAll$2,\n  IS_HTMLDDA: IS_HTMLDDA\n};\n\nvar $documentAll$1 = documentAll_1;\n\nvar documentAll$1 = $documentAll$1.all;\n\n// `IsCallable` abstract operation\n// https://tc39.es/ecma262/#sec-iscallable\nvar isCallable$i = $documentAll$1.IS_HTMLDDA ? function (argument) {\n  return typeof argument == 'function' || argument === documentAll$1;\n} : function (argument) {\n  return typeof argument == 'function';\n};\n\nvar objectGetOwnPropertyDescriptor = {};\n\nvar fails$u = fails$w;\n\n// Detect IE8's incomplete defineProperty implementation\nvar descriptors = !fails$u(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] !== 7;\n});\n\nvar NATIVE_BIND$2 = functionBindNative;\n\nvar call$d = Function.prototype.call;\n\nvar functionCall = NATIVE_BIND$2 ? call$d.bind(call$d) : function () {\n  return call$d.apply(call$d, arguments);\n};\n\nvar objectPropertyIsEnumerable = {};\n\nvar $propertyIsEnumerable$1 = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$9 = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor$9 && !$propertyIsEnumerable$1.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nobjectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor$9(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable$1;\n\nvar createPropertyDescriptor$5 = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\nvar uncurryThis$v = functionUncurryThis;\nvar fails$t = fails$w;\nvar classof$e = classofRaw$2;\n\nvar $Object$5 = Object;\nvar split = uncurryThis$v(''.split);\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar indexedObject = fails$t(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !$Object$5('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof$e(it) === 'String' ? split(it, '') : $Object$5(it);\n} : $Object$5;\n\n// we can't use just `it == null` since of `document.all` special case\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot-aec\nvar isNullOrUndefined$6 = function (it) {\n  return it === null || it === undefined;\n};\n\nvar isNullOrUndefined$5 = isNullOrUndefined$6;\n\nvar $TypeError$g = TypeError;\n\n// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nvar requireObjectCoercible$5 = function (it) {\n  if (isNullOrUndefined$5(it)) throw new $TypeError$g(\"Can't call method on \" + it);\n  return it;\n};\n\n// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject$3 = indexedObject;\nvar requireObjectCoercible$4 = requireObjectCoercible$5;\n\nvar toIndexedObject$a = function (it) {\n  return IndexedObject$3(requireObjectCoercible$4(it));\n};\n\nvar isCallable$h = isCallable$i;\nvar $documentAll = documentAll_1;\n\nvar documentAll = $documentAll.all;\n\nvar isObject$j = $documentAll.IS_HTMLDDA ? function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$h(it) || it === documentAll;\n} : function (it) {\n  return typeof it == 'object' ? it !== null : isCallable$h(it);\n};\n\nvar path$w = {};\n\nvar path$v = path$w;\nvar global$m = global$n;\nvar isCallable$g = isCallable$i;\n\nvar aFunction = function (variable) {\n  return isCallable$g(variable) ? variable : undefined;\n};\n\nvar getBuiltIn$c = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(path$v[namespace]) || aFunction(global$m[namespace])\n    : path$v[namespace] && path$v[namespace][method] || global$m[namespace] && global$m[namespace][method];\n};\n\nvar uncurryThis$u = functionUncurryThis;\n\nvar objectIsPrototypeOf = uncurryThis$u({}.isPrototypeOf);\n\nvar engineUserAgent = typeof navigator != 'undefined' && String(navigator.userAgent) || '';\n\nvar global$l = global$n;\nvar userAgent$2 = engineUserAgent;\n\nvar process = global$l.process;\nvar Deno = global$l.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  // in old Chrome, versions of V8 isn't V8 = Chrome / 10\n  // but their correct versions are not interesting for us\n  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\n\n// BrowserFS NodeJS `process` polyfill incorrectly set `.v8` to `0.0`\n// so check `userAgent` even if `.v8` exists, but 0\nif (!version && userAgent$2) {\n  match = userAgent$2.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent$2.match(/Chrome\\/(\\d+)/);\n    if (match) version = +match[1];\n  }\n}\n\nvar engineV8Version = version;\n\n/* eslint-disable es/no-symbol -- required for testing */\nvar V8_VERSION$2 = engineV8Version;\nvar fails$s = fails$w;\nvar global$k = global$n;\n\nvar $String$5 = global$k.String;\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nvar symbolConstructorDetection = !!Object.getOwnPropertySymbols && !fails$s(function () {\n  var symbol = Symbol('symbol detection');\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  // nb: Do not call `String` directly to avoid this being optimized out to `symbol+''` which will,\n  // of course, fail.\n  return !$String$5(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION$2 && V8_VERSION$2 < 41;\n});\n\n/* eslint-disable es/no-symbol -- required for testing */\nvar NATIVE_SYMBOL$5 = symbolConstructorDetection;\n\nvar useSymbolAsUid = NATIVE_SYMBOL$5\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n\nvar getBuiltIn$b = getBuiltIn$c;\nvar isCallable$f = isCallable$i;\nvar isPrototypeOf$k = objectIsPrototypeOf;\nvar USE_SYMBOL_AS_UID$1 = useSymbolAsUid;\n\nvar $Object$4 = Object;\n\nvar isSymbol$5 = USE_SYMBOL_AS_UID$1 ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  var $Symbol = getBuiltIn$b('Symbol');\n  return isCallable$f($Symbol) && isPrototypeOf$k($Symbol.prototype, $Object$4(it));\n};\n\nvar $String$4 = String;\n\nvar tryToString$6 = function (argument) {\n  try {\n    return $String$4(argument);\n  } catch (error) {\n    return 'Object';\n  }\n};\n\nvar isCallable$e = isCallable$i;\nvar tryToString$5 = tryToString$6;\n\nvar $TypeError$f = TypeError;\n\n// `Assert: IsCallable(argument) is true`\nvar aCallable$7 = function (argument) {\n  if (isCallable$e(argument)) return argument;\n  throw new $TypeError$f(tryToString$5(argument) + ' is not a function');\n};\n\nvar aCallable$6 = aCallable$7;\nvar isNullOrUndefined$4 = isNullOrUndefined$6;\n\n// `GetMethod` abstract operation\n// https://tc39.es/ecma262/#sec-getmethod\nvar getMethod$3 = function (V, P) {\n  var func = V[P];\n  return isNullOrUndefined$4(func) ? undefined : aCallable$6(func);\n};\n\nvar call$c = functionCall;\nvar isCallable$d = isCallable$i;\nvar isObject$i = isObject$j;\n\nvar $TypeError$e = TypeError;\n\n// `OrdinaryToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-ordinarytoprimitive\nvar ordinaryToPrimitive$1 = function (input, pref) {\n  var fn, val;\n  if (pref === 'string' && isCallable$d(fn = input.toString) && !isObject$i(val = call$c(fn, input))) return val;\n  if (isCallable$d(fn = input.valueOf) && !isObject$i(val = call$c(fn, input))) return val;\n  if (pref !== 'string' && isCallable$d(fn = input.toString) && !isObject$i(val = call$c(fn, input))) return val;\n  throw new $TypeError$e(\"Can't convert object to primitive value\");\n};\n\nvar shared$7 = {exports: {}};\n\nvar global$j = global$n;\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar defineProperty$f = Object.defineProperty;\n\nvar defineGlobalProperty$1 = function (key, value) {\n  try {\n    defineProperty$f(global$j, key, { value: value, configurable: true, writable: true });\n  } catch (error) {\n    global$j[key] = value;\n  } return value;\n};\n\nvar global$i = global$n;\nvar defineGlobalProperty = defineGlobalProperty$1;\n\nvar SHARED = '__core-js_shared__';\nvar store$3 = global$i[SHARED] || defineGlobalProperty(SHARED, {});\n\nvar sharedStore = store$3;\n\nvar store$2 = sharedStore;\n\n(shared$7.exports = function (key, value) {\n  return store$2[key] || (store$2[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.33.0',\n  mode: 'pure' ,\n  copyright: '© 2014-2023 Denis Pushkarev (zloirock.ru)',\n  license: 'https://github.com/zloirock/core-js/blob/v3.33.0/LICENSE',\n  source: 'https://github.com/zloirock/core-js'\n});\n\nvar sharedExports = shared$7.exports;\n\nvar requireObjectCoercible$3 = requireObjectCoercible$5;\n\nvar $Object$3 = Object;\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nvar toObject$e = function (argument) {\n  return $Object$3(requireObjectCoercible$3(argument));\n};\n\nvar uncurryThis$t = functionUncurryThis;\nvar toObject$d = toObject$e;\n\nvar hasOwnProperty = uncurryThis$t({}.hasOwnProperty);\n\n// `HasOwnProperty` abstract operation\n// https://tc39.es/ecma262/#sec-hasownproperty\n// eslint-disable-next-line es/no-object-hasown -- safe\nvar hasOwnProperty_1 = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty(toObject$d(it), key);\n};\n\nvar uncurryThis$s = functionUncurryThis;\n\nvar id$2 = 0;\nvar postfix = Math.random();\nvar toString$b = uncurryThis$s(1.0.toString);\n\nvar uid$4 = function (key) {\n  return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString$b(++id$2 + postfix, 36);\n};\n\nvar global$h = global$n;\nvar shared$6 = sharedExports;\nvar hasOwn$h = hasOwnProperty_1;\nvar uid$3 = uid$4;\nvar NATIVE_SYMBOL$4 = symbolConstructorDetection;\nvar USE_SYMBOL_AS_UID = useSymbolAsUid;\n\nvar Symbol$5 = global$h.Symbol;\nvar WellKnownSymbolsStore$2 = shared$6('wks');\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$5['for'] || Symbol$5 : Symbol$5 && Symbol$5.withoutSetter || uid$3;\n\nvar wellKnownSymbol$m = function (name) {\n  if (!hasOwn$h(WellKnownSymbolsStore$2, name)) {\n    WellKnownSymbolsStore$2[name] = NATIVE_SYMBOL$4 && hasOwn$h(Symbol$5, name)\n      ? Symbol$5[name]\n      : createWellKnownSymbol('Symbol.' + name);\n  } return WellKnownSymbolsStore$2[name];\n};\n\nvar call$b = functionCall;\nvar isObject$h = isObject$j;\nvar isSymbol$4 = isSymbol$5;\nvar getMethod$2 = getMethod$3;\nvar ordinaryToPrimitive = ordinaryToPrimitive$1;\nvar wellKnownSymbol$l = wellKnownSymbol$m;\n\nvar $TypeError$d = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol$l('toPrimitive');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\nvar toPrimitive$6 = function (input, pref) {\n  if (!isObject$h(input) || isSymbol$4(input)) return input;\n  var exoticToPrim = getMethod$2(input, TO_PRIMITIVE);\n  var result;\n  if (exoticToPrim) {\n    if (pref === undefined) pref = 'default';\n    result = call$b(exoticToPrim, input, pref);\n    if (!isObject$h(result) || isSymbol$4(result)) return result;\n    throw new $TypeError$d(\"Can't convert object to primitive value\");\n  }\n  if (pref === undefined) pref = 'number';\n  return ordinaryToPrimitive(input, pref);\n};\n\nvar toPrimitive$5 = toPrimitive$6;\nvar isSymbol$3 = isSymbol$5;\n\n// `ToPropertyKey` abstract operation\n// https://tc39.es/ecma262/#sec-topropertykey\nvar toPropertyKey$4 = function (argument) {\n  var key = toPrimitive$5(argument, 'string');\n  return isSymbol$3(key) ? key : key + '';\n};\n\nvar global$g = global$n;\nvar isObject$g = isObject$j;\n\nvar document$1 = global$g.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS$1 = isObject$g(document$1) && isObject$g(document$1.createElement);\n\nvar documentCreateElement$1 = function (it) {\n  return EXISTS$1 ? document$1.createElement(it) : {};\n};\n\nvar DESCRIPTORS$h = descriptors;\nvar fails$r = fails$w;\nvar createElement = documentCreateElement$1;\n\n// Thanks to IE8 for its funny defineProperty\nvar ie8DomDefine = !DESCRIPTORS$h && !fails$r(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a !== 7;\n});\n\nvar DESCRIPTORS$g = descriptors;\nvar call$a = functionCall;\nvar propertyIsEnumerableModule$2 = objectPropertyIsEnumerable;\nvar createPropertyDescriptor$4 = createPropertyDescriptor$5;\nvar toIndexedObject$9 = toIndexedObject$a;\nvar toPropertyKey$3 = toPropertyKey$4;\nvar hasOwn$g = hasOwnProperty_1;\nvar IE8_DOM_DEFINE$1 = ie8DomDefine;\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nobjectGetOwnPropertyDescriptor.f = DESCRIPTORS$g ? $getOwnPropertyDescriptor$2 : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject$9(O);\n  P = toPropertyKey$3(P);\n  if (IE8_DOM_DEFINE$1) try {\n    return $getOwnPropertyDescriptor$2(O, P);\n  } catch (error) { /* empty */ }\n  if (hasOwn$g(O, P)) return createPropertyDescriptor$4(!call$a(propertyIsEnumerableModule$2.f, O, P), O[P]);\n};\n\nvar fails$q = fails$w;\nvar isCallable$c = isCallable$i;\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced$1 = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value === POLYFILL ? true\n    : value === NATIVE ? false\n    : isCallable$c(detection) ? fails$q(detection)\n    : !!detection;\n};\n\nvar normalize = isForced$1.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced$1.data = {};\nvar NATIVE = isForced$1.NATIVE = 'N';\nvar POLYFILL = isForced$1.POLYFILL = 'P';\n\nvar isForced_1 = isForced$1;\n\nvar uncurryThis$r = functionUncurryThisClause;\nvar aCallable$5 = aCallable$7;\nvar NATIVE_BIND$1 = functionBindNative;\n\nvar bind$e = uncurryThis$r(uncurryThis$r.bind);\n\n// optional / simple context binding\nvar functionBindContext = function (fn, that) {\n  aCallable$5(fn);\n  return that === undefined ? fn : NATIVE_BIND$1 ? bind$e(fn, that) : function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\nvar objectDefineProperty = {};\n\nvar DESCRIPTORS$f = descriptors;\nvar fails$p = fails$w;\n\n// V8 ~ Chrome 36-\n// https://bugs.chromium.org/p/v8/issues/detail?id=3334\nvar v8PrototypeDefineBug = DESCRIPTORS$f && fails$p(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty(function () { /* empty */ }, 'prototype', {\n    value: 42,\n    writable: false\n  }).prototype !== 42;\n});\n\nvar isObject$f = isObject$j;\n\nvar $String$3 = String;\nvar $TypeError$c = TypeError;\n\n// `Assert: Type(argument) is Object`\nvar anObject$d = function (argument) {\n  if (isObject$f(argument)) return argument;\n  throw new $TypeError$c($String$3(argument) + ' is not an object');\n};\n\nvar DESCRIPTORS$e = descriptors;\nvar IE8_DOM_DEFINE = ie8DomDefine;\nvar V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;\nvar anObject$c = anObject$d;\nvar toPropertyKey$2 = toPropertyKey$4;\n\nvar $TypeError$b = TypeError;\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty$1 = Object.defineProperty;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE$1 = 'configurable';\nvar WRITABLE = 'writable';\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nobjectDefineProperty.f = DESCRIPTORS$e ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty(O, P, Attributes) {\n  anObject$c(O);\n  P = toPropertyKey$2(P);\n  anObject$c(Attributes);\n  if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n    var current = $getOwnPropertyDescriptor$1(O, P);\n    if (current && current[WRITABLE]) {\n      O[P] = Attributes.value;\n      Attributes = {\n        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],\n        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n        writable: false\n      };\n    }\n  } return $defineProperty$1(O, P, Attributes);\n} : $defineProperty$1 : function defineProperty(O, P, Attributes) {\n  anObject$c(O);\n  P = toPropertyKey$2(P);\n  anObject$c(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty$1(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw new $TypeError$b('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\nvar DESCRIPTORS$d = descriptors;\nvar definePropertyModule$3 = objectDefineProperty;\nvar createPropertyDescriptor$3 = createPropertyDescriptor$5;\n\nvar createNonEnumerableProperty$6 = DESCRIPTORS$d ? function (object, key, value) {\n  return definePropertyModule$3.f(object, key, createPropertyDescriptor$3(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\nvar global$f = global$n;\nvar apply$4 = functionApply;\nvar uncurryThis$q = functionUncurryThisClause;\nvar isCallable$b = isCallable$i;\nvar getOwnPropertyDescriptor$8 = objectGetOwnPropertyDescriptor.f;\nvar isForced = isForced_1;\nvar path$u = path$w;\nvar bind$d = functionBindContext;\nvar createNonEnumerableProperty$5 = createNonEnumerableProperty$6;\nvar hasOwn$f = hasOwnProperty_1;\n\nvar wrapConstructor = function (NativeConstructor) {\n  var Wrapper = function (a, b, c) {\n    if (this instanceof Wrapper) {\n      switch (arguments.length) {\n        case 0: return new NativeConstructor();\n        case 1: return new NativeConstructor(a);\n        case 2: return new NativeConstructor(a, b);\n      } return new NativeConstructor(a, b, c);\n    } return apply$4(NativeConstructor, this, arguments);\n  };\n  Wrapper.prototype = NativeConstructor.prototype;\n  return Wrapper;\n};\n\n/*\n  options.target         - name of the target object\n  options.global         - target is the global object\n  options.stat           - export as static methods of target\n  options.proto          - export as prototype methods of target\n  options.real           - real prototype method for the `pure` version\n  options.forced         - export even if the native feature is available\n  options.bind           - bind methods to the target, required for the `pure` version\n  options.wrap           - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe         - use the simple assignment of property instead of delete + defineProperty\n  options.sham           - add a flag to not completely full polyfills\n  options.enumerable     - export as enumerable property\n  options.dontCallGetSet - prevent calling a getter on target\n  options.name           - the .name of the function if it does not match the key\n*/\nvar _export = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var PROTO = options.proto;\n\n  var nativeSource = GLOBAL ? global$f : STATIC ? global$f[TARGET] : (global$f[TARGET] || {}).prototype;\n\n  var target = GLOBAL ? path$u : path$u[TARGET] || createNonEnumerableProperty$5(path$u, TARGET, {})[TARGET];\n  var targetPrototype = target.prototype;\n\n  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;\n  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;\n\n  for (key in source) {\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contains in native\n    USE_NATIVE = !FORCED && nativeSource && hasOwn$f(nativeSource, key);\n\n    targetProperty = target[key];\n\n    if (USE_NATIVE) if (options.dontCallGetSet) {\n      descriptor = getOwnPropertyDescriptor$8(nativeSource, key);\n      nativeProperty = descriptor && descriptor.value;\n    } else nativeProperty = nativeSource[key];\n\n    // export native or implementation\n    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];\n\n    if (USE_NATIVE && typeof targetProperty == typeof sourceProperty) continue;\n\n    // bind methods to global for calling from export context\n    if (options.bind && USE_NATIVE) resultProperty = bind$d(sourceProperty, global$f);\n    // wrap global constructors for prevent changes in this version\n    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);\n    // make static versions for prototype methods\n    else if (PROTO && isCallable$b(sourceProperty)) resultProperty = uncurryThis$q(sourceProperty);\n    // default case\n    else resultProperty = sourceProperty;\n\n    // add a flag to not completely full polyfills\n    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty$5(resultProperty, 'sham', true);\n    }\n\n    createNonEnumerableProperty$5(target, key, resultProperty);\n\n    if (PROTO) {\n      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';\n      if (!hasOwn$f(path$u, VIRTUAL_PROTOTYPE)) {\n        createNonEnumerableProperty$5(path$u, VIRTUAL_PROTOTYPE, {});\n      }\n      // export virtual prototype methods\n      createNonEnumerableProperty$5(path$u[VIRTUAL_PROTOTYPE], key, sourceProperty);\n      // export real prototype methods\n      if (options.real && targetPrototype && (FORCED || !targetPrototype[key])) {\n        createNonEnumerableProperty$5(targetPrototype, key, sourceProperty);\n      }\n    }\n  }\n};\n\nvar ceil = Math.ceil;\nvar floor$1 = Math.floor;\n\n// `Math.trunc` method\n// https://tc39.es/ecma262/#sec-math.trunc\n// eslint-disable-next-line es/no-math-trunc -- safe\nvar mathTrunc = Math.trunc || function trunc(x) {\n  var n = +x;\n  return (n > 0 ? floor$1 : ceil)(n);\n};\n\nvar trunc = mathTrunc;\n\n// `ToIntegerOrInfinity` abstract operation\n// https://tc39.es/ecma262/#sec-tointegerorinfinity\nvar toIntegerOrInfinity$4 = function (argument) {\n  var number = +argument;\n  // eslint-disable-next-line no-self-compare -- NaN check\n  return number !== number || number === 0 ? 0 : trunc(number);\n};\n\nvar toIntegerOrInfinity$3 = toIntegerOrInfinity$4;\n\nvar max$3 = Math.max;\nvar min$2 = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nvar toAbsoluteIndex$5 = function (index, length) {\n  var integer = toIntegerOrInfinity$3(index);\n  return integer < 0 ? max$3(integer + length, 0) : min$2(integer, length);\n};\n\nvar toIntegerOrInfinity$2 = toIntegerOrInfinity$4;\n\nvar min$1 = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nvar toLength$1 = function (argument) {\n  return argument > 0 ? min$1(toIntegerOrInfinity$2(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n\nvar toLength = toLength$1;\n\n// `LengthOfArrayLike` abstract operation\n// https://tc39.es/ecma262/#sec-lengthofarraylike\nvar lengthOfArrayLike$c = function (obj) {\n  return toLength(obj.length);\n};\n\nvar toIndexedObject$8 = toIndexedObject$a;\nvar toAbsoluteIndex$4 = toAbsoluteIndex$5;\nvar lengthOfArrayLike$b = lengthOfArrayLike$c;\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod$4 = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject$8($this);\n    var length = lengthOfArrayLike$b(O);\n    var index = toAbsoluteIndex$4(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el !== el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value !== value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nvar arrayIncludes = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod$4(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod$4(false)\n};\n\nvar hiddenKeys$6 = {};\n\nvar uncurryThis$p = functionUncurryThis;\nvar hasOwn$e = hasOwnProperty_1;\nvar toIndexedObject$7 = toIndexedObject$a;\nvar indexOf$4 = arrayIncludes.indexOf;\nvar hiddenKeys$5 = hiddenKeys$6;\n\nvar push$b = uncurryThis$p([].push);\n\nvar objectKeysInternal = function (object, names) {\n  var O = toIndexedObject$7(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !hasOwn$e(hiddenKeys$5, key) && hasOwn$e(O, key) && push$b(result, key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (hasOwn$e(O, key = names[i++])) {\n    ~indexOf$4(result, key) || push$b(result, key);\n  }\n  return result;\n};\n\n// IE8- don't enum bug keys\nvar enumBugKeys$3 = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n\nvar internalObjectKeys$1 = objectKeysInternal;\nvar enumBugKeys$2 = enumBugKeys$3;\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es/no-object-keys -- safe\nvar objectKeys$3 = Object.keys || function keys(O) {\n  return internalObjectKeys$1(O, enumBugKeys$2);\n};\n\nvar objectGetOwnPropertySymbols = {};\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nobjectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;\n\nvar DESCRIPTORS$c = descriptors;\nvar uncurryThis$o = functionUncurryThis;\nvar call$9 = functionCall;\nvar fails$o = fails$w;\nvar objectKeys$2 = objectKeys$3;\nvar getOwnPropertySymbolsModule$3 = objectGetOwnPropertySymbols;\nvar propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;\nvar toObject$c = toObject$e;\nvar IndexedObject$2 = indexedObject;\n\n// eslint-disable-next-line es/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es/no-object-defineproperty -- required for testing\nvar defineProperty$e = Object.defineProperty;\nvar concat$6 = uncurryThis$o([].concat);\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nvar objectAssign = !$assign || fails$o(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS$c && $assign({ b: 1 }, $assign(defineProperty$e({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty$e(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es/no-symbol -- safe\n  var symbol = Symbol('assign detection');\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] !== 7 || objectKeys$2($assign({}, B)).join('') !== alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject$c(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule$3.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule$1.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject$2(arguments[index++]);\n    var keys = getOwnPropertySymbols ? concat$6(objectKeys$2(S), getOwnPropertySymbols(S)) : objectKeys$2(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS$c || call$9(propertyIsEnumerable, S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n\nvar $$O = _export;\nvar assign$5 = objectAssign;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es/no-object-assign -- required for testing\n$$O({ target: 'Object', stat: true, arity: 2, forced: Object.assign !== assign$5 }, {\n  assign: assign$5\n});\n\nvar path$t = path$w;\n\nvar assign$4 = path$t.Object.assign;\n\nvar parent$1b = assign$4;\n\nvar assign$3 = parent$1b;\n\nvar assign$2 = assign$3;\n\nvar _Object$assign = /*@__PURE__*/getDefaultExportFromCjs(assign$2);\n\nvar uncurryThis$n = functionUncurryThis;\n\nvar arraySlice$5 = uncurryThis$n([].slice);\n\nvar uncurryThis$m = functionUncurryThis;\nvar aCallable$4 = aCallable$7;\nvar isObject$e = isObject$j;\nvar hasOwn$d = hasOwnProperty_1;\nvar arraySlice$4 = arraySlice$5;\nvar NATIVE_BIND = functionBindNative;\n\nvar $Function = Function;\nvar concat$5 = uncurryThis$m([].concat);\nvar join = uncurryThis$m([].join);\nvar factories = {};\n\nvar construct$4 = function (C, argsLength, args) {\n  if (!hasOwn$d(factories, argsLength)) {\n    var list = [];\n    var i = 0;\n    for (; i < argsLength; i++) list[i] = 'a[' + i + ']';\n    factories[argsLength] = $Function('C,a', 'return new C(' + join(list, ',') + ')');\n  } return factories[argsLength](C, args);\n};\n\n// `Function.prototype.bind` method implementation\n// https://tc39.es/ecma262/#sec-function.prototype.bind\n// eslint-disable-next-line es/no-function-prototype-bind -- detection\nvar functionBind = NATIVE_BIND ? $Function.bind : function bind(that /* , ...args */) {\n  var F = aCallable$4(this);\n  var Prototype = F.prototype;\n  var partArgs = arraySlice$4(arguments, 1);\n  var boundFunction = function bound(/* args... */) {\n    var args = concat$5(partArgs, arraySlice$4(arguments));\n    return this instanceof boundFunction ? construct$4(F, args.length, args) : F.apply(that, args);\n  };\n  if (isObject$e(Prototype)) boundFunction.prototype = Prototype;\n  return boundFunction;\n};\n\n// TODO: Remove from `core-js@4`\nvar $$N = _export;\nvar bind$c = functionBind;\n\n// `Function.prototype.bind` method\n// https://tc39.es/ecma262/#sec-function.prototype.bind\n// eslint-disable-next-line es/no-function-prototype-bind -- detection\n$$N({ target: 'Function', proto: true, forced: Function.bind !== bind$c }, {\n  bind: bind$c\n});\n\nvar path$s = path$w;\n\nvar entryVirtual$i = function (CONSTRUCTOR) {\n  return path$s[CONSTRUCTOR + 'Prototype'];\n};\n\nvar entryVirtual$h = entryVirtual$i;\n\nvar bind$b = entryVirtual$h('Function').bind;\n\nvar isPrototypeOf$j = objectIsPrototypeOf;\nvar method$f = bind$b;\n\nvar FunctionPrototype$2 = Function.prototype;\n\nvar bind$a = function (it) {\n  var own = it.bind;\n  return it === FunctionPrototype$2 || (isPrototypeOf$j(FunctionPrototype$2, it) && own === FunctionPrototype$2.bind) ? method$f : own;\n};\n\nvar parent$1a = bind$a;\n\nvar bind$9 = parent$1a;\n\nvar bind$8 = bind$9;\n\nvar _bindInstanceProperty$1 = /*@__PURE__*/getDefaultExportFromCjs(bind$8);\n\n/**\r\n * Draw a circle.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - The radius of the circle.\r\n */\nfunction drawCircle(ctx, x, y, r) {\n  ctx.beginPath();\n  ctx.arc(x, y, r, 0, 2 * Math.PI, false);\n  ctx.closePath();\n}\n/**\r\n * Draw a square.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - Half of the width and height of the square.\r\n */\nfunction drawSquare(ctx, x, y, r) {\n  ctx.beginPath();\n  ctx.rect(x - r, y - r, r * 2, r * 2);\n  ctx.closePath();\n}\n/**\r\n * Draw an equilateral triangle standing on a side.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - Half of the length of the sides.\r\n * @remarks\r\n * http://en.wikipedia.org/wiki/Equilateral_triangle\r\n */\nfunction drawTriangle(ctx, x, y, r) {\n  ctx.beginPath();\n  // the change in radius and the offset is here to center the shape\n  r *= 1.15;\n  y += 0.275 * r;\n  var s = r * 2;\n  var s2 = s / 2;\n  var ir = Math.sqrt(3) / 6 * s; // radius of inner circle\n  var h = Math.sqrt(s * s - s2 * s2); // height\n  ctx.moveTo(x, y - (h - ir));\n  ctx.lineTo(x + s2, y + ir);\n  ctx.lineTo(x - s2, y + ir);\n  ctx.lineTo(x, y - (h - ir));\n  ctx.closePath();\n}\n/**\r\n * Draw an equilateral triangle standing on a vertex.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - Half of the length of the sides.\r\n * @remarks\r\n * http://en.wikipedia.org/wiki/Equilateral_triangle\r\n */\nfunction drawTriangleDown(ctx, x, y, r) {\n  ctx.beginPath();\n  // the change in radius and the offset is here to center the shape\n  r *= 1.15;\n  y -= 0.275 * r;\n  var s = r * 2;\n  var s2 = s / 2;\n  var ir = Math.sqrt(3) / 6 * s; // radius of inner circle\n  var h = Math.sqrt(s * s - s2 * s2); // height\n  ctx.moveTo(x, y + (h - ir));\n  ctx.lineTo(x + s2, y - ir);\n  ctx.lineTo(x - s2, y - ir);\n  ctx.lineTo(x, y + (h - ir));\n  ctx.closePath();\n}\n/**\r\n * Draw a star.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - The outer radius of the star.\r\n */\nfunction drawStar(ctx, x, y, r) {\n  // http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/\n  ctx.beginPath();\n  // the change in radius and the offset is here to center the shape\n  r *= 0.82;\n  y += 0.1 * r;\n  for (var n = 0; n < 10; n++) {\n    var radius = n % 2 === 0 ? r * 1.3 : r * 0.5;\n    ctx.lineTo(x + radius * Math.sin(n * 2 * Math.PI / 10), y - radius * Math.cos(n * 2 * Math.PI / 10));\n  }\n  ctx.closePath();\n}\n/**\r\n * Draw a diamond.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - Half of the width and height of the diamond.\r\n * @remarks\r\n * http://www.html5canvastutorials.com/labs/html5-canvas-star-spinner/\r\n */\nfunction drawDiamond(ctx, x, y, r) {\n  ctx.beginPath();\n  ctx.lineTo(x, y + r);\n  ctx.lineTo(x + r, y);\n  ctx.lineTo(x, y - r);\n  ctx.lineTo(x - r, y);\n  ctx.closePath();\n}\n/**\r\n * Draw a rectangle with rounded corners.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param w - The width of the rectangle.\r\n * @param h - The height of the rectangle.\r\n * @param r - The radius of the corners.\r\n * @remarks\r\n * http://stackoverflow.com/questions/1255512/how-to-draw-a-rounded-rectangle-on-html-canvas\r\n */\nfunction drawRoundRect(ctx, x, y, w, h, r) {\n  var r2d = Math.PI / 180;\n  if (w - 2 * r < 0) {\n    r = w / 2;\n  } //ensure that the radius isn't too large for x\n  if (h - 2 * r < 0) {\n    r = h / 2;\n  } //ensure that the radius isn't too large for y\n  ctx.beginPath();\n  ctx.moveTo(x + r, y);\n  ctx.lineTo(x + w - r, y);\n  ctx.arc(x + w - r, y + r, r, r2d * 270, r2d * 360, false);\n  ctx.lineTo(x + w, y + h - r);\n  ctx.arc(x + w - r, y + h - r, r, 0, r2d * 90, false);\n  ctx.lineTo(x + r, y + h);\n  ctx.arc(x + r, y + h - r, r, r2d * 90, r2d * 180, false);\n  ctx.lineTo(x, y + r);\n  ctx.arc(x + r, y + r, r, r2d * 180, r2d * 270, false);\n  ctx.closePath();\n}\n/**\r\n * Draw an ellipse.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param w - The width of the ellipse.\r\n * @param h - The height of the ellipse.\r\n * @remarks\r\n * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\r\n *\r\n * Postfix '_vis' added to discern it from standard method ellipse().\r\n */\nfunction drawEllipse(ctx, x, y, w, h) {\n  var kappa = 0.5522848,\n    ox = w / 2 * kappa,\n    // control point offset horizontal\n    oy = h / 2 * kappa,\n    // control point offset vertical\n    xe = x + w,\n    // x-end\n    ye = y + h,\n    // y-end\n    xm = x + w / 2,\n    // x-middle\n    ym = y + h / 2; // y-middle\n  ctx.beginPath();\n  ctx.moveTo(x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.closePath();\n}\n/**\r\n * Draw an isometric cylinder.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param w - The width of the database.\r\n * @param h - The height of the database.\r\n * @remarks\r\n * http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\r\n */\nfunction drawDatabase(ctx, x, y, w, h) {\n  var f = 1 / 3;\n  var wEllipse = w;\n  var hEllipse = h * f;\n  var kappa = 0.5522848,\n    ox = wEllipse / 2 * kappa,\n    // control point offset horizontal\n    oy = hEllipse / 2 * kappa,\n    // control point offset vertical\n    xe = x + wEllipse,\n    // x-end\n    ye = y + hEllipse,\n    // y-end\n    xm = x + wEllipse / 2,\n    // x-middle\n    ym = y + hEllipse / 2,\n    // y-middle\n    ymb = y + (h - hEllipse / 2),\n    // y-midlle, bottom ellipse\n    yeb = y + h; // y-end, bottom ellipse\n  ctx.beginPath();\n  ctx.moveTo(xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.lineTo(xe, ymb);\n  ctx.bezierCurveTo(xe, ymb + oy, xm + ox, yeb, xm, yeb);\n  ctx.bezierCurveTo(xm - ox, yeb, x, ymb + oy, x, ymb);\n  ctx.lineTo(x, ym);\n}\n/**\r\n * Draw a dashed line.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The start position on the x axis.\r\n * @param y - The start position on the y axis.\r\n * @param x2 - The end position on the x axis.\r\n * @param y2 - The end position on the y axis.\r\n * @param pattern - List of lengths starting with line and then alternating between space and line.\r\n * @author David Jordan\r\n * @remarks\r\n * date 2012-08-08\r\n * http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas\r\n */\nfunction drawDashedLine(ctx, x, y, x2, y2, pattern) {\n  ctx.beginPath();\n  ctx.moveTo(x, y);\n  var patternLength = pattern.length;\n  var dx = x2 - x;\n  var dy = y2 - y;\n  var slope = dy / dx;\n  var distRemaining = Math.sqrt(dx * dx + dy * dy);\n  var patternIndex = 0;\n  var draw = true;\n  var xStep = 0;\n  var dashLength = +pattern[0];\n  while (distRemaining >= 0.1) {\n    dashLength = +pattern[patternIndex++ % patternLength];\n    if (dashLength > distRemaining) {\n      dashLength = distRemaining;\n    }\n    xStep = Math.sqrt(dashLength * dashLength / (1 + slope * slope));\n    xStep = dx < 0 ? -xStep : xStep;\n    x += xStep;\n    y += slope * xStep;\n    if (draw === true) {\n      ctx.lineTo(x, y);\n    } else {\n      ctx.moveTo(x, y);\n    }\n    distRemaining -= dashLength;\n    draw = !draw;\n  }\n}\n/**\r\n * Draw a hexagon.\r\n *\r\n * @param ctx - The context this shape will be rendered to.\r\n * @param x - The position of the center on the x axis.\r\n * @param y - The position of the center on the y axis.\r\n * @param r - The radius of the hexagon.\r\n */\nfunction drawHexagon(ctx, x, y, r) {\n  ctx.beginPath();\n  var sides = 6;\n  var a = Math.PI * 2 / sides;\n  ctx.moveTo(x + r, y);\n  for (var i = 1; i < sides; i++) {\n    ctx.lineTo(x + r * Math.cos(a * i), y + r * Math.sin(a * i));\n  }\n  ctx.closePath();\n}\nvar shapeMap = {\n  circle: drawCircle,\n  dashedLine: drawDashedLine,\n  database: drawDatabase,\n  diamond: drawDiamond,\n  ellipse: drawEllipse,\n  ellipse_vis: drawEllipse,\n  hexagon: drawHexagon,\n  roundRect: drawRoundRect,\n  square: drawSquare,\n  star: drawStar,\n  triangle: drawTriangle,\n  triangleDown: drawTriangleDown\n};\n/**\r\n * Returns either custom or native drawing function base on supplied name.\r\n *\r\n * @param name - The name of the function. Either the name of a\r\n * CanvasRenderingContext2D property or an export from shapes.ts without the\r\n * draw prefix.\r\n * @returns The function that can be used for rendering. In case of native\r\n * CanvasRenderingContext2D function the API is normalized to\r\n * `(ctx: CanvasRenderingContext2D, ...originalArgs) => void`.\r\n */\nfunction getShape(name) {\n  if (Object.prototype.hasOwnProperty.call(shapeMap, name)) {\n    return shapeMap[name];\n  } else {\n    return function (ctx) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      CanvasRenderingContext2D.prototype[name].call(ctx, args);\n    };\n  }\n}\n\nvar componentEmitter = {exports: {}};\n\n(function (module) {\n\t/**\r\n\t * Expose `Emitter`.\r\n\t */\r\n\r\n\t{\r\n\t  module.exports = Emitter;\r\n\t}\r\n\r\n\t/**\r\n\t * Initialize a new `Emitter`.\r\n\t *\r\n\t * @api public\r\n\t */\r\n\r\n\tfunction Emitter(obj) {\r\n\t  if (obj) return mixin(obj);\r\n\t}\r\n\t/**\r\n\t * Mixin the emitter properties.\r\n\t *\r\n\t * @param {Object} obj\r\n\t * @return {Object}\r\n\t * @api private\r\n\t */\r\n\r\n\tfunction mixin(obj) {\r\n\t  for (var key in Emitter.prototype) {\r\n\t    obj[key] = Emitter.prototype[key];\r\n\t  }\r\n\t  return obj;\r\n\t}\r\n\r\n\t/**\r\n\t * Listen on the given `event` with `fn`.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\r\n\tEmitter.prototype.on =\r\n\tEmitter.prototype.addEventListener = function(event, fn){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n\t    .push(fn);\r\n\t  return this;\r\n\t};\r\n\r\n\t/**\r\n\t * Adds an `event` listener that will be invoked a single\r\n\t * time then automatically removed.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\r\n\tEmitter.prototype.once = function(event, fn){\r\n\t  function on() {\r\n\t    this.off(event, on);\r\n\t    fn.apply(this, arguments);\r\n\t  }\r\n\r\n\t  on.fn = fn;\r\n\t  this.on(event, on);\r\n\t  return this;\r\n\t};\r\n\r\n\t/**\r\n\t * Remove the given callback for `event` or all\r\n\t * registered callbacks.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\r\n\tEmitter.prototype.off =\r\n\tEmitter.prototype.removeListener =\r\n\tEmitter.prototype.removeAllListeners =\r\n\tEmitter.prototype.removeEventListener = function(event, fn){\r\n\t  this._callbacks = this._callbacks || {};\r\n\r\n\t  // all\r\n\t  if (0 == arguments.length) {\r\n\t    this._callbacks = {};\r\n\t    return this;\r\n\t  }\r\n\r\n\t  // specific event\r\n\t  var callbacks = this._callbacks['$' + event];\r\n\t  if (!callbacks) return this;\r\n\r\n\t  // remove all handlers\r\n\t  if (1 == arguments.length) {\r\n\t    delete this._callbacks['$' + event];\r\n\t    return this;\r\n\t  }\r\n\r\n\t  // remove specific handler\r\n\t  var cb;\r\n\t  for (var i = 0; i < callbacks.length; i++) {\r\n\t    cb = callbacks[i];\r\n\t    if (cb === fn || cb.fn === fn) {\r\n\t      callbacks.splice(i, 1);\r\n\t      break;\r\n\t    }\r\n\t  }\r\n\r\n\t  // Remove event specific arrays for event types that no\r\n\t  // one is subscribed for to avoid memory leak.\r\n\t  if (callbacks.length === 0) {\r\n\t    delete this._callbacks['$' + event];\r\n\t  }\r\n\r\n\t  return this;\r\n\t};\r\n\r\n\t/**\r\n\t * Emit `event` with the given args.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Mixed} ...\r\n\t * @return {Emitter}\r\n\t */\r\n\r\n\tEmitter.prototype.emit = function(event){\r\n\t  this._callbacks = this._callbacks || {};\r\n\r\n\t  var args = new Array(arguments.length - 1)\r\n\t    , callbacks = this._callbacks['$' + event];\r\n\r\n\t  for (var i = 1; i < arguments.length; i++) {\r\n\t    args[i - 1] = arguments[i];\r\n\t  }\r\n\r\n\t  if (callbacks) {\r\n\t    callbacks = callbacks.slice(0);\r\n\t    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n\t      callbacks[i].apply(this, args);\r\n\t    }\r\n\t  }\r\n\r\n\t  return this;\r\n\t};\r\n\r\n\t/**\r\n\t * Return array of callbacks for `event`.\r\n\t *\r\n\t * @param {String} event\r\n\t * @return {Array}\r\n\t * @api public\r\n\t */\r\n\r\n\tEmitter.prototype.listeners = function(event){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t  return this._callbacks['$' + event] || [];\r\n\t};\r\n\r\n\t/**\r\n\t * Check if this emitter has `event` handlers.\r\n\t *\r\n\t * @param {String} event\r\n\t * @return {Boolean}\r\n\t * @api public\r\n\t */\r\n\r\n\tEmitter.prototype.hasListeners = function(event){\r\n\t  return !! this.listeners(event).length;\r\n\t}; \n} (componentEmitter));\n\nvar componentEmitterExports = componentEmitter.exports;\nvar Emitter = /*@__PURE__*/getDefaultExportFromCjs(componentEmitterExports);\n\nvar wellKnownSymbol$k = wellKnownSymbol$m;\n\nvar TO_STRING_TAG$3 = wellKnownSymbol$k('toStringTag');\nvar test$2 = {};\n\ntest$2[TO_STRING_TAG$3] = 'z';\n\nvar toStringTagSupport = String(test$2) === '[object z]';\n\nvar TO_STRING_TAG_SUPPORT$2 = toStringTagSupport;\nvar isCallable$a = isCallable$i;\nvar classofRaw = classofRaw$2;\nvar wellKnownSymbol$j = wellKnownSymbol$m;\n\nvar TO_STRING_TAG$2 = wellKnownSymbol$j('toStringTag');\nvar $Object$2 = Object;\n\n// ES3 wrong here\nvar CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) === 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (error) { /* empty */ }\n};\n\n// getting tag from ES6+ `Object.prototype.toString`\nvar classof$d = TO_STRING_TAG_SUPPORT$2 ? classofRaw : function (it) {\n  var O, tag, result;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (tag = tryGet(O = $Object$2(it), TO_STRING_TAG$2)) == 'string' ? tag\n    // builtinTag case\n    : CORRECT_ARGUMENTS ? classofRaw(O)\n    // ES3 arguments fallback\n    : (result = classofRaw(O)) === 'Object' && isCallable$a(O.callee) ? 'Arguments' : result;\n};\n\nvar classof$c = classof$d;\n\nvar $String$2 = String;\n\nvar toString$a = function (argument) {\n  if (classof$c(argument) === 'Symbol') throw new TypeError('Cannot convert a Symbol value to a string');\n  return $String$2(argument);\n};\n\nvar uncurryThis$l = functionUncurryThis;\nvar toIntegerOrInfinity$1 = toIntegerOrInfinity$4;\nvar toString$9 = toString$a;\nvar requireObjectCoercible$2 = requireObjectCoercible$5;\n\nvar charAt$3 = uncurryThis$l(''.charAt);\nvar charCodeAt$1 = uncurryThis$l(''.charCodeAt);\nvar stringSlice = uncurryThis$l(''.slice);\n\nvar createMethod$3 = function (CONVERT_TO_STRING) {\n  return function ($this, pos) {\n    var S = toString$9(requireObjectCoercible$2($this));\n    var position = toIntegerOrInfinity$1(pos);\n    var size = S.length;\n    var first, second;\n    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;\n    first = charCodeAt$1(S, position);\n    return first < 0xD800 || first > 0xDBFF || position + 1 === size\n      || (second = charCodeAt$1(S, position + 1)) < 0xDC00 || second > 0xDFFF\n        ? CONVERT_TO_STRING\n          ? charAt$3(S, position)\n          : first\n        : CONVERT_TO_STRING\n          ? stringSlice(S, position, position + 2)\n          : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  };\n};\n\nvar stringMultibyte = {\n  // `String.prototype.codePointAt` method\n  // https://tc39.es/ecma262/#sec-string.prototype.codepointat\n  codeAt: createMethod$3(false),\n  // `String.prototype.at` method\n  // https://github.com/mathiasbynens/String.prototype.at\n  charAt: createMethod$3(true)\n};\n\nvar global$e = global$n;\nvar isCallable$9 = isCallable$i;\n\nvar WeakMap$1 = global$e.WeakMap;\n\nvar weakMapBasicDetection = isCallable$9(WeakMap$1) && /native code/.test(String(WeakMap$1));\n\nvar shared$5 = sharedExports;\nvar uid$2 = uid$4;\n\nvar keys$3 = shared$5('keys');\n\nvar sharedKey$4 = function (key) {\n  return keys$3[key] || (keys$3[key] = uid$2(key));\n};\n\nvar NATIVE_WEAK_MAP$1 = weakMapBasicDetection;\nvar global$d = global$n;\nvar isObject$d = isObject$j;\nvar createNonEnumerableProperty$4 = createNonEnumerableProperty$6;\nvar hasOwn$c = hasOwnProperty_1;\nvar shared$4 = sharedStore;\nvar sharedKey$3 = sharedKey$4;\nvar hiddenKeys$4 = hiddenKeys$6;\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError$2 = global$d.TypeError;\nvar WeakMap = global$d.WeakMap;\nvar set$3, get$6, has;\n\nvar enforce = function (it) {\n  return has(it) ? get$6(it) : set$3(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject$d(it) || (state = get$6(it)).type !== TYPE) {\n      throw new TypeError$2('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP$1 || shared$4.state) {\n  var store$1 = shared$4.state || (shared$4.state = new WeakMap());\n  /* eslint-disable no-self-assign -- prototype methods protection */\n  store$1.get = store$1.get;\n  store$1.has = store$1.has;\n  store$1.set = store$1.set;\n  /* eslint-enable no-self-assign -- prototype methods protection */\n  set$3 = function (it, metadata) {\n    if (store$1.has(it)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    store$1.set(it, metadata);\n    return metadata;\n  };\n  get$6 = function (it) {\n    return store$1.get(it) || {};\n  };\n  has = function (it) {\n    return store$1.has(it);\n  };\n} else {\n  var STATE = sharedKey$3('state');\n  hiddenKeys$4[STATE] = true;\n  set$3 = function (it, metadata) {\n    if (hasOwn$c(it, STATE)) throw new TypeError$2(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty$4(it, STATE, metadata);\n    return metadata;\n  };\n  get$6 = function (it) {\n    return hasOwn$c(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return hasOwn$c(it, STATE);\n  };\n}\n\nvar internalState = {\n  set: set$3,\n  get: get$6,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n\nvar DESCRIPTORS$b = descriptors;\nvar hasOwn$b = hasOwnProperty_1;\n\nvar FunctionPrototype$1 = Function.prototype;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getDescriptor = DESCRIPTORS$b && Object.getOwnPropertyDescriptor;\n\nvar EXISTS = hasOwn$b(FunctionPrototype$1, 'name');\n// additional protection from minified / mangled / dropped function names\nvar PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS$b || (DESCRIPTORS$b && getDescriptor(FunctionPrototype$1, 'name').configurable));\n\nvar functionName = {\n  EXISTS: EXISTS,\n  PROPER: PROPER,\n  CONFIGURABLE: CONFIGURABLE\n};\n\nvar objectDefineProperties = {};\n\nvar DESCRIPTORS$a = descriptors;\nvar V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;\nvar definePropertyModule$2 = objectDefineProperty;\nvar anObject$b = anObject$d;\nvar toIndexedObject$6 = toIndexedObject$a;\nvar objectKeys$1 = objectKeys$3;\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es/no-object-defineproperties -- safe\nobjectDefineProperties.f = DESCRIPTORS$a && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject$b(O);\n  var props = toIndexedObject$6(Properties);\n  var keys = objectKeys$1(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule$2.f(O, key = keys[index++], props[key]);\n  return O;\n};\n\nvar getBuiltIn$a = getBuiltIn$c;\n\nvar html$1 = getBuiltIn$a('document', 'documentElement');\n\n/* global ActiveXObject -- old IE, WSH */\nvar anObject$a = anObject$d;\nvar definePropertiesModule$1 = objectDefineProperties;\nvar enumBugKeys$1 = enumBugKeys$3;\nvar hiddenKeys$3 = hiddenKeys$6;\nvar html = html$1;\nvar documentCreateElement = documentCreateElement$1;\nvar sharedKey$2 = sharedKey$4;\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE$1 = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO$1 = sharedKey$2('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    activeXDocument = new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = typeof document != 'undefined'\n    ? document.domain && activeXDocument\n      ? NullProtoObjectViaActiveX(activeXDocument) // old IE\n      : NullProtoObjectViaIFrame()\n    : NullProtoObjectViaActiveX(activeXDocument); // WSH\n  var length = enumBugKeys$1.length;\n  while (length--) delete NullProtoObject[PROTOTYPE$1][enumBugKeys$1[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys$3[IE_PROTO$1] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n// eslint-disable-next-line es/no-object-create -- safe\nvar objectCreate = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE$1] = anObject$a(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE$1] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO$1] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : definePropertiesModule$1.f(result, Properties);\n};\n\nvar fails$n = fails$w;\n\nvar correctPrototypeGetter = !fails$n(function () {\n  function F() { /* empty */ }\n  F.prototype.constructor = null;\n  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing\n  return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\nvar hasOwn$a = hasOwnProperty_1;\nvar isCallable$8 = isCallable$i;\nvar toObject$b = toObject$e;\nvar sharedKey$1 = sharedKey$4;\nvar CORRECT_PROTOTYPE_GETTER$1 = correctPrototypeGetter;\n\nvar IE_PROTO = sharedKey$1('IE_PROTO');\nvar $Object$1 = Object;\nvar ObjectPrototype$2 = $Object$1.prototype;\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n// eslint-disable-next-line es/no-object-getprototypeof -- safe\nvar objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER$1 ? $Object$1.getPrototypeOf : function (O) {\n  var object = toObject$b(O);\n  if (hasOwn$a(object, IE_PROTO)) return object[IE_PROTO];\n  var constructor = object.constructor;\n  if (isCallable$8(constructor) && object instanceof constructor) {\n    return constructor.prototype;\n  } return object instanceof $Object$1 ? ObjectPrototype$2 : null;\n};\n\nvar createNonEnumerableProperty$3 = createNonEnumerableProperty$6;\n\nvar defineBuiltIn$5 = function (target, key, value, options) {\n  if (options && options.enumerable) target[key] = value;\n  else createNonEnumerableProperty$3(target, key, value);\n  return target;\n};\n\nvar fails$m = fails$w;\nvar isCallable$7 = isCallable$i;\nvar isObject$c = isObject$j;\nvar create$a = objectCreate;\nvar getPrototypeOf$8 = objectGetPrototypeOf;\nvar defineBuiltIn$4 = defineBuiltIn$5;\nvar wellKnownSymbol$i = wellKnownSymbol$m;\n\nvar ITERATOR$6 = wellKnownSymbol$i('iterator');\nvar BUGGY_SAFARI_ITERATORS$1 = false;\n\n// `%IteratorPrototype%` object\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-object\nvar IteratorPrototype$1, PrototypeOfArrayIteratorPrototype, arrayIterator;\n\n/* eslint-disable es/no-array-prototype-keys -- safe */\nif ([].keys) {\n  arrayIterator = [].keys();\n  // Safari 8 has buggy iterators w/o `next`\n  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;\n  else {\n    PrototypeOfArrayIteratorPrototype = getPrototypeOf$8(getPrototypeOf$8(arrayIterator));\n    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$1 = PrototypeOfArrayIteratorPrototype;\n  }\n}\n\nvar NEW_ITERATOR_PROTOTYPE = !isObject$c(IteratorPrototype$1) || fails$m(function () {\n  var test = {};\n  // FF44- legacy iterators case\n  return IteratorPrototype$1[ITERATOR$6].call(test) !== test;\n});\n\nif (NEW_ITERATOR_PROTOTYPE) IteratorPrototype$1 = {};\nelse IteratorPrototype$1 = create$a(IteratorPrototype$1);\n\n// `%IteratorPrototype%[@@iterator]()` method\n// https://tc39.es/ecma262/#sec-%iteratorprototype%-@@iterator\nif (!isCallable$7(IteratorPrototype$1[ITERATOR$6])) {\n  defineBuiltIn$4(IteratorPrototype$1, ITERATOR$6, function () {\n    return this;\n  });\n}\n\nvar iteratorsCore = {\n  IteratorPrototype: IteratorPrototype$1,\n  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1\n};\n\nvar TO_STRING_TAG_SUPPORT$1 = toStringTagSupport;\nvar classof$b = classof$d;\n\n// `Object.prototype.toString` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.tostring\nvar objectToString = TO_STRING_TAG_SUPPORT$1 ? {}.toString : function toString() {\n  return '[object ' + classof$b(this) + ']';\n};\n\nvar TO_STRING_TAG_SUPPORT = toStringTagSupport;\nvar defineProperty$d = objectDefineProperty.f;\nvar createNonEnumerableProperty$2 = createNonEnumerableProperty$6;\nvar hasOwn$9 = hasOwnProperty_1;\nvar toString$8 = objectToString;\nvar wellKnownSymbol$h = wellKnownSymbol$m;\n\nvar TO_STRING_TAG$1 = wellKnownSymbol$h('toStringTag');\n\nvar setToStringTag$6 = function (it, TAG, STATIC, SET_METHOD) {\n  if (it) {\n    var target = STATIC ? it : it.prototype;\n    if (!hasOwn$9(target, TO_STRING_TAG$1)) {\n      defineProperty$d(target, TO_STRING_TAG$1, { configurable: true, value: TAG });\n    }\n    if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {\n      createNonEnumerableProperty$2(target, 'toString', toString$8);\n    }\n  }\n};\n\nvar iterators = {};\n\nvar IteratorPrototype = iteratorsCore.IteratorPrototype;\nvar create$9 = objectCreate;\nvar createPropertyDescriptor$2 = createPropertyDescriptor$5;\nvar setToStringTag$5 = setToStringTag$6;\nvar Iterators$5 = iterators;\n\nvar returnThis$1 = function () { return this; };\n\nvar iteratorCreateConstructor = function (IteratorConstructor, NAME, next, ENUMERABLE_NEXT) {\n  var TO_STRING_TAG = NAME + ' Iterator';\n  IteratorConstructor.prototype = create$9(IteratorPrototype, { next: createPropertyDescriptor$2(+!ENUMERABLE_NEXT, next) });\n  setToStringTag$5(IteratorConstructor, TO_STRING_TAG, false, true);\n  Iterators$5[TO_STRING_TAG] = returnThis$1;\n  return IteratorConstructor;\n};\n\nvar uncurryThis$k = functionUncurryThis;\nvar aCallable$3 = aCallable$7;\n\nvar functionUncurryThisAccessor = function (object, key, method) {\n  try {\n    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n    return uncurryThis$k(aCallable$3(Object.getOwnPropertyDescriptor(object, key)[method]));\n  } catch (error) { /* empty */ }\n};\n\nvar isCallable$6 = isCallable$i;\n\nvar $String$1 = String;\nvar $TypeError$a = TypeError;\n\nvar aPossiblePrototype$1 = function (argument) {\n  if (typeof argument == 'object' || isCallable$6(argument)) return argument;\n  throw new $TypeError$a(\"Can't set \" + $String$1(argument) + ' as a prototype');\n};\n\n/* eslint-disable no-proto -- safe */\nvar uncurryThisAccessor = functionUncurryThisAccessor;\nvar anObject$9 = anObject$d;\nvar aPossiblePrototype = aPossiblePrototype$1;\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es/no-object-setprototypeof -- safe\nvar objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');\n    setter(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject$9(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n\nvar $$M = _export;\nvar call$8 = functionCall;\nvar FunctionName = functionName;\nvar createIteratorConstructor = iteratorCreateConstructor;\nvar getPrototypeOf$7 = objectGetPrototypeOf;\nvar setToStringTag$4 = setToStringTag$6;\nvar defineBuiltIn$3 = defineBuiltIn$5;\nvar wellKnownSymbol$g = wellKnownSymbol$m;\nvar Iterators$4 = iterators;\nvar IteratorsCore = iteratorsCore;\n\nvar PROPER_FUNCTION_NAME = FunctionName.PROPER;\nFunctionName.CONFIGURABLE;\nIteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR$5 = wellKnownSymbol$g('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\n\nvar returnThis = function () { return this; };\n\nvar iteratorDefine = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n  createIteratorConstructor(IteratorConstructor, NAME, next);\n\n  var getIterationMethod = function (KIND) {\n    if (KIND === DEFAULT && defaultIterator) return defaultIterator;\n    if (!BUGGY_SAFARI_ITERATORS && KIND && KIND in IterablePrototype) return IterablePrototype[KIND];\n\n    switch (KIND) {\n      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };\n      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };\n      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };\n    }\n\n    return function () { return new IteratorConstructor(this); };\n  };\n\n  var TO_STRING_TAG = NAME + ' Iterator';\n  var INCORRECT_VALUES_NAME = false;\n  var IterablePrototype = Iterable.prototype;\n  var nativeIterator = IterablePrototype[ITERATOR$5]\n    || IterablePrototype['@@iterator']\n    || DEFAULT && IterablePrototype[DEFAULT];\n  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n  var anyNativeIterator = NAME === 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n  var CurrentIteratorPrototype, methods, KEY;\n\n  // fix native\n  if (anyNativeIterator) {\n    CurrentIteratorPrototype = getPrototypeOf$7(anyNativeIterator.call(new Iterable()));\n    if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag$4(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n      Iterators$4[TO_STRING_TAG] = returnThis;\n    }\n  }\n\n  // fix Array.prototype.{ values, @@iterator }.name in V8 / FF\n  if (PROPER_FUNCTION_NAME && DEFAULT === VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n    {\n      INCORRECT_VALUES_NAME = true;\n      defaultIterator = function values() { return call$8(nativeIterator, this); };\n    }\n  }\n\n  // export additional methods\n  if (DEFAULT) {\n    methods = {\n      values: getIterationMethod(VALUES),\n      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n      entries: getIterationMethod(ENTRIES)\n    };\n    if (FORCED) for (KEY in methods) {\n      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n        defineBuiltIn$3(IterablePrototype, KEY, methods[KEY]);\n      }\n    } else $$M({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);\n  }\n\n  // define iterator\n  if ((FORCED) && IterablePrototype[ITERATOR$5] !== defaultIterator) {\n    defineBuiltIn$3(IterablePrototype, ITERATOR$5, defaultIterator, { name: DEFAULT });\n  }\n  Iterators$4[NAME] = defaultIterator;\n\n  return methods;\n};\n\n// `CreateIterResultObject` abstract operation\n// https://tc39.es/ecma262/#sec-createiterresultobject\nvar createIterResultObject$3 = function (value, done) {\n  return { value: value, done: done };\n};\n\nvar charAt$2 = stringMultibyte.charAt;\nvar toString$7 = toString$a;\nvar InternalStateModule$5 = internalState;\nvar defineIterator$2 = iteratorDefine;\nvar createIterResultObject$2 = createIterResultObject$3;\n\nvar STRING_ITERATOR = 'String Iterator';\nvar setInternalState$5 = InternalStateModule$5.set;\nvar getInternalState$2 = InternalStateModule$5.getterFor(STRING_ITERATOR);\n\n// `String.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-string.prototype-@@iterator\ndefineIterator$2(String, 'String', function (iterated) {\n  setInternalState$5(this, {\n    type: STRING_ITERATOR,\n    string: toString$7(iterated),\n    index: 0\n  });\n// `%StringIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next\n}, function next() {\n  var state = getInternalState$2(this);\n  var string = state.string;\n  var index = state.index;\n  var point;\n  if (index >= string.length) return createIterResultObject$2(undefined, true);\n  point = charAt$2(string, index);\n  state.index += point.length;\n  return createIterResultObject$2(point, false);\n});\n\nvar call$7 = functionCall;\nvar anObject$8 = anObject$d;\nvar getMethod$1 = getMethod$3;\n\nvar iteratorClose$2 = function (iterator, kind, value) {\n  var innerResult, innerError;\n  anObject$8(iterator);\n  try {\n    innerResult = getMethod$1(iterator, 'return');\n    if (!innerResult) {\n      if (kind === 'throw') throw value;\n      return value;\n    }\n    innerResult = call$7(innerResult, iterator);\n  } catch (error) {\n    innerError = true;\n    innerResult = error;\n  }\n  if (kind === 'throw') throw value;\n  if (innerError) throw innerResult;\n  anObject$8(innerResult);\n  return value;\n};\n\nvar anObject$7 = anObject$d;\nvar iteratorClose$1 = iteratorClose$2;\n\n// call something on iterator step with safe closing on error\nvar callWithSafeIterationClosing$1 = function (iterator, fn, value, ENTRIES) {\n  try {\n    return ENTRIES ? fn(anObject$7(value)[0], value[1]) : fn(value);\n  } catch (error) {\n    iteratorClose$1(iterator, 'throw', error);\n  }\n};\n\nvar wellKnownSymbol$f = wellKnownSymbol$m;\nvar Iterators$3 = iterators;\n\nvar ITERATOR$4 = wellKnownSymbol$f('iterator');\nvar ArrayPrototype$g = Array.prototype;\n\n// check on default Array iterator\nvar isArrayIteratorMethod$2 = function (it) {\n  return it !== undefined && (Iterators$3.Array === it || ArrayPrototype$g[ITERATOR$4] === it);\n};\n\nvar uncurryThis$j = functionUncurryThis;\nvar isCallable$5 = isCallable$i;\nvar store = sharedStore;\n\nvar functionToString = uncurryThis$j(Function.toString);\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (!isCallable$5(store.inspectSource)) {\n  store.inspectSource = function (it) {\n    return functionToString(it);\n  };\n}\n\nvar inspectSource$1 = store.inspectSource;\n\nvar uncurryThis$i = functionUncurryThis;\nvar fails$l = fails$w;\nvar isCallable$4 = isCallable$i;\nvar classof$a = classof$d;\nvar getBuiltIn$9 = getBuiltIn$c;\nvar inspectSource = inspectSource$1;\n\nvar noop = function () { /* empty */ };\nvar empty = [];\nvar construct$3 = getBuiltIn$9('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec$2 = uncurryThis$i(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.test(noop);\n\nvar isConstructorModern = function isConstructor(argument) {\n  if (!isCallable$4(argument)) return false;\n  try {\n    construct$3(noop, empty, argument);\n    return true;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar isConstructorLegacy = function isConstructor(argument) {\n  if (!isCallable$4(argument)) return false;\n  switch (classof$a(argument)) {\n    case 'AsyncFunction':\n    case 'GeneratorFunction':\n    case 'AsyncGeneratorFunction': return false;\n  }\n  try {\n    // we can't check .prototype since constructors produced by .bind haven't it\n    // `Function#toString` throws on some built-it function in some legacy engines\n    // (for example, `DOMQuad` and similar in FF41-)\n    return INCORRECT_TO_STRING || !!exec$2(constructorRegExp, inspectSource(argument));\n  } catch (error) {\n    return true;\n  }\n};\n\nisConstructorLegacy.sham = true;\n\n// `IsConstructor` abstract operation\n// https://tc39.es/ecma262/#sec-isconstructor\nvar isConstructor$4 = !construct$3 || fails$l(function () {\n  var called;\n  return isConstructorModern(isConstructorModern.call)\n    || !isConstructorModern(Object)\n    || !isConstructorModern(function () { called = true; })\n    || called;\n}) ? isConstructorLegacy : isConstructorModern;\n\nvar toPropertyKey$1 = toPropertyKey$4;\nvar definePropertyModule$1 = objectDefineProperty;\nvar createPropertyDescriptor$1 = createPropertyDescriptor$5;\n\nvar createProperty$6 = function (object, key, value) {\n  var propertyKey = toPropertyKey$1(key);\n  if (propertyKey in object) definePropertyModule$1.f(object, propertyKey, createPropertyDescriptor$1(0, value));\n  else object[propertyKey] = value;\n};\n\nvar classof$9 = classof$d;\nvar getMethod = getMethod$3;\nvar isNullOrUndefined$3 = isNullOrUndefined$6;\nvar Iterators$2 = iterators;\nvar wellKnownSymbol$e = wellKnownSymbol$m;\n\nvar ITERATOR$3 = wellKnownSymbol$e('iterator');\n\nvar getIteratorMethod$9 = function (it) {\n  if (!isNullOrUndefined$3(it)) return getMethod(it, ITERATOR$3)\n    || getMethod(it, '@@iterator')\n    || Iterators$2[classof$9(it)];\n};\n\nvar call$6 = functionCall;\nvar aCallable$2 = aCallable$7;\nvar anObject$6 = anObject$d;\nvar tryToString$4 = tryToString$6;\nvar getIteratorMethod$8 = getIteratorMethod$9;\n\nvar $TypeError$9 = TypeError;\n\nvar getIterator$2 = function (argument, usingIterator) {\n  var iteratorMethod = arguments.length < 2 ? getIteratorMethod$8(argument) : usingIterator;\n  if (aCallable$2(iteratorMethod)) return anObject$6(call$6(iteratorMethod, argument));\n  throw new $TypeError$9(tryToString$4(argument) + ' is not iterable');\n};\n\nvar bind$7 = functionBindContext;\nvar call$5 = functionCall;\nvar toObject$a = toObject$e;\nvar callWithSafeIterationClosing = callWithSafeIterationClosing$1;\nvar isArrayIteratorMethod$1 = isArrayIteratorMethod$2;\nvar isConstructor$3 = isConstructor$4;\nvar lengthOfArrayLike$a = lengthOfArrayLike$c;\nvar createProperty$5 = createProperty$6;\nvar getIterator$1 = getIterator$2;\nvar getIteratorMethod$7 = getIteratorMethod$9;\n\nvar $Array$3 = Array;\n\n// `Array.from` method implementation\n// https://tc39.es/ecma262/#sec-array.from\nvar arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n  var O = toObject$a(arrayLike);\n  var IS_CONSTRUCTOR = isConstructor$3(this);\n  var argumentsLength = arguments.length;\n  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n  var mapping = mapfn !== undefined;\n  if (mapping) mapfn = bind$7(mapfn, argumentsLength > 2 ? arguments[2] : undefined);\n  var iteratorMethod = getIteratorMethod$7(O);\n  var index = 0;\n  var length, result, step, iterator, next, value;\n  // if the target is not iterable or it's an array with the default iterator - use a simple case\n  if (iteratorMethod && !(this === $Array$3 && isArrayIteratorMethod$1(iteratorMethod))) {\n    iterator = getIterator$1(O, iteratorMethod);\n    next = iterator.next;\n    result = IS_CONSTRUCTOR ? new this() : [];\n    for (;!(step = call$5(next, iterator)).done; index++) {\n      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;\n      createProperty$5(result, index, value);\n    }\n  } else {\n    length = lengthOfArrayLike$a(O);\n    result = IS_CONSTRUCTOR ? new this(length) : $Array$3(length);\n    for (;length > index; index++) {\n      value = mapping ? mapfn(O[index], index) : O[index];\n      createProperty$5(result, index, value);\n    }\n  }\n  result.length = index;\n  return result;\n};\n\nvar wellKnownSymbol$d = wellKnownSymbol$m;\n\nvar ITERATOR$2 = wellKnownSymbol$d('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var called = 0;\n  var iteratorWithReturn = {\n    next: function () {\n      return { done: !!called++ };\n    },\n    'return': function () {\n      SAFE_CLOSING = true;\n    }\n  };\n  iteratorWithReturn[ITERATOR$2] = function () {\n    return this;\n  };\n  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing\n  Array.from(iteratorWithReturn, function () { throw 2; });\n} catch (error) { /* empty */ }\n\nvar checkCorrectnessOfIteration$1 = function (exec, SKIP_CLOSING) {\n  try {\n    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;\n  } catch (error) { return false; } // workaround of old WebKit + `eval` bug\n  var ITERATION_SUPPORT = false;\n  try {\n    var object = {};\n    object[ITERATOR$2] = function () {\n      return {\n        next: function () {\n          return { done: ITERATION_SUPPORT = true };\n        }\n      };\n    };\n    exec(object);\n  } catch (error) { /* empty */ }\n  return ITERATION_SUPPORT;\n};\n\nvar $$L = _export;\nvar from$6 = arrayFrom;\nvar checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;\n\nvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n  // eslint-disable-next-line es/no-array-from -- required for testing\n  Array.from(iterable);\n});\n\n// `Array.from` method\n// https://tc39.es/ecma262/#sec-array.from\n$$L({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {\n  from: from$6\n});\n\nvar path$r = path$w;\n\nvar from$5 = path$r.Array.from;\n\nvar parent$19 = from$5;\n\nvar from$4 = parent$19;\n\nvar from$3 = from$4;\n\nvar _Array$from$1 = /*@__PURE__*/getDefaultExportFromCjs(from$3);\n\nvar toIndexedObject$5 = toIndexedObject$a;\nvar Iterators$1 = iterators;\nvar InternalStateModule$4 = internalState;\nobjectDefineProperty.f;\nvar defineIterator$1 = iteratorDefine;\nvar createIterResultObject$1 = createIterResultObject$3;\n\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState$4 = InternalStateModule$4.set;\nvar getInternalState$1 = InternalStateModule$4.getterFor(ARRAY_ITERATOR);\n\n// `Array.prototype.entries` method\n// https://tc39.es/ecma262/#sec-array.prototype.entries\n// `Array.prototype.keys` method\n// https://tc39.es/ecma262/#sec-array.prototype.keys\n// `Array.prototype.values` method\n// https://tc39.es/ecma262/#sec-array.prototype.values\n// `Array.prototype[@@iterator]` method\n// https://tc39.es/ecma262/#sec-array.prototype-@@iterator\n// `CreateArrayIterator` internal method\n// https://tc39.es/ecma262/#sec-createarrayiterator\ndefineIterator$1(Array, 'Array', function (iterated, kind) {\n  setInternalState$4(this, {\n    type: ARRAY_ITERATOR,\n    target: toIndexedObject$5(iterated), // target\n    index: 0,                          // next index\n    kind: kind                         // kind\n  });\n// `%ArrayIteratorPrototype%.next` method\n// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next\n}, function () {\n  var state = getInternalState$1(this);\n  var target = state.target;\n  var kind = state.kind;\n  var index = state.index++;\n  if (!target || index >= target.length) {\n    state.target = undefined;\n    return createIterResultObject$1(undefined, true);\n  }\n  switch (kind) {\n    case 'keys': return createIterResultObject$1(index, false);\n    case 'values': return createIterResultObject$1(target[index], false);\n  } return createIterResultObject$1([index, target[index]], false);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values%\n// https://tc39.es/ecma262/#sec-createunmappedargumentsobject\n// https://tc39.es/ecma262/#sec-createmappedargumentsobject\nIterators$1.Arguments = Iterators$1.Array;\n\nvar getIteratorMethod$6 = getIteratorMethod$9;\n\nvar getIteratorMethod_1 = getIteratorMethod$6;\n\n// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nvar domIterables = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n\nvar DOMIterables$2 = domIterables;\nvar global$c = global$n;\nvar classof$8 = classof$d;\nvar createNonEnumerableProperty$1 = createNonEnumerableProperty$6;\nvar Iterators = iterators;\nvar wellKnownSymbol$c = wellKnownSymbol$m;\n\nvar TO_STRING_TAG = wellKnownSymbol$c('toStringTag');\n\nfor (var COLLECTION_NAME in DOMIterables$2) {\n  var Collection = global$c[COLLECTION_NAME];\n  var CollectionPrototype = Collection && Collection.prototype;\n  if (CollectionPrototype && classof$8(CollectionPrototype) !== TO_STRING_TAG) {\n    createNonEnumerableProperty$1(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\n  }\n  Iterators[COLLECTION_NAME] = Iterators.Array;\n}\n\nvar parent$18 = getIteratorMethod_1;\n\n\nvar getIteratorMethod$5 = parent$18;\n\nvar parent$17 = getIteratorMethod$5;\n\nvar getIteratorMethod$4 = parent$17;\n\nvar parent$16 = getIteratorMethod$4;\n\nvar getIteratorMethod$3 = parent$16;\n\nvar getIteratorMethod$2 = getIteratorMethod$3;\n\nvar _getIteratorMethod$1 = /*@__PURE__*/getDefaultExportFromCjs(getIteratorMethod$2);\n\nvar getIteratorMethod$1 = getIteratorMethod$2;\n\nvar _getIteratorMethod = /*@__PURE__*/getDefaultExportFromCjs(getIteratorMethod$1);\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar defineProperty$c = {exports: {}};\n\nvar $$K = _export;\nvar DESCRIPTORS$9 = descriptors;\nvar defineProperty$b = objectDefineProperty.f;\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\n// eslint-disable-next-line es/no-object-defineproperty -- safe\n$$K({ target: 'Object', stat: true, forced: Object.defineProperty !== defineProperty$b, sham: !DESCRIPTORS$9 }, {\n  defineProperty: defineProperty$b\n});\n\nvar path$q = path$w;\n\nvar Object$5 = path$q.Object;\n\nvar defineProperty$a = defineProperty$c.exports = function defineProperty(it, key, desc) {\n  return Object$5.defineProperty(it, key, desc);\n};\n\nif (Object$5.defineProperty.sham) defineProperty$a.sham = true;\n\nvar definePropertyExports = defineProperty$c.exports;\n\nvar parent$15 = definePropertyExports;\n\nvar defineProperty$9 = parent$15;\n\nvar parent$14 = defineProperty$9;\n\nvar defineProperty$8 = parent$14;\n\nvar parent$13 = defineProperty$8;\n\nvar defineProperty$7 = parent$13;\n\nvar defineProperty$6 = defineProperty$7;\n\nvar _Object$defineProperty$1 = /*@__PURE__*/getDefaultExportFromCjs(defineProperty$6);\n\nvar classof$7 = classofRaw$2;\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es/no-array-isarray -- safe\nvar isArray$e = Array.isArray || function isArray(argument) {\n  return classof$7(argument) === 'Array';\n};\n\nvar $TypeError$8 = TypeError;\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; // 2 ** 53 - 1 == 9007199254740991\n\nvar doesNotExceedSafeInteger$3 = function (it) {\n  if (it > MAX_SAFE_INTEGER) throw $TypeError$8('Maximum allowed index exceeded');\n  return it;\n};\n\nvar isArray$d = isArray$e;\nvar isConstructor$2 = isConstructor$4;\nvar isObject$b = isObject$j;\nvar wellKnownSymbol$b = wellKnownSymbol$m;\n\nvar SPECIES$3 = wellKnownSymbol$b('species');\nvar $Array$2 = Array;\n\n// a part of `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesConstructor$1 = function (originalArray) {\n  var C;\n  if (isArray$d(originalArray)) {\n    C = originalArray.constructor;\n    // cross-realm fallback\n    if (isConstructor$2(C) && (C === $Array$2 || isArray$d(C.prototype))) C = undefined;\n    else if (isObject$b(C)) {\n      C = C[SPECIES$3];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? $Array$2 : C;\n};\n\nvar arraySpeciesConstructor = arraySpeciesConstructor$1;\n\n// `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nvar arraySpeciesCreate$3 = function (originalArray, length) {\n  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);\n};\n\nvar fails$k = fails$w;\nvar wellKnownSymbol$a = wellKnownSymbol$m;\nvar V8_VERSION$1 = engineV8Version;\n\nvar SPECIES$2 = wellKnownSymbol$a('species');\n\nvar arrayMethodHasSpeciesSupport$5 = function (METHOD_NAME) {\n  // We can't use this feature detection in V8 since it causes\n  // deoptimization and serious performance degradation\n  // https://github.com/zloirock/core-js/issues/677\n  return V8_VERSION$1 >= 51 || !fails$k(function () {\n    var array = [];\n    var constructor = array.constructor = {};\n    constructor[SPECIES$2] = function () {\n      return { foo: 1 };\n    };\n    return array[METHOD_NAME](Boolean).foo !== 1;\n  });\n};\n\nvar $$J = _export;\nvar fails$j = fails$w;\nvar isArray$c = isArray$e;\nvar isObject$a = isObject$j;\nvar toObject$9 = toObject$e;\nvar lengthOfArrayLike$9 = lengthOfArrayLike$c;\nvar doesNotExceedSafeInteger$2 = doesNotExceedSafeInteger$3;\nvar createProperty$4 = createProperty$6;\nvar arraySpeciesCreate$2 = arraySpeciesCreate$3;\nvar arrayMethodHasSpeciesSupport$4 = arrayMethodHasSpeciesSupport$5;\nvar wellKnownSymbol$9 = wellKnownSymbol$m;\nvar V8_VERSION = engineV8Version;\n\nvar IS_CONCAT_SPREADABLE = wellKnownSymbol$9('isConcatSpreadable');\n\n// We can't use this feature detection in V8 since it causes\n// deoptimization and serious performance degradation\n// https://github.com/zloirock/core-js/issues/679\nvar IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails$j(function () {\n  var array = [];\n  array[IS_CONCAT_SPREADABLE] = false;\n  return array.concat()[0] !== array;\n});\n\nvar isConcatSpreadable = function (O) {\n  if (!isObject$a(O)) return false;\n  var spreadable = O[IS_CONCAT_SPREADABLE];\n  return spreadable !== undefined ? !!spreadable : isArray$c(O);\n};\n\nvar FORCED$a = !IS_CONCAT_SPREADABLE_SUPPORT || !arrayMethodHasSpeciesSupport$4('concat');\n\n// `Array.prototype.concat` method\n// https://tc39.es/ecma262/#sec-array.prototype.concat\n// with adding support of @@isConcatSpreadable and @@species\n$$J({ target: 'Array', proto: true, arity: 1, forced: FORCED$a }, {\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  concat: function concat(arg) {\n    var O = toObject$9(this);\n    var A = arraySpeciesCreate$2(O, 0);\n    var n = 0;\n    var i, k, length, len, E;\n    for (i = -1, length = arguments.length; i < length; i++) {\n      E = i === -1 ? O : arguments[i];\n      if (isConcatSpreadable(E)) {\n        len = lengthOfArrayLike$9(E);\n        doesNotExceedSafeInteger$2(n + len);\n        for (k = 0; k < len; k++, n++) if (k in E) createProperty$4(A, n, E[k]);\n      } else {\n        doesNotExceedSafeInteger$2(n + 1);\n        createProperty$4(A, n++, E);\n      }\n    }\n    A.length = n;\n    return A;\n  }\n});\n\nvar objectGetOwnPropertyNames = {};\n\nvar internalObjectKeys = objectKeysInternal;\nvar enumBugKeys = enumBugKeys$3;\n\nvar hiddenKeys$2 = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nobjectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys$2);\n};\n\nvar objectGetOwnPropertyNamesExternal = {};\n\nvar toAbsoluteIndex$3 = toAbsoluteIndex$5;\nvar lengthOfArrayLike$8 = lengthOfArrayLike$c;\nvar createProperty$3 = createProperty$6;\n\nvar $Array$1 = Array;\nvar max$2 = Math.max;\n\nvar arraySliceSimple = function (O, start, end) {\n  var length = lengthOfArrayLike$8(O);\n  var k = toAbsoluteIndex$3(start, length);\n  var fin = toAbsoluteIndex$3(end === undefined ? length : end, length);\n  var result = $Array$1(max$2(fin - k, 0));\n  var n = 0;\n  for (; k < fin; k++, n++) createProperty$3(result, n, O[k]);\n  result.length = n;\n  return result;\n};\n\n/* eslint-disable es/no-object-getownpropertynames -- safe */\nvar classof$6 = classofRaw$2;\nvar toIndexedObject$4 = toIndexedObject$a;\nvar $getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;\nvar arraySlice$3 = arraySliceSimple;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return $getOwnPropertyNames$1(it);\n  } catch (error) {\n    return arraySlice$3(windowNames);\n  }\n};\n\n// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nobjectGetOwnPropertyNamesExternal.f = function getOwnPropertyNames(it) {\n  return windowNames && classof$6(it) === 'Window'\n    ? getWindowNames(it)\n    : $getOwnPropertyNames$1(toIndexedObject$4(it));\n};\n\nvar defineProperty$5 = objectDefineProperty;\n\nvar defineBuiltInAccessor$3 = function (target, name, descriptor) {\n  return defineProperty$5.f(target, name, descriptor);\n};\n\nvar wellKnownSymbolWrapped = {};\n\nvar wellKnownSymbol$8 = wellKnownSymbol$m;\n\nwellKnownSymbolWrapped.f = wellKnownSymbol$8;\n\nvar path$p = path$w;\nvar hasOwn$8 = hasOwnProperty_1;\nvar wrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;\nvar defineProperty$4 = objectDefineProperty.f;\n\nvar wellKnownSymbolDefine = function (NAME) {\n  var Symbol = path$p.Symbol || (path$p.Symbol = {});\n  if (!hasOwn$8(Symbol, NAME)) defineProperty$4(Symbol, NAME, {\n    value: wrappedWellKnownSymbolModule$1.f(NAME)\n  });\n};\n\nvar call$4 = functionCall;\nvar getBuiltIn$8 = getBuiltIn$c;\nvar wellKnownSymbol$7 = wellKnownSymbol$m;\nvar defineBuiltIn$2 = defineBuiltIn$5;\n\nvar symbolDefineToPrimitive = function () {\n  var Symbol = getBuiltIn$8('Symbol');\n  var SymbolPrototype = Symbol && Symbol.prototype;\n  var valueOf = SymbolPrototype && SymbolPrototype.valueOf;\n  var TO_PRIMITIVE = wellKnownSymbol$7('toPrimitive');\n\n  if (SymbolPrototype && !SymbolPrototype[TO_PRIMITIVE]) {\n    // `Symbol.prototype[@@toPrimitive]` method\n    // https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive\n    // eslint-disable-next-line no-unused-vars -- required for .length\n    defineBuiltIn$2(SymbolPrototype, TO_PRIMITIVE, function (hint) {\n      return call$4(valueOf, this);\n    }, { arity: 1 });\n  }\n};\n\nvar bind$6 = functionBindContext;\nvar uncurryThis$h = functionUncurryThis;\nvar IndexedObject$1 = indexedObject;\nvar toObject$8 = toObject$e;\nvar lengthOfArrayLike$7 = lengthOfArrayLike$c;\nvar arraySpeciesCreate$1 = arraySpeciesCreate$3;\n\nvar push$a = uncurryThis$h([].push);\n\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterReject }` methods implementation\nvar createMethod$2 = function (TYPE) {\n  var IS_MAP = TYPE === 1;\n  var IS_FILTER = TYPE === 2;\n  var IS_SOME = TYPE === 3;\n  var IS_EVERY = TYPE === 4;\n  var IS_FIND_INDEX = TYPE === 6;\n  var IS_FILTER_REJECT = TYPE === 7;\n  var NO_HOLES = TYPE === 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject$8($this);\n    var self = IndexedObject$1(O);\n    var boundFunction = bind$6(callbackfn, that);\n    var length = lengthOfArrayLike$7(self);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate$1;\n    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_REJECT ? create($this, 0) : undefined;\n    var value, result;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3: return true;              // some\n          case 5: return value;             // find\n          case 6: return index;             // findIndex\n          case 2: push$a(target, value);      // filter\n        } else switch (TYPE) {\n          case 4: return false;             // every\n          case 7: push$a(target, value);      // filterReject\n        }\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\n\nvar arrayIteration = {\n  // `Array.prototype.forEach` method\n  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod$2(0),\n  // `Array.prototype.map` method\n  // https://tc39.es/ecma262/#sec-array.prototype.map\n  map: createMethod$2(1),\n  // `Array.prototype.filter` method\n  // https://tc39.es/ecma262/#sec-array.prototype.filter\n  filter: createMethod$2(2),\n  // `Array.prototype.some` method\n  // https://tc39.es/ecma262/#sec-array.prototype.some\n  some: createMethod$2(3),\n  // `Array.prototype.every` method\n  // https://tc39.es/ecma262/#sec-array.prototype.every\n  every: createMethod$2(4),\n  // `Array.prototype.find` method\n  // https://tc39.es/ecma262/#sec-array.prototype.find\n  find: createMethod$2(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod$2(6),\n  // `Array.prototype.filterReject` method\n  // https://github.com/tc39/proposal-array-filtering\n  filterReject: createMethod$2(7)\n};\n\nvar $$I = _export;\nvar global$b = global$n;\nvar call$3 = functionCall;\nvar uncurryThis$g = functionUncurryThis;\nvar DESCRIPTORS$8 = descriptors;\nvar NATIVE_SYMBOL$3 = symbolConstructorDetection;\nvar fails$i = fails$w;\nvar hasOwn$7 = hasOwnProperty_1;\nvar isPrototypeOf$i = objectIsPrototypeOf;\nvar anObject$5 = anObject$d;\nvar toIndexedObject$3 = toIndexedObject$a;\nvar toPropertyKey = toPropertyKey$4;\nvar $toString = toString$a;\nvar createPropertyDescriptor = createPropertyDescriptor$5;\nvar nativeObjectCreate = objectCreate;\nvar objectKeys = objectKeys$3;\nvar getOwnPropertyNamesModule$2 = objectGetOwnPropertyNames;\nvar getOwnPropertyNamesExternal = objectGetOwnPropertyNamesExternal;\nvar getOwnPropertySymbolsModule$2 = objectGetOwnPropertySymbols;\nvar getOwnPropertyDescriptorModule$2 = objectGetOwnPropertyDescriptor;\nvar definePropertyModule = objectDefineProperty;\nvar definePropertiesModule = objectDefineProperties;\nvar propertyIsEnumerableModule = objectPropertyIsEnumerable;\nvar defineBuiltIn$1 = defineBuiltIn$5;\nvar defineBuiltInAccessor$2 = defineBuiltInAccessor$3;\nvar shared$3 = sharedExports;\nvar sharedKey = sharedKey$4;\nvar hiddenKeys$1 = hiddenKeys$6;\nvar uid$1 = uid$4;\nvar wellKnownSymbol$6 = wellKnownSymbol$m;\nvar wrappedWellKnownSymbolModule = wellKnownSymbolWrapped;\nvar defineWellKnownSymbol$l = wellKnownSymbolDefine;\nvar defineSymbolToPrimitive$1 = symbolDefineToPrimitive;\nvar setToStringTag$3 = setToStringTag$6;\nvar InternalStateModule$3 = internalState;\nvar $forEach$1 = arrayIteration.forEach;\n\nvar HIDDEN = sharedKey('hidden');\nvar SYMBOL = 'Symbol';\nvar PROTOTYPE = 'prototype';\n\nvar setInternalState$3 = InternalStateModule$3.set;\nvar getInternalState = InternalStateModule$3.getterFor(SYMBOL);\n\nvar ObjectPrototype$1 = Object[PROTOTYPE];\nvar $Symbol = global$b.Symbol;\nvar SymbolPrototype = $Symbol && $Symbol[PROTOTYPE];\nvar RangeError$1 = global$b.RangeError;\nvar TypeError$1 = global$b.TypeError;\nvar QObject = global$b.QObject;\nvar nativeGetOwnPropertyDescriptor$1 = getOwnPropertyDescriptorModule$2.f;\nvar nativeDefineProperty = definePropertyModule.f;\nvar nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;\nvar nativePropertyIsEnumerable = propertyIsEnumerableModule.f;\nvar push$9 = uncurryThis$g([].push);\n\nvar AllSymbols = shared$3('symbols');\nvar ObjectPrototypeSymbols = shared$3('op-symbols');\nvar WellKnownSymbolsStore$1 = shared$3('wks');\n\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar fallbackDefineProperty = function (O, P, Attributes) {\n  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$1(ObjectPrototype$1, P);\n  if (ObjectPrototypeDescriptor) delete ObjectPrototype$1[P];\n  nativeDefineProperty(O, P, Attributes);\n  if (ObjectPrototypeDescriptor && O !== ObjectPrototype$1) {\n    nativeDefineProperty(ObjectPrototype$1, P, ObjectPrototypeDescriptor);\n  }\n};\n\nvar setSymbolDescriptor = DESCRIPTORS$8 && fails$i(function () {\n  return nativeObjectCreate(nativeDefineProperty({}, 'a', {\n    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }\n  })).a !== 7;\n}) ? fallbackDefineProperty : nativeDefineProperty;\n\nvar wrap = function (tag, description) {\n  var symbol = AllSymbols[tag] = nativeObjectCreate(SymbolPrototype);\n  setInternalState$3(symbol, {\n    type: SYMBOL,\n    tag: tag,\n    description: description\n  });\n  if (!DESCRIPTORS$8) symbol.description = description;\n  return symbol;\n};\n\nvar $defineProperty = function defineProperty(O, P, Attributes) {\n  if (O === ObjectPrototype$1) $defineProperty(ObjectPrototypeSymbols, P, Attributes);\n  anObject$5(O);\n  var key = toPropertyKey(P);\n  anObject$5(Attributes);\n  if (hasOwn$7(AllSymbols, key)) {\n    if (!Attributes.enumerable) {\n      if (!hasOwn$7(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));\n      O[HIDDEN][key] = true;\n    } else {\n      if (hasOwn$7(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;\n      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });\n    } return setSymbolDescriptor(O, key, Attributes);\n  } return nativeDefineProperty(O, key, Attributes);\n};\n\nvar $defineProperties = function defineProperties(O, Properties) {\n  anObject$5(O);\n  var properties = toIndexedObject$3(Properties);\n  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));\n  $forEach$1(keys, function (key) {\n    if (!DESCRIPTORS$8 || call$3($propertyIsEnumerable, properties, key)) $defineProperty(O, key, properties[key]);\n  });\n  return O;\n};\n\nvar $create = function create(O, Properties) {\n  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);\n};\n\nvar $propertyIsEnumerable = function propertyIsEnumerable(V) {\n  var P = toPropertyKey(V);\n  var enumerable = call$3(nativePropertyIsEnumerable, this, P);\n  if (this === ObjectPrototype$1 && hasOwn$7(AllSymbols, P) && !hasOwn$7(ObjectPrototypeSymbols, P)) return false;\n  return enumerable || !hasOwn$7(this, P) || !hasOwn$7(AllSymbols, P) || hasOwn$7(this, HIDDEN) && this[HIDDEN][P]\n    ? enumerable : true;\n};\n\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {\n  var it = toIndexedObject$3(O);\n  var key = toPropertyKey(P);\n  if (it === ObjectPrototype$1 && hasOwn$7(AllSymbols, key) && !hasOwn$7(ObjectPrototypeSymbols, key)) return;\n  var descriptor = nativeGetOwnPropertyDescriptor$1(it, key);\n  if (descriptor && hasOwn$7(AllSymbols, key) && !(hasOwn$7(it, HIDDEN) && it[HIDDEN][key])) {\n    descriptor.enumerable = true;\n  }\n  return descriptor;\n};\n\nvar $getOwnPropertyNames = function getOwnPropertyNames(O) {\n  var names = nativeGetOwnPropertyNames(toIndexedObject$3(O));\n  var result = [];\n  $forEach$1(names, function (key) {\n    if (!hasOwn$7(AllSymbols, key) && !hasOwn$7(hiddenKeys$1, key)) push$9(result, key);\n  });\n  return result;\n};\n\nvar $getOwnPropertySymbols = function (O) {\n  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$1;\n  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject$3(O));\n  var result = [];\n  $forEach$1(names, function (key) {\n    if (hasOwn$7(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn$7(ObjectPrototype$1, key))) {\n      push$9(result, AllSymbols[key]);\n    }\n  });\n  return result;\n};\n\n// `Symbol` constructor\n// https://tc39.es/ecma262/#sec-symbol-constructor\nif (!NATIVE_SYMBOL$3) {\n  $Symbol = function Symbol() {\n    if (isPrototypeOf$i(SymbolPrototype, this)) throw new TypeError$1('Symbol is not a constructor');\n    var description = !arguments.length || arguments[0] === undefined ? undefined : $toString(arguments[0]);\n    var tag = uid$1(description);\n    var setter = function (value) {\n      if (this === ObjectPrototype$1) call$3(setter, ObjectPrototypeSymbols, value);\n      if (hasOwn$7(this, HIDDEN) && hasOwn$7(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      var descriptor = createPropertyDescriptor(1, value);\n      try {\n        setSymbolDescriptor(this, tag, descriptor);\n      } catch (error) {\n        if (!(error instanceof RangeError$1)) throw error;\n        fallbackDefineProperty(this, tag, descriptor);\n      }\n    };\n    if (DESCRIPTORS$8 && USE_SETTER) setSymbolDescriptor(ObjectPrototype$1, tag, { configurable: true, set: setter });\n    return wrap(tag, description);\n  };\n\n  SymbolPrototype = $Symbol[PROTOTYPE];\n\n  defineBuiltIn$1(SymbolPrototype, 'toString', function toString() {\n    return getInternalState(this).tag;\n  });\n\n  defineBuiltIn$1($Symbol, 'withoutSetter', function (description) {\n    return wrap(uid$1(description), description);\n  });\n\n  propertyIsEnumerableModule.f = $propertyIsEnumerable;\n  definePropertyModule.f = $defineProperty;\n  definePropertiesModule.f = $defineProperties;\n  getOwnPropertyDescriptorModule$2.f = $getOwnPropertyDescriptor;\n  getOwnPropertyNamesModule$2.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;\n  getOwnPropertySymbolsModule$2.f = $getOwnPropertySymbols;\n\n  wrappedWellKnownSymbolModule.f = function (name) {\n    return wrap(wellKnownSymbol$6(name), name);\n  };\n\n  if (DESCRIPTORS$8) {\n    // https://github.com/tc39/proposal-Symbol-description\n    defineBuiltInAccessor$2(SymbolPrototype, 'description', {\n      configurable: true,\n      get: function description() {\n        return getInternalState(this).description;\n      }\n    });\n  }\n}\n\n$$I({ global: true, constructor: true, wrap: true, forced: !NATIVE_SYMBOL$3, sham: !NATIVE_SYMBOL$3 }, {\n  Symbol: $Symbol\n});\n\n$forEach$1(objectKeys(WellKnownSymbolsStore$1), function (name) {\n  defineWellKnownSymbol$l(name);\n});\n\n$$I({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL$3 }, {\n  useSetter: function () { USE_SETTER = true; },\n  useSimple: function () { USE_SETTER = false; }\n});\n\n$$I({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL$3, sham: !DESCRIPTORS$8 }, {\n  // `Object.create` method\n  // https://tc39.es/ecma262/#sec-object.create\n  create: $create,\n  // `Object.defineProperty` method\n  // https://tc39.es/ecma262/#sec-object.defineproperty\n  defineProperty: $defineProperty,\n  // `Object.defineProperties` method\n  // https://tc39.es/ecma262/#sec-object.defineproperties\n  defineProperties: $defineProperties,\n  // `Object.getOwnPropertyDescriptor` method\n  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor\n});\n\n$$I({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL$3 }, {\n  // `Object.getOwnPropertyNames` method\n  // https://tc39.es/ecma262/#sec-object.getownpropertynames\n  getOwnPropertyNames: $getOwnPropertyNames\n});\n\n// `Symbol.prototype[@@toPrimitive]` method\n// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive\ndefineSymbolToPrimitive$1();\n\n// `Symbol.prototype[@@toStringTag]` property\n// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag\nsetToStringTag$3($Symbol, SYMBOL);\n\nhiddenKeys$1[HIDDEN] = true;\n\nvar NATIVE_SYMBOL$2 = symbolConstructorDetection;\n\n/* eslint-disable es/no-symbol -- safe */\nvar symbolRegistryDetection = NATIVE_SYMBOL$2 && !!Symbol['for'] && !!Symbol.keyFor;\n\nvar $$H = _export;\nvar getBuiltIn$7 = getBuiltIn$c;\nvar hasOwn$6 = hasOwnProperty_1;\nvar toString$6 = toString$a;\nvar shared$2 = sharedExports;\nvar NATIVE_SYMBOL_REGISTRY$1 = symbolRegistryDetection;\n\nvar StringToSymbolRegistry = shared$2('string-to-symbol-registry');\nvar SymbolToStringRegistry$1 = shared$2('symbol-to-string-registry');\n\n// `Symbol.for` method\n// https://tc39.es/ecma262/#sec-symbol.for\n$$H({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY$1 }, {\n  'for': function (key) {\n    var string = toString$6(key);\n    if (hasOwn$6(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];\n    var symbol = getBuiltIn$7('Symbol')(string);\n    StringToSymbolRegistry[string] = symbol;\n    SymbolToStringRegistry$1[symbol] = string;\n    return symbol;\n  }\n});\n\nvar $$G = _export;\nvar hasOwn$5 = hasOwnProperty_1;\nvar isSymbol$2 = isSymbol$5;\nvar tryToString$3 = tryToString$6;\nvar shared$1 = sharedExports;\nvar NATIVE_SYMBOL_REGISTRY = symbolRegistryDetection;\n\nvar SymbolToStringRegistry = shared$1('symbol-to-string-registry');\n\n// `Symbol.keyFor` method\n// https://tc39.es/ecma262/#sec-symbol.keyfor\n$$G({ target: 'Symbol', stat: true, forced: !NATIVE_SYMBOL_REGISTRY }, {\n  keyFor: function keyFor(sym) {\n    if (!isSymbol$2(sym)) throw new TypeError(tryToString$3(sym) + ' is not a symbol');\n    if (hasOwn$5(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];\n  }\n});\n\nvar uncurryThis$f = functionUncurryThis;\nvar isArray$b = isArray$e;\nvar isCallable$3 = isCallable$i;\nvar classof$5 = classofRaw$2;\nvar toString$5 = toString$a;\n\nvar push$8 = uncurryThis$f([].push);\n\nvar getJsonReplacerFunction = function (replacer) {\n  if (isCallable$3(replacer)) return replacer;\n  if (!isArray$b(replacer)) return;\n  var rawLength = replacer.length;\n  var keys = [];\n  for (var i = 0; i < rawLength; i++) {\n    var element = replacer[i];\n    if (typeof element == 'string') push$8(keys, element);\n    else if (typeof element == 'number' || classof$5(element) === 'Number' || classof$5(element) === 'String') push$8(keys, toString$5(element));\n  }\n  var keysLength = keys.length;\n  var root = true;\n  return function (key, value) {\n    if (root) {\n      root = false;\n      return value;\n    }\n    if (isArray$b(this)) return value;\n    for (var j = 0; j < keysLength; j++) if (keys[j] === key) return value;\n  };\n};\n\nvar $$F = _export;\nvar getBuiltIn$6 = getBuiltIn$c;\nvar apply$3 = functionApply;\nvar call$2 = functionCall;\nvar uncurryThis$e = functionUncurryThis;\nvar fails$h = fails$w;\nvar isCallable$2 = isCallable$i;\nvar isSymbol$1 = isSymbol$5;\nvar arraySlice$2 = arraySlice$5;\nvar getReplacerFunction = getJsonReplacerFunction;\nvar NATIVE_SYMBOL$1 = symbolConstructorDetection;\n\nvar $String = String;\nvar $stringify = getBuiltIn$6('JSON', 'stringify');\nvar exec$1 = uncurryThis$e(/./.exec);\nvar charAt$1 = uncurryThis$e(''.charAt);\nvar charCodeAt = uncurryThis$e(''.charCodeAt);\nvar replace$1 = uncurryThis$e(''.replace);\nvar numberToString = uncurryThis$e(1.0.toString);\n\nvar tester = /[\\uD800-\\uDFFF]/g;\nvar low = /^[\\uD800-\\uDBFF]$/;\nvar hi = /^[\\uDC00-\\uDFFF]$/;\n\nvar WRONG_SYMBOLS_CONVERSION = !NATIVE_SYMBOL$1 || fails$h(function () {\n  var symbol = getBuiltIn$6('Symbol')('stringify detection');\n  // MS Edge converts symbol values to JSON as {}\n  return $stringify([symbol]) !== '[null]'\n    // WebKit converts symbol values to JSON as null\n    || $stringify({ a: symbol }) !== '{}'\n    // V8 throws on boxed symbols\n    || $stringify(Object(symbol)) !== '{}';\n});\n\n// https://github.com/tc39/proposal-well-formed-stringify\nvar ILL_FORMED_UNICODE = fails$h(function () {\n  return $stringify('\\uDF06\\uD834') !== '\"\\\\udf06\\\\ud834\"'\n    || $stringify('\\uDEAD') !== '\"\\\\udead\"';\n});\n\nvar stringifyWithSymbolsFix = function (it, replacer) {\n  var args = arraySlice$2(arguments);\n  var $replacer = getReplacerFunction(replacer);\n  if (!isCallable$2($replacer) && (it === undefined || isSymbol$1(it))) return; // IE8 returns string on undefined\n  args[1] = function (key, value) {\n    // some old implementations (like WebKit) could pass numbers as keys\n    if (isCallable$2($replacer)) value = call$2($replacer, this, $String(key), value);\n    if (!isSymbol$1(value)) return value;\n  };\n  return apply$3($stringify, null, args);\n};\n\nvar fixIllFormed = function (match, offset, string) {\n  var prev = charAt$1(string, offset - 1);\n  var next = charAt$1(string, offset + 1);\n  if ((exec$1(low, match) && !exec$1(hi, next)) || (exec$1(hi, match) && !exec$1(low, prev))) {\n    return '\\\\u' + numberToString(charCodeAt(match, 0), 16);\n  } return match;\n};\n\nif ($stringify) {\n  // `JSON.stringify` method\n  // https://tc39.es/ecma262/#sec-json.stringify\n  $$F({ target: 'JSON', stat: true, arity: 3, forced: WRONG_SYMBOLS_CONVERSION || ILL_FORMED_UNICODE }, {\n    // eslint-disable-next-line no-unused-vars -- required for `.length`\n    stringify: function stringify(it, replacer, space) {\n      var args = arraySlice$2(arguments);\n      var result = apply$3(WRONG_SYMBOLS_CONVERSION ? stringifyWithSymbolsFix : $stringify, null, args);\n      return ILL_FORMED_UNICODE && typeof result == 'string' ? replace$1(result, tester, fixIllFormed) : result;\n    }\n  });\n}\n\nvar $$E = _export;\nvar NATIVE_SYMBOL = symbolConstructorDetection;\nvar fails$g = fails$w;\nvar getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;\nvar toObject$7 = toObject$e;\n\n// V8 ~ Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives\n// https://bugs.chromium.org/p/v8/issues/detail?id=3443\nvar FORCED$9 = !NATIVE_SYMBOL || fails$g(function () { getOwnPropertySymbolsModule$1.f(1); });\n\n// `Object.getOwnPropertySymbols` method\n// https://tc39.es/ecma262/#sec-object.getownpropertysymbols\n$$E({ target: 'Object', stat: true, forced: FORCED$9 }, {\n  getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n    var $getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;\n    return $getOwnPropertySymbols ? $getOwnPropertySymbols(toObject$7(it)) : [];\n  }\n});\n\nvar defineWellKnownSymbol$k = wellKnownSymbolDefine;\n\n// `Symbol.asyncIterator` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.asynciterator\ndefineWellKnownSymbol$k('asyncIterator');\n\nvar defineWellKnownSymbol$j = wellKnownSymbolDefine;\n\n// `Symbol.hasInstance` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.hasinstance\ndefineWellKnownSymbol$j('hasInstance');\n\nvar defineWellKnownSymbol$i = wellKnownSymbolDefine;\n\n// `Symbol.isConcatSpreadable` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.isconcatspreadable\ndefineWellKnownSymbol$i('isConcatSpreadable');\n\nvar defineWellKnownSymbol$h = wellKnownSymbolDefine;\n\n// `Symbol.iterator` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.iterator\ndefineWellKnownSymbol$h('iterator');\n\nvar defineWellKnownSymbol$g = wellKnownSymbolDefine;\n\n// `Symbol.match` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.match\ndefineWellKnownSymbol$g('match');\n\nvar defineWellKnownSymbol$f = wellKnownSymbolDefine;\n\n// `Symbol.matchAll` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.matchall\ndefineWellKnownSymbol$f('matchAll');\n\nvar defineWellKnownSymbol$e = wellKnownSymbolDefine;\n\n// `Symbol.replace` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.replace\ndefineWellKnownSymbol$e('replace');\n\nvar defineWellKnownSymbol$d = wellKnownSymbolDefine;\n\n// `Symbol.search` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.search\ndefineWellKnownSymbol$d('search');\n\nvar defineWellKnownSymbol$c = wellKnownSymbolDefine;\n\n// `Symbol.species` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.species\ndefineWellKnownSymbol$c('species');\n\nvar defineWellKnownSymbol$b = wellKnownSymbolDefine;\n\n// `Symbol.split` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.split\ndefineWellKnownSymbol$b('split');\n\nvar defineWellKnownSymbol$a = wellKnownSymbolDefine;\nvar defineSymbolToPrimitive = symbolDefineToPrimitive;\n\n// `Symbol.toPrimitive` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.toprimitive\ndefineWellKnownSymbol$a('toPrimitive');\n\n// `Symbol.prototype[@@toPrimitive]` method\n// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive\ndefineSymbolToPrimitive();\n\nvar getBuiltIn$5 = getBuiltIn$c;\nvar defineWellKnownSymbol$9 = wellKnownSymbolDefine;\nvar setToStringTag$2 = setToStringTag$6;\n\n// `Symbol.toStringTag` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.tostringtag\ndefineWellKnownSymbol$9('toStringTag');\n\n// `Symbol.prototype[@@toStringTag]` property\n// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag\nsetToStringTag$2(getBuiltIn$5('Symbol'), 'Symbol');\n\nvar defineWellKnownSymbol$8 = wellKnownSymbolDefine;\n\n// `Symbol.unscopables` well-known symbol\n// https://tc39.es/ecma262/#sec-symbol.unscopables\ndefineWellKnownSymbol$8('unscopables');\n\nvar global$a = global$n;\nvar setToStringTag$1 = setToStringTag$6;\n\n// JSON[@@toStringTag] property\n// https://tc39.es/ecma262/#sec-json-@@tostringtag\nsetToStringTag$1(global$a.JSON, 'JSON', true);\n\nvar path$o = path$w;\n\nvar symbol$5 = path$o.Symbol;\n\nvar parent$12 = symbol$5;\n\n\nvar symbol$4 = parent$12;\n\nvar wellKnownSymbol$5 = wellKnownSymbol$m;\nvar defineProperty$3 = objectDefineProperty.f;\n\nvar METADATA$1 = wellKnownSymbol$5('metadata');\nvar FunctionPrototype = Function.prototype;\n\n// Function.prototype[@@metadata]\n// https://github.com/tc39/proposal-decorator-metadata\nif (FunctionPrototype[METADATA$1] === undefined) {\n  defineProperty$3(FunctionPrototype, METADATA$1, {\n    value: null\n  });\n}\n\nvar defineWellKnownSymbol$7 = wellKnownSymbolDefine;\n\n// `Symbol.asyncDispose` well-known symbol\n// https://github.com/tc39/proposal-async-explicit-resource-management\ndefineWellKnownSymbol$7('asyncDispose');\n\nvar defineWellKnownSymbol$6 = wellKnownSymbolDefine;\n\n// `Symbol.dispose` well-known symbol\n// https://github.com/tc39/proposal-explicit-resource-management\ndefineWellKnownSymbol$6('dispose');\n\n// TODO: Remove from `core-js@4`\nvar defineWellKnownSymbol$5 = wellKnownSymbolDefine;\n\n// `Symbol.metadata` well-known symbol\n// https://github.com/tc39/proposal-decorators\ndefineWellKnownSymbol$5('metadata');\n\nvar parent$11 = symbol$4;\n\n\n\n\n\n\nvar symbol$3 = parent$11;\n\nvar getBuiltIn$4 = getBuiltIn$c;\nvar uncurryThis$d = functionUncurryThis;\n\nvar Symbol$4 = getBuiltIn$4('Symbol');\nvar keyFor = Symbol$4.keyFor;\nvar thisSymbolValue$1 = uncurryThis$d(Symbol$4.prototype.valueOf);\n\n// `Symbol.isRegisteredSymbol` method\n// https://tc39.es/proposal-symbol-predicates/#sec-symbol-isregisteredsymbol\nvar symbolIsRegistered = Symbol$4.isRegisteredSymbol || function isRegisteredSymbol(value) {\n  try {\n    return keyFor(thisSymbolValue$1(value)) !== undefined;\n  } catch (error) {\n    return false;\n  }\n};\n\nvar $$D = _export;\nvar isRegisteredSymbol$1 = symbolIsRegistered;\n\n// `Symbol.isRegisteredSymbol` method\n// https://tc39.es/proposal-symbol-predicates/#sec-symbol-isregisteredsymbol\n$$D({ target: 'Symbol', stat: true }, {\n  isRegisteredSymbol: isRegisteredSymbol$1\n});\n\nvar shared = sharedExports;\nvar getBuiltIn$3 = getBuiltIn$c;\nvar uncurryThis$c = functionUncurryThis;\nvar isSymbol = isSymbol$5;\nvar wellKnownSymbol$4 = wellKnownSymbol$m;\n\nvar Symbol$3 = getBuiltIn$3('Symbol');\nvar $isWellKnownSymbol = Symbol$3.isWellKnownSymbol;\nvar getOwnPropertyNames$4 = getBuiltIn$3('Object', 'getOwnPropertyNames');\nvar thisSymbolValue = uncurryThis$c(Symbol$3.prototype.valueOf);\nvar WellKnownSymbolsStore = shared('wks');\n\nfor (var i = 0, symbolKeys = getOwnPropertyNames$4(Symbol$3), symbolKeysLength = symbolKeys.length; i < symbolKeysLength; i++) {\n  // some old engines throws on access to some keys like `arguments` or `caller`\n  try {\n    var symbolKey = symbolKeys[i];\n    if (isSymbol(Symbol$3[symbolKey])) wellKnownSymbol$4(symbolKey);\n  } catch (error) { /* empty */ }\n}\n\n// `Symbol.isWellKnownSymbol` method\n// https://tc39.es/proposal-symbol-predicates/#sec-symbol-iswellknownsymbol\n// We should patch it for newly added well-known symbols. If it's not required, this module just will not be injected\nvar symbolIsWellKnown = function isWellKnownSymbol(value) {\n  if ($isWellKnownSymbol && $isWellKnownSymbol(value)) return true;\n  try {\n    var symbol = thisSymbolValue(value);\n    for (var j = 0, keys = getOwnPropertyNames$4(WellKnownSymbolsStore), keysLength = keys.length; j < keysLength; j++) {\n      // eslint-disable-next-line eqeqeq -- polyfilled symbols case\n      if (WellKnownSymbolsStore[keys[j]] == symbol) return true;\n    }\n  } catch (error) { /* empty */ }\n  return false;\n};\n\nvar $$C = _export;\nvar isWellKnownSymbol$1 = symbolIsWellKnown;\n\n// `Symbol.isWellKnownSymbol` method\n// https://tc39.es/proposal-symbol-predicates/#sec-symbol-iswellknownsymbol\n// We should patch it for newly added well-known symbols. If it's not required, this module just will not be injected\n$$C({ target: 'Symbol', stat: true, forced: true }, {\n  isWellKnownSymbol: isWellKnownSymbol$1\n});\n\nvar defineWellKnownSymbol$4 = wellKnownSymbolDefine;\n\n// `Symbol.matcher` well-known symbol\n// https://github.com/tc39/proposal-pattern-matching\ndefineWellKnownSymbol$4('matcher');\n\nvar defineWellKnownSymbol$3 = wellKnownSymbolDefine;\n\n// `Symbol.observable` well-known symbol\n// https://github.com/tc39/proposal-observable\ndefineWellKnownSymbol$3('observable');\n\nvar $$B = _export;\nvar isRegisteredSymbol = symbolIsRegistered;\n\n// `Symbol.isRegistered` method\n// obsolete version of https://tc39.es/proposal-symbol-predicates/#sec-symbol-isregisteredsymbol\n$$B({ target: 'Symbol', stat: true, name: 'isRegisteredSymbol' }, {\n  isRegistered: isRegisteredSymbol\n});\n\nvar $$A = _export;\nvar isWellKnownSymbol = symbolIsWellKnown;\n\n// `Symbol.isWellKnown` method\n// obsolete version of https://tc39.es/proposal-symbol-predicates/#sec-symbol-iswellknownsymbol\n// We should patch it for newly added well-known symbols. If it's not required, this module just will not be injected\n$$A({ target: 'Symbol', stat: true, name: 'isWellKnownSymbol', forced: true }, {\n  isWellKnown: isWellKnownSymbol\n});\n\nvar defineWellKnownSymbol$2 = wellKnownSymbolDefine;\n\n// `Symbol.metadataKey` well-known symbol\n// https://github.com/tc39/proposal-decorator-metadata\ndefineWellKnownSymbol$2('metadataKey');\n\n// TODO: remove from `core-js@4`\nvar defineWellKnownSymbol$1 = wellKnownSymbolDefine;\n\n// `Symbol.patternMatch` well-known symbol\n// https://github.com/tc39/proposal-pattern-matching\ndefineWellKnownSymbol$1('patternMatch');\n\n// TODO: remove from `core-js@4`\nvar defineWellKnownSymbol = wellKnownSymbolDefine;\n\ndefineWellKnownSymbol('replaceAll');\n\nvar parent$10 = symbol$3;\n\n\n\n\n// TODO: Remove from `core-js@4`\n\n\n\n\n\n\nvar symbol$2 = parent$10;\n\nvar symbol$1 = symbol$2;\n\nvar _Symbol$1 = /*@__PURE__*/getDefaultExportFromCjs(symbol$1);\n\nvar WrappedWellKnownSymbolModule$1 = wellKnownSymbolWrapped;\n\nvar iterator$4 = WrappedWellKnownSymbolModule$1.f('iterator');\n\nvar parent$$ = iterator$4;\n\n\nvar iterator$3 = parent$$;\n\nvar parent$_ = iterator$3;\n\nvar iterator$2 = parent$_;\n\nvar parent$Z = iterator$2;\n\nvar iterator$1 = parent$Z;\n\nvar iterator = iterator$1;\n\nvar _Symbol$iterator = /*@__PURE__*/getDefaultExportFromCjs(iterator);\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof _Symbol$1 && \"symbol\" == typeof _Symbol$iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof _Symbol$1 && o.constructor === _Symbol$1 && o !== _Symbol$1.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\nvar WrappedWellKnownSymbolModule = wellKnownSymbolWrapped;\n\nvar toPrimitive$4 = WrappedWellKnownSymbolModule.f('toPrimitive');\n\nvar parent$Y = toPrimitive$4;\n\nvar toPrimitive$3 = parent$Y;\n\nvar parent$X = toPrimitive$3;\n\nvar toPrimitive$2 = parent$X;\n\nvar parent$W = toPrimitive$2;\n\nvar toPrimitive$1 = parent$W;\n\nvar toPrimitive = toPrimitive$1;\n\nvar _Symbol$toPrimitive = /*@__PURE__*/getDefaultExportFromCjs(toPrimitive);\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[_Symbol$toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    _Object$defineProperty$1(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  _Object$defineProperty$1(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nvar $$z = _export;\nvar isArray$a = isArray$e;\n\n// `Array.isArray` method\n// https://tc39.es/ecma262/#sec-array.isarray\n$$z({ target: 'Array', stat: true }, {\n  isArray: isArray$a\n});\n\nvar path$n = path$w;\n\nvar isArray$9 = path$n.Array.isArray;\n\nvar parent$V = isArray$9;\n\nvar isArray$8 = parent$V;\n\nvar parent$U = isArray$8;\n\nvar isArray$7 = parent$U;\n\nvar parent$T = isArray$7;\n\nvar isArray$6 = parent$T;\n\nvar isArray$5 = isArray$6;\n\nvar _Array$isArray$1 = /*@__PURE__*/getDefaultExportFromCjs(isArray$5);\n\nfunction _arrayWithHoles(arr) {\n  if (_Array$isArray$1(arr)) return arr;\n}\n\nvar DESCRIPTORS$7 = descriptors;\nvar isArray$4 = isArray$e;\n\nvar $TypeError$7 = TypeError;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor$7 = Object.getOwnPropertyDescriptor;\n\n// Safari < 13 does not throw an error in this case\nvar SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS$7 && !function () {\n  // makes no sense without proper strict mode support\n  if (this !== undefined) return true;\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty([], 'length', { writable: false }).length = 1;\n  } catch (error) {\n    return error instanceof TypeError;\n  }\n}();\n\nvar arraySetLength = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {\n  if (isArray$4(O) && !getOwnPropertyDescriptor$7(O, 'length').writable) {\n    throw new $TypeError$7('Cannot set read only .length');\n  } return O.length = length;\n} : function (O, length) {\n  return O.length = length;\n};\n\nvar $$y = _export;\nvar toObject$6 = toObject$e;\nvar lengthOfArrayLike$6 = lengthOfArrayLike$c;\nvar setArrayLength$1 = arraySetLength;\nvar doesNotExceedSafeInteger$1 = doesNotExceedSafeInteger$3;\nvar fails$f = fails$w;\n\nvar INCORRECT_TO_LENGTH = fails$f(function () {\n  return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;\n});\n\n// V8 and Safari <= 15.4, FF < 23 throws InternalError\n// https://bugs.chromium.org/p/v8/issues/detail?id=12681\nvar properErrorOnNonWritableLength = function () {\n  try {\n    // eslint-disable-next-line es/no-object-defineproperty -- safe\n    Object.defineProperty([], 'length', { writable: false }).push();\n  } catch (error) {\n    return error instanceof TypeError;\n  }\n};\n\nvar FORCED$8 = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();\n\n// `Array.prototype.push` method\n// https://tc39.es/ecma262/#sec-array.prototype.push\n$$y({ target: 'Array', proto: true, arity: 1, forced: FORCED$8 }, {\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  push: function push(item) {\n    var O = toObject$6(this);\n    var len = lengthOfArrayLike$6(O);\n    var argCount = arguments.length;\n    doesNotExceedSafeInteger$1(len + argCount);\n    for (var i = 0; i < argCount; i++) {\n      O[len] = arguments[i];\n      len++;\n    }\n    setArrayLength$1(O, len);\n    return len;\n  }\n});\n\nvar entryVirtual$g = entryVirtual$i;\n\nvar push$7 = entryVirtual$g('Array').push;\n\nvar isPrototypeOf$h = objectIsPrototypeOf;\nvar method$e = push$7;\n\nvar ArrayPrototype$f = Array.prototype;\n\nvar push$6 = function (it) {\n  var own = it.push;\n  return it === ArrayPrototype$f || (isPrototypeOf$h(ArrayPrototype$f, it) && own === ArrayPrototype$f.push) ? method$e : own;\n};\n\nvar parent$S = push$6;\n\nvar push$5 = parent$S;\n\nvar parent$R = push$5;\n\nvar push$4 = parent$R;\n\nvar parent$Q = push$4;\n\nvar push$3 = parent$Q;\n\nvar push$2 = push$3;\n\nvar _pushInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(push$2);\n\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof _Symbol$1 && _getIteratorMethod$1(r) || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (_pushInstanceProperty(a).call(a, e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\n\nvar $$x = _export;\nvar isArray$3 = isArray$e;\nvar isConstructor$1 = isConstructor$4;\nvar isObject$9 = isObject$j;\nvar toAbsoluteIndex$2 = toAbsoluteIndex$5;\nvar lengthOfArrayLike$5 = lengthOfArrayLike$c;\nvar toIndexedObject$2 = toIndexedObject$a;\nvar createProperty$2 = createProperty$6;\nvar wellKnownSymbol$3 = wellKnownSymbol$m;\nvar arrayMethodHasSpeciesSupport$3 = arrayMethodHasSpeciesSupport$5;\nvar nativeSlice = arraySlice$5;\n\nvar HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport$3('slice');\n\nvar SPECIES$1 = wellKnownSymbol$3('species');\nvar $Array = Array;\nvar max$1 = Math.max;\n\n// `Array.prototype.slice` method\n// https://tc39.es/ecma262/#sec-array.prototype.slice\n// fallback for not array-like ES3 strings and DOM objects\n$$x({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$3 }, {\n  slice: function slice(start, end) {\n    var O = toIndexedObject$2(this);\n    var length = lengthOfArrayLike$5(O);\n    var k = toAbsoluteIndex$2(start, length);\n    var fin = toAbsoluteIndex$2(end === undefined ? length : end, length);\n    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible\n    var Constructor, result, n;\n    if (isArray$3(O)) {\n      Constructor = O.constructor;\n      // cross-realm fallback\n      if (isConstructor$1(Constructor) && (Constructor === $Array || isArray$3(Constructor.prototype))) {\n        Constructor = undefined;\n      } else if (isObject$9(Constructor)) {\n        Constructor = Constructor[SPECIES$1];\n        if (Constructor === null) Constructor = undefined;\n      }\n      if (Constructor === $Array || Constructor === undefined) {\n        return nativeSlice(O, k, fin);\n      }\n    }\n    result = new (Constructor === undefined ? $Array : Constructor)(max$1(fin - k, 0));\n    for (n = 0; k < fin; k++, n++) if (k in O) createProperty$2(result, n, O[k]);\n    result.length = n;\n    return result;\n  }\n});\n\nvar entryVirtual$f = entryVirtual$i;\n\nvar slice$6 = entryVirtual$f('Array').slice;\n\nvar isPrototypeOf$g = objectIsPrototypeOf;\nvar method$d = slice$6;\n\nvar ArrayPrototype$e = Array.prototype;\n\nvar slice$5 = function (it) {\n  var own = it.slice;\n  return it === ArrayPrototype$e || (isPrototypeOf$g(ArrayPrototype$e, it) && own === ArrayPrototype$e.slice) ? method$d : own;\n};\n\nvar parent$P = slice$5;\n\nvar slice$4 = parent$P;\n\nvar parent$O = slice$4;\n\nvar slice$3 = parent$O;\n\nvar parent$N = slice$3;\n\nvar slice$2 = parent$N;\n\nvar slice$1 = slice$2;\n\nvar _sliceInstanceProperty$1 = /*@__PURE__*/getDefaultExportFromCjs(slice$1);\n\nvar parent$M = from$4;\n\nvar from$2 = parent$M;\n\nvar parent$L = from$2;\n\nvar from$1 = parent$L;\n\nvar from = from$1;\n\nvar _Array$from = /*@__PURE__*/getDefaultExportFromCjs(from);\n\nfunction _arrayLikeToArray$7(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\n\nfunction _unsupportedIterableToArray$7(o, minLen) {\n  var _context;\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray$7(o, minLen);\n  var n = _sliceInstanceProperty$1(_context = Object.prototype.toString.call(o)).call(_context, 8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return _Array$from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$7(arr, i) || _nonIterableRest();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (_Array$isArray$1(arr)) return _arrayLikeToArray$7(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof _Symbol$1 !== \"undefined\" && _getIteratorMethod$1(iter) != null || iter[\"@@iterator\"] != null) return _Array$from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$7(arr) || _nonIterableSpread();\n}\n\nvar symbol = symbol$4;\n\nvar _Symbol = /*@__PURE__*/getDefaultExportFromCjs(symbol);\n\nvar entryVirtual$e = entryVirtual$i;\n\nvar concat$4 = entryVirtual$e('Array').concat;\n\nvar isPrototypeOf$f = objectIsPrototypeOf;\nvar method$c = concat$4;\n\nvar ArrayPrototype$d = Array.prototype;\n\nvar concat$3 = function (it) {\n  var own = it.concat;\n  return it === ArrayPrototype$d || (isPrototypeOf$f(ArrayPrototype$d, it) && own === ArrayPrototype$d.concat) ? method$c : own;\n};\n\nvar parent$K = concat$3;\n\nvar concat$2 = parent$K;\n\nvar concat$1 = concat$2;\n\nvar _concatInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(concat$1);\n\nvar slice = slice$4;\n\nvar _sliceInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(slice);\n\nvar getBuiltIn$2 = getBuiltIn$c;\nvar uncurryThis$b = functionUncurryThis;\nvar getOwnPropertyNamesModule$1 = objectGetOwnPropertyNames;\nvar getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;\nvar anObject$4 = anObject$d;\n\nvar concat = uncurryThis$b([].concat);\n\n// all object keys, includes non-enumerable and symbols\nvar ownKeys$5 = getBuiltIn$2('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule$1.f(anObject$4(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\n\nvar isArray$2 = isArray$8;\n\nvar _Array$isArray = /*@__PURE__*/getDefaultExportFromCjs(isArray$2);\n\nvar $$w = _export;\nvar $map = arrayIteration.map;\nvar arrayMethodHasSpeciesSupport$2 = arrayMethodHasSpeciesSupport$5;\n\nvar HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport$2('map');\n\n// `Array.prototype.map` method\n// https://tc39.es/ecma262/#sec-array.prototype.map\n// with adding support of @@species\n$$w({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 }, {\n  map: function map(callbackfn /* , thisArg */) {\n    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar entryVirtual$d = entryVirtual$i;\n\nvar map$6 = entryVirtual$d('Array').map;\n\nvar isPrototypeOf$e = objectIsPrototypeOf;\nvar method$b = map$6;\n\nvar ArrayPrototype$c = Array.prototype;\n\nvar map$5 = function (it) {\n  var own = it.map;\n  return it === ArrayPrototype$c || (isPrototypeOf$e(ArrayPrototype$c, it) && own === ArrayPrototype$c.map) ? method$b : own;\n};\n\nvar parent$J = map$5;\n\nvar map$4 = parent$J;\n\nvar map$3 = map$4;\n\nvar _mapInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(map$3);\n\nvar $$v = _export;\nvar toObject$5 = toObject$e;\nvar nativeKeys = objectKeys$3;\nvar fails$e = fails$w;\n\nvar FAILS_ON_PRIMITIVES$3 = fails$e(function () { nativeKeys(1); });\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n$$v({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$3 }, {\n  keys: function keys(it) {\n    return nativeKeys(toObject$5(it));\n  }\n});\n\nvar path$m = path$w;\n\nvar keys$2 = path$m.Object.keys;\n\nvar parent$I = keys$2;\n\nvar keys$1 = parent$I;\n\nvar keys = keys$1;\n\nvar _Object$keys = /*@__PURE__*/getDefaultExportFromCjs(keys);\n\n// TODO: Remove from `core-js@4`\nvar $$u = _export;\nvar uncurryThis$a = functionUncurryThis;\n\nvar $Date = Date;\nvar thisTimeValue = uncurryThis$a($Date.prototype.getTime);\n\n// `Date.now` method\n// https://tc39.es/ecma262/#sec-date.now\n$$u({ target: 'Date', stat: true }, {\n  now: function now() {\n    return thisTimeValue(new $Date());\n  }\n});\n\nvar path$l = path$w;\n\nvar now$3 = path$l.Date.now;\n\nvar parent$H = now$3;\n\nvar now$2 = parent$H;\n\nvar now$1 = now$2;\n\nvar _Date$now = /*@__PURE__*/getDefaultExportFromCjs(now$1);\n\nvar fails$d = fails$w;\n\nvar arrayMethodIsStrict$6 = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails$d(function () {\n    // eslint-disable-next-line no-useless-call -- required for testing\n    method.call(null, argument || function () { return 1; }, 1);\n  });\n};\n\nvar $forEach = arrayIteration.forEach;\nvar arrayMethodIsStrict$5 = arrayMethodIsStrict$6;\n\nvar STRICT_METHOD$3 = arrayMethodIsStrict$5('forEach');\n\n// `Array.prototype.forEach` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.foreach\nvar arrayForEach = !STRICT_METHOD$3 ? function forEach(callbackfn /* , thisArg */) {\n  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n// eslint-disable-next-line es/no-array-prototype-foreach -- safe\n} : [].forEach;\n\nvar $$t = _export;\nvar forEach$6 = arrayForEach;\n\n// `Array.prototype.forEach` method\n// https://tc39.es/ecma262/#sec-array.prototype.foreach\n// eslint-disable-next-line es/no-array-prototype-foreach -- safe\n$$t({ target: 'Array', proto: true, forced: [].forEach !== forEach$6 }, {\n  forEach: forEach$6\n});\n\nvar entryVirtual$c = entryVirtual$i;\n\nvar forEach$5 = entryVirtual$c('Array').forEach;\n\nvar parent$G = forEach$5;\n\nvar forEach$4 = parent$G;\n\nvar classof$4 = classof$d;\nvar hasOwn$4 = hasOwnProperty_1;\nvar isPrototypeOf$d = objectIsPrototypeOf;\nvar method$a = forEach$4;\n\nvar ArrayPrototype$b = Array.prototype;\n\nvar DOMIterables$1 = {\n  DOMTokenList: true,\n  NodeList: true\n};\n\nvar forEach$3 = function (it) {\n  var own = it.forEach;\n  return it === ArrayPrototype$b || (isPrototypeOf$d(ArrayPrototype$b, it) && own === ArrayPrototype$b.forEach)\n    || hasOwn$4(DOMIterables$1, classof$4(it)) ? method$a : own;\n};\n\nvar forEach$2 = forEach$3;\n\nvar _forEachInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(forEach$2);\n\nvar $$s = _export;\nvar uncurryThis$9 = functionUncurryThis;\nvar isArray$1 = isArray$e;\n\nvar nativeReverse = uncurryThis$9([].reverse);\nvar test$1 = [1, 2];\n\n// `Array.prototype.reverse` method\n// https://tc39.es/ecma262/#sec-array.prototype.reverse\n// fix for Safari 12.0 bug\n// https://bugs.webkit.org/show_bug.cgi?id=188794\n$$s({ target: 'Array', proto: true, forced: String(test$1) === String(test$1.reverse()) }, {\n  reverse: function reverse() {\n    // eslint-disable-next-line no-self-assign -- dirty hack\n    if (isArray$1(this)) this.length = this.length;\n    return nativeReverse(this);\n  }\n});\n\nvar entryVirtual$b = entryVirtual$i;\n\nvar reverse$3 = entryVirtual$b('Array').reverse;\n\nvar isPrototypeOf$c = objectIsPrototypeOf;\nvar method$9 = reverse$3;\n\nvar ArrayPrototype$a = Array.prototype;\n\nvar reverse$2 = function (it) {\n  var own = it.reverse;\n  return it === ArrayPrototype$a || (isPrototypeOf$c(ArrayPrototype$a, it) && own === ArrayPrototype$a.reverse) ? method$9 : own;\n};\n\nvar parent$F = reverse$2;\n\nvar reverse$1 = parent$F;\n\nvar reverse = reverse$1;\n\nvar _reverseInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(reverse);\n\nvar tryToString$2 = tryToString$6;\n\nvar $TypeError$6 = TypeError;\n\nvar deletePropertyOrThrow$2 = function (O, P) {\n  if (!delete O[P]) throw new $TypeError$6('Cannot delete property ' + tryToString$2(P) + ' of ' + tryToString$2(O));\n};\n\nvar $$r = _export;\nvar toObject$4 = toObject$e;\nvar toAbsoluteIndex$1 = toAbsoluteIndex$5;\nvar toIntegerOrInfinity = toIntegerOrInfinity$4;\nvar lengthOfArrayLike$4 = lengthOfArrayLike$c;\nvar setArrayLength = arraySetLength;\nvar doesNotExceedSafeInteger = doesNotExceedSafeInteger$3;\nvar arraySpeciesCreate = arraySpeciesCreate$3;\nvar createProperty$1 = createProperty$6;\nvar deletePropertyOrThrow$1 = deletePropertyOrThrow$2;\nvar arrayMethodHasSpeciesSupport$1 = arrayMethodHasSpeciesSupport$5;\n\nvar HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport$1('splice');\n\nvar max = Math.max;\nvar min = Math.min;\n\n// `Array.prototype.splice` method\n// https://tc39.es/ecma262/#sec-array.prototype.splice\n// with adding support of @@species\n$$r({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$1 }, {\n  splice: function splice(start, deleteCount /* , ...items */) {\n    var O = toObject$4(this);\n    var len = lengthOfArrayLike$4(O);\n    var actualStart = toAbsoluteIndex$1(start, len);\n    var argumentsLength = arguments.length;\n    var insertCount, actualDeleteCount, A, k, from, to;\n    if (argumentsLength === 0) {\n      insertCount = actualDeleteCount = 0;\n    } else if (argumentsLength === 1) {\n      insertCount = 0;\n      actualDeleteCount = len - actualStart;\n    } else {\n      insertCount = argumentsLength - 2;\n      actualDeleteCount = min(max(toIntegerOrInfinity(deleteCount), 0), len - actualStart);\n    }\n    doesNotExceedSafeInteger(len + insertCount - actualDeleteCount);\n    A = arraySpeciesCreate(O, actualDeleteCount);\n    for (k = 0; k < actualDeleteCount; k++) {\n      from = actualStart + k;\n      if (from in O) createProperty$1(A, k, O[from]);\n    }\n    A.length = actualDeleteCount;\n    if (insertCount < actualDeleteCount) {\n      for (k = actualStart; k < len - actualDeleteCount; k++) {\n        from = k + actualDeleteCount;\n        to = k + insertCount;\n        if (from in O) O[to] = O[from];\n        else deletePropertyOrThrow$1(O, to);\n      }\n      for (k = len; k > len - actualDeleteCount + insertCount; k--) deletePropertyOrThrow$1(O, k - 1);\n    } else if (insertCount > actualDeleteCount) {\n      for (k = len - actualDeleteCount; k > actualStart; k--) {\n        from = k + actualDeleteCount - 1;\n        to = k + insertCount - 1;\n        if (from in O) O[to] = O[from];\n        else deletePropertyOrThrow$1(O, to);\n      }\n    }\n    for (k = 0; k < insertCount; k++) {\n      O[k + actualStart] = arguments[k + 2];\n    }\n    setArrayLength(O, len - actualDeleteCount + insertCount);\n    return A;\n  }\n});\n\nvar entryVirtual$a = entryVirtual$i;\n\nvar splice$4 = entryVirtual$a('Array').splice;\n\nvar isPrototypeOf$b = objectIsPrototypeOf;\nvar method$8 = splice$4;\n\nvar ArrayPrototype$9 = Array.prototype;\n\nvar splice$3 = function (it) {\n  var own = it.splice;\n  return it === ArrayPrototype$9 || (isPrototypeOf$b(ArrayPrototype$9, it) && own === ArrayPrototype$9.splice) ? method$8 : own;\n};\n\nvar parent$E = splice$3;\n\nvar splice$2 = parent$E;\n\nvar splice$1 = splice$2;\n\nvar _spliceInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(splice$1);\n\nvar $$q = _export;\nvar $includes = arrayIncludes.includes;\nvar fails$c = fails$w;\n\n// FF99+ bug\nvar BROKEN_ON_SPARSE = fails$c(function () {\n  // eslint-disable-next-line es/no-array-prototype-includes -- detection\n  return !Array(1).includes();\n});\n\n// `Array.prototype.includes` method\n// https://tc39.es/ecma262/#sec-array.prototype.includes\n$$q({ target: 'Array', proto: true, forced: BROKEN_ON_SPARSE }, {\n  includes: function includes(el /* , fromIndex = 0 */) {\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar entryVirtual$9 = entryVirtual$i;\n\nvar includes$4 = entryVirtual$9('Array').includes;\n\nvar isObject$8 = isObject$j;\nvar classof$3 = classofRaw$2;\nvar wellKnownSymbol$2 = wellKnownSymbol$m;\n\nvar MATCH$1 = wellKnownSymbol$2('match');\n\n// `IsRegExp` abstract operation\n// https://tc39.es/ecma262/#sec-isregexp\nvar isRegexp = function (it) {\n  var isRegExp;\n  return isObject$8(it) && ((isRegExp = it[MATCH$1]) !== undefined ? !!isRegExp : classof$3(it) === 'RegExp');\n};\n\nvar isRegExp = isRegexp;\n\nvar $TypeError$5 = TypeError;\n\nvar notARegexp = function (it) {\n  if (isRegExp(it)) {\n    throw new $TypeError$5(\"The method doesn't accept regular expressions\");\n  } return it;\n};\n\nvar wellKnownSymbol$1 = wellKnownSymbol$m;\n\nvar MATCH = wellKnownSymbol$1('match');\n\nvar correctIsRegexpLogic = function (METHOD_NAME) {\n  var regexp = /./;\n  try {\n    '/./'[METHOD_NAME](regexp);\n  } catch (error1) {\n    try {\n      regexp[MATCH] = false;\n      return '/./'[METHOD_NAME](regexp);\n    } catch (error2) { /* empty */ }\n  } return false;\n};\n\nvar $$p = _export;\nvar uncurryThis$8 = functionUncurryThis;\nvar notARegExp = notARegexp;\nvar requireObjectCoercible$1 = requireObjectCoercible$5;\nvar toString$4 = toString$a;\nvar correctIsRegExpLogic = correctIsRegexpLogic;\n\nvar stringIndexOf = uncurryThis$8(''.indexOf);\n\n// `String.prototype.includes` method\n// https://tc39.es/ecma262/#sec-string.prototype.includes\n$$p({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {\n  includes: function includes(searchString /* , position = 0 */) {\n    return !!~stringIndexOf(\n      toString$4(requireObjectCoercible$1(this)),\n      toString$4(notARegExp(searchString)),\n      arguments.length > 1 ? arguments[1] : undefined\n    );\n  }\n});\n\nvar entryVirtual$8 = entryVirtual$i;\n\nvar includes$3 = entryVirtual$8('String').includes;\n\nvar isPrototypeOf$a = objectIsPrototypeOf;\nvar arrayMethod = includes$4;\nvar stringMethod = includes$3;\n\nvar ArrayPrototype$8 = Array.prototype;\nvar StringPrototype = String.prototype;\n\nvar includes$2 = function (it) {\n  var own = it.includes;\n  if (it === ArrayPrototype$8 || (isPrototypeOf$a(ArrayPrototype$8, it) && own === ArrayPrototype$8.includes)) return arrayMethod;\n  if (typeof it == 'string' || it === StringPrototype || (isPrototypeOf$a(StringPrototype, it) && own === StringPrototype.includes)) {\n    return stringMethod;\n  } return own;\n};\n\nvar parent$D = includes$2;\n\nvar includes$1 = parent$D;\n\nvar includes = includes$1;\n\nvar _includesInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(includes);\n\nvar $$o = _export;\nvar fails$b = fails$w;\nvar toObject$3 = toObject$e;\nvar nativeGetPrototypeOf = objectGetPrototypeOf;\nvar CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;\n\nvar FAILS_ON_PRIMITIVES$2 = fails$b(function () { nativeGetPrototypeOf(1); });\n\n// `Object.getPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.getprototypeof\n$$o({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$2, sham: !CORRECT_PROTOTYPE_GETTER }, {\n  getPrototypeOf: function getPrototypeOf(it) {\n    return nativeGetPrototypeOf(toObject$3(it));\n  }\n});\n\nvar path$k = path$w;\n\nvar getPrototypeOf$6 = path$k.Object.getPrototypeOf;\n\nvar parent$C = getPrototypeOf$6;\n\nvar getPrototypeOf$5 = parent$C;\n\nvar getPrototypeOf$4 = getPrototypeOf$5;\n\nvar _Object$getPrototypeOf$1 = /*@__PURE__*/getDefaultExportFromCjs(getPrototypeOf$4);\n\nvar $$n = _export;\nvar $filter = arrayIteration.filter;\nvar arrayMethodHasSpeciesSupport = arrayMethodHasSpeciesSupport$5;\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');\n\n// `Array.prototype.filter` method\n// https://tc39.es/ecma262/#sec-array.prototype.filter\n// with adding support of @@species\n$$n({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  filter: function filter(callbackfn /* , thisArg */) {\n    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar entryVirtual$7 = entryVirtual$i;\n\nvar filter$3 = entryVirtual$7('Array').filter;\n\nvar isPrototypeOf$9 = objectIsPrototypeOf;\nvar method$7 = filter$3;\n\nvar ArrayPrototype$7 = Array.prototype;\n\nvar filter$2 = function (it) {\n  var own = it.filter;\n  return it === ArrayPrototype$7 || (isPrototypeOf$9(ArrayPrototype$7, it) && own === ArrayPrototype$7.filter) ? method$7 : own;\n};\n\nvar parent$B = filter$2;\n\nvar filter$1 = parent$B;\n\nvar filter = filter$1;\n\nvar _filterInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(filter);\n\n// a string of all valid unicode whitespaces\nvar whitespaces$3 = '\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u2000\\u2001\\u2002' +\n  '\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF';\n\nvar uncurryThis$7 = functionUncurryThis;\nvar requireObjectCoercible = requireObjectCoercible$5;\nvar toString$3 = toString$a;\nvar whitespaces$2 = whitespaces$3;\n\nvar replace = uncurryThis$7(''.replace);\nvar ltrim = RegExp('^[' + whitespaces$2 + ']+');\nvar rtrim = RegExp('(^|[^' + whitespaces$2 + '])[' + whitespaces$2 + ']+$');\n\n// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\nvar createMethod$1 = function (TYPE) {\n  return function ($this) {\n    var string = toString$3(requireObjectCoercible($this));\n    if (TYPE & 1) string = replace(string, ltrim, '');\n    if (TYPE & 2) string = replace(string, rtrim, '$1');\n    return string;\n  };\n};\n\nvar stringTrim = {\n  // `String.prototype.{ trimLeft, trimStart }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n  start: createMethod$1(1),\n  // `String.prototype.{ trimRight, trimEnd }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimend\n  end: createMethod$1(2),\n  // `String.prototype.trim` method\n  // https://tc39.es/ecma262/#sec-string.prototype.trim\n  trim: createMethod$1(3)\n};\n\nvar global$9 = global$n;\nvar fails$a = fails$w;\nvar uncurryThis$6 = functionUncurryThis;\nvar toString$2 = toString$a;\nvar trim$1 = stringTrim.trim;\nvar whitespaces$1 = whitespaces$3;\n\nvar $parseInt$1 = global$9.parseInt;\nvar Symbol$2 = global$9.Symbol;\nvar ITERATOR$1 = Symbol$2 && Symbol$2.iterator;\nvar hex = /^[+-]?0x/i;\nvar exec = uncurryThis$6(hex.exec);\nvar FORCED$7 = $parseInt$1(whitespaces$1 + '08') !== 8 || $parseInt$1(whitespaces$1 + '0x16') !== 22\n  // MS Edge 18- broken with boxed symbols\n  || (ITERATOR$1 && !fails$a(function () { $parseInt$1(Object(ITERATOR$1)); }));\n\n// `parseInt` method\n// https://tc39.es/ecma262/#sec-parseint-string-radix\nvar numberParseInt = FORCED$7 ? function parseInt(string, radix) {\n  var S = trim$1(toString$2(string));\n  return $parseInt$1(S, (radix >>> 0) || (exec(hex, S) ? 16 : 10));\n} : $parseInt$1;\n\nvar $$m = _export;\nvar $parseInt = numberParseInt;\n\n// `parseInt` method\n// https://tc39.es/ecma262/#sec-parseint-string-radix\n$$m({ global: true, forced: parseInt !== $parseInt }, {\n  parseInt: $parseInt\n});\n\nvar path$j = path$w;\n\nvar _parseInt$3 = path$j.parseInt;\n\nvar parent$A = _parseInt$3;\n\nvar _parseInt$2 = parent$A;\n\nvar _parseInt = _parseInt$2;\n\nvar _parseInt$1 = /*@__PURE__*/getDefaultExportFromCjs(_parseInt);\n\n/* eslint-disable es/no-array-prototype-indexof -- required for testing */\nvar $$l = _export;\nvar uncurryThis$5 = functionUncurryThisClause;\nvar $indexOf = arrayIncludes.indexOf;\nvar arrayMethodIsStrict$4 = arrayMethodIsStrict$6;\n\nvar nativeIndexOf = uncurryThis$5([].indexOf);\n\nvar NEGATIVE_ZERO = !!nativeIndexOf && 1 / nativeIndexOf([1], 1, -0) < 0;\nvar FORCED$6 = NEGATIVE_ZERO || !arrayMethodIsStrict$4('indexOf');\n\n// `Array.prototype.indexOf` method\n// https://tc39.es/ecma262/#sec-array.prototype.indexof\n$$l({ target: 'Array', proto: true, forced: FORCED$6 }, {\n  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {\n    var fromIndex = arguments.length > 1 ? arguments[1] : undefined;\n    return NEGATIVE_ZERO\n      // convert -0 to +0\n      ? nativeIndexOf(this, searchElement, fromIndex) || 0\n      : $indexOf(this, searchElement, fromIndex);\n  }\n});\n\nvar entryVirtual$6 = entryVirtual$i;\n\nvar indexOf$3 = entryVirtual$6('Array').indexOf;\n\nvar isPrototypeOf$8 = objectIsPrototypeOf;\nvar method$6 = indexOf$3;\n\nvar ArrayPrototype$6 = Array.prototype;\n\nvar indexOf$2 = function (it) {\n  var own = it.indexOf;\n  return it === ArrayPrototype$6 || (isPrototypeOf$8(ArrayPrototype$6, it) && own === ArrayPrototype$6.indexOf) ? method$6 : own;\n};\n\nvar parent$z = indexOf$2;\n\nvar indexOf$1 = parent$z;\n\nvar indexOf = indexOf$1;\n\nvar _indexOfInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(indexOf);\n\n// TODO: Remove from `core-js@4`\nvar $$k = _export;\nvar DESCRIPTORS$6 = descriptors;\nvar create$8 = objectCreate;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\n$$k({ target: 'Object', stat: true, sham: !DESCRIPTORS$6 }, {\n  create: create$8\n});\n\nvar path$i = path$w;\n\nvar Object$4 = path$i.Object;\n\nvar create$7 = function create(P, D) {\n  return Object$4.create(P, D);\n};\n\nvar parent$y = create$7;\n\nvar create$6 = parent$y;\n\nvar create$5 = create$6;\n\nvar _Object$create$1 = /*@__PURE__*/getDefaultExportFromCjs(create$5);\n\nvar path$h = path$w;\nvar apply$2 = functionApply;\n\n// eslint-disable-next-line es/no-json -- safe\nif (!path$h.JSON) path$h.JSON = { stringify: JSON.stringify };\n\n// eslint-disable-next-line no-unused-vars -- required for `.length`\nvar stringify$2 = function stringify(it, replacer, space) {\n  return apply$2(path$h.JSON.stringify, null, arguments);\n};\n\nvar parent$x = stringify$2;\n\nvar stringify$1 = parent$x;\n\nvar stringify = stringify$1;\n\nvar _JSON$stringify = /*@__PURE__*/getDefaultExportFromCjs(stringify);\n\n/* global Bun -- Deno case */\nvar engineIsBun = typeof Bun == 'function' && Bun && typeof Bun.version == 'string';\n\nvar $TypeError$4 = TypeError;\n\nvar validateArgumentsLength$1 = function (passed, required) {\n  if (passed < required) throw new $TypeError$4('Not enough arguments');\n  return passed;\n};\n\nvar global$8 = global$n;\nvar apply$1 = functionApply;\nvar isCallable$1 = isCallable$i;\nvar ENGINE_IS_BUN = engineIsBun;\nvar USER_AGENT = engineUserAgent;\nvar arraySlice$1 = arraySlice$5;\nvar validateArgumentsLength = validateArgumentsLength$1;\n\nvar Function$1 = global$8.Function;\n// dirty IE9- and Bun 0.3.0- checks\nvar WRAP = /MSIE .\\./.test(USER_AGENT) || ENGINE_IS_BUN && (function () {\n  var version = global$8.Bun.version.split('.');\n  return version.length < 3 || version[0] === '0' && (version[1] < 3 || version[1] === '3' && version[2] === '0');\n})();\n\n// IE9- / Bun 0.3.0- setTimeout / setInterval / setImmediate additional parameters fix\n// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers\n// https://github.com/oven-sh/bun/issues/1633\nvar schedulersFix$2 = function (scheduler, hasTimeArg) {\n  var firstParamIndex = hasTimeArg ? 2 : 1;\n  return WRAP ? function (handler, timeout /* , ...arguments */) {\n    var boundArgs = validateArgumentsLength(arguments.length, 1) > firstParamIndex;\n    var fn = isCallable$1(handler) ? handler : Function$1(handler);\n    var params = boundArgs ? arraySlice$1(arguments, firstParamIndex) : [];\n    var callback = boundArgs ? function () {\n      apply$1(fn, this, params);\n    } : fn;\n    return hasTimeArg ? scheduler(callback, timeout) : scheduler(callback);\n  } : scheduler;\n};\n\nvar $$j = _export;\nvar global$7 = global$n;\nvar schedulersFix$1 = schedulersFix$2;\n\nvar setInterval$2 = schedulersFix$1(global$7.setInterval, true);\n\n// Bun / IE9- setInterval additional parameters fix\n// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval\n$$j({ global: true, bind: true, forced: global$7.setInterval !== setInterval$2 }, {\n  setInterval: setInterval$2\n});\n\nvar $$i = _export;\nvar global$6 = global$n;\nvar schedulersFix = schedulersFix$2;\n\nvar setTimeout$3 = schedulersFix(global$6.setTimeout, true);\n\n// Bun / IE9- setTimeout additional parameters fix\n// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout\n$$i({ global: true, bind: true, forced: global$6.setTimeout !== setTimeout$3 }, {\n  setTimeout: setTimeout$3\n});\n\nvar path$g = path$w;\n\nvar setTimeout$2 = path$g.setTimeout;\n\nvar setTimeout$1 = setTimeout$2;\n\nvar _setTimeout = /*@__PURE__*/getDefaultExportFromCjs(setTimeout$1);\n\nvar toObject$2 = toObject$e;\nvar toAbsoluteIndex = toAbsoluteIndex$5;\nvar lengthOfArrayLike$3 = lengthOfArrayLike$c;\n\n// `Array.prototype.fill` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.fill\nvar arrayFill = function fill(value /* , start = 0, end = @length */) {\n  var O = toObject$2(this);\n  var length = lengthOfArrayLike$3(O);\n  var argumentsLength = arguments.length;\n  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);\n  var end = argumentsLength > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);\n  while (endPos > index) O[index++] = value;\n  return O;\n};\n\nvar $$h = _export;\nvar fill$4 = arrayFill;\n\n// `Array.prototype.fill` method\n// https://tc39.es/ecma262/#sec-array.prototype.fill\n$$h({ target: 'Array', proto: true }, {\n  fill: fill$4\n});\n\nvar entryVirtual$5 = entryVirtual$i;\n\nvar fill$3 = entryVirtual$5('Array').fill;\n\nvar isPrototypeOf$7 = objectIsPrototypeOf;\nvar method$5 = fill$3;\n\nvar ArrayPrototype$5 = Array.prototype;\n\nvar fill$2 = function (it) {\n  var own = it.fill;\n  return it === ArrayPrototype$5 || (isPrototypeOf$7(ArrayPrototype$5, it) && own === ArrayPrototype$5.fill) ? method$5 : own;\n};\n\nvar parent$w = fill$2;\n\nvar fill$1 = parent$w;\n\nvar fill = fill$1;\n\nvar _fillInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(fill);\n\n/*! Hammer.JS - v2.0.17-rc - 2019-12-16\n * http://naver.github.io/egjs\n *\n * Forked By Naver egjs\n * Copyright (c) hammerjs\n * Licensed under the MIT license */\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized$1(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} target\n * @param {...Object} objects_to_assign\n * @returns {Object} target\n */\nvar assign;\n\nif (typeof Object.assign !== 'function') {\n  assign = function assign(target) {\n    if (target === undefined || target === null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    var output = Object(target);\n\n    for (var index = 1; index < arguments.length; index++) {\n      var source = arguments[index];\n\n      if (source !== undefined && source !== null) {\n        for (var nextKey in source) {\n          if (source.hasOwnProperty(nextKey)) {\n            output[nextKey] = source[nextKey];\n          }\n        }\n      }\n    }\n\n    return output;\n  };\n} else {\n  assign = Object.assign;\n}\n\nvar assign$1 = assign;\n\nvar VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\nvar TEST_ELEMENT = typeof document === \"undefined\" ? {\n  style: {}\n} : document.createElement('div');\nvar TYPE_FUNCTION = 'function';\nvar round = Math.round,\n    abs$1 = Math.abs;\nvar now = Date.now;\n\n/**\n * @private\n * get the prefixed property\n * @param {Object} obj\n * @param {String} property\n * @returns {String|Undefined} prefixed\n */\n\nfunction prefixed(obj, property) {\n  var prefix;\n  var prop;\n  var camelProp = property[0].toUpperCase() + property.slice(1);\n  var i = 0;\n\n  while (i < VENDOR_PREFIXES.length) {\n    prefix = VENDOR_PREFIXES[i];\n    prop = prefix ? prefix + camelProp : property;\n\n    if (prop in obj) {\n      return prop;\n    }\n\n    i++;\n  }\n\n  return undefined;\n}\n\n/* eslint-disable no-new-func, no-nested-ternary */\nvar win;\n\nif (typeof window === \"undefined\") {\n  // window is undefined in node.js\n  win = {};\n} else {\n  win = window;\n}\n\nvar PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\nvar NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;\nfunction getTouchActionProps() {\n  if (!NATIVE_TOUCH_ACTION) {\n    return false;\n  }\n\n  var touchMap = {};\n  var cssSupports = win.CSS && win.CSS.supports;\n  ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n    // If css.supports is not supported but there is native touch-action assume it supports\n    // all values. This is the case for IE 10 and 11.\n    return touchMap[val] = cssSupports ? win.CSS.supports('touch-action', val) : true;\n  });\n  return touchMap;\n}\n\nvar TOUCH_ACTION_COMPUTE = 'compute';\nvar TOUCH_ACTION_AUTO = 'auto';\nvar TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\nvar TOUCH_ACTION_NONE = 'none';\nvar TOUCH_ACTION_PAN_X = 'pan-x';\nvar TOUCH_ACTION_PAN_Y = 'pan-y';\nvar TOUCH_ACTION_MAP = getTouchActionProps();\n\nvar MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\nvar SUPPORT_TOUCH = 'ontouchstart' in win;\nvar SUPPORT_POINTER_EVENTS = prefixed(win, 'PointerEvent') !== undefined;\nvar SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\nvar INPUT_TYPE_TOUCH = 'touch';\nvar INPUT_TYPE_PEN = 'pen';\nvar INPUT_TYPE_MOUSE = 'mouse';\nvar INPUT_TYPE_KINECT = 'kinect';\nvar COMPUTE_INTERVAL = 25;\nvar INPUT_START = 1;\nvar INPUT_MOVE = 2;\nvar INPUT_END = 4;\nvar INPUT_CANCEL = 8;\nvar DIRECTION_NONE = 1;\nvar DIRECTION_LEFT = 2;\nvar DIRECTION_RIGHT = 4;\nvar DIRECTION_UP = 8;\nvar DIRECTION_DOWN = 16;\nvar DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\nvar DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\nvar DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\nvar PROPS_XY = ['x', 'y'];\nvar PROPS_CLIENT_XY = ['clientX', 'clientY'];\n\n/**\n * @private\n * walk objects and arrays\n * @param {Object} obj\n * @param {Function} iterator\n * @param {Object} context\n */\nfunction each(obj, iterator, context) {\n  var i;\n\n  if (!obj) {\n    return;\n  }\n\n  if (obj.forEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length !== undefined) {\n    i = 0;\n\n    while (i < obj.length) {\n      iterator.call(context, obj[i], i, obj);\n      i++;\n    }\n  } else {\n    for (i in obj) {\n      obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n    }\n  }\n}\n\n/**\n * @private\n * let a boolean value also be a function that must return a boolean\n * this first item in args will be used as the context\n * @param {Boolean|Function} val\n * @param {Array} [args]\n * @returns {Boolean}\n */\n\nfunction boolOrFn(val, args) {\n  if (typeof val === TYPE_FUNCTION) {\n    return val.apply(args ? args[0] || undefined : undefined, args);\n  }\n\n  return val;\n}\n\n/**\n * @private\n * small indexOf wrapper\n * @param {String} str\n * @param {String} find\n * @returns {Boolean} found\n */\nfunction inStr(str, find) {\n  return str.indexOf(find) > -1;\n}\n\n/**\n * @private\n * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n * @param {String} actions\n * @returns {*}\n */\n\nfunction cleanTouchActions(actions) {\n  // none\n  if (inStr(actions, TOUCH_ACTION_NONE)) {\n    return TOUCH_ACTION_NONE;\n  }\n\n  var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n  var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n  // for different directions, e.g. horizontal pan but vertical swipe?)\n  // we need none (as otherwise with pan-x pan-y combined none of these\n  // recognizers will work, since the browser would handle all panning\n\n  if (hasPanX && hasPanY) {\n    return TOUCH_ACTION_NONE;\n  } // pan-x OR pan-y\n\n\n  if (hasPanX || hasPanY) {\n    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n  } // manipulation\n\n\n  if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n    return TOUCH_ACTION_MANIPULATION;\n  }\n\n  return TOUCH_ACTION_AUTO;\n}\n\n/**\n * @private\n * Touch Action\n * sets the touchAction property or uses the js alternative\n * @param {Manager} manager\n * @param {String} value\n * @constructor\n */\n\nvar TouchAction =\n/*#__PURE__*/\nfunction () {\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n  /**\n   * @private\n   * set the touchAction value on the element or enable the polyfill\n   * @param {String} value\n   */\n\n\n  var _proto = TouchAction.prototype;\n\n  _proto.set = function set(value) {\n    // find out the touch-action by the event handlers\n    if (value === TOUCH_ACTION_COMPUTE) {\n      value = this.compute();\n    }\n\n    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n      this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n    }\n\n    this.actions = value.toLowerCase().trim();\n  };\n  /**\n   * @private\n   * just re-set the touchAction value\n   */\n\n\n  _proto.update = function update() {\n    this.set(this.manager.options.touchAction);\n  };\n  /**\n   * @private\n   * compute the value for the touchAction property based on the recognizer's settings\n   * @returns {String} value\n   */\n\n\n  _proto.compute = function compute() {\n    var actions = [];\n    each(this.manager.recognizers, function (recognizer) {\n      if (boolOrFn(recognizer.options.enable, [recognizer])) {\n        actions = actions.concat(recognizer.getTouchAction());\n      }\n    });\n    return cleanTouchActions(actions.join(' '));\n  };\n  /**\n   * @private\n   * this method is called on each input cycle and provides the preventing of the browser behavior\n   * @param {Object} input\n   */\n\n\n  _proto.preventDefaults = function preventDefaults(input) {\n    var srcEvent = input.srcEvent;\n    var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n    if (this.manager.session.prevented) {\n      srcEvent.preventDefault();\n      return;\n    }\n\n    var actions = this.actions;\n    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n    if (hasNone) {\n      // do not prevent defaults if this is a tap gesture\n      var isTapPointer = input.pointers.length === 1;\n      var isTapMovement = input.distance < 2;\n      var isTapTouchTime = input.deltaTime < 250;\n\n      if (isTapPointer && isTapMovement && isTapTouchTime) {\n        return;\n      }\n    }\n\n    if (hasPanX && hasPanY) {\n      // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n      return;\n    }\n\n    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n      return this.preventSrc(srcEvent);\n    }\n  };\n  /**\n   * @private\n   * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n   * @param {Object} srcEvent\n   */\n\n\n  _proto.preventSrc = function preventSrc(srcEvent) {\n    this.manager.session.prevented = true;\n    srcEvent.preventDefault();\n  };\n\n  return TouchAction;\n}();\n\n/**\n * @private\n * find if a node is in the given parent\n * @method hasParent\n * @param {HTMLElement} node\n * @param {HTMLElement} parent\n * @return {Boolean} found\n */\nfunction hasParent(node, parent) {\n  while (node) {\n    if (node === parent) {\n      return true;\n    }\n\n    node = node.parentNode;\n  }\n\n  return false;\n}\n\n/**\n * @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties\n */\n\nfunction getCenter(pointers) {\n  var pointersLength = pointers.length; // no need to loop when only one touch\n\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    };\n  }\n\n  var x = 0;\n  var y = 0;\n  var i = 0;\n\n  while (i < pointersLength) {\n    x += pointers[i].clientX;\n    y += pointers[i].clientY;\n    i++;\n  }\n\n  return {\n    x: round(x / pointersLength),\n    y: round(y / pointersLength)\n  };\n}\n\n/**\n * @private\n * create a simple clone from the input used for storage of firstInput and firstMultiple\n * @param {Object} input\n * @returns {Object} clonedInputData\n */\n\nfunction simpleCloneInputData(input) {\n  // make a simple copy of the pointers because we will get a reference if we don't\n  // we only need clientXY for the calculations\n  var pointers = [];\n  var i = 0;\n\n  while (i < input.pointers.length) {\n    pointers[i] = {\n      clientX: round(input.pointers[i].clientX),\n      clientY: round(input.pointers[i].clientY)\n    };\n    i++;\n  }\n\n  return {\n    timeStamp: now(),\n    pointers: pointers,\n    center: getCenter(pointers),\n    deltaX: input.deltaX,\n    deltaY: input.deltaY\n  };\n}\n\n/**\n * @private\n * calculate the absolute distance between two points\n * @param {Object} p1 {x, y}\n * @param {Object} p2 {x, y}\n * @param {Array} [props] containing x and y keys\n * @return {Number} distance\n */\n\nfunction getDistance(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.sqrt(x * x + y * y);\n}\n\n/**\n * @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle\n */\n\nfunction getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }\n\n  var x = p2[props[0]] - p1[props[0]];\n  var y = p2[props[1]] - p1[props[1]];\n  return Math.atan2(y, x) * 180 / Math.PI;\n}\n\n/**\n * @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction\n */\n\nfunction getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }\n\n  if (abs$1(x) >= abs$1(y)) {\n    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n  }\n\n  return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n}\n\nfunction computeDeltaXY(session, input) {\n  var center = input.center; // let { offsetDelta:offset = {}, prevDelta = {}, prevInput = {} } = session;\n  // jscs throwing error on defalut destructured values and without defaults tests fail\n\n  var offset = session.offsetDelta || {};\n  var prevDelta = session.prevDelta || {};\n  var prevInput = session.prevInput || {};\n\n  if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n    prevDelta = session.prevDelta = {\n      x: prevInput.deltaX || 0,\n      y: prevInput.deltaY || 0\n    };\n    offset = session.offsetDelta = {\n      x: center.x,\n      y: center.y\n    };\n  }\n\n  input.deltaX = prevDelta.x + (center.x - offset.x);\n  input.deltaY = prevDelta.y + (center.y - offset.y);\n}\n\n/**\n * @private\n * calculate the velocity between two points. unit is in px per ms.\n * @param {Number} deltaTime\n * @param {Number} x\n * @param {Number} y\n * @return {Object} velocity `x` and `y`\n */\nfunction getVelocity(deltaTime, x, y) {\n  return {\n    x: x / deltaTime || 0,\n    y: y / deltaTime || 0\n  };\n}\n\n/**\n * @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale\n */\n\nfunction getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation\n */\n\nfunction getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}\n\n/**\n * @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input\n */\n\nfunction computeIntervalInputData(session, input) {\n  var last = session.lastInterval || input;\n  var deltaTime = input.timeStamp - last.timeStamp;\n  var velocity;\n  var velocityX;\n  var velocityY;\n  var direction;\n\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    var deltaX = input.deltaX - last.deltaX;\n    var deltaY = input.deltaY - last.deltaY;\n    var v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = abs$1(v.x) > abs$1(v.y) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n    session.lastInterval = input;\n  } else {\n    // use latest velocity info if it doesn't overtake a minimum period\n    velocity = last.velocity;\n    velocityX = last.velocityX;\n    velocityY = last.velocityY;\n    direction = last.direction;\n  }\n\n  input.velocity = velocity;\n  input.velocityX = velocityX;\n  input.velocityY = velocityY;\n  input.direction = direction;\n}\n\n/**\n* @private\n * extend the data with some usable properties like scale, rotate, velocity etc\n * @param {Object} manager\n * @param {Object} input\n */\n\nfunction computeInputData(manager, input) {\n  var session = manager.session;\n  var pointers = input.pointers;\n  var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n  if (!session.firstInput) {\n    session.firstInput = simpleCloneInputData(input);\n  } // to compute scale and rotation we need to store the multiple touches\n\n\n  if (pointersLength > 1 && !session.firstMultiple) {\n    session.firstMultiple = simpleCloneInputData(input);\n  } else if (pointersLength === 1) {\n    session.firstMultiple = false;\n  }\n\n  var firstInput = session.firstInput,\n      firstMultiple = session.firstMultiple;\n  var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n  var center = input.center = getCenter(pointers);\n  input.timeStamp = now();\n  input.deltaTime = input.timeStamp - firstInput.timeStamp;\n  input.angle = getAngle(offsetCenter, center);\n  input.distance = getDistance(offsetCenter, center);\n  computeDeltaXY(session, input);\n  input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n  var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n  input.overallVelocityX = overallVelocity.x;\n  input.overallVelocityY = overallVelocity.y;\n  input.overallVelocity = abs$1(overallVelocity.x) > abs$1(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n  input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n  input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n  input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n  computeIntervalInputData(session, input); // find the correct target\n\n  var target = manager.element;\n  var srcEvent = input.srcEvent;\n  var srcEventTarget;\n\n  if (srcEvent.composedPath) {\n    srcEventTarget = srcEvent.composedPath()[0];\n  } else if (srcEvent.path) {\n    srcEventTarget = srcEvent.path[0];\n  } else {\n    srcEventTarget = srcEvent.target;\n  }\n\n  if (hasParent(srcEventTarget, target)) {\n    target = srcEventTarget;\n  }\n\n  input.target = target;\n}\n\n/**\n * @private\n * handle input events\n * @param {Manager} manager\n * @param {String} eventType\n * @param {Object} input\n */\n\nfunction inputHandler(manager, eventType, input) {\n  var pointersLen = input.pointers.length;\n  var changedPointersLen = input.changedPointers.length;\n  var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n  var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n  input.isFirst = !!isFirst;\n  input.isFinal = !!isFinal;\n\n  if (isFirst) {\n    manager.session = {};\n  } // source event is the normalized value of the domEvents\n  // like 'touchstart, mouseup, pointerdown'\n\n\n  input.eventType = eventType; // compute scale, rotation etc\n\n  computeInputData(manager, input); // emit secret event\n\n  manager.emit('hammer.input', input);\n  manager.recognize(input);\n  manager.session.prevInput = input;\n}\n\n/**\n * @private\n * split string on whitespace\n * @param {String} str\n * @returns {Array} words\n */\nfunction splitStr(str) {\n  return str.trim().split(/\\s+/g);\n}\n\n/**\n * @private\n * addEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\nfunction addEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.addEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * removeEventListener with multiple events at once\n * @param {EventTarget} target\n * @param {String} types\n * @param {Function} handler\n */\n\nfunction removeEventListeners(target, types, handler) {\n  each(splitStr(types), function (type) {\n    target.removeEventListener(type, handler, false);\n  });\n}\n\n/**\n * @private\n * get the window object of an element\n * @param {HTMLElement} element\n * @returns {DocumentView|Window}\n */\nfunction getWindowForElement(element) {\n  var doc = element.ownerDocument || element;\n  return doc.defaultView || doc.parentWindow || window;\n}\n\n/**\n * @private\n * create new input type manager\n * @param {Manager} manager\n * @param {Function} callback\n * @returns {Input}\n * @constructor\n */\n\nvar Input =\n/*#__PURE__*/\nfunction () {\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n  /**\n   * @private\n   * should handle the inputEvent data and trigger the callback\n   * @virtual\n   */\n\n\n  var _proto = Input.prototype;\n\n  _proto.handler = function handler() {};\n  /**\n   * @private\n   * bind the events\n   */\n\n\n  _proto.init = function init() {\n    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n  /**\n   * @private\n   * unbind the events\n   */\n\n\n  _proto.destroy = function destroy() {\n    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n  };\n\n  return Input;\n}();\n\n/**\n * @private\n * find if a array contains the object using indexOf or a simple polyFill\n * @param {Array} src\n * @param {String} find\n * @param {String} [findByKey]\n * @return {Boolean|Number} false when not found, or the index\n */\nfunction inArray(src, find, findByKey) {\n  if (src.indexOf && !findByKey) {\n    return src.indexOf(find);\n  } else {\n    var i = 0;\n\n    while (i < src.length) {\n      if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n        // do not use === here, test fails\n        return i;\n      }\n\n      i++;\n    }\n\n    return -1;\n  }\n}\n\nvar POINTER_INPUT_MAP = {\n  pointerdown: INPUT_START,\n  pointermove: INPUT_MOVE,\n  pointerup: INPUT_END,\n  pointercancel: INPUT_CANCEL,\n  pointerout: INPUT_CANCEL\n}; // in IE10 the pointer types is defined as an enum\n\nvar IE10_POINTER_TYPE_ENUM = {\n  2: INPUT_TYPE_TOUCH,\n  3: INPUT_TYPE_PEN,\n  4: INPUT_TYPE_MOUSE,\n  5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\n};\nvar POINTER_ELEMENT_EVENTS = 'pointerdown';\nvar POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\nif (win.MSPointerEvent && !win.PointerEvent) {\n  POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n  POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n}\n/**\n * @private\n * Pointer events input\n * @constructor\n * @extends Input\n */\n\n\nvar PointerEventInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(PointerEventInput, _Input);\n\n  function PointerEventInput() {\n    var _this;\n\n    var proto = PointerEventInput.prototype;\n    proto.evEl = POINTER_ELEMENT_EVENTS;\n    proto.evWin = POINTER_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.store = _this.manager.session.pointerEvents = [];\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  var _proto = PointerEventInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var store = this.store;\n    var removePointer = false;\n    var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n    var isTouch = pointerType === INPUT_TYPE_TOUCH; // get index of the event in the store\n\n    var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n      if (storeIndex < 0) {\n        store.push(ev);\n        storeIndex = store.length - 1;\n      }\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      removePointer = true;\n    } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n\n    if (storeIndex < 0) {\n      return;\n    } // update the event in the store\n\n\n    store[storeIndex] = ev;\n    this.callback(this.manager, eventType, {\n      pointers: store,\n      changedPointers: [ev],\n      pointerType: pointerType,\n      srcEvent: ev\n    });\n\n    if (removePointer) {\n      // remove from the store\n      store.splice(storeIndex, 1);\n    }\n  };\n\n  return PointerEventInput;\n}(Input);\n\n/**\n * @private\n * convert array-like objects to real arrays\n * @param {Object} obj\n * @returns {Array}\n */\nfunction toArray(obj) {\n  return Array.prototype.slice.call(obj, 0);\n}\n\n/**\n * @private\n * unique array with objects based on a key (like 'id') or just by the array's value\n * @param {Array} src [{id:1},{id:2},{id:1}]\n * @param {String} [key]\n * @param {Boolean} [sort=False]\n * @returns {Array} [{id:1},{id:2}]\n */\n\nfunction uniqueArray(src, key, sort) {\n  var results = [];\n  var values = [];\n  var i = 0;\n\n  while (i < src.length) {\n    var val = key ? src[i][key] : src[i];\n\n    if (inArray(values, val) < 0) {\n      results.push(src[i]);\n    }\n\n    values[i] = val;\n    i++;\n  }\n\n  if (sort) {\n    if (!key) {\n      results = results.sort();\n    } else {\n      results = results.sort(function (a, b) {\n        return a[key] > b[key];\n      });\n    }\n  }\n\n  return results;\n}\n\nvar TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Multi-user touch events input\n * @constructor\n * @extends Input\n */\n\nvar TouchInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(TouchInput, _Input);\n\n  function TouchInput() {\n    var _this;\n\n    TouchInput.prototype.evTarget = TOUCH_TARGET_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.targetIds = {}; // this.evTarget = TOUCH_TARGET_EVENTS;\n\n    return _this;\n  }\n\n  var _proto = TouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = TOUCH_INPUT_MAP[ev.type];\n    var touches = getTouches.call(this, ev, type);\n\n    if (!touches) {\n      return;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return TouchInput;\n}(Input);\n\nfunction getTouches(ev, type) {\n  var allTouches = toArray(ev.touches);\n  var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n  if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n    targetIds[allTouches[0].identifier] = true;\n    return [allTouches, allTouches];\n  }\n\n  var i;\n  var targetTouches;\n  var changedTouches = toArray(ev.changedTouches);\n  var changedTargetTouches = [];\n  var target = this.target; // get target touches from touches\n\n  targetTouches = allTouches.filter(function (touch) {\n    return hasParent(touch.target, target);\n  }); // collect touches\n\n  if (type === INPUT_START) {\n    i = 0;\n\n    while (i < targetTouches.length) {\n      targetIds[targetTouches[i].identifier] = true;\n      i++;\n    }\n  } // filter changed touches to only contain touches that exist in the collected target ids\n\n\n  i = 0;\n\n  while (i < changedTouches.length) {\n    if (targetIds[changedTouches[i].identifier]) {\n      changedTargetTouches.push(changedTouches[i]);\n    } // cleanup removed touches\n\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      delete targetIds[changedTouches[i].identifier];\n    }\n\n    i++;\n  }\n\n  if (!changedTargetTouches.length) {\n    return;\n  }\n\n  return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n  uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n}\n\nvar MOUSE_INPUT_MAP = {\n  mousedown: INPUT_START,\n  mousemove: INPUT_MOVE,\n  mouseup: INPUT_END\n};\nvar MOUSE_ELEMENT_EVENTS = 'mousedown';\nvar MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n/**\n * @private\n * Mouse events input\n * @constructor\n * @extends Input\n */\n\nvar MouseInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(MouseInput, _Input);\n\n  function MouseInput() {\n    var _this;\n\n    var proto = MouseInput.prototype;\n    proto.evEl = MOUSE_ELEMENT_EVENTS;\n    proto.evWin = MOUSE_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.pressed = false; // mousedown state\n\n    return _this;\n  }\n  /**\n   * @private\n   * handle mouse events\n   * @param {Object} ev\n   */\n\n\n  var _proto = MouseInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n    if (eventType & INPUT_START && ev.button === 0) {\n      this.pressed = true;\n    }\n\n    if (eventType & INPUT_MOVE && ev.which !== 1) {\n      eventType = INPUT_END;\n    } // mouse must be down\n\n\n    if (!this.pressed) {\n      return;\n    }\n\n    if (eventType & INPUT_END) {\n      this.pressed = false;\n    }\n\n    this.callback(this.manager, eventType, {\n      pointers: [ev],\n      changedPointers: [ev],\n      pointerType: INPUT_TYPE_MOUSE,\n      srcEvent: ev\n    });\n  };\n\n  return MouseInput;\n}(Input);\n\n/**\n * @private\n * Combined touch and mouse input\n *\n * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n * This because touch devices also emit mouse events while doing a touch.\n *\n * @constructor\n * @extends Input\n */\n\nvar DEDUP_TIMEOUT = 2500;\nvar DEDUP_DISTANCE = 25;\n\nfunction setLastTouch(eventData) {\n  var _eventData$changedPoi = eventData.changedPointers,\n      touch = _eventData$changedPoi[0];\n\n  if (touch.identifier === this.primaryTouch) {\n    var lastTouch = {\n      x: touch.clientX,\n      y: touch.clientY\n    };\n    var lts = this.lastTouches;\n    this.lastTouches.push(lastTouch);\n\n    var removeLastTouch = function removeLastTouch() {\n      var i = lts.indexOf(lastTouch);\n\n      if (i > -1) {\n        lts.splice(i, 1);\n      }\n    };\n\n    setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n  }\n}\n\nfunction recordTouches(eventType, eventData) {\n  if (eventType & INPUT_START) {\n    this.primaryTouch = eventData.changedPointers[0].identifier;\n    setLastTouch.call(this, eventData);\n  } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n    setLastTouch.call(this, eventData);\n  }\n}\n\nfunction isSyntheticEvent(eventData) {\n  var x = eventData.srcEvent.clientX;\n  var y = eventData.srcEvent.clientY;\n\n  for (var i = 0; i < this.lastTouches.length; i++) {\n    var t = this.lastTouches[i];\n    var dx = Math.abs(x - t.x);\n    var dy = Math.abs(y - t.y);\n\n    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar TouchMouseInput =\n/*#__PURE__*/\nfunction () {\n  var TouchMouseInput =\n  /*#__PURE__*/\n  function (_Input) {\n    _inheritsLoose(TouchMouseInput, _Input);\n\n    function TouchMouseInput(_manager, callback) {\n      var _this;\n\n      _this = _Input.call(this, _manager, callback) || this;\n\n      _this.handler = function (manager, inputEvent, inputData) {\n        var isTouch = inputData.pointerType === INPUT_TYPE_TOUCH;\n        var isMouse = inputData.pointerType === INPUT_TYPE_MOUSE;\n\n        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n          return;\n        } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n\n        if (isTouch) {\n          recordTouches.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputEvent, inputData);\n        } else if (isMouse && isSyntheticEvent.call(_assertThisInitialized$1(_assertThisInitialized$1(_this)), inputData)) {\n          return;\n        }\n\n        _this.callback(manager, inputEvent, inputData);\n      };\n\n      _this.touch = new TouchInput(_this.manager, _this.handler);\n      _this.mouse = new MouseInput(_this.manager, _this.handler);\n      _this.primaryTouch = null;\n      _this.lastTouches = [];\n      return _this;\n    }\n    /**\n     * @private\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n\n\n    var _proto = TouchMouseInput.prototype;\n\n    /**\n     * @private\n     * remove the event listeners\n     */\n    _proto.destroy = function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    };\n\n    return TouchMouseInput;\n  }(Input);\n\n  return TouchMouseInput;\n}();\n\n/**\n * @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}\n */\n\nfunction createInputInstance(manager) {\n  var Type; // let inputClass = manager.options.inputClass;\n\n  var inputClass = manager.options.inputClass;\n\n  if (inputClass) {\n    Type = inputClass;\n  } else if (SUPPORT_POINTER_EVENTS) {\n    Type = PointerEventInput;\n  } else if (SUPPORT_ONLY_TOUCH) {\n    Type = TouchInput;\n  } else if (!SUPPORT_TOUCH) {\n    Type = MouseInput;\n  } else {\n    Type = TouchMouseInput;\n  }\n\n  return new Type(manager, inputHandler);\n}\n\n/**\n * @private\n * if the argument is an array, we want to execute the fn on each entry\n * if it aint an array we don't want to do a thing.\n * this is used by all the methods that accept a single and array argument.\n * @param {*|Array} arg\n * @param {String} fn\n * @param {Object} [context]\n * @returns {Boolean}\n */\n\nfunction invokeArrayArg(arg, fn, context) {\n  if (Array.isArray(arg)) {\n    each(arg, context[fn], context);\n    return true;\n  }\n\n  return false;\n}\n\nvar STATE_POSSIBLE = 1;\nvar STATE_BEGAN = 2;\nvar STATE_CHANGED = 4;\nvar STATE_ENDED = 8;\nvar STATE_RECOGNIZED = STATE_ENDED;\nvar STATE_CANCELLED = 16;\nvar STATE_FAILED = 32;\n\n/**\n * @private\n * get a unique id\n * @returns {number} uniqueId\n */\nvar _uniqueId = 1;\nfunction uniqueId() {\n  return _uniqueId++;\n}\n\n/**\n * @private\n * get a recognizer by name if it is bound to a manager\n * @param {Recognizer|String} otherRecognizer\n * @param {Recognizer} recognizer\n * @returns {Recognizer}\n */\nfunction getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n  var manager = recognizer.manager;\n\n  if (manager) {\n    return manager.get(otherRecognizer);\n  }\n\n  return otherRecognizer;\n}\n\n/**\n * @private\n * get a usable string, used as event postfix\n * @param {constant} state\n * @returns {String} state\n */\n\nfunction stateStr(state) {\n  if (state & STATE_CANCELLED) {\n    return 'cancel';\n  } else if (state & STATE_ENDED) {\n    return 'end';\n  } else if (state & STATE_CHANGED) {\n    return 'move';\n  } else if (state & STATE_BEGAN) {\n    return 'start';\n  }\n\n  return '';\n}\n\n/**\n * @private\n * Recognizer flow explained; *\n * All recognizers have the initial state of POSSIBLE when a input session starts.\n * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n * Example session for mouse-input: mousedown -> mousemove -> mouseup\n *\n * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n * which determines with state it should be.\n *\n * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n * POSSIBLE to give it another change on the next cycle.\n *\n *               Possible\n *                  |\n *            +-----+---------------+\n *            |                     |\n *      +-----+-----+               |\n *      |           |               |\n *   Failed      Cancelled          |\n *                          +-------+------+\n *                          |              |\n *                      Recognized       Began\n *                                         |\n *                                      Changed\n *                                         |\n *                                  Ended/Recognized\n */\n\n/**\n * @private\n * Recognizer\n * Every recognizer needs to extend from this class.\n * @constructor\n * @param {Object} options\n */\n\nvar Recognizer =\n/*#__PURE__*/\nfunction () {\n  function Recognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = _extends({\n      enable: true\n    }, options);\n    this.id = uniqueId();\n    this.manager = null; // default is enable true\n\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @return {Recognizer}\n   */\n\n\n  var _proto = Recognizer.prototype;\n\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n    this.manager && this.manager.touchAction.update();\n    return this;\n  };\n  /**\n   * @private\n   * recognize simultaneous with an other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.recognizeWith = function recognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n      return this;\n    }\n\n    var simultaneous = this.simultaneous;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (!simultaneous[otherRecognizer.id]) {\n      simultaneous[otherRecognizer.id] = otherRecognizer;\n      otherRecognizer.recognizeWith(this);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.dropRecognizeWith = function dropRecognizeWith(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    delete this.simultaneous[otherRecognizer.id];\n    return this;\n  };\n  /**\n   * @private\n   * recognizer can only run when an other is failing\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.requireFailure = function requireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n      return this;\n    }\n\n    var requireFail = this.requireFail;\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n    if (inArray(requireFail, otherRecognizer) === -1) {\n      requireFail.push(otherRecognizer);\n      otherRecognizer.requireFailure(this);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * drop the requireFailure link. it does not remove the link on the other recognizer.\n   * @param {Recognizer} otherRecognizer\n   * @returns {Recognizer} this\n   */\n\n\n  _proto.dropRequireFailure = function dropRequireFailure(otherRecognizer) {\n    if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n      return this;\n    }\n\n    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n    var index = inArray(this.requireFail, otherRecognizer);\n\n    if (index > -1) {\n      this.requireFail.splice(index, 1);\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * has require failures boolean\n   * @returns {boolean}\n   */\n\n\n  _proto.hasRequireFailures = function hasRequireFailures() {\n    return this.requireFail.length > 0;\n  };\n  /**\n   * @private\n   * if the recognizer can recognize simultaneous with an other recognizer\n   * @param {Recognizer} otherRecognizer\n   * @returns {Boolean}\n   */\n\n\n  _proto.canRecognizeWith = function canRecognizeWith(otherRecognizer) {\n    return !!this.simultaneous[otherRecognizer.id];\n  };\n  /**\n   * @private\n   * You should use `tryEmit` instead of `emit` directly to check\n   * that all the needed recognizers has failed before emitting.\n   * @param {Object} input\n   */\n\n\n  _proto.emit = function emit(input) {\n    var self = this;\n    var state = this.state;\n\n    function emit(event) {\n      self.manager.emit(event, input);\n    } // 'panstart' and 'panmove'\n\n\n    if (state < STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n\n    emit(self.options.event); // simple 'eventName' events\n\n    if (input.additionalEvent) {\n      // additional event(panleft, panright, pinchin, pinchout...)\n      emit(input.additionalEvent);\n    } // panend and pancancel\n\n\n    if (state >= STATE_ENDED) {\n      emit(self.options.event + stateStr(state));\n    }\n  };\n  /**\n   * @private\n   * Check that all the require failure recognizers has failed,\n   * if true, it emits a gesture event,\n   * otherwise, setup the state to FAILED.\n   * @param {Object} input\n   */\n\n\n  _proto.tryEmit = function tryEmit(input) {\n    if (this.canEmit()) {\n      return this.emit(input);\n    } // it's failing anyway\n\n\n    this.state = STATE_FAILED;\n  };\n  /**\n   * @private\n   * can we emit?\n   * @returns {boolean}\n   */\n\n\n  _proto.canEmit = function canEmit() {\n    var i = 0;\n\n    while (i < this.requireFail.length) {\n      if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n        return false;\n      }\n\n      i++;\n    }\n\n    return true;\n  };\n  /**\n   * @private\n   * update the recognizer\n   * @param {Object} inputData\n   */\n\n\n  _proto.recognize = function recognize(inputData) {\n    // make a new copy of the inputData\n    // so we can change the inputData without messing up the other recognizers\n    var inputDataClone = assign$1({}, inputData); // is is enabled and allow recognizing?\n\n    if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n      this.reset();\n      this.state = STATE_FAILED;\n      return;\n    } // reset when we've reached the end\n\n\n    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n      this.state = STATE_POSSIBLE;\n    }\n\n    this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n    // so trigger an event\n\n    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n      this.tryEmit(inputDataClone);\n    }\n  };\n  /**\n   * @private\n   * return the state of the recognizer\n   * the actual recognizing happens in this method\n   * @virtual\n   * @param {Object} inputData\n   * @returns {constant} STATE\n   */\n\n  /* jshint ignore:start */\n\n\n  _proto.process = function process(inputData) {};\n  /* jshint ignore:end */\n\n  /**\n   * @private\n   * return the preferred touch-action\n   * @virtual\n   * @returns {Array}\n   */\n\n\n  _proto.getTouchAction = function getTouchAction() {};\n  /**\n   * @private\n   * called when the gesture isn't allowed to recognize\n   * like when another is being recognized or it is disabled\n   * @virtual\n   */\n\n\n  _proto.reset = function reset() {};\n\n  return Recognizer;\n}();\n\n/**\n * @private\n * A tap is recognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n * a single tap.\n *\n * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n * multi-taps being recognized.\n * @constructor\n * @extends Recognizer\n */\n\nvar TapRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(TapRecognizer, _Recognizer);\n\n  function TapRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10\n    }, options)) || this; // previous time and center,\n    // used for tap counting\n\n    _this.pTime = false;\n    _this.pCenter = false;\n    _this._timer = null;\n    _this._input = null;\n    _this.count = 0;\n    return _this;\n  }\n\n  var _proto = TapRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_MANIPULATION];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTouchTime = input.deltaTime < options.time;\n    this.reset();\n\n    if (input.eventType & INPUT_START && this.count === 0) {\n      return this.failTimeout();\n    } // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n\n    if (validMovement && validTouchTime && validPointers) {\n      if (input.eventType !== INPUT_END) {\n        return this.failTimeout();\n      }\n\n      var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n      var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n      this.pTime = input.timeStamp;\n      this.pCenter = input.center;\n\n      if (!validMultiTap || !validInterval) {\n        this.count = 1;\n      } else {\n        this.count += 1;\n      }\n\n      this._input = input; // if tap count matches we have recognized it,\n      // else it has began recognizing...\n\n      var tapCount = this.count % options.taps;\n\n      if (tapCount === 0) {\n        // no failing requirements, immediately trigger the tap event\n        // or wait as long as the multitap interval to trigger\n        if (!this.hasRequireFailures()) {\n          return STATE_RECOGNIZED;\n        } else {\n          this._timer = setTimeout(function () {\n            _this2.state = STATE_RECOGNIZED;\n\n            _this2.tryEmit();\n          }, options.interval);\n          return STATE_BEGAN;\n        }\n      }\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.failTimeout = function failTimeout() {\n    var _this3 = this;\n\n    this._timer = setTimeout(function () {\n      _this3.state = STATE_FAILED;\n    }, this.options.interval);\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit() {\n    if (this.state === STATE_RECOGNIZED) {\n      this._input.tapCount = this.count;\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return TapRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * This recognizer is just used as a base for the simple attribute recognizers.\n * @constructor\n * @extends Recognizer\n */\n\nvar AttrRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(AttrRecognizer, _Recognizer);\n\n  function AttrRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _Recognizer.call(this, _extends({\n      pointers: 1\n    }, options)) || this;\n  }\n  /**\n   * @private\n   * Used to check if it the recognizer receives valid input, like input.distance > 10.\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {Boolean} recognized\n   */\n\n\n  var _proto = AttrRecognizer.prototype;\n\n  _proto.attrTest = function attrTest(input) {\n    var optionPointers = this.options.pointers;\n    return optionPointers === 0 || input.pointers.length === optionPointers;\n  };\n  /**\n   * @private\n   * Process the input and return the state for the recognizer\n   * @memberof AttrRecognizer\n   * @param {Object} input\n   * @returns {*} State\n   */\n\n\n  _proto.process = function process(input) {\n    var state = this.state;\n    var eventType = input.eventType;\n    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n    var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n      return state | STATE_CANCELLED;\n    } else if (isRecognized || isValid) {\n      if (eventType & INPUT_END) {\n        return state | STATE_ENDED;\n      } else if (!(state & STATE_BEGAN)) {\n        return STATE_BEGAN;\n      }\n\n      return state | STATE_CHANGED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  return AttrRecognizer;\n}(Recognizer);\n\n/**\n * @private\n * direction cons to string\n * @param {constant} direction\n * @returns {String}\n */\n\nfunction directionStr(direction) {\n  if (direction === DIRECTION_DOWN) {\n    return 'down';\n  } else if (direction === DIRECTION_UP) {\n    return 'up';\n  } else if (direction === DIRECTION_LEFT) {\n    return 'left';\n  } else if (direction === DIRECTION_RIGHT) {\n    return 'right';\n  }\n\n  return '';\n}\n\n/**\n * @private\n * Pan\n * Recognized when the pointer is down and moved in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PanRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(PanRecognizer, _AttrRecognizer);\n\n  function PanRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _AttrRecognizer.call(this, _extends({\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    }, options)) || this;\n    _this.pX = null;\n    _this.pY = null;\n    return _this;\n  }\n\n  var _proto = PanRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    var direction = this.options.direction;\n    var actions = [];\n\n    if (direction & DIRECTION_HORIZONTAL) {\n      actions.push(TOUCH_ACTION_PAN_Y);\n    }\n\n    if (direction & DIRECTION_VERTICAL) {\n      actions.push(TOUCH_ACTION_PAN_X);\n    }\n\n    return actions;\n  };\n\n  _proto.directionTest = function directionTest(input) {\n    var options = this.options;\n    var hasMoved = true;\n    var distance = input.distance;\n    var direction = input.direction;\n    var x = input.deltaX;\n    var y = input.deltaY; // lock to axis?\n\n    if (!(direction & options.direction)) {\n      if (options.direction & DIRECTION_HORIZONTAL) {\n        direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n        hasMoved = x !== this.pX;\n        distance = Math.abs(input.deltaX);\n      } else {\n        direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n        hasMoved = y !== this.pY;\n        distance = Math.abs(input.deltaY);\n      }\n    }\n\n    input.direction = direction;\n    return hasMoved && distance > options.threshold && direction & options.direction;\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return AttrRecognizer.prototype.attrTest.call(this, input) && ( // replace with a super call\n    this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n  };\n\n  _proto.emit = function emit(input) {\n    this.pX = input.deltaX;\n    this.pY = input.deltaY;\n    var direction = directionStr(input.direction);\n\n    if (direction) {\n      input.additionalEvent = this.options.event + direction;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PanRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Swipe\n * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar SwipeRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(SwipeRecognizer, _AttrRecognizer);\n\n  function SwipeRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    }, options)) || this;\n  }\n\n  var _proto = SwipeRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return PanRecognizer.prototype.getTouchAction.call(this);\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    var direction = this.options.direction;\n    var velocity;\n\n    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n      velocity = input.overallVelocity;\n    } else if (direction & DIRECTION_HORIZONTAL) {\n      velocity = input.overallVelocityX;\n    } else if (direction & DIRECTION_VERTICAL) {\n      velocity = input.overallVelocityY;\n    }\n\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers === this.options.pointers && abs$1(velocity) > this.options.velocity && input.eventType & INPUT_END;\n  };\n\n  _proto.emit = function emit(input) {\n    var direction = directionStr(input.offsetDirection);\n\n    if (direction) {\n      this.manager.emit(this.options.event + direction, input);\n    }\n\n    this.manager.emit(this.options.event, input);\n  };\n\n  return SwipeRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Pinch\n * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar PinchRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(PinchRecognizer, _AttrRecognizer);\n\n  function PinchRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  _proto.emit = function emit(input) {\n    if (input.scale !== 1) {\n      var inOut = input.scale < 1 ? 'in' : 'out';\n      input.additionalEvent = this.options.event + inOut;\n    }\n\n    _AttrRecognizer.prototype.emit.call(this, input);\n  };\n\n  return PinchRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Rotate\n * Recognized when two or more pointer are moving in a circular motion.\n * @constructor\n * @extends AttrRecognizer\n */\n\nvar RotateRecognizer =\n/*#__PURE__*/\nfunction (_AttrRecognizer) {\n  _inheritsLoose(RotateRecognizer, _AttrRecognizer);\n\n  function RotateRecognizer(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return _AttrRecognizer.call(this, _extends({\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    }, options)) || this;\n  }\n\n  var _proto = RotateRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_NONE];\n  };\n\n  _proto.attrTest = function attrTest(input) {\n    return _AttrRecognizer.prototype.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n  };\n\n  return RotateRecognizer;\n}(AttrRecognizer);\n\n/**\n * @private\n * Press\n * Recognized when the pointer is down for x ms without any movement.\n * @constructor\n * @extends Recognizer\n */\n\nvar PressRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(PressRecognizer, _Recognizer);\n\n  function PressRecognizer(options) {\n    var _this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    _this = _Recognizer.call(this, _extends({\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9\n    }, options)) || this;\n    _this._timer = null;\n    _this._input = null;\n    return _this;\n  }\n\n  var _proto = PressRecognizer.prototype;\n\n  _proto.getTouchAction = function getTouchAction() {\n    return [TOUCH_ACTION_AUTO];\n  };\n\n  _proto.process = function process(input) {\n    var _this2 = this;\n\n    var options = this.options;\n    var validPointers = input.pointers.length === options.pointers;\n    var validMovement = input.distance < options.threshold;\n    var validTime = input.deltaTime > options.time;\n    this._input = input; // we only allow little movement\n    // and we've reached an end event, so a tap is possible\n\n    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n      this.reset();\n    } else if (input.eventType & INPUT_START) {\n      this.reset();\n      this._timer = setTimeout(function () {\n        _this2.state = STATE_RECOGNIZED;\n\n        _this2.tryEmit();\n      }, options.time);\n    } else if (input.eventType & INPUT_END) {\n      return STATE_RECOGNIZED;\n    }\n\n    return STATE_FAILED;\n  };\n\n  _proto.reset = function reset() {\n    clearTimeout(this._timer);\n  };\n\n  _proto.emit = function emit(input) {\n    if (this.state !== STATE_RECOGNIZED) {\n      return;\n    }\n\n    if (input && input.eventType & INPUT_END) {\n      this.manager.emit(this.options.event + \"up\", input);\n    } else {\n      this._input.timeStamp = now();\n      this.manager.emit(this.options.event, this._input);\n    }\n  };\n\n  return PressRecognizer;\n}(Recognizer);\n\nvar defaults = {\n  /**\n   * @private\n   * set if DOM events are being triggered.\n   * But this is slower and unused by simple implementations, so disabled by default.\n   * @type {Boolean}\n   * @default false\n   */\n  domEvents: false,\n\n  /**\n   * @private\n   * The value for the touchAction property/fallback.\n   * When set to `compute` it will magically set the correct value based on the added recognizers.\n   * @type {String}\n   * @default compute\n   */\n  touchAction: TOUCH_ACTION_COMPUTE,\n\n  /**\n   * @private\n   * @type {Boolean}\n   * @default true\n   */\n  enable: true,\n\n  /**\n   * @private\n   * EXPERIMENTAL FEATURE -- can be removed/changed\n   * Change the parent input target element.\n   * If Null, then it is being set the to main element.\n   * @type {Null|EventTarget}\n   * @default null\n   */\n  inputTarget: null,\n\n  /**\n   * @private\n   * force an input class\n   * @type {Null|Function}\n   * @default null\n   */\n  inputClass: null,\n\n  /**\n   * @private\n   * Some CSS properties can be used to improve the working of Hammer.\n   * Add them to this method and they will be set when creating a new Manager.\n   * @namespace\n   */\n  cssProps: {\n    /**\n     * @private\n     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userSelect: \"none\",\n\n    /**\n     * @private\n     * Disable the Windows Phone grippers when pressing an element.\n     * @type {String}\n     * @default 'none'\n     */\n    touchSelect: \"none\",\n\n    /**\n     * @private\n     * Disables the default callout shown when you touch and hold a touch target.\n     * On iOS, when you touch and hold a touch target such as a link, Safari displays\n     * a callout containing information about the link. This property allows you to disable that callout.\n     * @type {String}\n     * @default 'none'\n     */\n    touchCallout: \"none\",\n\n    /**\n     * @private\n     * Specifies whether zooming is enabled. Used by IE10>\n     * @type {String}\n     * @default 'none'\n     */\n    contentZooming: \"none\",\n\n    /**\n     * @private\n     * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n     * @type {String}\n     * @default 'none'\n     */\n    userDrag: \"none\",\n\n    /**\n     * @private\n     * Overrides the highlight color shown when the user taps a link or a JavaScript\n     * clickable element in iOS. This property obeys the alpha value, if specified.\n     * @type {String}\n     * @default 'rgba(0,0,0,0)'\n     */\n    tapHighlightColor: \"rgba(0,0,0,0)\"\n  }\n};\n/**\n * @private\n * Default recognizer setup when calling `Hammer()`\n * When creating a new Manager these will be skipped.\n * This is separated with other defaults because of tree-shaking.\n * @type {Array}\n */\n\nvar preset = [[RotateRecognizer, {\n  enable: false\n}], [PinchRecognizer, {\n  enable: false\n}, ['rotate']], [SwipeRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}], [PanRecognizer, {\n  direction: DIRECTION_HORIZONTAL\n}, ['swipe']], [TapRecognizer], [TapRecognizer, {\n  event: 'doubletap',\n  taps: 2\n}, ['tap']], [PressRecognizer]];\n\nvar STOP = 1;\nvar FORCED_STOP = 2;\n/**\n * @private\n * add/remove the css properties as defined in manager.options.cssProps\n * @param {Manager} manager\n * @param {Boolean} add\n */\n\nfunction toggleCssProps(manager, add) {\n  var element = manager.element;\n\n  if (!element.style) {\n    return;\n  }\n\n  var prop;\n  each(manager.options.cssProps, function (value, name) {\n    prop = prefixed(element.style, name);\n\n    if (add) {\n      manager.oldCssProps[prop] = element.style[prop];\n      element.style[prop] = value;\n    } else {\n      element.style[prop] = manager.oldCssProps[prop] || \"\";\n    }\n  });\n\n  if (!add) {\n    manager.oldCssProps = {};\n  }\n}\n/**\n * @private\n * trigger dom event\n * @param {String} event\n * @param {Object} data\n */\n\n\nfunction triggerDomEvent(event, data) {\n  var gestureEvent = document.createEvent(\"Event\");\n  gestureEvent.initEvent(event, true, true);\n  gestureEvent.gesture = data;\n  data.target.dispatchEvent(gestureEvent);\n}\n/**\n* @private\n * Manager\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\n\nvar Manager =\n/*#__PURE__*/\nfunction () {\n  function Manager(element, options) {\n    var _this = this;\n\n    this.options = assign$1({}, defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = _this.add(new item[0](item[1]));\n\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n  /**\n   * @private\n   * set options\n   * @param {Object} options\n   * @returns {Manager}\n   */\n\n\n  var _proto = Manager.prototype;\n\n  _proto.set = function set(options) {\n    assign$1(this.options, options); // Options that need a little more setup\n\n    if (options.touchAction) {\n      this.touchAction.update();\n    }\n\n    if (options.inputTarget) {\n      // Clean up existing event listeners and reinitialize\n      this.input.destroy();\n      this.input.target = options.inputTarget;\n      this.input.init();\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * stop recognizing for this session.\n   * This session will be discarded, when a new [input]start event is fired.\n   * When forced, the recognizer cycle is stopped immediately.\n   * @param {Boolean} [force]\n   */\n\n\n  _proto.stop = function stop(force) {\n    this.session.stopped = force ? FORCED_STOP : STOP;\n  };\n  /**\n   * @private\n   * run the recognizers!\n   * called by the inputHandler function on every movement of the pointers (touches)\n   * it walks through all the recognizers and tries to detect the gesture that is being made\n   * @param {Object} inputData\n   */\n\n\n  _proto.recognize = function recognize(inputData) {\n    var session = this.session;\n\n    if (session.stopped) {\n      return;\n    } // run the touch-action polyfill\n\n\n    this.touchAction.preventDefaults(inputData);\n    var recognizer;\n    var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n    // if no recognizer is detecting a thing, it is set to `null`\n\n    var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n    // or when we're in a new session\n\n    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n      session.curRecognizer = null;\n      curRecognizer = null;\n    }\n\n    var i = 0;\n\n    while (i < recognizers.length) {\n      recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n      // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n      // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n      //      that is being recognized.\n      // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n      //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n      if (session.stopped !== FORCED_STOP && ( // 1\n      !curRecognizer || recognizer === curRecognizer || // 2\n      recognizer.canRecognizeWith(curRecognizer))) {\n        // 3\n        recognizer.recognize(inputData);\n      } else {\n        recognizer.reset();\n      } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n      // current active recognizer. but only if we don't already have an active recognizer\n\n\n      if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n        session.curRecognizer = recognizer;\n        curRecognizer = recognizer;\n      }\n\n      i++;\n    }\n  };\n  /**\n   * @private\n   * get a recognizer by its event name.\n   * @param {Recognizer|String} recognizer\n   * @returns {Recognizer|Null}\n   */\n\n\n  _proto.get = function get(recognizer) {\n    if (recognizer instanceof Recognizer) {\n      return recognizer;\n    }\n\n    var recognizers = this.recognizers;\n\n    for (var i = 0; i < recognizers.length; i++) {\n      if (recognizers[i].options.event === recognizer) {\n        return recognizers[i];\n      }\n    }\n\n    return null;\n  };\n  /**\n   * @private add a recognizer to the manager\n   * existing recognizers with the same event name will be removed\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer|Manager}\n   */\n\n\n  _proto.add = function add(recognizer) {\n    if (invokeArrayArg(recognizer, \"add\", this)) {\n      return this;\n    } // remove existing\n\n\n    var existing = this.get(recognizer.options.event);\n\n    if (existing) {\n      this.remove(existing);\n    }\n\n    this.recognizers.push(recognizer);\n    recognizer.manager = this;\n    this.touchAction.update();\n    return recognizer;\n  };\n  /**\n   * @private\n   * remove a recognizer by name or instance\n   * @param {Recognizer|String} recognizer\n   * @returns {Manager}\n   */\n\n\n  _proto.remove = function remove(recognizer) {\n    if (invokeArrayArg(recognizer, \"remove\", this)) {\n      return this;\n    }\n\n    var targetRecognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n    if (recognizer) {\n      var recognizers = this.recognizers;\n      var index = inArray(recognizers, targetRecognizer);\n\n      if (index !== -1) {\n        recognizers.splice(index, 1);\n        this.touchAction.update();\n      }\n    }\n\n    return this;\n  };\n  /**\n   * @private\n   * bind event\n   * @param {String} events\n   * @param {Function} handler\n   * @returns {EventEmitter} this\n   */\n\n\n  _proto.on = function on(events, handler) {\n    if (events === undefined || handler === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      handlers[event] = handlers[event] || [];\n      handlers[event].push(handler);\n    });\n    return this;\n  };\n  /**\n   * @private unbind event, leave emit blank to remove all handlers\n   * @param {String} events\n   * @param {Function} [handler]\n   * @returns {EventEmitter} this\n   */\n\n\n  _proto.off = function off(events, handler) {\n    if (events === undefined) {\n      return this;\n    }\n\n    var handlers = this.handlers;\n    each(splitStr(events), function (event) {\n      if (!handler) {\n        delete handlers[event];\n      } else {\n        handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n      }\n    });\n    return this;\n  };\n  /**\n   * @private emit event to the listeners\n   * @param {String} event\n   * @param {Object} data\n   */\n\n\n  _proto.emit = function emit(event, data) {\n    // we also want to trigger dom events\n    if (this.options.domEvents) {\n      triggerDomEvent(event, data);\n    } // no handlers, so skip it all\n\n\n    var handlers = this.handlers[event] && this.handlers[event].slice();\n\n    if (!handlers || !handlers.length) {\n      return;\n    }\n\n    data.type = event;\n\n    data.preventDefault = function () {\n      data.srcEvent.preventDefault();\n    };\n\n    var i = 0;\n\n    while (i < handlers.length) {\n      handlers[i](data);\n      i++;\n    }\n  };\n  /**\n   * @private\n   * destroy the manager and unbinds all events\n   * it doesn't unbind dom events, that is the user own responsibility\n   */\n\n\n  _proto.destroy = function destroy() {\n    this.element && toggleCssProps(this, false);\n    this.handlers = {};\n    this.session = {};\n    this.input.destroy();\n    this.element = null;\n  };\n\n  return Manager;\n}();\n\nvar SINGLE_TOUCH_INPUT_MAP = {\n  touchstart: INPUT_START,\n  touchmove: INPUT_MOVE,\n  touchend: INPUT_END,\n  touchcancel: INPUT_CANCEL\n};\nvar SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\nvar SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n/**\n * @private\n * Touch events input\n * @constructor\n * @extends Input\n */\n\nvar SingleTouchInput =\n/*#__PURE__*/\nfunction (_Input) {\n  _inheritsLoose(SingleTouchInput, _Input);\n\n  function SingleTouchInput() {\n    var _this;\n\n    var proto = SingleTouchInput.prototype;\n    proto.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    proto.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    _this = _Input.apply(this, arguments) || this;\n    _this.started = false;\n    return _this;\n  }\n\n  var _proto = SingleTouchInput.prototype;\n\n  _proto.handler = function handler(ev) {\n    var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n    if (type === INPUT_START) {\n      this.started = true;\n    }\n\n    if (!this.started) {\n      return;\n    }\n\n    var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n      this.started = false;\n    }\n\n    this.callback(this.manager, type, {\n      pointers: touches[0],\n      changedPointers: touches[1],\n      pointerType: INPUT_TYPE_TOUCH,\n      srcEvent: ev\n    });\n  };\n\n  return SingleTouchInput;\n}(Input);\n\nfunction normalizeSingleTouches(ev, type) {\n  var all = toArray(ev.touches);\n  var changed = toArray(ev.changedTouches);\n\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }\n\n  return [all, changed];\n}\n\n/**\n * @private\n * wrap a method with a deprecation warning and stack trace\n * @param {Function} method\n * @param {String} name\n * @param {String} message\n * @returns {Function} A new function wrapping the supplied method.\n */\nfunction deprecate(method, name, message) {\n  var deprecationMessage = \"DEPRECATED METHOD: \" + name + \"\\n\" + message + \" AT \\n\";\n  return function () {\n    var e = new Error('get-stack-trace');\n    var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n    var log = window.console && (window.console.warn || window.console.log);\n\n    if (log) {\n      log.call(window.console, deprecationMessage, stack);\n    }\n\n    return method.apply(this, arguments);\n  };\n}\n\n/**\n * @private\n * extend object.\n * means that properties in dest will be overwritten by the ones in src.\n * @param {Object} dest\n * @param {Object} src\n * @param {Boolean} [merge=false]\n * @returns {Object} dest\n */\n\nvar extend = deprecate(function (dest, src, merge) {\n  var keys = Object.keys(src);\n  var i = 0;\n\n  while (i < keys.length) {\n    if (!merge || merge && dest[keys[i]] === undefined) {\n      dest[keys[i]] = src[keys[i]];\n    }\n\n    i++;\n  }\n\n  return dest;\n}, 'extend', 'Use `assign`.');\n\n/**\n * @private\n * merge the values from src in the dest.\n * means that properties that exist in dest will not be overwritten by src\n * @param {Object} dest\n * @param {Object} src\n * @returns {Object} dest\n */\n\nvar merge$2 = deprecate(function (dest, src) {\n  return extend(dest, src, true);\n}, 'merge', 'Use `assign`.');\n\n/**\n * @private\n * simple class inheritance\n * @param {Function} child\n * @param {Function} base\n * @param {Object} [properties]\n */\n\nfunction inherit(child, base, properties) {\n  var baseP = base.prototype;\n  var childP;\n  childP = child.prototype = Object.create(baseP);\n  childP.constructor = child;\n  childP._super = baseP;\n\n  if (properties) {\n    assign$1(childP, properties);\n  }\n}\n\n/**\n * @private\n * simple function bind\n * @param {Function} fn\n * @param {Object} context\n * @returns {Function}\n */\nfunction bindFn(fn, context) {\n  return function boundFn() {\n    return fn.apply(context, arguments);\n  };\n}\n\n/**\n * @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor\n */\n\nvar Hammer$2 =\n/*#__PURE__*/\nfunction () {\n  var Hammer =\n  /**\n    * @private\n    * @const {string}\n    */\n  function Hammer(element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return new Manager(element, _extends({\n      recognizers: preset.concat()\n    }, options));\n  };\n\n  Hammer.VERSION = \"2.0.17-rc\";\n  Hammer.DIRECTION_ALL = DIRECTION_ALL;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.DIRECTION_LEFT = DIRECTION_LEFT;\n  Hammer.DIRECTION_RIGHT = DIRECTION_RIGHT;\n  Hammer.DIRECTION_UP = DIRECTION_UP;\n  Hammer.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\n  Hammer.DIRECTION_VERTICAL = DIRECTION_VERTICAL;\n  Hammer.DIRECTION_NONE = DIRECTION_NONE;\n  Hammer.DIRECTION_DOWN = DIRECTION_DOWN;\n  Hammer.INPUT_START = INPUT_START;\n  Hammer.INPUT_MOVE = INPUT_MOVE;\n  Hammer.INPUT_END = INPUT_END;\n  Hammer.INPUT_CANCEL = INPUT_CANCEL;\n  Hammer.STATE_POSSIBLE = STATE_POSSIBLE;\n  Hammer.STATE_BEGAN = STATE_BEGAN;\n  Hammer.STATE_CHANGED = STATE_CHANGED;\n  Hammer.STATE_ENDED = STATE_ENDED;\n  Hammer.STATE_RECOGNIZED = STATE_RECOGNIZED;\n  Hammer.STATE_CANCELLED = STATE_CANCELLED;\n  Hammer.STATE_FAILED = STATE_FAILED;\n  Hammer.Manager = Manager;\n  Hammer.Input = Input;\n  Hammer.TouchAction = TouchAction;\n  Hammer.TouchInput = TouchInput;\n  Hammer.MouseInput = MouseInput;\n  Hammer.PointerEventInput = PointerEventInput;\n  Hammer.TouchMouseInput = TouchMouseInput;\n  Hammer.SingleTouchInput = SingleTouchInput;\n  Hammer.Recognizer = Recognizer;\n  Hammer.AttrRecognizer = AttrRecognizer;\n  Hammer.Tap = TapRecognizer;\n  Hammer.Pan = PanRecognizer;\n  Hammer.Swipe = SwipeRecognizer;\n  Hammer.Pinch = PinchRecognizer;\n  Hammer.Rotate = RotateRecognizer;\n  Hammer.Press = PressRecognizer;\n  Hammer.on = addEventListeners;\n  Hammer.off = removeEventListeners;\n  Hammer.each = each;\n  Hammer.merge = merge$2;\n  Hammer.extend = extend;\n  Hammer.bindFn = bindFn;\n  Hammer.assign = assign$1;\n  Hammer.inherit = inherit;\n  Hammer.bindFn = bindFn;\n  Hammer.prefixed = prefixed;\n  Hammer.toArray = toArray;\n  Hammer.inArray = inArray;\n  Hammer.uniqueArray = uniqueArray;\n  Hammer.splitStr = splitStr;\n  Hammer.boolOrFn = boolOrFn;\n  Hammer.hasParent = hasParent;\n  Hammer.addEventListeners = addEventListeners;\n  Hammer.removeEventListeners = removeEventListeners;\n  Hammer.defaults = assign$1({}, defaults, {\n    preset: preset\n  });\n  return Hammer;\n}();\n\n//  style loader but by script tag, not by the loader.\n\nHammer$2.defaults;\n\nvar RealHammer = Hammer$2;\n\nfunction _createForOfIteratorHelper$6(o, allowArrayLike) { var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$6(o, minLen) { var _context17; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$6(o, minLen); var n = _sliceInstanceProperty(_context17 = Object.prototype.toString.call(o)).call(_context17, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return _Array$from$1(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }\nfunction _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n/**\r\n * Use this symbol to delete properies in deepObjectAssign.\r\n */\n_Symbol(\"DELETE\");\n\n/**\r\n * Seedable, fast and reasonably good (not crypto but more than okay for our\r\n * needs) random number generator.\r\n *\r\n * @remarks\r\n * Adapted from {@link https://web.archive.org/web/20110429100736/http://baagoe.com:80/en/RandomMusings/javascript}.\r\n * Original algorithm created by Johannes Baagøe \\<baagoe\\@baagoe.com\\> in 2010.\r\n */\n/**\r\n * Create a seeded pseudo random generator based on Alea by Johannes Baagøe.\r\n *\r\n * @param seed - All supplied arguments will be used as a seed. In case nothing\r\n * is supplied the current time will be used to seed the generator.\r\n * @returns A ready to use seeded generator.\r\n */\nfunction Alea() {\n  for (var _len3 = arguments.length, seed = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    seed[_key3] = arguments[_key3];\n  }\n  return AleaImplementation(seed.length ? seed : [_Date$now()]);\n}\n/**\r\n * An implementation of [[Alea]] without user input validation.\r\n *\r\n * @param seed - The data that will be used to seed the generator.\r\n * @returns A ready to use seeded generator.\r\n */\nfunction AleaImplementation(seed) {\n  var _mashSeed = mashSeed(seed),\n    _mashSeed2 = _slicedToArray(_mashSeed, 3),\n    s0 = _mashSeed2[0],\n    s1 = _mashSeed2[1],\n    s2 = _mashSeed2[2];\n  var c = 1;\n  var random = function random() {\n    var t = 2091639 * s0 + c * 2.3283064365386963e-10; // 2^-32\n    s0 = s1;\n    s1 = s2;\n    return s2 = t - (c = t | 0);\n  };\n  random.uint32 = function () {\n    return random() * 0x100000000;\n  }; // 2^32\n  random.fract53 = function () {\n    return random() + (random() * 0x200000 | 0) * 1.1102230246251565e-16;\n  }; // 2^-53\n  random.algorithm = \"Alea\";\n  random.seed = seed;\n  random.version = \"0.9\";\n  return random;\n}\n/**\r\n * Turn arbitrary data into values [[AleaImplementation]] can use to generate\r\n * random numbers.\r\n *\r\n * @param seed - Arbitrary data that will be used as the seed.\r\n * @returns Three numbers to use as initial values for [[AleaImplementation]].\r\n */\nfunction mashSeed() {\n  var mash = Mash();\n  var s0 = mash(\" \");\n  var s1 = mash(\" \");\n  var s2 = mash(\" \");\n  for (var i = 0; i < arguments.length; i++) {\n    s0 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n    if (s0 < 0) {\n      s0 += 1;\n    }\n    s1 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n    if (s1 < 0) {\n      s1 += 1;\n    }\n    s2 -= mash(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n    if (s2 < 0) {\n      s2 += 1;\n    }\n  }\n  return [s0, s1, s2];\n}\n/**\r\n * Create a new mash function.\r\n *\r\n * @returns A nonpure function that takes arbitrary [[Mashable]] data and turns\r\n * them into numbers.\r\n */\nfunction Mash() {\n  var n = 0xefc8249d;\n  return function (data) {\n    var string = data.toString();\n    for (var i = 0; i < string.length; i++) {\n      n += string.charCodeAt(i);\n      var h = 0.02519603282416938 * n;\n      n = h >>> 0;\n      h -= n;\n      h *= n;\n      n = h >>> 0;\n      h -= n;\n      n += h * 0x100000000; // 2^32\n    }\n\n    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n  };\n}\n\n/**\n * Setup a mock hammer.js object, for unit testing.\n *\n * Inspiration: https://github.com/uber/deck.gl/pull/658\n *\n * @returns {{on: noop, off: noop, destroy: noop, emit: noop, get: get}}\n */\nfunction hammerMock() {\n  var noop = function noop() {};\n  return {\n    on: noop,\n    off: noop,\n    destroy: noop,\n    emit: noop,\n    get: function get() {\n      return {\n        set: noop\n      };\n    }\n  };\n}\nvar Hammer$1 = typeof window !== \"undefined\" ? window.Hammer || RealHammer : function () {\n  // hammer.js is only available in a browser, not in node.js. Replacing it with a mock object.\n  return hammerMock();\n};\n\n/**\n * Turn an element into an clickToUse element.\n * When not active, the element has a transparent overlay. When the overlay is\n * clicked, the mode is changed to active.\n * When active, the element is displayed with a blue border around it, and\n * the interactive contents of the element can be used. When clicked outside\n * the element, the elements mode is changed to inactive.\n *\n * @param {Element} container\n * @class Activator\n */\nfunction Activator$1(container) {\n  var _this = this,\n    _context3;\n  this._cleanupQueue = [];\n  this.active = false;\n  this._dom = {\n    container: container,\n    overlay: document.createElement(\"div\")\n  };\n  this._dom.overlay.classList.add(\"vis-overlay\");\n  this._dom.container.appendChild(this._dom.overlay);\n  this._cleanupQueue.push(function () {\n    _this._dom.overlay.parentNode.removeChild(_this._dom.overlay);\n  });\n  var hammer = Hammer$1(this._dom.overlay);\n  hammer.on(\"tap\", _bindInstanceProperty$1(_context3 = this._onTapOverlay).call(_context3, this));\n  this._cleanupQueue.push(function () {\n    hammer.destroy();\n    // FIXME: cleaning up hammer instances doesn't work (Timeline not removed\n    // from memory)\n  });\n\n  // block all touch events (except tap)\n  var events = [\"tap\", \"doubletap\", \"press\", \"pinch\", \"pan\", \"panstart\", \"panmove\", \"panend\"];\n  _forEachInstanceProperty(events).call(events, function (event) {\n    hammer.on(event, function (event) {\n      event.srcEvent.stopPropagation();\n    });\n  });\n\n  // attach a click event to the window, in order to deactivate when clicking outside the timeline\n  if (document && document.body) {\n    this._onClick = function (event) {\n      if (!_hasParent(event.target, container)) {\n        _this.deactivate();\n      }\n    };\n    document.body.addEventListener(\"click\", this._onClick);\n    this._cleanupQueue.push(function () {\n      document.body.removeEventListener(\"click\", _this._onClick);\n    });\n  }\n\n  // prepare escape key listener for deactivating when active\n  this._escListener = function (event) {\n    if (\"key\" in event ? event.key === \"Escape\" : event.keyCode === 27 /* the keyCode is for IE11 */) {\n      _this.deactivate();\n    }\n  };\n}\n\n// turn into an event emitter\nEmitter(Activator$1.prototype);\n\n// The currently active activator\nActivator$1.current = null;\n\n/**\n * Destroy the activator. Cleans up all created DOM and event listeners\n */\nActivator$1.prototype.destroy = function () {\n  var _context4, _context5;\n  this.deactivate();\n  var _iterator2 = _createForOfIteratorHelper$6(_reverseInstanceProperty(_context4 = _spliceInstanceProperty(_context5 = this._cleanupQueue).call(_context5, 0)).call(_context4)),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var callback = _step2.value;\n      callback();\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n};\n\n/**\n * Activate the element\n * Overlay is hidden, element is decorated with a blue shadow border\n */\nActivator$1.prototype.activate = function () {\n  // we allow only one active activator at a time\n  if (Activator$1.current) {\n    Activator$1.current.deactivate();\n  }\n  Activator$1.current = this;\n  this.active = true;\n  this._dom.overlay.style.display = \"none\";\n  this._dom.container.classList.add(\"vis-active\");\n  this.emit(\"change\");\n  this.emit(\"activate\");\n\n  // ugly hack: bind ESC after emitting the events, as the Network rebinds all\n  // keyboard events on a 'change' event\n  document.body.addEventListener(\"keydown\", this._escListener);\n};\n\n/**\n * Deactivate the element\n * Overlay is displayed on top of the element\n */\nActivator$1.prototype.deactivate = function () {\n  this.active = false;\n  this._dom.overlay.style.display = \"block\";\n  this._dom.container.classList.remove(\"vis-active\");\n  document.body.removeEventListener(\"keydown\", this._escListener);\n  this.emit(\"change\");\n  this.emit(\"deactivate\");\n};\n\n/**\n * Handle a tap event: activate the container\n *\n * @param {Event}  event   The event\n * @private\n */\nActivator$1.prototype._onTapOverlay = function (event) {\n  // activate the container\n  this.activate();\n  event.srcEvent.stopPropagation();\n};\n\n/**\n * Test whether the element has the requested parent element somewhere in\n * its chain of parent nodes.\n *\n * @param {HTMLElement} element\n * @param {HTMLElement} parent\n * @returns {boolean} Returns true when the parent is found somewhere in the\n *                    chain of parent nodes.\n * @private\n */\nfunction _hasParent(element, parent) {\n  while (element) {\n    if (element === parent) {\n      return true;\n    }\n    element = element.parentNode;\n  }\n  return false;\n}\n// Color REs\nvar fullHexRE = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\nvar shortHexRE = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\nvar rgbRE = /^rgb\\( *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *\\)$/i;\nvar rgbaRE = /^rgba\\( *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *(1?\\d{1,2}|2[0-4]\\d|25[0-5]) *, *([01]|0?\\.\\d+) *\\)$/i;\n/**\r\n * Remove everything in the DOM object.\r\n *\r\n * @param DOMobject - Node whose child nodes will be recursively deleted.\r\n */\nfunction recursiveDOMDelete(DOMobject) {\n  if (DOMobject) {\n    while (DOMobject.hasChildNodes() === true) {\n      var child = DOMobject.firstChild;\n      if (child) {\n        recursiveDOMDelete(child);\n        DOMobject.removeChild(child);\n      }\n    }\n  }\n}\n/**\r\n * Test whether given object is a string.\r\n *\r\n * @param value - Input value of unknown type.\r\n * @returns True if string, false otherwise.\r\n */\nfunction isString(value) {\n  return value instanceof String || typeof value === \"string\";\n}\n/**\r\n * Test whether given object is a object (not primitive or null).\r\n *\r\n * @param value - Input value of unknown type.\r\n * @returns True if not null object, false otherwise.\r\n */\nfunction isObject$7(value) {\n  return _typeof(value) === \"object\" && value !== null;\n}\n/**\r\n * Copy property from b to a if property present in a.\r\n * If property in b explicitly set to null, delete it if `allowDeletion` set.\r\n *\r\n * Internal helper routine, should not be exported. Not added to `exports` for that reason.\r\n *\r\n * @param a - Target object.\r\n * @param b - Source object.\r\n * @param prop - Name of property to copy from b to a.\r\n * @param allowDeletion - If true, delete property in a if explicitly set to null in b.\r\n */\nfunction copyOrDelete(a, b, prop, allowDeletion) {\n  var doDeletion = false;\n  if (allowDeletion === true) {\n    doDeletion = b[prop] === null && a[prop] !== undefined;\n  }\n  if (doDeletion) {\n    delete a[prop];\n  } else {\n    a[prop] = b[prop]; // Remember, this is a reference copy!\n  }\n}\n/**\r\n * Fill an object with a possibly partially defined other object.\r\n *\r\n * Only copies values for the properties already present in a.\r\n * That means an object is not created on a property if only the b object has it.\r\n *\r\n * @param a - The object that will have it's properties updated.\r\n * @param b - The object with property updates.\r\n * @param allowDeletion - If true, delete properties in a that are explicitly set to null in b.\r\n */\nfunction fillIfDefined(a, b) {\n  var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // NOTE: iteration of properties of a\n  // NOTE: prototype properties iterated over as well\n  for (var prop in a) {\n    if (b[prop] !== undefined) {\n      if (b[prop] === null || _typeof(b[prop]) !== \"object\") {\n        // Note: typeof null === 'object'\n        copyOrDelete(a, b, prop, allowDeletion);\n      } else {\n        var aProp = a[prop];\n        var bProp = b[prop];\n        if (isObject$7(aProp) && isObject$7(bProp)) {\n          fillIfDefined(aProp, bProp, allowDeletion);\n        }\n      }\n    }\n  }\n}\n/**\r\n * Extend object a with selected properties of object b.\r\n * Only properties with defined values are copied.\r\n *\r\n * @remarks\r\n * Previous version of this routine implied that multiple source objects could\r\n * be used; however, the implementation was **wrong**. Since multiple (\\>1)\r\n * sources weren't used anywhere in the `vis.js` code, this has been removed\r\n * @param props - Names of first-level properties to copy over.\r\n * @param a - Target object.\r\n * @param b - Source object.\r\n * @param allowDeletion - If true, delete property in a if explicitly set to null in b.\r\n * @returns Argument a.\r\n */\nfunction selectiveDeepExtend(props, a, b) {\n  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // TODO: add support for Arrays to deepExtend\n  if (_Array$isArray(b)) {\n    throw new TypeError(\"Arrays are not supported by deepExtend\");\n  }\n  for (var p = 0; p < props.length; p++) {\n    var prop = props[p];\n    if (Object.prototype.hasOwnProperty.call(b, prop)) {\n      if (b[prop] && b[prop].constructor === Object) {\n        if (a[prop] === undefined) {\n          a[prop] = {};\n        }\n        if (a[prop].constructor === Object) {\n          deepExtend(a[prop], b[prop], false, allowDeletion);\n        } else {\n          copyOrDelete(a, b, prop, allowDeletion);\n        }\n      } else if (_Array$isArray(b[prop])) {\n        throw new TypeError(\"Arrays are not supported by deepExtend\");\n      } else {\n        copyOrDelete(a, b, prop, allowDeletion);\n      }\n    }\n  }\n  return a;\n}\n/**\r\n * Extend object `a` with properties of object `b`, ignoring properties which\r\n * are explicitly specified to be excluded.\r\n *\r\n * @remarks\r\n * The properties of `b` are considered for copying. Properties which are\r\n * themselves objects are are also extended. Only properties with defined\r\n * values are copied.\r\n * @param propsToExclude - Names of properties which should *not* be copied.\r\n * @param a - Object to extend.\r\n * @param b - Object to take properties from for extension.\r\n * @param allowDeletion - If true, delete properties in a that are explicitly\r\n * set to null in b.\r\n * @returns Argument a.\r\n */\nfunction selectiveNotDeepExtend(propsToExclude, a, b) {\n  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // TODO: add support for Arrays to deepExtend\n  // NOTE: array properties have an else-below; apparently, there is a problem here.\n  if (_Array$isArray(b)) {\n    throw new TypeError(\"Arrays are not supported by deepExtend\");\n  }\n  for (var prop in b) {\n    if (!Object.prototype.hasOwnProperty.call(b, prop)) {\n      continue;\n    } // Handle local properties only\n    if (_includesInstanceProperty(propsToExclude).call(propsToExclude, prop)) {\n      continue;\n    } // In exclusion list, skip\n    if (b[prop] && b[prop].constructor === Object) {\n      if (a[prop] === undefined) {\n        a[prop] = {};\n      }\n      if (a[prop].constructor === Object) {\n        deepExtend(a[prop], b[prop]); // NOTE: allowDeletion not propagated!\n      } else {\n        copyOrDelete(a, b, prop, allowDeletion);\n      }\n    } else if (_Array$isArray(b[prop])) {\n      a[prop] = [];\n      for (var i = 0; i < b[prop].length; i++) {\n        a[prop].push(b[prop][i]);\n      }\n    } else {\n      copyOrDelete(a, b, prop, allowDeletion);\n    }\n  }\n  return a;\n}\n/**\r\n * Deep extend an object a with the properties of object b.\r\n *\r\n * @param a - Target object.\r\n * @param b - Source object.\r\n * @param protoExtend - If true, the prototype values will also be extended.\r\n * (That is the options objects that inherit from others will also get the\r\n * inherited options).\r\n * @param allowDeletion - If true, the values of fields that are null will be deleted.\r\n * @returns Argument a.\r\n */\nfunction deepExtend(a, b) {\n  var protoExtend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var allowDeletion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  for (var prop in b) {\n    if (Object.prototype.hasOwnProperty.call(b, prop) || protoExtend === true) {\n      if (_typeof(b[prop]) === \"object\" && b[prop] !== null && _Object$getPrototypeOf$1(b[prop]) === Object.prototype) {\n        if (a[prop] === undefined) {\n          a[prop] = deepExtend({}, b[prop], protoExtend); // NOTE: allowDeletion not propagated!\n        } else if (_typeof(a[prop]) === \"object\" && a[prop] !== null && _Object$getPrototypeOf$1(a[prop]) === Object.prototype) {\n          deepExtend(a[prop], b[prop], protoExtend); // NOTE: allowDeletion not propagated!\n        } else {\n          copyOrDelete(a, b, prop, allowDeletion);\n        }\n      } else if (_Array$isArray(b[prop])) {\n        var _context6;\n        a[prop] = _sliceInstanceProperty(_context6 = b[prop]).call(_context6);\n      } else {\n        copyOrDelete(a, b, prop, allowDeletion);\n      }\n    }\n  }\n  return a;\n}\n/**\r\n * Used to extend an array and copy it. This is used to propagate paths recursively.\r\n *\r\n * @param arr - First part.\r\n * @param newValue - The value to be aadded into the array.\r\n * @returns A new array with all items from arr and newValue (which is last).\r\n */\nfunction copyAndExtendArray(arr, newValue) {\n  var _context7;\n  return _concatInstanceProperty(_context7 = []).call(_context7, _toConsumableArray(arr), [newValue]);\n}\n/**\r\n * Used to extend an array and copy it. This is used to propagate paths recursively.\r\n *\r\n * @param arr - The array to be copied.\r\n * @returns Shallow copy of arr.\r\n */\nfunction copyArray(arr) {\n  return _sliceInstanceProperty(arr).call(arr);\n}\n/**\r\n * Retrieve the absolute left value of a DOM element.\r\n *\r\n * @param elem - A dom element, for example a div.\r\n * @returns The absolute left position of this element in the browser page.\r\n */\nfunction getAbsoluteLeft(elem) {\n  return elem.getBoundingClientRect().left;\n}\n/**\r\n * Retrieve the absolute top value of a DOM element.\r\n *\r\n * @param elem - A dom element, for example a div.\r\n * @returns The absolute top position of this element in the browser page.\r\n */\nfunction getAbsoluteTop(elem) {\n  return elem.getBoundingClientRect().top;\n}\n/**\r\n * For each method for both arrays and objects.\r\n * In case of an array, the built-in Array.forEach() is applied (**No, it's not!**).\r\n * In case of an Object, the method loops over all properties of the object.\r\n *\r\n * @param object - An Object or Array to be iterated over.\r\n * @param callback - Array.forEach-like callback.\r\n */\nfunction forEach$1(object, callback) {\n  if (_Array$isArray(object)) {\n    // array\n    var len = object.length;\n    for (var i = 0; i < len; i++) {\n      callback(object[i], i, object);\n    }\n  } else {\n    // object\n    for (var key in object) {\n      if (Object.prototype.hasOwnProperty.call(object, key)) {\n        callback(object[key], key, object);\n      }\n    }\n  }\n}\n/**\r\n * Convert hex color string into RGB color object.\r\n *\r\n * @remarks\r\n * {@link http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb}\r\n * @param hex - Hex color string (3 or 6 digits, with or without #).\r\n * @returns RGB color object.\r\n */\nfunction hexToRGB(hex) {\n  var result;\n  switch (hex.length) {\n    case 3:\n    case 4:\n      result = shortHexRE.exec(hex);\n      return result ? {\n        r: _parseInt$1(result[1] + result[1], 16),\n        g: _parseInt$1(result[2] + result[2], 16),\n        b: _parseInt$1(result[3] + result[3], 16)\n      } : null;\n    case 6:\n    case 7:\n      result = fullHexRE.exec(hex);\n      return result ? {\n        r: _parseInt$1(result[1], 16),\n        g: _parseInt$1(result[2], 16),\n        b: _parseInt$1(result[3], 16)\n      } : null;\n    default:\n      return null;\n  }\n}\n/**\r\n * This function takes string color in hex or RGB format and adds the opacity, RGBA is passed through unchanged.\r\n *\r\n * @param color - The color string (hex, RGB, RGBA).\r\n * @param opacity - The new opacity.\r\n * @returns RGBA string, for example 'rgba(255, 0, 127, 0.3)'.\r\n */\nfunction overrideOpacity(color, opacity) {\n  if (_includesInstanceProperty(color).call(color, \"rgba\")) {\n    return color;\n  } else if (_includesInstanceProperty(color).call(color, \"rgb\")) {\n    var rgb = color.substr(_indexOfInstanceProperty(color).call(color, \"(\") + 1).replace(\")\", \"\").split(\",\");\n    return \"rgba(\" + rgb[0] + \",\" + rgb[1] + \",\" + rgb[2] + \",\" + opacity + \")\";\n  } else {\n    var _rgb = hexToRGB(color);\n    if (_rgb == null) {\n      return color;\n    } else {\n      return \"rgba(\" + _rgb.r + \",\" + _rgb.g + \",\" + _rgb.b + \",\" + opacity + \")\";\n    }\n  }\n}\n/**\r\n * Convert RGB \\<0, 255\\> into hex color string.\r\n *\r\n * @param red - Red channel.\r\n * @param green - Green channel.\r\n * @param blue - Blue channel.\r\n * @returns Hex color string (for example: '#0acdc0').\r\n */\nfunction RGBToHex(red, green, blue) {\n  var _context10;\n  return \"#\" + _sliceInstanceProperty(_context10 = ((1 << 24) + (red << 16) + (green << 8) + blue).toString(16)).call(_context10, 1);\n}\n/**\r\n * Parse a color property into an object with border, background, and highlight colors.\r\n *\r\n * @param inputColor - Shorthand color string or input color object.\r\n * @param defaultColor - Full color object to fill in missing values in inputColor.\r\n * @returns Color object.\r\n */\nfunction parseColor(inputColor, defaultColor) {\n  if (isString(inputColor)) {\n    var colorStr = inputColor;\n    if (isValidRGB(colorStr)) {\n      var _context11;\n      var rgb = _mapInstanceProperty(_context11 = colorStr.substr(4).substr(0, colorStr.length - 5).split(\",\")).call(_context11, function (value) {\n        return _parseInt$1(value);\n      });\n      colorStr = RGBToHex(rgb[0], rgb[1], rgb[2]);\n    }\n    if (isValidHex(colorStr) === true) {\n      var hsv = hexToHSV(colorStr);\n      var lighterColorHSV = {\n        h: hsv.h,\n        s: hsv.s * 0.8,\n        v: Math.min(1, hsv.v * 1.02)\n      };\n      var darkerColorHSV = {\n        h: hsv.h,\n        s: Math.min(1, hsv.s * 1.25),\n        v: hsv.v * 0.8\n      };\n      var darkerColorHex = HSVToHex(darkerColorHSV.h, darkerColorHSV.s, darkerColorHSV.v);\n      var lighterColorHex = HSVToHex(lighterColorHSV.h, lighterColorHSV.s, lighterColorHSV.v);\n      return {\n        background: colorStr,\n        border: darkerColorHex,\n        highlight: {\n          background: lighterColorHex,\n          border: darkerColorHex\n        },\n        hover: {\n          background: lighterColorHex,\n          border: darkerColorHex\n        }\n      };\n    } else {\n      return {\n        background: colorStr,\n        border: colorStr,\n        highlight: {\n          background: colorStr,\n          border: colorStr\n        },\n        hover: {\n          background: colorStr,\n          border: colorStr\n        }\n      };\n    }\n  } else {\n    if (defaultColor) {\n      var color = {\n        background: inputColor.background || defaultColor.background,\n        border: inputColor.border || defaultColor.border,\n        highlight: isString(inputColor.highlight) ? {\n          border: inputColor.highlight,\n          background: inputColor.highlight\n        } : {\n          background: inputColor.highlight && inputColor.highlight.background || defaultColor.highlight.background,\n          border: inputColor.highlight && inputColor.highlight.border || defaultColor.highlight.border\n        },\n        hover: isString(inputColor.hover) ? {\n          border: inputColor.hover,\n          background: inputColor.hover\n        } : {\n          border: inputColor.hover && inputColor.hover.border || defaultColor.hover.border,\n          background: inputColor.hover && inputColor.hover.background || defaultColor.hover.background\n        }\n      };\n      return color;\n    } else {\n      var _color = {\n        background: inputColor.background || undefined,\n        border: inputColor.border || undefined,\n        highlight: isString(inputColor.highlight) ? {\n          border: inputColor.highlight,\n          background: inputColor.highlight\n        } : {\n          background: inputColor.highlight && inputColor.highlight.background || undefined,\n          border: inputColor.highlight && inputColor.highlight.border || undefined\n        },\n        hover: isString(inputColor.hover) ? {\n          border: inputColor.hover,\n          background: inputColor.hover\n        } : {\n          border: inputColor.hover && inputColor.hover.border || undefined,\n          background: inputColor.hover && inputColor.hover.background || undefined\n        }\n      };\n      return _color;\n    }\n  }\n}\n/**\r\n * Convert RGB \\<0, 255\\> into HSV object.\r\n *\r\n * @remarks\r\n * {@link http://www.javascripter.net/faq/rgb2hsv.htm}\r\n * @param red - Red channel.\r\n * @param green - Green channel.\r\n * @param blue - Blue channel.\r\n * @returns HSV color object.\r\n */\nfunction RGBToHSV(red, green, blue) {\n  red = red / 255;\n  green = green / 255;\n  blue = blue / 255;\n  var minRGB = Math.min(red, Math.min(green, blue));\n  var maxRGB = Math.max(red, Math.max(green, blue));\n  // Black-gray-white\n  if (minRGB === maxRGB) {\n    return {\n      h: 0,\n      s: 0,\n      v: minRGB\n    };\n  }\n  // Colors other than black-gray-white:\n  var d = red === minRGB ? green - blue : blue === minRGB ? red - green : blue - red;\n  var h = red === minRGB ? 3 : blue === minRGB ? 1 : 5;\n  var hue = 60 * (h - d / (maxRGB - minRGB)) / 360;\n  var saturation = (maxRGB - minRGB) / maxRGB;\n  var value = maxRGB;\n  return {\n    h: hue,\n    s: saturation,\n    v: value\n  };\n}\n/**\r\n * Convert HSV \\<0, 1\\> into RGB color object.\r\n *\r\n * @remarks\r\n * {@link https://gist.github.com/mjijackson/5311256}\r\n * @param h - Hue.\r\n * @param s - Saturation.\r\n * @param v - Value.\r\n * @returns RGB color object.\r\n */\nfunction HSVToRGB(h, s, v) {\n  var r;\n  var g;\n  var b;\n  var i = Math.floor(h * 6);\n  var f = h * 6 - i;\n  var p = v * (1 - s);\n  var q = v * (1 - f * s);\n  var t = v * (1 - (1 - f) * s);\n  switch (i % 6) {\n    case 0:\n      r = v, g = t, b = p;\n      break;\n    case 1:\n      r = q, g = v, b = p;\n      break;\n    case 2:\n      r = p, g = v, b = t;\n      break;\n    case 3:\n      r = p, g = q, b = v;\n      break;\n    case 4:\n      r = t, g = p, b = v;\n      break;\n    case 5:\n      r = v, g = p, b = q;\n      break;\n  }\n  return {\n    r: Math.floor(r * 255),\n    g: Math.floor(g * 255),\n    b: Math.floor(b * 255)\n  };\n}\n/**\r\n * Convert HSV \\<0, 1\\> into hex color string.\r\n *\r\n * @param h - Hue.\r\n * @param s - Saturation.\r\n * @param v - Value.\r\n * @returns Hex color string.\r\n */\nfunction HSVToHex(h, s, v) {\n  var rgb = HSVToRGB(h, s, v);\n  return RGBToHex(rgb.r, rgb.g, rgb.b);\n}\n/**\r\n * Convert hex color string into HSV \\<0, 1\\>.\r\n *\r\n * @param hex - Hex color string.\r\n * @returns HSV color object.\r\n */\nfunction hexToHSV(hex) {\n  var rgb = hexToRGB(hex);\n  if (!rgb) {\n    throw new TypeError(\"'\".concat(hex, \"' is not a valid color.\"));\n  }\n  return RGBToHSV(rgb.r, rgb.g, rgb.b);\n}\n/**\r\n * Validate hex color string.\r\n *\r\n * @param hex - Unknown string that may contain a color.\r\n * @returns True if the string is valid, false otherwise.\r\n */\nfunction isValidHex(hex) {\n  var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(hex);\n  return isOk;\n}\n/**\r\n * Validate RGB color string.\r\n *\r\n * @param rgb - Unknown string that may contain a color.\r\n * @returns True if the string is valid, false otherwise.\r\n */\nfunction isValidRGB(rgb) {\n  return rgbRE.test(rgb);\n}\n/**\r\n * Validate RGBA color string.\r\n *\r\n * @param rgba - Unknown string that may contain a color.\r\n * @returns True if the string is valid, false otherwise.\r\n */\nfunction isValidRGBA(rgba) {\n  return rgbaRE.test(rgba);\n}\n/**\r\n * This recursively redirects the prototype of JSON objects to the referenceObject.\r\n * This is used for default options.\r\n *\r\n * @param referenceObject - The original object.\r\n * @returns The Element if the referenceObject is an Element, or a new object inheriting from the referenceObject.\r\n */\nfunction bridgeObject(referenceObject) {\n  if (referenceObject === null || _typeof(referenceObject) !== \"object\") {\n    return null;\n  }\n  if (referenceObject instanceof Element) {\n    // Avoid bridging DOM objects\n    return referenceObject;\n  }\n  var objectTo = _Object$create$1(referenceObject);\n  for (var i in referenceObject) {\n    if (Object.prototype.hasOwnProperty.call(referenceObject, i)) {\n      if (_typeof(referenceObject[i]) == \"object\") {\n        objectTo[i] = bridgeObject(referenceObject[i]);\n      }\n    }\n  }\n  return objectTo;\n}\n/**\r\n * This is used to set the options of subobjects in the options object.\r\n *\r\n * A requirement of these subobjects is that they have an 'enabled' element\r\n * which is optional for the user but mandatory for the program.\r\n *\r\n * The added value here of the merge is that option 'enabled' is set as required.\r\n *\r\n * @param mergeTarget - Either this.options or the options used for the groups.\r\n * @param options - Options.\r\n * @param option - Option key in the options argument.\r\n * @param globalOptions - Global options, passed in to determine value of option 'enabled'.\r\n */\nfunction mergeOptions(mergeTarget, options, option) {\n  var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  // Local helpers\n  var isPresent = function isPresent(obj) {\n    return obj !== null && obj !== undefined;\n  };\n  var isObject = function isObject(obj) {\n    return obj !== null && _typeof(obj) === \"object\";\n  };\n  // https://stackoverflow.com/a/34491287/1223531\n  var isEmpty = function isEmpty(obj) {\n    for (var x in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, x)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  // Guards\n  if (!isObject(mergeTarget)) {\n    throw new Error(\"Parameter mergeTarget must be an object\");\n  }\n  if (!isObject(options)) {\n    throw new Error(\"Parameter options must be an object\");\n  }\n  if (!isPresent(option)) {\n    throw new Error(\"Parameter option must have a value\");\n  }\n  if (!isObject(globalOptions)) {\n    throw new Error(\"Parameter globalOptions must be an object\");\n  }\n  //\n  // Actual merge routine, separated from main logic\n  // Only a single level of options is merged. Deeper levels are ref'd. This may actually be an issue.\n  //\n  var doMerge = function doMerge(target, options, option) {\n    if (!isObject(target[option])) {\n      target[option] = {};\n    }\n    var src = options[option];\n    var dst = target[option];\n    for (var prop in src) {\n      if (Object.prototype.hasOwnProperty.call(src, prop)) {\n        dst[prop] = src[prop];\n      }\n    }\n  };\n  // Local initialization\n  var srcOption = options[option];\n  var globalPassed = isObject(globalOptions) && !isEmpty(globalOptions);\n  var globalOption = globalPassed ? globalOptions[option] : undefined;\n  var globalEnabled = globalOption ? globalOption.enabled : undefined;\n  /////////////////////////////////////////\n  // Main routine\n  /////////////////////////////////////////\n  if (srcOption === undefined) {\n    return; // Nothing to do\n  }\n\n  if (typeof srcOption === \"boolean\") {\n    if (!isObject(mergeTarget[option])) {\n      mergeTarget[option] = {};\n    }\n    mergeTarget[option].enabled = srcOption;\n    return;\n  }\n  if (srcOption === null && !isObject(mergeTarget[option])) {\n    // If possible, explicit copy from globals\n    if (isPresent(globalOption)) {\n      mergeTarget[option] = _Object$create$1(globalOption);\n    } else {\n      return; // Nothing to do\n    }\n  }\n\n  if (!isObject(srcOption)) {\n    return;\n  }\n  //\n  // Ensure that 'enabled' is properly set. It is required internally\n  // Note that the value from options will always overwrite the existing value\n  //\n  var enabled = true; // default value\n  if (srcOption.enabled !== undefined) {\n    enabled = srcOption.enabled;\n  } else {\n    // Take from globals, if present\n    if (globalEnabled !== undefined) {\n      enabled = globalOption.enabled;\n    }\n  }\n  doMerge(mergeTarget, options, option);\n  mergeTarget[option].enabled = enabled;\n}\n/*\r\n * Easing Functions.\r\n * Only considering the t value for the range [0, 1] => [0, 1].\r\n *\r\n * Inspiration: from http://gizma.com/easing/\r\n * https://gist.github.com/gre/1650294\r\n */\nvar easingFunctions = {\n  /**\r\n   * Provides no easing and no acceleration.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  linear: function linear(t) {\n    return t;\n  },\n  /**\r\n   * Accelerate from zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeInQuad: function easeInQuad(t) {\n    return t * t;\n  },\n  /**\r\n   * Decelerate to zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeOutQuad: function easeOutQuad(t) {\n    return t * (2 - t);\n  },\n  /**\r\n   * Accelerate until halfway, then decelerate.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeInOutQuad: function easeInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  },\n  /**\r\n   * Accelerate from zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeInCubic: function easeInCubic(t) {\n    return t * t * t;\n  },\n  /**\r\n   * Decelerate to zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeOutCubic: function easeOutCubic(t) {\n    return --t * t * t + 1;\n  },\n  /**\r\n   * Accelerate until halfway, then decelerate.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeInOutCubic: function easeInOutCubic(t) {\n    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n  },\n  /**\r\n   * Accelerate from zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeInQuart: function easeInQuart(t) {\n    return t * t * t * t;\n  },\n  /**\r\n   * Decelerate to zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeOutQuart: function easeOutQuart(t) {\n    return 1 - --t * t * t * t;\n  },\n  /**\r\n   * Accelerate until halfway, then decelerate.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeInOutQuart: function easeInOutQuart(t) {\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n  },\n  /**\r\n   * Accelerate from zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeInQuint: function easeInQuint(t) {\n    return t * t * t * t * t;\n  },\n  /**\r\n   * Decelerate to zero velocity.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeOutQuint: function easeOutQuint(t) {\n    return 1 + --t * t * t * t * t;\n  },\n  /**\r\n   * Accelerate until halfway, then decelerate.\r\n   *\r\n   * @param t - Time.\r\n   * @returns Value at time t.\r\n   */\n  easeInOutQuint: function easeInOutQuint(t) {\n    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n  }\n};\n// @TODO: This doesn't work properly.\n// It works only for single property objects,\n// otherwise it combines all of the types in a union.\n// export function topMost<K1 extends string, V1> (\n//   pile: Record<K1, undefined | V1>[],\n//   accessors: K1 | [K1]\n// ): undefined | V1\n// export function topMost<K1 extends string, K2 extends string, V1, V2> (\n//   pile: Record<K1, undefined | V1 | Record<K2, undefined | V2>>[],\n//   accessors: [K1, K2]\n// ): undefined | V1 | V2\n// export function topMost<K1 extends string, K2 extends string, K3 extends string, V1, V2, V3> (\n//   pile: Record<K1, undefined | V1 | Record<K2, undefined | V2 | Record<K3, undefined | V3>>>[],\n//   accessors: [K1, K2, K3]\n// ): undefined | V1 | V2 | V3\n/**\r\n * Get the top most property value from a pile of objects.\r\n *\r\n * @param pile - Array of objects, no required format.\r\n * @param accessors - Array of property names.\r\n * For example `object['foo']['bar']` → `['foo', 'bar']`.\r\n * @returns Value of the property with given accessors path from the first pile item where it's not undefined.\r\n */\nfunction topMost(pile, accessors) {\n  var candidate;\n  if (!_Array$isArray(accessors)) {\n    accessors = [accessors];\n  }\n  var _iterator3 = _createForOfIteratorHelper$6(pile),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var member = _step3.value;\n      if (member) {\n        candidate = member[accessors[0]];\n        for (var i = 1; i < accessors.length; i++) {\n          if (candidate) {\n            candidate = candidate[accessors[i]];\n          }\n        }\n        if (typeof candidate !== \"undefined\") {\n          break;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n  return candidate;\n}\nvar htmlColors = {\n  black: \"#000000\",\n  navy: \"#000080\",\n  darkblue: \"#00008B\",\n  mediumblue: \"#0000CD\",\n  blue: \"#0000FF\",\n  darkgreen: \"#006400\",\n  green: \"#008000\",\n  teal: \"#008080\",\n  darkcyan: \"#008B8B\",\n  deepskyblue: \"#00BFFF\",\n  darkturquoise: \"#00CED1\",\n  mediumspringgreen: \"#00FA9A\",\n  lime: \"#00FF00\",\n  springgreen: \"#00FF7F\",\n  aqua: \"#00FFFF\",\n  cyan: \"#00FFFF\",\n  midnightblue: \"#191970\",\n  dodgerblue: \"#1E90FF\",\n  lightseagreen: \"#20B2AA\",\n  forestgreen: \"#228B22\",\n  seagreen: \"#2E8B57\",\n  darkslategray: \"#2F4F4F\",\n  limegreen: \"#32CD32\",\n  mediumseagreen: \"#3CB371\",\n  turquoise: \"#40E0D0\",\n  royalblue: \"#4169E1\",\n  steelblue: \"#4682B4\",\n  darkslateblue: \"#483D8B\",\n  mediumturquoise: \"#48D1CC\",\n  indigo: \"#4B0082\",\n  darkolivegreen: \"#556B2F\",\n  cadetblue: \"#5F9EA0\",\n  cornflowerblue: \"#6495ED\",\n  mediumaquamarine: \"#66CDAA\",\n  dimgray: \"#696969\",\n  slateblue: \"#6A5ACD\",\n  olivedrab: \"#6B8E23\",\n  slategray: \"#708090\",\n  lightslategray: \"#778899\",\n  mediumslateblue: \"#7B68EE\",\n  lawngreen: \"#7CFC00\",\n  chartreuse: \"#7FFF00\",\n  aquamarine: \"#7FFFD4\",\n  maroon: \"#800000\",\n  purple: \"#800080\",\n  olive: \"#808000\",\n  gray: \"#808080\",\n  skyblue: \"#87CEEB\",\n  lightskyblue: \"#87CEFA\",\n  blueviolet: \"#8A2BE2\",\n  darkred: \"#8B0000\",\n  darkmagenta: \"#8B008B\",\n  saddlebrown: \"#8B4513\",\n  darkseagreen: \"#8FBC8F\",\n  lightgreen: \"#90EE90\",\n  mediumpurple: \"#9370D8\",\n  darkviolet: \"#9400D3\",\n  palegreen: \"#98FB98\",\n  darkorchid: \"#9932CC\",\n  yellowgreen: \"#9ACD32\",\n  sienna: \"#A0522D\",\n  brown: \"#A52A2A\",\n  darkgray: \"#A9A9A9\",\n  lightblue: \"#ADD8E6\",\n  greenyellow: \"#ADFF2F\",\n  paleturquoise: \"#AFEEEE\",\n  lightsteelblue: \"#B0C4DE\",\n  powderblue: \"#B0E0E6\",\n  firebrick: \"#B22222\",\n  darkgoldenrod: \"#B8860B\",\n  mediumorchid: \"#BA55D3\",\n  rosybrown: \"#BC8F8F\",\n  darkkhaki: \"#BDB76B\",\n  silver: \"#C0C0C0\",\n  mediumvioletred: \"#C71585\",\n  indianred: \"#CD5C5C\",\n  peru: \"#CD853F\",\n  chocolate: \"#D2691E\",\n  tan: \"#D2B48C\",\n  lightgrey: \"#D3D3D3\",\n  palevioletred: \"#D87093\",\n  thistle: \"#D8BFD8\",\n  orchid: \"#DA70D6\",\n  goldenrod: \"#DAA520\",\n  crimson: \"#DC143C\",\n  gainsboro: \"#DCDCDC\",\n  plum: \"#DDA0DD\",\n  burlywood: \"#DEB887\",\n  lightcyan: \"#E0FFFF\",\n  lavender: \"#E6E6FA\",\n  darksalmon: \"#E9967A\",\n  violet: \"#EE82EE\",\n  palegoldenrod: \"#EEE8AA\",\n  lightcoral: \"#F08080\",\n  khaki: \"#F0E68C\",\n  aliceblue: \"#F0F8FF\",\n  honeydew: \"#F0FFF0\",\n  azure: \"#F0FFFF\",\n  sandybrown: \"#F4A460\",\n  wheat: \"#F5DEB3\",\n  beige: \"#F5F5DC\",\n  whitesmoke: \"#F5F5F5\",\n  mintcream: \"#F5FFFA\",\n  ghostwhite: \"#F8F8FF\",\n  salmon: \"#FA8072\",\n  antiquewhite: \"#FAEBD7\",\n  linen: \"#FAF0E6\",\n  lightgoldenrodyellow: \"#FAFAD2\",\n  oldlace: \"#FDF5E6\",\n  red: \"#FF0000\",\n  fuchsia: \"#FF00FF\",\n  magenta: \"#FF00FF\",\n  deeppink: \"#FF1493\",\n  orangered: \"#FF4500\",\n  tomato: \"#FF6347\",\n  hotpink: \"#FF69B4\",\n  coral: \"#FF7F50\",\n  darkorange: \"#FF8C00\",\n  lightsalmon: \"#FFA07A\",\n  orange: \"#FFA500\",\n  lightpink: \"#FFB6C1\",\n  pink: \"#FFC0CB\",\n  gold: \"#FFD700\",\n  peachpuff: \"#FFDAB9\",\n  navajowhite: \"#FFDEAD\",\n  moccasin: \"#FFE4B5\",\n  bisque: \"#FFE4C4\",\n  mistyrose: \"#FFE4E1\",\n  blanchedalmond: \"#FFEBCD\",\n  papayawhip: \"#FFEFD5\",\n  lavenderblush: \"#FFF0F5\",\n  seashell: \"#FFF5EE\",\n  cornsilk: \"#FFF8DC\",\n  lemonchiffon: \"#FFFACD\",\n  floralwhite: \"#FFFAF0\",\n  snow: \"#FFFAFA\",\n  yellow: \"#FFFF00\",\n  lightyellow: \"#FFFFE0\",\n  ivory: \"#FFFFF0\",\n  white: \"#FFFFFF\"\n};\n\n/**\n * @param {number} [pixelRatio=1]\n */\nvar ColorPicker$1 = /*#__PURE__*/function () {\n  /**\n   * @param {number} [pixelRatio=1]\n   */\n  function ColorPicker() {\n    var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    _classCallCheck(this, ColorPicker);\n    this.pixelRatio = pixelRatio;\n    this.generated = false;\n    this.centerCoordinates = {\n      x: 289 / 2,\n      y: 289 / 2\n    };\n    this.r = 289 * 0.49;\n    this.color = {\n      r: 255,\n      g: 255,\n      b: 255,\n      a: 1.0\n    };\n    this.hueCircle = undefined;\n    this.initialColor = {\n      r: 255,\n      g: 255,\n      b: 255,\n      a: 1.0\n    };\n    this.previousColor = undefined;\n    this.applied = false;\n\n    // bound by\n    this.updateCallback = function () {};\n    this.closeCallback = function () {};\n\n    // create all DOM elements\n    this._create();\n  }\n\n  /**\n   * this inserts the colorPicker into a div from the DOM\n   *\n   * @param {Element} container\n   */\n  _createClass(ColorPicker, [{\n    key: \"insertTo\",\n    value: function insertTo(container) {\n      if (this.hammer !== undefined) {\n        this.hammer.destroy();\n        this.hammer = undefined;\n      }\n      this.container = container;\n      this.container.appendChild(this.frame);\n      this._bindHammer();\n      this._setSize();\n    }\n\n    /**\n     * the callback is executed on apply and save. Bind it to the application\n     *\n     * @param {Function} callback\n     */\n  }, {\n    key: \"setUpdateCallback\",\n    value: function setUpdateCallback(callback) {\n      if (typeof callback === \"function\") {\n        this.updateCallback = callback;\n      } else {\n        throw new Error(\"Function attempted to set as colorPicker update callback is not a function.\");\n      }\n    }\n\n    /**\n     * the callback is executed on apply and save. Bind it to the application\n     *\n     * @param {Function} callback\n     */\n  }, {\n    key: \"setCloseCallback\",\n    value: function setCloseCallback(callback) {\n      if (typeof callback === \"function\") {\n        this.closeCallback = callback;\n      } else {\n        throw new Error(\"Function attempted to set as colorPicker closing callback is not a function.\");\n      }\n    }\n\n    /**\n     *\n     * @param {string} color\n     * @returns {string}\n     * @private\n     */\n  }, {\n    key: \"_isColorString\",\n    value: function _isColorString(color) {\n      if (typeof color === \"string\") {\n        return htmlColors[color];\n      }\n    }\n\n    /**\n     * Set the color of the colorPicker\n     * Supported formats:\n     * 'red'                   --> HTML color string\n     * '#ffffff'               --> hex string\n     * 'rgb(255,255,255)'      --> rgb string\n     * 'rgba(255,255,255,1.0)' --> rgba string\n     * {r:255,g:255,b:255}     --> rgb object\n     * {r:255,g:255,b:255,a:1.0} --> rgba object\n     *\n     * @param {string | object} color\n     * @param {boolean} [setInitial=true]\n     */\n  }, {\n    key: \"setColor\",\n    value: function setColor(color) {\n      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (color === \"none\") {\n        return;\n      }\n      var rgba;\n\n      // if a html color shorthand is used, convert to hex\n      var htmlColor = this._isColorString(color);\n      if (htmlColor !== undefined) {\n        color = htmlColor;\n      }\n\n      // check format\n      if (isString(color) === true) {\n        if (isValidRGB(color) === true) {\n          var rgbaArray = color.substr(4).substr(0, color.length - 5).split(\",\");\n          rgba = {\n            r: rgbaArray[0],\n            g: rgbaArray[1],\n            b: rgbaArray[2],\n            a: 1.0\n          };\n        } else if (isValidRGBA(color) === true) {\n          var _rgbaArray = color.substr(5).substr(0, color.length - 6).split(\",\");\n          rgba = {\n            r: _rgbaArray[0],\n            g: _rgbaArray[1],\n            b: _rgbaArray[2],\n            a: _rgbaArray[3]\n          };\n        } else if (isValidHex(color) === true) {\n          var rgbObj = hexToRGB(color);\n          rgba = {\n            r: rgbObj.r,\n            g: rgbObj.g,\n            b: rgbObj.b,\n            a: 1.0\n          };\n        }\n      } else {\n        if (color instanceof Object) {\n          if (color.r !== undefined && color.g !== undefined && color.b !== undefined) {\n            var alpha = color.a !== undefined ? color.a : \"1.0\";\n            rgba = {\n              r: color.r,\n              g: color.g,\n              b: color.b,\n              a: alpha\n            };\n          }\n        }\n      }\n\n      // set color\n      if (rgba === undefined) {\n        throw new Error(\"Unknown color passed to the colorPicker. Supported are strings: rgb, hex, rgba. Object: rgb ({r:r,g:g,b:b,[a:a]}). Supplied: \" + _JSON$stringify(color));\n      } else {\n        this._setColor(rgba, setInitial);\n      }\n    }\n\n    /**\n     * this shows the color picker.\n     * The hue circle is constructed once and stored.\n     */\n  }, {\n    key: \"show\",\n    value: function show() {\n      if (this.closeCallback !== undefined) {\n        this.closeCallback();\n        this.closeCallback = undefined;\n      }\n      this.applied = false;\n      this.frame.style.display = \"block\";\n      this._generateHueCircle();\n    }\n\n    // ------------------------------------------ PRIVATE ----------------------------- //\n\n    /**\n     * Hide the picker. Is called by the cancel button.\n     * Optional boolean to store the previous color for easy access later on.\n     *\n     * @param {boolean} [storePrevious=true]\n     * @private\n     */\n  }, {\n    key: \"_hide\",\n    value: function _hide() {\n      var _this2 = this;\n      var storePrevious = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      // store the previous color for next time;\n      if (storePrevious === true) {\n        this.previousColor = _Object$assign({}, this.color);\n      }\n      if (this.applied === true) {\n        this.updateCallback(this.initialColor);\n      }\n      this.frame.style.display = \"none\";\n\n      // call the closing callback, restoring the onclick method.\n      // this is in a setTimeout because it will trigger the show again before the click is done.\n      _setTimeout(function () {\n        if (_this2.closeCallback !== undefined) {\n          _this2.closeCallback();\n          _this2.closeCallback = undefined;\n        }\n      }, 0);\n    }\n\n    /**\n     * bound to the save button. Saves and hides.\n     *\n     * @private\n     */\n  }, {\n    key: \"_save\",\n    value: function _save() {\n      this.updateCallback(this.color);\n      this.applied = false;\n      this._hide();\n    }\n\n    /**\n     * Bound to apply button. Saves but does not close. Is undone by the cancel button.\n     *\n     * @private\n     */\n  }, {\n    key: \"_apply\",\n    value: function _apply() {\n      this.applied = true;\n      this.updateCallback(this.color);\n      this._updatePicker(this.color);\n    }\n\n    /**\n     * load the color from the previous session.\n     *\n     * @private\n     */\n  }, {\n    key: \"_loadLast\",\n    value: function _loadLast() {\n      if (this.previousColor !== undefined) {\n        this.setColor(this.previousColor, false);\n      } else {\n        alert(\"There is no last color to load...\");\n      }\n    }\n\n    /**\n     * set the color, place the picker\n     *\n     * @param {object} rgba\n     * @param {boolean} [setInitial=true]\n     * @private\n     */\n  }, {\n    key: \"_setColor\",\n    value: function _setColor(rgba) {\n      var setInitial = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      // store the initial color\n      if (setInitial === true) {\n        this.initialColor = _Object$assign({}, rgba);\n      }\n      this.color = rgba;\n      var hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);\n      var angleConvert = 2 * Math.PI;\n      var radius = this.r * hsv.s;\n      var x = this.centerCoordinates.x + radius * Math.sin(angleConvert * hsv.h);\n      var y = this.centerCoordinates.y + radius * Math.cos(angleConvert * hsv.h);\n      this.colorPickerSelector.style.left = x - 0.5 * this.colorPickerSelector.clientWidth + \"px\";\n      this.colorPickerSelector.style.top = y - 0.5 * this.colorPickerSelector.clientHeight + \"px\";\n      this._updatePicker(rgba);\n    }\n\n    /**\n     * bound to opacity control\n     *\n     * @param {number} value\n     * @private\n     */\n  }, {\n    key: \"_setOpacity\",\n    value: function _setOpacity(value) {\n      this.color.a = value / 100;\n      this._updatePicker(this.color);\n    }\n\n    /**\n     * bound to brightness control\n     *\n     * @param {number} value\n     * @private\n     */\n  }, {\n    key: \"_setBrightness\",\n    value: function _setBrightness(value) {\n      var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);\n      hsv.v = value / 100;\n      var rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);\n      rgba[\"a\"] = this.color.a;\n      this.color = rgba;\n      this._updatePicker();\n    }\n\n    /**\n     * update the color picker. A black circle overlays the hue circle to mimic the brightness decreasing.\n     *\n     * @param {object} rgba\n     * @private\n     */\n  }, {\n    key: \"_updatePicker\",\n    value: function _updatePicker() {\n      var rgba = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.color;\n      var hsv = RGBToHSV(rgba.r, rgba.g, rgba.b);\n      var ctx = this.colorPickerCanvas.getContext(\"2d\");\n      if (this.pixelRation === undefined) {\n        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);\n      }\n      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n\n      // clear the canvas\n      var w = this.colorPickerCanvas.clientWidth;\n      var h = this.colorPickerCanvas.clientHeight;\n      ctx.clearRect(0, 0, w, h);\n      ctx.putImageData(this.hueCircle, 0, 0);\n      ctx.fillStyle = \"rgba(0,0,0,\" + (1 - hsv.v) + \")\";\n      ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);\n      _fillInstanceProperty(ctx).call(ctx);\n      this.brightnessRange.value = 100 * hsv.v;\n      this.opacityRange.value = 100 * rgba.a;\n      this.initialColorDiv.style.backgroundColor = \"rgba(\" + this.initialColor.r + \",\" + this.initialColor.g + \",\" + this.initialColor.b + \",\" + this.initialColor.a + \")\";\n      this.newColorDiv.style.backgroundColor = \"rgba(\" + this.color.r + \",\" + this.color.g + \",\" + this.color.b + \",\" + this.color.a + \")\";\n    }\n\n    /**\n     * used by create to set the size of the canvas.\n     *\n     * @private\n     */\n  }, {\n    key: \"_setSize\",\n    value: function _setSize() {\n      this.colorPickerCanvas.style.width = \"100%\";\n      this.colorPickerCanvas.style.height = \"100%\";\n      this.colorPickerCanvas.width = 289 * this.pixelRatio;\n      this.colorPickerCanvas.height = 289 * this.pixelRatio;\n    }\n\n    /**\n     * create all dom elements\n     * TODO: cleanup, lots of similar dom elements\n     *\n     * @private\n     */\n  }, {\n    key: \"_create\",\n    value: function _create() {\n      var _context12, _context13, _context14, _context15;\n      this.frame = document.createElement(\"div\");\n      this.frame.className = \"vis-color-picker\";\n      this.colorPickerDiv = document.createElement(\"div\");\n      this.colorPickerSelector = document.createElement(\"div\");\n      this.colorPickerSelector.className = \"vis-selector\";\n      this.colorPickerDiv.appendChild(this.colorPickerSelector);\n      this.colorPickerCanvas = document.createElement(\"canvas\");\n      this.colorPickerDiv.appendChild(this.colorPickerCanvas);\n      if (!this.colorPickerCanvas.getContext) {\n        var noCanvas = document.createElement(\"DIV\");\n        noCanvas.style.color = \"red\";\n        noCanvas.style.fontWeight = \"bold\";\n        noCanvas.style.padding = \"10px\";\n        noCanvas.innerText = \"Error: your browser does not support HTML canvas\";\n        this.colorPickerCanvas.appendChild(noCanvas);\n      } else {\n        var ctx = this.colorPickerCanvas.getContext(\"2d\");\n        this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);\n        this.colorPickerCanvas.getContext(\"2d\").setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n      }\n      this.colorPickerDiv.className = \"vis-color\";\n      this.opacityDiv = document.createElement(\"div\");\n      this.opacityDiv.className = \"vis-opacity\";\n      this.brightnessDiv = document.createElement(\"div\");\n      this.brightnessDiv.className = \"vis-brightness\";\n      this.arrowDiv = document.createElement(\"div\");\n      this.arrowDiv.className = \"vis-arrow\";\n      this.opacityRange = document.createElement(\"input\");\n      try {\n        this.opacityRange.type = \"range\"; // Not supported on IE9\n        this.opacityRange.min = \"0\";\n        this.opacityRange.max = \"100\";\n      } catch (err) {\n        // TODO: Add some error handling.\n      }\n      this.opacityRange.value = \"100\";\n      this.opacityRange.className = \"vis-range\";\n      this.brightnessRange = document.createElement(\"input\");\n      try {\n        this.brightnessRange.type = \"range\"; // Not supported on IE9\n        this.brightnessRange.min = \"0\";\n        this.brightnessRange.max = \"100\";\n      } catch (err) {\n        // TODO: Add some error handling.\n      }\n      this.brightnessRange.value = \"100\";\n      this.brightnessRange.className = \"vis-range\";\n      this.opacityDiv.appendChild(this.opacityRange);\n      this.brightnessDiv.appendChild(this.brightnessRange);\n      var me = this;\n      this.opacityRange.onchange = function () {\n        me._setOpacity(this.value);\n      };\n      this.opacityRange.oninput = function () {\n        me._setOpacity(this.value);\n      };\n      this.brightnessRange.onchange = function () {\n        me._setBrightness(this.value);\n      };\n      this.brightnessRange.oninput = function () {\n        me._setBrightness(this.value);\n      };\n      this.brightnessLabel = document.createElement(\"div\");\n      this.brightnessLabel.className = \"vis-label vis-brightness\";\n      this.brightnessLabel.innerText = \"brightness:\";\n      this.opacityLabel = document.createElement(\"div\");\n      this.opacityLabel.className = \"vis-label vis-opacity\";\n      this.opacityLabel.innerText = \"opacity:\";\n      this.newColorDiv = document.createElement(\"div\");\n      this.newColorDiv.className = \"vis-new-color\";\n      this.newColorDiv.innerText = \"new\";\n      this.initialColorDiv = document.createElement(\"div\");\n      this.initialColorDiv.className = \"vis-initial-color\";\n      this.initialColorDiv.innerText = \"initial\";\n      this.cancelButton = document.createElement(\"div\");\n      this.cancelButton.className = \"vis-button vis-cancel\";\n      this.cancelButton.innerText = \"cancel\";\n      this.cancelButton.onclick = _bindInstanceProperty$1(_context12 = this._hide).call(_context12, this, false);\n      this.applyButton = document.createElement(\"div\");\n      this.applyButton.className = \"vis-button vis-apply\";\n      this.applyButton.innerText = \"apply\";\n      this.applyButton.onclick = _bindInstanceProperty$1(_context13 = this._apply).call(_context13, this);\n      this.saveButton = document.createElement(\"div\");\n      this.saveButton.className = \"vis-button vis-save\";\n      this.saveButton.innerText = \"save\";\n      this.saveButton.onclick = _bindInstanceProperty$1(_context14 = this._save).call(_context14, this);\n      this.loadButton = document.createElement(\"div\");\n      this.loadButton.className = \"vis-button vis-load\";\n      this.loadButton.innerText = \"load last\";\n      this.loadButton.onclick = _bindInstanceProperty$1(_context15 = this._loadLast).call(_context15, this);\n      this.frame.appendChild(this.colorPickerDiv);\n      this.frame.appendChild(this.arrowDiv);\n      this.frame.appendChild(this.brightnessLabel);\n      this.frame.appendChild(this.brightnessDiv);\n      this.frame.appendChild(this.opacityLabel);\n      this.frame.appendChild(this.opacityDiv);\n      this.frame.appendChild(this.newColorDiv);\n      this.frame.appendChild(this.initialColorDiv);\n      this.frame.appendChild(this.cancelButton);\n      this.frame.appendChild(this.applyButton);\n      this.frame.appendChild(this.saveButton);\n      this.frame.appendChild(this.loadButton);\n    }\n\n    /**\n     * bind hammer to the color picker\n     *\n     * @private\n     */\n  }, {\n    key: \"_bindHammer\",\n    value: function _bindHammer() {\n      var _this3 = this;\n      this.drag = {};\n      this.pinch = {};\n      this.hammer = new Hammer$1(this.colorPickerCanvas);\n      this.hammer.get(\"pinch\").set({\n        enable: true\n      });\n      this.hammer.on(\"hammer.input\", function (event) {\n        if (event.isFirst) {\n          _this3._moveSelector(event);\n        }\n      });\n      this.hammer.on(\"tap\", function (event) {\n        _this3._moveSelector(event);\n      });\n      this.hammer.on(\"panstart\", function (event) {\n        _this3._moveSelector(event);\n      });\n      this.hammer.on(\"panmove\", function (event) {\n        _this3._moveSelector(event);\n      });\n      this.hammer.on(\"panend\", function (event) {\n        _this3._moveSelector(event);\n      });\n    }\n\n    /**\n     * generate the hue circle. This is relatively heavy (200ms) and is done only once on the first time it is shown.\n     *\n     * @private\n     */\n  }, {\n    key: \"_generateHueCircle\",\n    value: function _generateHueCircle() {\n      if (this.generated === false) {\n        var ctx = this.colorPickerCanvas.getContext(\"2d\");\n        if (this.pixelRation === undefined) {\n          this.pixelRatio = (window.devicePixelRatio || 1) / (ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1);\n        }\n        ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n\n        // clear the canvas\n        var w = this.colorPickerCanvas.clientWidth;\n        var h = this.colorPickerCanvas.clientHeight;\n        ctx.clearRect(0, 0, w, h);\n\n        // draw hue circle\n        var x, y, hue, sat;\n        this.centerCoordinates = {\n          x: w * 0.5,\n          y: h * 0.5\n        };\n        this.r = 0.49 * w;\n        var angleConvert = 2 * Math.PI / 360;\n        var hfac = 1 / 360;\n        var sfac = 1 / this.r;\n        var rgb;\n        for (hue = 0; hue < 360; hue++) {\n          for (sat = 0; sat < this.r; sat++) {\n            x = this.centerCoordinates.x + sat * Math.sin(angleConvert * hue);\n            y = this.centerCoordinates.y + sat * Math.cos(angleConvert * hue);\n            rgb = HSVToRGB(hue * hfac, sat * sfac, 1);\n            ctx.fillStyle = \"rgb(\" + rgb.r + \",\" + rgb.g + \",\" + rgb.b + \")\";\n            ctx.fillRect(x - 0.5, y - 0.5, 2, 2);\n          }\n        }\n        ctx.strokeStyle = \"rgba(0,0,0,1)\";\n        ctx.circle(this.centerCoordinates.x, this.centerCoordinates.y, this.r);\n        ctx.stroke();\n        this.hueCircle = ctx.getImageData(0, 0, w, h);\n      }\n      this.generated = true;\n    }\n\n    /**\n     * move the selector. This is called by hammer functions.\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n  }, {\n    key: \"_moveSelector\",\n    value: function _moveSelector(event) {\n      var rect = this.colorPickerDiv.getBoundingClientRect();\n      var left = event.center.x - rect.left;\n      var top = event.center.y - rect.top;\n      var centerY = 0.5 * this.colorPickerDiv.clientHeight;\n      var centerX = 0.5 * this.colorPickerDiv.clientWidth;\n      var x = left - centerX;\n      var y = top - centerY;\n      var angle = Math.atan2(x, y);\n      var radius = 0.98 * Math.min(Math.sqrt(x * x + y * y), centerX);\n      var newTop = Math.cos(angle) * radius + centerY;\n      var newLeft = Math.sin(angle) * radius + centerX;\n      this.colorPickerSelector.style.top = newTop - 0.5 * this.colorPickerSelector.clientHeight + \"px\";\n      this.colorPickerSelector.style.left = newLeft - 0.5 * this.colorPickerSelector.clientWidth + \"px\";\n\n      // set color\n      var h = angle / (2 * Math.PI);\n      h = h < 0 ? h + 1 : h;\n      var s = radius / this.r;\n      var hsv = RGBToHSV(this.color.r, this.color.g, this.color.b);\n      hsv.h = h;\n      hsv.s = s;\n      var rgba = HSVToRGB(hsv.h, hsv.s, hsv.v);\n      rgba[\"a\"] = this.color.a;\n      this.color = rgba;\n\n      // update previews\n      this.initialColorDiv.style.backgroundColor = \"rgba(\" + this.initialColor.r + \",\" + this.initialColor.g + \",\" + this.initialColor.b + \",\" + this.initialColor.a + \")\";\n      this.newColorDiv.style.backgroundColor = \"rgba(\" + this.color.r + \",\" + this.color.g + \",\" + this.color.b + \",\" + this.color.a + \")\";\n    }\n  }]);\n  return ColorPicker;\n}();\n\n/**\n * Wrap given text (last argument) in HTML elements (all preceding arguments).\n *\n * @param {...any} rest - List of tag names followed by inner text.\n * @returns An element or a text node.\n */\nfunction wrapInTag() {\n  for (var _len5 = arguments.length, rest = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    rest[_key5] = arguments[_key5];\n  }\n  if (rest.length < 1) {\n    throw new TypeError(\"Invalid arguments.\");\n  } else if (rest.length === 1) {\n    return document.createTextNode(rest[0]);\n  } else {\n    var element = document.createElement(rest[0]);\n    element.appendChild(wrapInTag.apply(void 0, _toConsumableArray(_sliceInstanceProperty(rest).call(rest, 1))));\n    return element;\n  }\n}\n\n/**\n * The way this works is for all properties of this.possible options, you can supply the property name in any form to list the options.\n * Boolean options are recognised as Boolean\n * Number options should be written as array: [default value, min value, max value, stepsize]\n * Colors should be written as array: ['color', '#ffffff']\n * Strings with should be written as array: [option1, option2, option3, ..]\n *\n * The options are matched with their counterparts in each of the modules and the values used in the configuration are\n */\nvar Configurator$1 = /*#__PURE__*/function () {\n  /**\n   * @param {object} parentModule        | the location where parentModule.setOptions() can be called\n   * @param {object} defaultContainer    | the default container of the module\n   * @param {object} configureOptions    | the fully configured and predefined options set found in allOptions.js\n   * @param {number} pixelRatio          | canvas pixel ratio\n   * @param {Function} hideOption        | custom logic to dynamically hide options\n   */\n  function Configurator(parentModule, defaultContainer, configureOptions) {\n    var pixelRatio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    var hideOption = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : function () {\n      return false;\n    };\n    _classCallCheck(this, Configurator);\n    this.parent = parentModule;\n    this.changedOptions = [];\n    this.container = defaultContainer;\n    this.allowCreation = false;\n    this.hideOption = hideOption;\n    this.options = {};\n    this.initialized = false;\n    this.popupCounter = 0;\n    this.defaultOptions = {\n      enabled: false,\n      filter: true,\n      container: undefined,\n      showButton: true\n    };\n    _Object$assign(this.options, this.defaultOptions);\n    this.configureOptions = configureOptions;\n    this.moduleOptions = {};\n    this.domElements = [];\n    this.popupDiv = {};\n    this.popupLimit = 5;\n    this.popupHistory = {};\n    this.colorPicker = new ColorPicker$1(pixelRatio);\n    this.wrapper = undefined;\n  }\n\n  /**\n   * refresh all options.\n   * Because all modules parse their options by themselves, we just use their options. We copy them here.\n   *\n   * @param {object} options\n   */\n  _createClass(Configurator, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        // reset the popup history because the indices may have been changed.\n        this.popupHistory = {};\n        this._removePopup();\n        var enabled = true;\n        if (typeof options === \"string\") {\n          this.options.filter = options;\n        } else if (_Array$isArray(options)) {\n          this.options.filter = options.join();\n        } else if (_typeof(options) === \"object\") {\n          if (options == null) {\n            throw new TypeError(\"options cannot be null\");\n          }\n          if (options.container !== undefined) {\n            this.options.container = options.container;\n          }\n          if (_filterInstanceProperty(options) !== undefined) {\n            this.options.filter = _filterInstanceProperty(options);\n          }\n          if (options.showButton !== undefined) {\n            this.options.showButton = options.showButton;\n          }\n          if (options.enabled !== undefined) {\n            enabled = options.enabled;\n          }\n        } else if (typeof options === \"boolean\") {\n          this.options.filter = true;\n          enabled = options;\n        } else if (typeof options === \"function\") {\n          this.options.filter = options;\n          enabled = true;\n        }\n        if (_filterInstanceProperty(this.options) === false) {\n          enabled = false;\n        }\n        this.options.enabled = enabled;\n      }\n      this._clean();\n    }\n\n    /**\n     *\n     * @param {object} moduleOptions\n     */\n  }, {\n    key: \"setModuleOptions\",\n    value: function setModuleOptions(moduleOptions) {\n      this.moduleOptions = moduleOptions;\n      if (this.options.enabled === true) {\n        this._clean();\n        if (this.options.container !== undefined) {\n          this.container = this.options.container;\n        }\n        this._create();\n      }\n    }\n\n    /**\n     * Create all DOM elements\n     *\n     * @private\n     */\n  }, {\n    key: \"_create\",\n    value: function _create() {\n      this._clean();\n      this.changedOptions = [];\n      var filter = _filterInstanceProperty(this.options);\n      var counter = 0;\n      var show = false;\n      for (var _option in this.configureOptions) {\n        if (Object.prototype.hasOwnProperty.call(this.configureOptions, _option)) {\n          this.allowCreation = false;\n          show = false;\n          if (typeof filter === \"function\") {\n            show = filter(_option, []);\n            show = show || this._handleObject(this.configureOptions[_option], [_option], true);\n          } else if (filter === true || _indexOfInstanceProperty(filter).call(filter, _option) !== -1) {\n            show = true;\n          }\n          if (show !== false) {\n            this.allowCreation = true;\n\n            // linebreak between categories\n            if (counter > 0) {\n              this._makeItem([]);\n            }\n            // a header for the category\n            this._makeHeader(_option);\n\n            // get the sub options\n            this._handleObject(this.configureOptions[_option], [_option]);\n          }\n          counter++;\n        }\n      }\n      this._makeButton();\n      this._push();\n      //~ this.colorPicker.insertTo(this.container);\n    }\n\n    /**\n     * draw all DOM elements on the screen\n     *\n     * @private\n     */\n  }, {\n    key: \"_push\",\n    value: function _push() {\n      this.wrapper = document.createElement(\"div\");\n      this.wrapper.className = \"vis-configuration-wrapper\";\n      this.container.appendChild(this.wrapper);\n      for (var i = 0; i < this.domElements.length; i++) {\n        this.wrapper.appendChild(this.domElements[i]);\n      }\n      this._showPopupIfNeeded();\n    }\n\n    /**\n     * delete all DOM elements\n     *\n     * @private\n     */\n  }, {\n    key: \"_clean\",\n    value: function _clean() {\n      for (var i = 0; i < this.domElements.length; i++) {\n        this.wrapper.removeChild(this.domElements[i]);\n      }\n      if (this.wrapper !== undefined) {\n        this.container.removeChild(this.wrapper);\n        this.wrapper = undefined;\n      }\n      this.domElements = [];\n      this._removePopup();\n    }\n\n    /**\n     * get the value from the actualOptions if it exists\n     *\n     * @param {Array} path    | where to look for the actual option\n     * @returns {*}\n     * @private\n     */\n  }, {\n    key: \"_getValue\",\n    value: function _getValue(path) {\n      var base = this.moduleOptions;\n      for (var i = 0; i < path.length; i++) {\n        if (base[path[i]] !== undefined) {\n          base = base[path[i]];\n        } else {\n          base = undefined;\n          break;\n        }\n      }\n      return base;\n    }\n\n    /**\n     * all option elements are wrapped in an item\n     *\n     * @param {Array} path    | where to look for the actual option\n     * @param {Array.<Element>} domElements\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_makeItem\",\n    value: function _makeItem(path) {\n      if (this.allowCreation === true) {\n        var item = document.createElement(\"div\");\n        item.className = \"vis-configuration vis-config-item vis-config-s\" + path.length;\n        for (var _len6 = arguments.length, domElements = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n          domElements[_key6 - 1] = arguments[_key6];\n        }\n        _forEachInstanceProperty(domElements).call(domElements, function (element) {\n          item.appendChild(element);\n        });\n        this.domElements.push(item);\n        return this.domElements.length;\n      }\n      return 0;\n    }\n\n    /**\n     * header for major subjects\n     *\n     * @param {string} name\n     * @private\n     */\n  }, {\n    key: \"_makeHeader\",\n    value: function _makeHeader(name) {\n      var div = document.createElement(\"div\");\n      div.className = \"vis-configuration vis-config-header\";\n      div.innerText = name;\n      this._makeItem([], div);\n    }\n\n    /**\n     * make a label, if it is an object label, it gets different styling.\n     *\n     * @param {string} name\n     * @param {Array} path    | where to look for the actual option\n     * @param {string} objectLabel\n     * @returns {HTMLElement}\n     * @private\n     */\n  }, {\n    key: \"_makeLabel\",\n    value: function _makeLabel(name, path) {\n      var objectLabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var div = document.createElement(\"div\");\n      div.className = \"vis-configuration vis-config-label vis-config-s\" + path.length;\n      if (objectLabel === true) {\n        while (div.firstChild) {\n          div.removeChild(div.firstChild);\n        }\n        div.appendChild(wrapInTag(\"i\", \"b\", name));\n      } else {\n        div.innerText = name + \":\";\n      }\n      return div;\n    }\n\n    /**\n     * make a dropdown list for multiple possible string optoins\n     *\n     * @param {Array.<number>} arr\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n  }, {\n    key: \"_makeDropdown\",\n    value: function _makeDropdown(arr, value, path) {\n      var select = document.createElement(\"select\");\n      select.className = \"vis-configuration vis-config-select\";\n      var selectedValue = 0;\n      if (value !== undefined) {\n        if (_indexOfInstanceProperty(arr).call(arr, value) !== -1) {\n          selectedValue = _indexOfInstanceProperty(arr).call(arr, value);\n        }\n      }\n      for (var i = 0; i < arr.length; i++) {\n        var _option2 = document.createElement(\"option\");\n        _option2.value = arr[i];\n        if (i === selectedValue) {\n          _option2.selected = \"selected\";\n        }\n        _option2.innerText = arr[i];\n        select.appendChild(_option2);\n      }\n      var me = this;\n      select.onchange = function () {\n        me._update(this.value, path);\n      };\n      var label = this._makeLabel(path[path.length - 1], path);\n      this._makeItem(path, label, select);\n    }\n\n    /**\n     * make a range object for numeric options\n     *\n     * @param {Array.<number>} arr\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n  }, {\n    key: \"_makeRange\",\n    value: function _makeRange(arr, value, path) {\n      var defaultValue = arr[0];\n      var min = arr[1];\n      var max = arr[2];\n      var step = arr[3];\n      var range = document.createElement(\"input\");\n      range.className = \"vis-configuration vis-config-range\";\n      try {\n        range.type = \"range\"; // not supported on IE9\n        range.min = min;\n        range.max = max;\n      } catch (err) {\n        // TODO: Add some error handling.\n      }\n      range.step = step;\n\n      // set up the popup settings in case they are needed.\n      var popupString = \"\";\n      var popupValue = 0;\n      if (value !== undefined) {\n        var factor = 1.2;\n        if (value < 0 && value * factor < min) {\n          range.min = Math.ceil(value * factor);\n          popupValue = range.min;\n          popupString = \"range increased\";\n        } else if (value / factor < min) {\n          range.min = Math.ceil(value / factor);\n          popupValue = range.min;\n          popupString = \"range increased\";\n        }\n        if (value * factor > max && max !== 1) {\n          range.max = Math.ceil(value * factor);\n          popupValue = range.max;\n          popupString = \"range increased\";\n        }\n        range.value = value;\n      } else {\n        range.value = defaultValue;\n      }\n      var input = document.createElement(\"input\");\n      input.className = \"vis-configuration vis-config-rangeinput\";\n      input.value = range.value;\n      var me = this;\n      range.onchange = function () {\n        input.value = this.value;\n        me._update(Number(this.value), path);\n      };\n      range.oninput = function () {\n        input.value = this.value;\n      };\n      var label = this._makeLabel(path[path.length - 1], path);\n      var itemIndex = this._makeItem(path, label, range, input);\n\n      // if a popup is needed AND it has not been shown for this value, show it.\n      if (popupString !== \"\" && this.popupHistory[itemIndex] !== popupValue) {\n        this.popupHistory[itemIndex] = popupValue;\n        this._setupPopup(popupString, itemIndex);\n      }\n    }\n\n    /**\n     * make a button object\n     *\n     * @private\n     */\n  }, {\n    key: \"_makeButton\",\n    value: function _makeButton() {\n      var _this4 = this;\n      if (this.options.showButton === true) {\n        var generateButton = document.createElement(\"div\");\n        generateButton.className = \"vis-configuration vis-config-button\";\n        generateButton.innerText = \"generate options\";\n        generateButton.onclick = function () {\n          _this4._printOptions();\n        };\n        generateButton.onmouseover = function () {\n          generateButton.className = \"vis-configuration vis-config-button hover\";\n        };\n        generateButton.onmouseout = function () {\n          generateButton.className = \"vis-configuration vis-config-button\";\n        };\n        this.optionsContainer = document.createElement(\"div\");\n        this.optionsContainer.className = \"vis-configuration vis-config-option-container\";\n        this.domElements.push(this.optionsContainer);\n        this.domElements.push(generateButton);\n      }\n    }\n\n    /**\n     * prepare the popup\n     *\n     * @param {string} string\n     * @param {number} index\n     * @private\n     */\n  }, {\n    key: \"_setupPopup\",\n    value: function _setupPopup(string, index) {\n      var _this5 = this;\n      if (this.initialized === true && this.allowCreation === true && this.popupCounter < this.popupLimit) {\n        var div = document.createElement(\"div\");\n        div.id = \"vis-configuration-popup\";\n        div.className = \"vis-configuration-popup\";\n        div.innerText = string;\n        div.onclick = function () {\n          _this5._removePopup();\n        };\n        this.popupCounter += 1;\n        this.popupDiv = {\n          html: div,\n          index: index\n        };\n      }\n    }\n\n    /**\n     * remove the popup from the dom\n     *\n     * @private\n     */\n  }, {\n    key: \"_removePopup\",\n    value: function _removePopup() {\n      if (this.popupDiv.html !== undefined) {\n        this.popupDiv.html.parentNode.removeChild(this.popupDiv.html);\n        clearTimeout(this.popupDiv.hideTimeout);\n        clearTimeout(this.popupDiv.deleteTimeout);\n        this.popupDiv = {};\n      }\n    }\n\n    /**\n     * Show the popup if it is needed.\n     *\n     * @private\n     */\n  }, {\n    key: \"_showPopupIfNeeded\",\n    value: function _showPopupIfNeeded() {\n      var _this6 = this;\n      if (this.popupDiv.html !== undefined) {\n        var correspondingElement = this.domElements[this.popupDiv.index];\n        var rect = correspondingElement.getBoundingClientRect();\n        this.popupDiv.html.style.left = rect.left + \"px\";\n        this.popupDiv.html.style.top = rect.top - 30 + \"px\"; // 30 is the height;\n        document.body.appendChild(this.popupDiv.html);\n        this.popupDiv.hideTimeout = _setTimeout(function () {\n          _this6.popupDiv.html.style.opacity = 0;\n        }, 1500);\n        this.popupDiv.deleteTimeout = _setTimeout(function () {\n          _this6._removePopup();\n        }, 1800);\n      }\n    }\n\n    /**\n     * make a checkbox for boolean options.\n     *\n     * @param {number} defaultValue\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n  }, {\n    key: \"_makeCheckbox\",\n    value: function _makeCheckbox(defaultValue, value, path) {\n      var checkbox = document.createElement(\"input\");\n      checkbox.type = \"checkbox\";\n      checkbox.className = \"vis-configuration vis-config-checkbox\";\n      checkbox.checked = defaultValue;\n      if (value !== undefined) {\n        checkbox.checked = value;\n        if (value !== defaultValue) {\n          if (_typeof(defaultValue) === \"object\") {\n            if (value !== defaultValue.enabled) {\n              this.changedOptions.push({\n                path: path,\n                value: value\n              });\n            }\n          } else {\n            this.changedOptions.push({\n              path: path,\n              value: value\n            });\n          }\n        }\n      }\n      var me = this;\n      checkbox.onchange = function () {\n        me._update(this.checked, path);\n      };\n      var label = this._makeLabel(path[path.length - 1], path);\n      this._makeItem(path, label, checkbox);\n    }\n\n    /**\n     * make a text input field for string options.\n     *\n     * @param {number} defaultValue\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n  }, {\n    key: \"_makeTextInput\",\n    value: function _makeTextInput(defaultValue, value, path) {\n      var checkbox = document.createElement(\"input\");\n      checkbox.type = \"text\";\n      checkbox.className = \"vis-configuration vis-config-text\";\n      checkbox.value = value;\n      if (value !== defaultValue) {\n        this.changedOptions.push({\n          path: path,\n          value: value\n        });\n      }\n      var me = this;\n      checkbox.onchange = function () {\n        me._update(this.value, path);\n      };\n      var label = this._makeLabel(path[path.length - 1], path);\n      this._makeItem(path, label, checkbox);\n    }\n\n    /**\n     * make a color field with a color picker for color fields\n     *\n     * @param {Array.<number>} arr\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n  }, {\n    key: \"_makeColorField\",\n    value: function _makeColorField(arr, value, path) {\n      var _this7 = this;\n      var defaultColor = arr[1];\n      var div = document.createElement(\"div\");\n      value = value === undefined ? defaultColor : value;\n      if (value !== \"none\") {\n        div.className = \"vis-configuration vis-config-colorBlock\";\n        div.style.backgroundColor = value;\n      } else {\n        div.className = \"vis-configuration vis-config-colorBlock none\";\n      }\n      value = value === undefined ? defaultColor : value;\n      div.onclick = function () {\n        _this7._showColorPicker(value, div, path);\n      };\n      var label = this._makeLabel(path[path.length - 1], path);\n      this._makeItem(path, label, div);\n    }\n\n    /**\n     * used by the color buttons to call the color picker.\n     *\n     * @param {number} value\n     * @param {HTMLElement} div\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n  }, {\n    key: \"_showColorPicker\",\n    value: function _showColorPicker(value, div, path) {\n      var _this8 = this;\n      // clear the callback from this div\n      div.onclick = function () {};\n      this.colorPicker.insertTo(div);\n      this.colorPicker.show();\n      this.colorPicker.setColor(value);\n      this.colorPicker.setUpdateCallback(function (color) {\n        var colorString = \"rgba(\" + color.r + \",\" + color.g + \",\" + color.b + \",\" + color.a + \")\";\n        div.style.backgroundColor = colorString;\n        _this8._update(colorString, path);\n      });\n\n      // on close of the colorpicker, restore the callback.\n      this.colorPicker.setCloseCallback(function () {\n        div.onclick = function () {\n          _this8._showColorPicker(value, div, path);\n        };\n      });\n    }\n\n    /**\n     * parse an object and draw the correct items\n     *\n     * @param {object} obj\n     * @param {Array} [path=[]]    | where to look for the actual option\n     * @param {boolean} [checkOnly=false]\n     * @returns {boolean}\n     * @private\n     */\n  }, {\n    key: \"_handleObject\",\n    value: function _handleObject(obj) {\n      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var checkOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var show = false;\n      var filter = _filterInstanceProperty(this.options);\n      var visibleInSet = false;\n      for (var subObj in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, subObj)) {\n          show = true;\n          var item = obj[subObj];\n          var newPath = copyAndExtendArray(path, subObj);\n          if (typeof filter === \"function\") {\n            show = filter(subObj, path);\n\n            // if needed we must go deeper into the object.\n            if (show === false) {\n              if (!_Array$isArray(item) && typeof item !== \"string\" && typeof item !== \"boolean\" && item instanceof Object) {\n                this.allowCreation = false;\n                show = this._handleObject(item, newPath, true);\n                this.allowCreation = checkOnly === false;\n              }\n            }\n          }\n          if (show !== false) {\n            visibleInSet = true;\n            var value = this._getValue(newPath);\n            if (_Array$isArray(item)) {\n              this._handleArray(item, value, newPath);\n            } else if (typeof item === \"string\") {\n              this._makeTextInput(item, value, newPath);\n            } else if (typeof item === \"boolean\") {\n              this._makeCheckbox(item, value, newPath);\n            } else if (item instanceof Object) {\n              // skip the options that are not enabled\n              if (!this.hideOption(path, subObj, this.moduleOptions)) {\n                // initially collapse options with an disabled enabled option.\n                if (item.enabled !== undefined) {\n                  var enabledPath = copyAndExtendArray(newPath, \"enabled\");\n                  var enabledValue = this._getValue(enabledPath);\n                  if (enabledValue === true) {\n                    var label = this._makeLabel(subObj, newPath, true);\n                    this._makeItem(newPath, label);\n                    visibleInSet = this._handleObject(item, newPath) || visibleInSet;\n                  } else {\n                    this._makeCheckbox(item, enabledValue, newPath);\n                  }\n                } else {\n                  var _label = this._makeLabel(subObj, newPath, true);\n                  this._makeItem(newPath, _label);\n                  visibleInSet = this._handleObject(item, newPath) || visibleInSet;\n                }\n              }\n            } else {\n              console.error(\"dont know how to handle\", item, subObj, newPath);\n            }\n          }\n        }\n      }\n      return visibleInSet;\n    }\n\n    /**\n     * handle the array type of option\n     *\n     * @param {Array.<number>} arr\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n  }, {\n    key: \"_handleArray\",\n    value: function _handleArray(arr, value, path) {\n      if (typeof arr[0] === \"string\" && arr[0] === \"color\") {\n        this._makeColorField(arr, value, path);\n        if (arr[1] !== value) {\n          this.changedOptions.push({\n            path: path,\n            value: value\n          });\n        }\n      } else if (typeof arr[0] === \"string\") {\n        this._makeDropdown(arr, value, path);\n        if (arr[0] !== value) {\n          this.changedOptions.push({\n            path: path,\n            value: value\n          });\n        }\n      } else if (typeof arr[0] === \"number\") {\n        this._makeRange(arr, value, path);\n        if (arr[0] !== value) {\n          this.changedOptions.push({\n            path: path,\n            value: Number(value)\n          });\n        }\n      }\n    }\n\n    /**\n     * called to update the network with the new settings.\n     *\n     * @param {number} value\n     * @param {Array} path    | where to look for the actual option\n     * @private\n     */\n  }, {\n    key: \"_update\",\n    value: function _update(value, path) {\n      var options = this._constructOptions(value, path);\n      if (this.parent.body && this.parent.body.emitter && this.parent.body.emitter.emit) {\n        this.parent.body.emitter.emit(\"configChange\", options);\n      }\n      this.initialized = true;\n      this.parent.setOptions(options);\n    }\n\n    /**\n     *\n     * @param {string | boolean} value\n     * @param {Array.<string>} path\n     * @param {{}} optionsObj\n     * @returns {{}}\n     * @private\n     */\n  }, {\n    key: \"_constructOptions\",\n    value: function _constructOptions(value, path) {\n      var optionsObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var pointer = optionsObj;\n\n      // when dropdown boxes can be string or boolean, we typecast it into correct types\n      value = value === \"true\" ? true : value;\n      value = value === \"false\" ? false : value;\n      for (var i = 0; i < path.length; i++) {\n        if (path[i] !== \"global\") {\n          if (pointer[path[i]] === undefined) {\n            pointer[path[i]] = {};\n          }\n          if (i !== path.length - 1) {\n            pointer = pointer[path[i]];\n          } else {\n            pointer[path[i]] = value;\n          }\n        }\n      }\n      return optionsObj;\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: \"_printOptions\",\n    value: function _printOptions() {\n      var options = this.getOptions();\n      while (this.optionsContainer.firstChild) {\n        this.optionsContainer.removeChild(this.optionsContainer.firstChild);\n      }\n      this.optionsContainer.appendChild(wrapInTag(\"pre\", \"const options = \" + _JSON$stringify(options, null, 2)));\n    }\n\n    /**\n     *\n     * @returns {{}} options\n     */\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      var options = {};\n      for (var i = 0; i < this.changedOptions.length; i++) {\n        this._constructOptions(this.changedOptions[i].value, this.changedOptions[i].path, options);\n      }\n      return options;\n    }\n  }]);\n  return Configurator;\n}();\n\n/**\n * Popup is a class to create a popup window with some text\n */\nvar Popup$1 = /*#__PURE__*/function () {\n  /**\n   * @param {Element} container       The container object.\n   * @param {string}  overflowMethod  How the popup should act to overflowing ('flip' or 'cap')\n   */\n  function Popup(container, overflowMethod) {\n    _classCallCheck(this, Popup);\n    this.container = container;\n    this.overflowMethod = overflowMethod || \"cap\";\n    this.x = 0;\n    this.y = 0;\n    this.padding = 5;\n    this.hidden = false;\n\n    // create the frame\n    this.frame = document.createElement(\"div\");\n    this.frame.className = \"vis-tooltip\";\n    this.container.appendChild(this.frame);\n  }\n\n  /**\n   * @param {number} x   Horizontal position of the popup window\n   * @param {number} y   Vertical position of the popup window\n   */\n  _createClass(Popup, [{\n    key: \"setPosition\",\n    value: function setPosition(x, y) {\n      this.x = _parseInt$1(x);\n      this.y = _parseInt$1(y);\n    }\n\n    /**\n     * Set the content for the popup window. This can be HTML code or text.\n     *\n     * @param {string | Element} content\n     */\n  }, {\n    key: \"setText\",\n    value: function setText(content) {\n      if (content instanceof Element) {\n        while (this.frame.firstChild) {\n          this.frame.removeChild(this.frame.firstChild);\n        }\n        this.frame.appendChild(content);\n      } else {\n        // String containing literal text, element has to be used for HTML due to\n        // XSS risks associated with innerHTML (i.e. prevent XSS by accident).\n        this.frame.innerText = content;\n      }\n    }\n\n    /**\n     * Show the popup window\n     *\n     * @param {boolean} [doShow]    Show or hide the window\n     */\n  }, {\n    key: \"show\",\n    value: function show(doShow) {\n      if (doShow === undefined) {\n        doShow = true;\n      }\n      if (doShow === true) {\n        var height = this.frame.clientHeight;\n        var width = this.frame.clientWidth;\n        var maxHeight = this.frame.parentNode.clientHeight;\n        var maxWidth = this.frame.parentNode.clientWidth;\n        var left = 0,\n          top = 0;\n        if (this.overflowMethod == \"flip\") {\n          var isLeft = false,\n            isTop = true; // Where around the position it's located\n\n          if (this.y - height < this.padding) {\n            isTop = false;\n          }\n          if (this.x + width > maxWidth - this.padding) {\n            isLeft = true;\n          }\n          if (isLeft) {\n            left = this.x - width;\n          } else {\n            left = this.x;\n          }\n          if (isTop) {\n            top = this.y - height;\n          } else {\n            top = this.y;\n          }\n        } else {\n          top = this.y - height;\n          if (top + height + this.padding > maxHeight) {\n            top = maxHeight - height - this.padding;\n          }\n          if (top < this.padding) {\n            top = this.padding;\n          }\n          left = this.x;\n          if (left + width + this.padding > maxWidth) {\n            left = maxWidth - width - this.padding;\n          }\n          if (left < this.padding) {\n            left = this.padding;\n          }\n        }\n        this.frame.style.left = left + \"px\";\n        this.frame.style.top = top + \"px\";\n        this.frame.style.visibility = \"visible\";\n        this.hidden = false;\n      } else {\n        this.hide();\n      }\n    }\n\n    /**\n     * Hide the popup window\n     */\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      this.hidden = true;\n      this.frame.style.left = \"0\";\n      this.frame.style.top = \"0\";\n      this.frame.style.visibility = \"hidden\";\n    }\n\n    /**\n     * Remove the popup window\n     */\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.frame.parentNode.removeChild(this.frame); // Remove element from DOM\n    }\n  }]);\n  return Popup;\n}();\nvar errorFound = false;\nvar allOptions$1;\nvar VALIDATOR_PRINT_STYLE$1 = \"background: #FFeeee; color: #dd0000\";\n\n/**\n *  Used to validate options.\n */\nvar Validator$1 = /*#__PURE__*/function () {\n  function Validator() {\n    _classCallCheck(this, Validator);\n  }\n  _createClass(Validator, null, [{\n    key: \"validate\",\n    value:\n    /**\n     * Main function to be called\n     *\n     * @param {object} options\n     * @param {object} referenceOptions\n     * @param {object} subObject\n     * @returns {boolean}\n     * @static\n     */\n    function validate(options, referenceOptions, subObject) {\n      errorFound = false;\n      allOptions$1 = referenceOptions;\n      var usedOptions = referenceOptions;\n      if (subObject !== undefined) {\n        usedOptions = referenceOptions[subObject];\n      }\n      Validator.parse(options, usedOptions, []);\n      return errorFound;\n    }\n\n    /**\n     * Will traverse an object recursively and check every value\n     *\n     * @param {object} options\n     * @param {object} referenceOptions\n     * @param {Array} path    | where to look for the actual option\n     * @static\n     */\n  }, {\n    key: \"parse\",\n    value: function parse(options, referenceOptions, path) {\n      for (var _option3 in options) {\n        if (Object.prototype.hasOwnProperty.call(options, _option3)) {\n          Validator.check(_option3, options, referenceOptions, path);\n        }\n      }\n    }\n\n    /**\n     * Check every value. If the value is an object, call the parse function on that object.\n     *\n     * @param {string} option\n     * @param {object} options\n     * @param {object} referenceOptions\n     * @param {Array} path    | where to look for the actual option\n     * @static\n     */\n  }, {\n    key: \"check\",\n    value: function check(option, options, referenceOptions, path) {\n      if (referenceOptions[option] === undefined && referenceOptions.__any__ === undefined) {\n        Validator.getSuggestion(option, referenceOptions, path);\n        return;\n      }\n      var referenceOption = option;\n      var is_object = true;\n      if (referenceOptions[option] === undefined && referenceOptions.__any__ !== undefined) {\n        // NOTE: This only triggers if the __any__ is in the top level of the options object.\n        //       THAT'S A REALLY BAD PLACE TO ALLOW IT!!!!\n        // TODO: Examine if needed, remove if possible\n\n        // __any__ is a wildcard. Any value is accepted and will be further analysed by reference.\n        referenceOption = \"__any__\";\n\n        // if the any-subgroup is not a predefined object in the configurator,\n        // we do not look deeper into the object.\n        is_object = Validator.getType(options[option]) === \"object\";\n      }\n      var refOptionObj = referenceOptions[referenceOption];\n      if (is_object && refOptionObj.__type__ !== undefined) {\n        refOptionObj = refOptionObj.__type__;\n      }\n      Validator.checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path);\n    }\n\n    /**\n     *\n     * @param {string}  option           | the option property\n     * @param {object}  options          | The supplied options object\n     * @param {object}  referenceOptions | The reference options containing all options and their allowed formats\n     * @param {string}  referenceOption  | Usually this is the same as option, except when handling an __any__ tag.\n     * @param {string}  refOptionObj     | This is the type object from the reference options\n     * @param {Array}   path             | where in the object is the option\n     * @static\n     */\n  }, {\n    key: \"checkFields\",\n    value: function checkFields(option, options, referenceOptions, referenceOption, refOptionObj, path) {\n      var log = function log(message) {\n        console.error(\"%c\" + message + Validator.printLocation(path, option), VALIDATOR_PRINT_STYLE$1);\n      };\n      var optionType = Validator.getType(options[option]);\n      var refOptionType = refOptionObj[optionType];\n      if (refOptionType !== undefined) {\n        // if the type is correct, we check if it is supposed to be one of a few select values\n        if (Validator.getType(refOptionType) === \"array\" && _indexOfInstanceProperty(refOptionType).call(refOptionType, options[option]) === -1) {\n          log('Invalid option detected in \"' + option + '\".' + \" Allowed values are:\" + Validator.print(refOptionType) + ' not \"' + options[option] + '\". ');\n          errorFound = true;\n        } else if (optionType === \"object\" && referenceOption !== \"__any__\") {\n          path = copyAndExtendArray(path, option);\n          Validator.parse(options[option], referenceOptions[referenceOption], path);\n        }\n      } else if (refOptionObj[\"any\"] === undefined) {\n        // type of the field is incorrect and the field cannot be any\n        log('Invalid type received for \"' + option + '\". Expected: ' + Validator.print(_Object$keys(refOptionObj)) + \". Received [\" + optionType + '] \"' + options[option] + '\"');\n        errorFound = true;\n      }\n    }\n\n    /**\n     *\n     * @param {object | boolean | number | string | Array.<number> | Date | Node | Moment | undefined | null} object\n     * @returns {string}\n     * @static\n     */\n  }, {\n    key: \"getType\",\n    value: function getType(object) {\n      var type = _typeof(object);\n      if (type === \"object\") {\n        if (object === null) {\n          return \"null\";\n        }\n        if (object instanceof Boolean) {\n          return \"boolean\";\n        }\n        if (object instanceof Number) {\n          return \"number\";\n        }\n        if (object instanceof String) {\n          return \"string\";\n        }\n        if (_Array$isArray(object)) {\n          return \"array\";\n        }\n        if (object instanceof Date) {\n          return \"date\";\n        }\n        if (object.nodeType !== undefined) {\n          return \"dom\";\n        }\n        if (object._isAMomentObject === true) {\n          return \"moment\";\n        }\n        return \"object\";\n      } else if (type === \"number\") {\n        return \"number\";\n      } else if (type === \"boolean\") {\n        return \"boolean\";\n      } else if (type === \"string\") {\n        return \"string\";\n      } else if (type === undefined) {\n        return \"undefined\";\n      }\n      return type;\n    }\n\n    /**\n     * @param {string} option\n     * @param {object} options\n     * @param {Array.<string>} path\n     * @static\n     */\n  }, {\n    key: \"getSuggestion\",\n    value: function getSuggestion(option, options, path) {\n      var localSearch = Validator.findInOptions(option, options, path, false);\n      var globalSearch = Validator.findInOptions(option, allOptions$1, [], true);\n      var localSearchThreshold = 8;\n      var globalSearchThreshold = 4;\n      var msg;\n      if (localSearch.indexMatch !== undefined) {\n        msg = \" in \" + Validator.printLocation(localSearch.path, option, \"\") + 'Perhaps it was incomplete? Did you mean: \"' + localSearch.indexMatch + '\"?\\n\\n';\n      } else if (globalSearch.distance <= globalSearchThreshold && localSearch.distance > globalSearch.distance) {\n        msg = \" in \" + Validator.printLocation(localSearch.path, option, \"\") + \"Perhaps it was misplaced? Matching option found at: \" + Validator.printLocation(globalSearch.path, globalSearch.closestMatch, \"\");\n      } else if (localSearch.distance <= localSearchThreshold) {\n        msg = '. Did you mean \"' + localSearch.closestMatch + '\"?' + Validator.printLocation(localSearch.path, option);\n      } else {\n        msg = \". Did you mean one of these: \" + Validator.print(_Object$keys(options)) + Validator.printLocation(path, option);\n      }\n      console.error('%cUnknown option detected: \"' + option + '\"' + msg, VALIDATOR_PRINT_STYLE$1);\n      errorFound = true;\n    }\n\n    /**\n     * traverse the options in search for a match.\n     *\n     * @param {string} option\n     * @param {object} options\n     * @param {Array} path    | where to look for the actual option\n     * @param {boolean} [recursive=false]\n     * @returns {{closestMatch: string, path: Array, distance: number}}\n     * @static\n     */\n  }, {\n    key: \"findInOptions\",\n    value: function findInOptions(option, options, path) {\n      var recursive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var min = 1e9;\n      var closestMatch = \"\";\n      var closestMatchPath = [];\n      var lowerCaseOption = option.toLowerCase();\n      var indexMatch = undefined;\n      for (var op in options) {\n        var distance = void 0;\n        if (options[op].__type__ !== undefined && recursive === true) {\n          var result = Validator.findInOptions(option, options[op], copyAndExtendArray(path, op));\n          if (min > result.distance) {\n            closestMatch = result.closestMatch;\n            closestMatchPath = result.path;\n            min = result.distance;\n            indexMatch = result.indexMatch;\n          }\n        } else {\n          var _context16;\n          if (_indexOfInstanceProperty(_context16 = op.toLowerCase()).call(_context16, lowerCaseOption) !== -1) {\n            indexMatch = op;\n          }\n          distance = Validator.levenshteinDistance(option, op);\n          if (min > distance) {\n            closestMatch = op;\n            closestMatchPath = copyArray(path);\n            min = distance;\n          }\n        }\n      }\n      return {\n        closestMatch: closestMatch,\n        path: closestMatchPath,\n        distance: min,\n        indexMatch: indexMatch\n      };\n    }\n\n    /**\n     * @param {Array.<string>} path\n     * @param {object} option\n     * @param {string} prefix\n     * @returns {string}\n     * @static\n     */\n  }, {\n    key: \"printLocation\",\n    value: function printLocation(path, option) {\n      var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Problem value found at: \\n\";\n      var str = \"\\n\\n\" + prefix + \"options = {\\n\";\n      for (var i = 0; i < path.length; i++) {\n        for (var j = 0; j < i + 1; j++) {\n          str += \"  \";\n        }\n        str += path[i] + \": {\\n\";\n      }\n      for (var _j = 0; _j < path.length + 1; _j++) {\n        str += \"  \";\n      }\n      str += option + \"\\n\";\n      for (var _i5 = 0; _i5 < path.length + 1; _i5++) {\n        for (var _j2 = 0; _j2 < path.length - _i5; _j2++) {\n          str += \"  \";\n        }\n        str += \"}\\n\";\n      }\n      return str + \"\\n\\n\";\n    }\n\n    /**\n     * @param {object} options\n     * @returns {string}\n     * @static\n     */\n  }, {\n    key: \"print\",\n    value: function print(options) {\n      return _JSON$stringify(options).replace(/(\")|(\\[)|(\\])|(,\"__type__\")/g, \"\").replace(/(,)/g, \", \");\n    }\n\n    /**\n     *  Compute the edit distance between the two given strings\n     * http://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#JavaScript\n     *\n     * Copyright (c) 2011 Andrei Mackenzie\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n     *\n     * @param {string} a\n     * @param {string} b\n     * @returns {Array.<Array.<number>>}}\n     * @static\n     */\n  }, {\n    key: \"levenshteinDistance\",\n    value: function levenshteinDistance(a, b) {\n      if (a.length === 0) return b.length;\n      if (b.length === 0) return a.length;\n      var matrix = [];\n\n      // increment along the first column of each row\n      var i;\n      for (i = 0; i <= b.length; i++) {\n        matrix[i] = [i];\n      }\n\n      // increment each column in the first row\n      var j;\n      for (j = 0; j <= a.length; j++) {\n        matrix[0][j] = j;\n      }\n\n      // Fill in the rest of the matrix\n      for (i = 1; i <= b.length; i++) {\n        for (j = 1; j <= a.length; j++) {\n          if (b.charAt(i - 1) == a.charAt(j - 1)) {\n            matrix[i][j] = matrix[i - 1][j - 1];\n          } else {\n            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1,\n            // substitution\n            Math.min(matrix[i][j - 1] + 1,\n            // insertion\n            matrix[i - 1][j] + 1)); // deletion\n          }\n        }\n      }\n\n      return matrix[b.length][a.length];\n    }\n  }]);\n  return Validator;\n}();\nvar Activator = Activator$1;\nvar Configurator = Configurator$1;\nvar Hammer = Hammer$1;\nvar Popup = Popup$1;\nvar VALIDATOR_PRINT_STYLE = VALIDATOR_PRINT_STYLE$1;\nvar Validator = Validator$1;\n\n/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-unused-vars */\n/* eslint-disable no-var */\n\n/**\n * Parse a text source containing data in DOT language into a JSON object.\n * The object contains two lists: one with nodes and one with edges.\n *\n * DOT language reference: http://www.graphviz.org/doc/info/lang.html\n *\n * DOT language attributes: http://graphviz.org/content/attrs\n *\n * @param {string} data     Text containing a graph in DOT-notation\n * @returns {object} graph   An object containing two parameters:\n *                          {Object[]} nodes\n *                          {Object[]} edges\n *\n * -------------------------------------------\n * TODO\n * ====\n *\n * For label handling, this is an incomplete implementation. From docs (quote #3015):\n *\n * > the escape sequences \"\\n\", \"\\l\" and \"\\r\" divide the label into lines, centered,\n * > left-justified, and right-justified, respectively.\n *\n * Source: http://www.graphviz.org/content/attrs#kescString\n *\n * > As another aid for readability, dot allows double-quoted strings to span multiple physical\n * > lines using the standard C convention of a backslash immediately preceding a newline\n * > character\n * > In addition, double-quoted strings can be concatenated using a '+' operator.\n * > As HTML strings can contain newline characters, which are used solely for formatting,\n * > the language does not allow escaped newlines or concatenation operators to be used\n * > within them.\n *\n * - Currently, only '\\\\n' is handled\n * - Note that text explicitly says 'labels'; the dot parser currently handles escape\n *   sequences in **all** strings.\n */\nfunction parseDOT(data) {\n  dot = data;\n  return parseGraph();\n}\n\n// mapping of attributes from DOT (the keys) to vis.js (the values)\nvar NODE_ATTR_MAPPING = {\n  fontsize: \"font.size\",\n  fontcolor: \"font.color\",\n  labelfontcolor: \"font.color\",\n  fontname: \"font.face\",\n  color: [\"color.border\", \"color.background\"],\n  fillcolor: \"color.background\",\n  tooltip: \"title\",\n  labeltooltip: \"title\"\n};\nvar EDGE_ATTR_MAPPING = _Object$create$1(NODE_ATTR_MAPPING);\nEDGE_ATTR_MAPPING.color = \"color.color\";\nEDGE_ATTR_MAPPING.style = \"dashes\";\n\n// token types enumeration\nvar TOKENTYPE = {\n  NULL: 0,\n  DELIMITER: 1,\n  IDENTIFIER: 2,\n  UNKNOWN: 3\n};\n\n// map with all delimiters\nvar DELIMITERS = {\n  \"{\": true,\n  \"}\": true,\n  \"[\": true,\n  \"]\": true,\n  \";\": true,\n  \"=\": true,\n  \",\": true,\n  \"->\": true,\n  \"--\": true\n};\nvar dot = \"\"; // current dot file\nvar index = 0; // current index in dot file\nvar c = \"\"; // current token character in expr\nvar token = \"\"; // current token\nvar tokenType = TOKENTYPE.NULL; // type of the token\n\n/**\n * Get the first character from the dot file.\n * The character is stored into the char c. If the end of the dot file is\n * reached, the function puts an empty string in c.\n */\nfunction first() {\n  index = 0;\n  c = dot.charAt(0);\n}\n\n/**\n * Get the next character from the dot file.\n * The character is stored into the char c. If the end of the dot file is\n * reached, the function puts an empty string in c.\n */\nfunction next() {\n  index++;\n  c = dot.charAt(index);\n}\n\n/**\n * Preview the next character from the dot file.\n *\n * @returns {string} cNext\n */\nfunction nextPreview() {\n  return dot.charAt(index + 1);\n}\n\n/**\n * Test whether given character is alphabetic or numeric ( a-zA-Z_0-9.:# )\n *\n * @param {string} c\n * @returns {boolean} isAlphaNumeric\n */\nfunction isAlphaNumeric(c) {\n  var charCode = c.charCodeAt(0);\n  if (charCode < 47) {\n    // #.\n    return charCode === 35 || charCode === 46;\n  }\n  if (charCode < 59) {\n    // 0-9 and :\n    return charCode > 47;\n  }\n  if (charCode < 91) {\n    // A-Z\n    return charCode > 64;\n  }\n  if (charCode < 96) {\n    // _\n    return charCode === 95;\n  }\n  if (charCode < 123) {\n    // a-z\n    return charCode > 96;\n  }\n  return false;\n}\n\n/**\n * Merge all options of object b into object b\n *\n * @param {object} a\n * @param {object} b\n * @returns {object} a\n */\nfunction merge$1(a, b) {\n  if (!a) {\n    a = {};\n  }\n  if (b) {\n    for (var name in b) {\n      if (b.hasOwnProperty(name)) {\n        a[name] = b[name];\n      }\n    }\n  }\n  return a;\n}\n\n/**\n * Set a value in an object, where the provided parameter name can be a\n * path with nested parameters. For example:\n *\n *     var obj = {a: 2};\n *     setValue(obj, 'b.c', 3);     // obj = {a: 2, b: {c: 3}}\n *\n * @param {object} obj\n * @param {string} path  A parameter name or dot-separated parameter path,\n *                      like \"color.highlight.border\".\n * @param {*} value\n */\nfunction setValue(obj, path, value) {\n  var keys = path.split(\".\");\n  var o = obj;\n  while (keys.length) {\n    var key = keys.shift();\n    if (keys.length) {\n      // this isn't the end point\n      if (!o[key]) {\n        o[key] = {};\n      }\n      o = o[key];\n    } else {\n      // this is the end point\n      o[key] = value;\n    }\n  }\n}\n\n/**\n * Add a node to a graph object. If there is already a node with\n * the same id, their attributes will be merged.\n *\n * @param {object} graph\n * @param {object} node\n */\nfunction addNode(graph, node) {\n  var i, len;\n  var current = null;\n\n  // find root graph (in case of subgraph)\n  var graphs = [graph]; // list with all graphs from current graph to root graph\n  var root = graph;\n  while (root.parent) {\n    graphs.push(root.parent);\n    root = root.parent;\n  }\n\n  // find existing node (at root level) by its id\n  if (root.nodes) {\n    for (i = 0, len = root.nodes.length; i < len; i++) {\n      if (node.id === root.nodes[i].id) {\n        current = root.nodes[i];\n        break;\n      }\n    }\n  }\n  if (!current) {\n    // this is a new node\n    current = {\n      id: node.id\n    };\n    if (graph.node) {\n      // clone default attributes\n      current.attr = merge$1(current.attr, graph.node);\n    }\n  }\n\n  // add node to this (sub)graph and all its parent graphs\n  for (i = graphs.length - 1; i >= 0; i--) {\n    var _context;\n    var g = graphs[i];\n    if (!g.nodes) {\n      g.nodes = [];\n    }\n    if (_indexOfInstanceProperty(_context = g.nodes).call(_context, current) === -1) {\n      g.nodes.push(current);\n    }\n  }\n\n  // merge attributes\n  if (node.attr) {\n    current.attr = merge$1(current.attr, node.attr);\n  }\n}\n\n/**\n * Add an edge to a graph object\n *\n * @param {object} graph\n * @param {object} edge\n */\nfunction addEdge(graph, edge) {\n  if (!graph.edges) {\n    graph.edges = [];\n  }\n  graph.edges.push(edge);\n  if (graph.edge) {\n    var attr = merge$1({}, graph.edge); // clone default attributes\n    edge.attr = merge$1(attr, edge.attr); // merge attributes\n  }\n}\n\n/**\n * Create an edge to a graph object\n *\n * @param {object} graph\n * @param {string | number | object} from\n * @param {string | number | object} to\n * @param {string} type\n * @param {object | null} attr\n * @returns {object} edge\n */\nfunction createEdge(graph, from, to, type, attr) {\n  var edge = {\n    from: from,\n    to: to,\n    type: type\n  };\n  if (graph.edge) {\n    edge.attr = merge$1({}, graph.edge); // clone default attributes\n  }\n\n  edge.attr = merge$1(edge.attr || {}, attr); // merge attributes\n\n  // Move arrows attribute from attr to edge temporally created in\n  // parseAttributeList().\n  if (attr != null) {\n    if (attr.hasOwnProperty(\"arrows\") && attr[\"arrows\"] != null) {\n      edge[\"arrows\"] = {\n        to: {\n          enabled: true,\n          type: attr.arrows.type\n        }\n      };\n      attr[\"arrows\"] = null;\n    }\n  }\n  return edge;\n}\n\n/**\n * Get next token in the current dot file.\n * The token and token type are available as token and tokenType\n */\nfunction getToken() {\n  tokenType = TOKENTYPE.NULL;\n  token = \"\";\n\n  // skip over whitespaces\n  while (c === \" \" || c === \"\\t\" || c === \"\\n\" || c === \"\\r\") {\n    // space, tab, enter\n    next();\n  }\n  do {\n    var isComment = false;\n\n    // skip comment\n    if (c === \"#\") {\n      // find the previous non-space character\n      var i = index - 1;\n      while (dot.charAt(i) === \" \" || dot.charAt(i) === \"\\t\") {\n        i--;\n      }\n      if (dot.charAt(i) === \"\\n\" || dot.charAt(i) === \"\") {\n        // the # is at the start of a line, this is indeed a line comment\n        while (c != \"\" && c != \"\\n\") {\n          next();\n        }\n        isComment = true;\n      }\n    }\n    if (c === \"/\" && nextPreview() === \"/\") {\n      // skip line comment\n      while (c != \"\" && c != \"\\n\") {\n        next();\n      }\n      isComment = true;\n    }\n    if (c === \"/\" && nextPreview() === \"*\") {\n      // skip block comment\n      while (c != \"\") {\n        if (c === \"*\" && nextPreview() === \"/\") {\n          // end of block comment found. skip these last two characters\n          next();\n          next();\n          break;\n        } else {\n          next();\n        }\n      }\n      isComment = true;\n    }\n\n    // skip over whitespaces\n    while (c === \" \" || c === \"\\t\" || c === \"\\n\" || c === \"\\r\") {\n      // space, tab, enter\n      next();\n    }\n  } while (isComment);\n\n  // check for end of dot file\n  if (c === \"\") {\n    // token is still empty\n    tokenType = TOKENTYPE.DELIMITER;\n    return;\n  }\n\n  // check for delimiters consisting of 2 characters\n  var c2 = c + nextPreview();\n  if (DELIMITERS[c2]) {\n    tokenType = TOKENTYPE.DELIMITER;\n    token = c2;\n    next();\n    next();\n    return;\n  }\n\n  // check for delimiters consisting of 1 character\n  if (DELIMITERS[c]) {\n    tokenType = TOKENTYPE.DELIMITER;\n    token = c;\n    next();\n    return;\n  }\n\n  // check for an identifier (number or string)\n  // TODO: more precise parsing of numbers/strings (and the port separator ':')\n  if (isAlphaNumeric(c) || c === \"-\") {\n    token += c;\n    next();\n    while (isAlphaNumeric(c)) {\n      token += c;\n      next();\n    }\n    if (token === \"false\") {\n      token = false; // convert to boolean\n    } else if (token === \"true\") {\n      token = true; // convert to boolean\n    } else if (!isNaN(Number(token))) {\n      token = Number(token); // convert to number\n    }\n\n    tokenType = TOKENTYPE.IDENTIFIER;\n    return;\n  }\n\n  // check for a string enclosed by double quotes\n  if (c === '\"') {\n    next();\n    while (c != \"\" && (c != '\"' || c === '\"' && nextPreview() === '\"')) {\n      if (c === '\"') {\n        // skip the escape character\n        token += c;\n        next();\n      } else if (c === \"\\\\\" && nextPreview() === \"n\") {\n        // Honor a newline escape sequence\n        token += \"\\n\";\n        next();\n      } else {\n        token += c;\n      }\n      next();\n    }\n    if (c != '\"') {\n      throw newSyntaxError('End of string \" expected');\n    }\n    next();\n    tokenType = TOKENTYPE.IDENTIFIER;\n    return;\n  }\n\n  // something unknown is found, wrong characters, a syntax error\n  tokenType = TOKENTYPE.UNKNOWN;\n  while (c != \"\") {\n    token += c;\n    next();\n  }\n  throw new SyntaxError('Syntax error in part \"' + chop(token, 30) + '\"');\n}\n\n/**\n * Parse a graph.\n *\n * @returns {object} graph\n */\nfunction parseGraph() {\n  var graph = {};\n  first();\n  getToken();\n\n  // optional strict keyword\n  if (token === \"strict\") {\n    graph.strict = true;\n    getToken();\n  }\n\n  // graph or digraph keyword\n  if (token === \"graph\" || token === \"digraph\") {\n    graph.type = token;\n    getToken();\n  }\n\n  // optional graph id\n  if (tokenType === TOKENTYPE.IDENTIFIER) {\n    graph.id = token;\n    getToken();\n  }\n\n  // open angle bracket\n  if (token != \"{\") {\n    throw newSyntaxError(\"Angle bracket { expected\");\n  }\n  getToken();\n\n  // statements\n  parseStatements(graph);\n\n  // close angle bracket\n  if (token != \"}\") {\n    throw newSyntaxError(\"Angle bracket } expected\");\n  }\n  getToken();\n\n  // end of file\n  if (token !== \"\") {\n    throw newSyntaxError(\"End of file expected\");\n  }\n  getToken();\n\n  // remove temporary default options\n  delete graph.node;\n  delete graph.edge;\n  delete graph.graph;\n  return graph;\n}\n\n/**\n * Parse a list with statements.\n *\n * @param {object} graph\n */\nfunction parseStatements(graph) {\n  while (token !== \"\" && token != \"}\") {\n    parseStatement(graph);\n    if (token === \";\") {\n      getToken();\n    }\n  }\n}\n\n/**\n * Parse a single statement. Can be a an attribute statement, node\n * statement, a series of node statements and edge statements, or a\n * parameter.\n *\n * @param {object} graph\n */\nfunction parseStatement(graph) {\n  // parse subgraph\n  var subgraph = parseSubgraph(graph);\n  if (subgraph) {\n    // edge statements\n    parseEdge(graph, subgraph);\n    return;\n  }\n\n  // parse an attribute statement\n  var attr = parseAttributeStatement(graph);\n  if (attr) {\n    return;\n  }\n\n  // parse node\n  if (tokenType != TOKENTYPE.IDENTIFIER) {\n    throw newSyntaxError(\"Identifier expected\");\n  }\n  var id = token; // id can be a string or a number\n  getToken();\n  if (token === \"=\") {\n    // id statement\n    getToken();\n    if (tokenType != TOKENTYPE.IDENTIFIER) {\n      throw newSyntaxError(\"Identifier expected\");\n    }\n    graph[id] = token;\n    getToken();\n    // TODO: implement comma separated list with \"a_list: ID=ID [','] [a_list] \"\n  } else {\n    parseNodeStatement(graph, id);\n  }\n}\n\n/**\n * Parse a subgraph\n *\n * @param {object} graph    parent graph object\n * @returns {object | null} subgraph\n */\nfunction parseSubgraph(graph) {\n  var subgraph = null;\n\n  // optional subgraph keyword\n  if (token === \"subgraph\") {\n    subgraph = {};\n    subgraph.type = \"subgraph\";\n    getToken();\n\n    // optional graph id\n    if (tokenType === TOKENTYPE.IDENTIFIER) {\n      subgraph.id = token;\n      getToken();\n    }\n  }\n\n  // open angle bracket\n  if (token === \"{\") {\n    getToken();\n    if (!subgraph) {\n      subgraph = {};\n    }\n    subgraph.parent = graph;\n    subgraph.node = graph.node;\n    subgraph.edge = graph.edge;\n    subgraph.graph = graph.graph;\n\n    // statements\n    parseStatements(subgraph);\n\n    // close angle bracket\n    if (token != \"}\") {\n      throw newSyntaxError(\"Angle bracket } expected\");\n    }\n    getToken();\n\n    // remove temporary default options\n    delete subgraph.node;\n    delete subgraph.edge;\n    delete subgraph.graph;\n    delete subgraph.parent;\n\n    // register at the parent graph\n    if (!graph.subgraphs) {\n      graph.subgraphs = [];\n    }\n    graph.subgraphs.push(subgraph);\n  }\n  return subgraph;\n}\n\n/**\n * parse an attribute statement like \"node [shape=circle fontSize=16]\".\n * Available keywords are 'node', 'edge', 'graph'.\n * The previous list with default attributes will be replaced\n *\n * @param {object} graph\n * @returns {string | null} keyword Returns the name of the parsed attribute\n *                                  (node, edge, graph), or null if nothing\n *                                  is parsed.\n */\nfunction parseAttributeStatement(graph) {\n  // attribute statements\n  if (token === \"node\") {\n    getToken();\n\n    // node attributes\n    graph.node = parseAttributeList();\n    return \"node\";\n  } else if (token === \"edge\") {\n    getToken();\n\n    // edge attributes\n    graph.edge = parseAttributeList();\n    return \"edge\";\n  } else if (token === \"graph\") {\n    getToken();\n\n    // graph attributes\n    graph.graph = parseAttributeList();\n    return \"graph\";\n  }\n  return null;\n}\n\n/**\n * parse a node statement\n *\n * @param {object} graph\n * @param {string | number} id\n */\nfunction parseNodeStatement(graph, id) {\n  // node statement\n  var node = {\n    id: id\n  };\n  var attr = parseAttributeList();\n  if (attr) {\n    node.attr = attr;\n  }\n  addNode(graph, node);\n\n  // edge statements\n  parseEdge(graph, id);\n}\n\n/**\n * Parse an edge or a series of edges\n *\n * @param {object} graph\n * @param {string | number} from        Id of the from node\n */\nfunction parseEdge(graph, from) {\n  while (token === \"->\" || token === \"--\") {\n    var to;\n    var type = token;\n    getToken();\n    var subgraph = parseSubgraph(graph);\n    if (subgraph) {\n      to = subgraph;\n    } else {\n      if (tokenType != TOKENTYPE.IDENTIFIER) {\n        throw newSyntaxError(\"Identifier or subgraph expected\");\n      }\n      to = token;\n      addNode(graph, {\n        id: to\n      });\n      getToken();\n    }\n\n    // parse edge attributes\n    var attr = parseAttributeList();\n\n    // create edge\n    var edge = createEdge(graph, from, to, type, attr);\n    addEdge(graph, edge);\n    from = to;\n  }\n}\n\n/**\n * Parse a set with attributes,\n * for example [label=\"1.000\", shape=solid]\n *\n * @returns {object | null} attr\n */\nfunction parseAttributeList() {\n  var i;\n  var attr = null;\n\n  // edge styles of dot and vis\n  var edgeStyles = {\n    dashed: true,\n    solid: false,\n    dotted: [1, 5]\n  };\n\n  /**\n   * Define arrow types.\n   * vis currently supports types defined in 'arrowTypes'.\n   * Details of arrow shapes are described in\n   * http://www.graphviz.org/content/arrow-shapes\n   */\n  var arrowTypes = {\n    dot: \"circle\",\n    box: \"box\",\n    crow: \"crow\",\n    curve: \"curve\",\n    icurve: \"inv_curve\",\n    normal: \"triangle\",\n    inv: \"inv_triangle\",\n    diamond: \"diamond\",\n    tee: \"bar\",\n    vee: \"vee\"\n  };\n\n  /**\n   * 'attr_list' contains attributes for checking if some of them are affected\n   * later. For instance, both of 'arrowhead' and 'dir' (edge style defined\n   * in DOT) make changes to 'arrows' attribute in vis.\n   */\n  var attr_list = new Array();\n  var attr_names = new Array(); // used for checking the case.\n\n  // parse attributes\n  while (token === \"[\") {\n    getToken();\n    attr = {};\n    while (token !== \"\" && token != \"]\") {\n      if (tokenType != TOKENTYPE.IDENTIFIER) {\n        throw newSyntaxError(\"Attribute name expected\");\n      }\n      var name = token;\n      getToken();\n      if (token != \"=\") {\n        throw newSyntaxError(\"Equal sign = expected\");\n      }\n      getToken();\n      if (tokenType != TOKENTYPE.IDENTIFIER) {\n        throw newSyntaxError(\"Attribute value expected\");\n      }\n      var value = token;\n\n      // convert from dot style to vis\n      if (name === \"style\") {\n        value = edgeStyles[value];\n      }\n      var arrowType;\n      if (name === \"arrowhead\") {\n        arrowType = arrowTypes[value];\n        name = \"arrows\";\n        value = {\n          to: {\n            enabled: true,\n            type: arrowType\n          }\n        };\n      }\n      if (name === \"arrowtail\") {\n        arrowType = arrowTypes[value];\n        name = \"arrows\";\n        value = {\n          from: {\n            enabled: true,\n            type: arrowType\n          }\n        };\n      }\n      attr_list.push({\n        attr: attr,\n        name: name,\n        value: value\n      });\n      attr_names.push(name);\n      getToken();\n      if (token == \",\") {\n        getToken();\n      }\n    }\n    if (token != \"]\") {\n      throw newSyntaxError(\"Bracket ] expected\");\n    }\n    getToken();\n  }\n\n  /**\n   * As explained in [1], graphviz has limitations for combination of\n   * arrow[head|tail] and dir. If attribute list includes 'dir',\n   * following cases just be supported.\n   *   1. both or none + arrowhead, arrowtail\n   *   2. forward + arrowhead (arrowtail is not affedted)\n   *   3. back + arrowtail (arrowhead is not affected)\n   * [1] https://www.graphviz.org/doc/info/attrs.html#h:undir_note\n   */\n  if (_includesInstanceProperty(attr_names).call(attr_names, \"dir\")) {\n    var idx = {}; // get index of 'arrows' and 'dir'\n    idx.arrows = {};\n    for (i = 0; i < attr_list.length; i++) {\n      if (attr_list[i].name === \"arrows\") {\n        if (attr_list[i].value.to != null) {\n          idx.arrows.to = i;\n        } else if (attr_list[i].value.from != null) {\n          idx.arrows.from = i;\n        } else {\n          throw newSyntaxError(\"Invalid value of arrows\");\n        }\n      } else if (attr_list[i].name === \"dir\") {\n        idx.dir = i;\n      }\n    }\n\n    // first, add default arrow shape if it is not assigned to avoid error\n    var dir_type = attr_list[idx.dir].value;\n    if (!_includesInstanceProperty(attr_names).call(attr_names, \"arrows\")) {\n      if (dir_type === \"both\") {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: {\n            to: {\n              enabled: true\n            }\n          }\n        });\n        idx.arrows.to = attr_list.length - 1;\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: {\n            from: {\n              enabled: true\n            }\n          }\n        });\n        idx.arrows.from = attr_list.length - 1;\n      } else if (dir_type === \"forward\") {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: {\n            to: {\n              enabled: true\n            }\n          }\n        });\n        idx.arrows.to = attr_list.length - 1;\n      } else if (dir_type === \"back\") {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: {\n            from: {\n              enabled: true\n            }\n          }\n        });\n        idx.arrows.from = attr_list.length - 1;\n      } else if (dir_type === \"none\") {\n        attr_list.push({\n          attr: attr_list[idx.dir].attr,\n          name: \"arrows\",\n          value: \"\"\n        });\n        idx.arrows.to = attr_list.length - 1;\n      } else {\n        throw newSyntaxError('Invalid dir type \"' + dir_type + '\"');\n      }\n    }\n    var from_type;\n    var to_type;\n    // update 'arrows' attribute from 'dir'.\n    if (dir_type === \"both\") {\n      // both of shapes of 'from' and 'to' are given\n      if (idx.arrows.to && idx.arrows.from) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n        _spliceInstanceProperty(attr_list).call(attr_list, idx.arrows.from, 1);\n\n        // shape of 'to' is assigned and use default to 'from'\n      } else if (idx.arrows.to) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = \"arrow\";\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n\n        // only shape of 'from' is assigned and use default for 'to'\n      } else if (idx.arrows.from) {\n        to_type = \"arrow\";\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.from] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n      }\n    } else if (dir_type === \"back\") {\n      // given both of shapes, but use only 'from'\n      if (idx.arrows.to && idx.arrows.from) {\n        to_type = \"\";\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.from] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n\n        // given shape of 'to', but does not use it\n      } else if (idx.arrows.to) {\n        to_type = \"\";\n        from_type = \"arrow\";\n        idx.arrows.from = idx.arrows.to;\n        attr_list[idx.arrows.from] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n\n        // assign given 'from' shape\n      } else if (idx.arrows.from) {\n        to_type = \"\";\n        from_type = attr_list[idx.arrows.from].value.from.type;\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.from].attr,\n          name: attr_list[idx.arrows.from].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n      }\n      attr_list[idx.arrows.from] = {\n        attr: attr_list[idx.arrows.from].attr,\n        name: attr_list[idx.arrows.from].name,\n        value: {\n          from: {\n            enabled: true,\n            type: attr_list[idx.arrows.from].value.from.type\n          }\n        }\n      };\n    } else if (dir_type === \"none\") {\n      var idx_arrow;\n      if (idx.arrows.to) {\n        idx_arrow = idx.arrows.to;\n      } else {\n        idx_arrow = idx.arrows.from;\n      }\n      attr_list[idx_arrow] = {\n        attr: attr_list[idx_arrow].attr,\n        name: attr_list[idx_arrow].name,\n        value: \"\"\n      };\n    } else if (dir_type === \"forward\") {\n      // given both of shapes, but use only 'to'\n      if (idx.arrows.to && idx.arrows.from) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = \"\";\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n\n        // assign given 'to' shape\n      } else if (idx.arrows.to) {\n        to_type = attr_list[idx.arrows.to].value.to.type;\n        from_type = \"\";\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n\n        // given shape of 'from', but does not use it\n      } else if (idx.arrows.from) {\n        to_type = \"arrow\";\n        from_type = \"\";\n        idx.arrows.to = idx.arrows.from;\n        attr_list[idx.arrows.to] = {\n          attr: attr_list[idx.arrows.to].attr,\n          name: attr_list[idx.arrows.to].name,\n          value: {\n            to: {\n              enabled: true,\n              type: to_type\n            },\n            from: {\n              enabled: true,\n              type: from_type\n            }\n          }\n        };\n      }\n      attr_list[idx.arrows.to] = {\n        attr: attr_list[idx.arrows.to].attr,\n        name: attr_list[idx.arrows.to].name,\n        value: {\n          to: {\n            enabled: true,\n            type: attr_list[idx.arrows.to].value.to.type\n          }\n        }\n      };\n    } else {\n      throw newSyntaxError('Invalid dir type \"' + dir_type + '\"');\n    }\n\n    // remove 'dir' attribute no need anymore\n    _spliceInstanceProperty(attr_list).call(attr_list, idx.dir, 1);\n  }\n\n  // parse 'penwidth'\n  var nof_attr_list;\n  if (_includesInstanceProperty(attr_names).call(attr_names, \"penwidth\")) {\n    var tmp_attr_list = [];\n    nof_attr_list = attr_list.length;\n    for (i = 0; i < nof_attr_list; i++) {\n      // exclude 'width' from attr_list if 'penwidth' exists\n      if (attr_list[i].name !== \"width\") {\n        if (attr_list[i].name === \"penwidth\") {\n          attr_list[i].name = \"width\";\n        }\n        tmp_attr_list.push(attr_list[i]);\n      }\n    }\n    attr_list = tmp_attr_list;\n  }\n  nof_attr_list = attr_list.length;\n  for (i = 0; i < nof_attr_list; i++) {\n    setValue(attr_list[i].attr, attr_list[i].name, attr_list[i].value);\n  }\n  return attr;\n}\n\n/**\n * Create a syntax error with extra information on current token and index.\n *\n * @param {string} message\n * @returns {SyntaxError} err\n */\nfunction newSyntaxError(message) {\n  return new SyntaxError(message + ', got \"' + chop(token, 30) + '\" (char ' + index + \")\");\n}\n\n/**\n * Chop off text after a maximum length\n *\n * @param {string} text\n * @param {number} maxLength\n * @returns {string}\n */\nfunction chop(text, maxLength) {\n  return text.length <= maxLength ? text : text.substr(0, 27) + \"...\";\n}\n\n/**\n * Execute a function fn for each pair of elements in two arrays\n *\n * @param {Array | *} array1\n * @param {Array | *} array2\n * @param {Function} fn\n */\nfunction forEach2(array1, array2, fn) {\n  if (_Array$isArray(array1)) {\n    _forEachInstanceProperty(array1).call(array1, function (elem1) {\n      if (_Array$isArray(array2)) {\n        _forEachInstanceProperty(array2).call(array2, function (elem2) {\n          fn(elem1, elem2);\n        });\n      } else {\n        fn(elem1, array2);\n      }\n    });\n  } else {\n    if (_Array$isArray(array2)) {\n      _forEachInstanceProperty(array2).call(array2, function (elem2) {\n        fn(array1, elem2);\n      });\n    } else {\n      fn(array1, array2);\n    }\n  }\n}\n\n/**\n * Set a nested property on an object\n * When nested objects are missing, they will be created.\n * For example setProp({}, 'font.color', 'red') will return {font: {color: 'red'}}\n *\n * @param {object} object\n * @param {string} path   A dot separated string like 'font.color'\n * @param {*} value       Value for the property\n * @returns {object} Returns the original object, allows for chaining.\n */\nfunction setProp(object, path, value) {\n  var names = path.split(\".\");\n  var prop = names.pop();\n\n  // traverse over the nested objects\n  var obj = object;\n  for (var i = 0; i < names.length; i++) {\n    var name = names[i];\n    if (!(name in obj)) {\n      obj[name] = {};\n    }\n    obj = obj[name];\n  }\n\n  // set the property value\n  obj[prop] = value;\n  return object;\n}\n\n/**\n * Convert an object with DOT attributes to their vis.js equivalents.\n *\n * @param {object} attr     Object with DOT attributes\n * @param {object} mapping\n * @returns {object}         Returns an object with vis.js attributes\n */\nfunction convertAttr(attr, mapping) {\n  var converted = {};\n  for (var prop in attr) {\n    if (attr.hasOwnProperty(prop)) {\n      var visProp = mapping[prop];\n      if (_Array$isArray(visProp)) {\n        _forEachInstanceProperty(visProp).call(visProp, function (visPropI) {\n          setProp(converted, visPropI, attr[prop]);\n        });\n      } else if (typeof visProp === \"string\") {\n        setProp(converted, visProp, attr[prop]);\n      } else {\n        setProp(converted, prop, attr[prop]);\n      }\n    }\n  }\n  return converted;\n}\n\n/**\n * Convert a string containing a graph in DOT language into a map containing\n * with nodes and edges in the format of graph.\n *\n * @param {string} data         Text containing a graph in DOT-notation\n * @returns {object} graphData\n */\nfunction DOTToGraph(data) {\n  // parse the DOT file\n  var dotData = parseDOT(data);\n  var graphData = {\n    nodes: [],\n    edges: [],\n    options: {}\n  };\n\n  // copy the nodes\n  if (dotData.nodes) {\n    var _context2;\n    _forEachInstanceProperty(_context2 = dotData.nodes).call(_context2, function (dotNode) {\n      var graphNode = {\n        id: dotNode.id,\n        label: String(dotNode.label || dotNode.id)\n      };\n      merge$1(graphNode, convertAttr(dotNode.attr, NODE_ATTR_MAPPING));\n      if (graphNode.image) {\n        graphNode.shape = \"image\";\n      }\n      graphData.nodes.push(graphNode);\n    });\n  }\n\n  // copy the edges\n  if (dotData.edges) {\n    var _context3;\n    /**\n     * Convert an edge in DOT format to an edge with VisGraph format\n     *\n     * @param {object} dotEdge\n     * @returns {object} graphEdge\n     */\n    var convertEdge = function convertEdge(dotEdge) {\n      var graphEdge = {\n        from: dotEdge.from,\n        to: dotEdge.to\n      };\n      merge$1(graphEdge, convertAttr(dotEdge.attr, EDGE_ATTR_MAPPING));\n\n      // Add arrows attribute to default styled arrow.\n      // The reason why default style is not added in parseAttributeList() is\n      // because only default is cleared before here.\n      if (graphEdge.arrows == null && dotEdge.type === \"->\") {\n        graphEdge.arrows = \"to\";\n      }\n      return graphEdge;\n    };\n    _forEachInstanceProperty(_context3 = dotData.edges).call(_context3, function (dotEdge) {\n      var from, to;\n      if (dotEdge.from instanceof Object) {\n        from = dotEdge.from.nodes;\n      } else {\n        from = {\n          id: dotEdge.from\n        };\n      }\n      if (dotEdge.to instanceof Object) {\n        to = dotEdge.to.nodes;\n      } else {\n        to = {\n          id: dotEdge.to\n        };\n      }\n      if (dotEdge.from instanceof Object && dotEdge.from.edges) {\n        var _context4;\n        _forEachInstanceProperty(_context4 = dotEdge.from.edges).call(_context4, function (subEdge) {\n          var graphEdge = convertEdge(subEdge);\n          graphData.edges.push(graphEdge);\n        });\n      }\n      forEach2(from, to, function (from, to) {\n        var subEdge = createEdge(graphData, from.id, to.id, dotEdge.type, dotEdge.attr);\n        var graphEdge = convertEdge(subEdge);\n        graphData.edges.push(graphEdge);\n      });\n      if (dotEdge.to instanceof Object && dotEdge.to.edges) {\n        var _context5;\n        _forEachInstanceProperty(_context5 = dotEdge.to.edges).call(_context5, function (subEdge) {\n          var graphEdge = convertEdge(subEdge);\n          graphData.edges.push(graphEdge);\n        });\n      }\n    });\n  }\n\n  // copy the options\n  if (dotData.attr) {\n    graphData.options = dotData.attr;\n  }\n  return graphData;\n}\n\n/* eslint-enable no-var */\n/* eslint-enable no-unused-vars */\n/* eslint-enable no-prototype-builtins */\n\nvar dotparser = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tDOTToGraph: DOTToGraph,\n\tparseDOT: parseDOT\n});\n\n/**\r\n * Convert Gephi to Vis.\r\n *\r\n * @param gephiJSON - The parsed JSON data in Gephi format.\r\n * @param optionsObj - Additional options.\r\n * @returns The converted data ready to be used in Vis.\r\n */\nfunction parseGephi(gephiJSON, optionsObj) {\n  var _context;\n  var options = {\n    edges: {\n      inheritColor: false\n    },\n    nodes: {\n      fixed: false,\n      parseColor: false\n    }\n  };\n  if (optionsObj != null) {\n    if (optionsObj.fixed != null) {\n      options.nodes.fixed = optionsObj.fixed;\n    }\n    if (optionsObj.parseColor != null) {\n      options.nodes.parseColor = optionsObj.parseColor;\n    }\n    if (optionsObj.inheritColor != null) {\n      options.edges.inheritColor = optionsObj.inheritColor;\n    }\n  }\n  var gEdges = gephiJSON.edges;\n  var vEdges = _mapInstanceProperty(gEdges).call(gEdges, function (gEdge) {\n    var vEdge = {\n      from: gEdge.source,\n      id: gEdge.id,\n      to: gEdge.target\n    };\n    if (gEdge.attributes != null) {\n      vEdge.attributes = gEdge.attributes;\n    }\n    if (gEdge.label != null) {\n      vEdge.label = gEdge.label;\n    }\n    if (gEdge.attributes != null && gEdge.attributes.title != null) {\n      vEdge.title = gEdge.attributes.title;\n    }\n    if (gEdge.type === \"Directed\") {\n      vEdge.arrows = \"to\";\n    }\n    // edge['value'] = gEdge.attributes != null ? gEdge.attributes.Weight : undefined;\n    // edge['width'] = edge['value'] != null ? undefined : edgegEdge.size;\n    if (gEdge.color && options.edges.inheritColor === false) {\n      vEdge.color = gEdge.color;\n    }\n    return vEdge;\n  });\n  var vNodes = _mapInstanceProperty(_context = gephiJSON.nodes).call(_context, function (gNode) {\n    var vNode = {\n      id: gNode.id,\n      fixed: options.nodes.fixed && gNode.x != null && gNode.y != null\n    };\n    if (gNode.attributes != null) {\n      vNode.attributes = gNode.attributes;\n    }\n    if (gNode.label != null) {\n      vNode.label = gNode.label;\n    }\n    if (gNode.size != null) {\n      vNode.size = gNode.size;\n    }\n    if (gNode.attributes != null && gNode.attributes.title != null) {\n      vNode.title = gNode.attributes.title;\n    }\n    if (gNode.title != null) {\n      vNode.title = gNode.title;\n    }\n    if (gNode.x != null) {\n      vNode.x = gNode.x;\n    }\n    if (gNode.y != null) {\n      vNode.y = gNode.y;\n    }\n    if (gNode.color != null) {\n      if (options.nodes.parseColor === true) {\n        vNode.color = gNode.color;\n      } else {\n        vNode.color = {\n          background: gNode.color,\n          border: gNode.color,\n          highlight: {\n            background: gNode.color,\n            border: gNode.color\n          },\n          hover: {\n            background: gNode.color,\n            border: gNode.color\n          }\n        };\n      }\n    }\n    return vNode;\n  });\n  return {\n    nodes: vNodes,\n    edges: vEdges\n  };\n}\n\nvar gephiParser = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tparseGephi: parseGephi\n});\n\n// English\nvar en = {\n  addDescription: \"Click in an empty space to place a new node.\",\n  addEdge: \"Add Edge\",\n  addNode: \"Add Node\",\n  back: \"Back\",\n  close: \"Close\",\n  createEdgeError: \"Cannot link edges to a cluster.\",\n  del: \"Delete selected\",\n  deleteClusterError: \"Clusters cannot be deleted.\",\n  edgeDescription: \"Click on a node and drag the edge to another node to connect them.\",\n  edit: \"Edit\",\n  editClusterError: \"Clusters cannot be edited.\",\n  editEdge: \"Edit Edge\",\n  editEdgeDescription: \"Click on the control points and drag them to a node to connect to it.\",\n  editNode: \"Edit Node\"\n};\n// German\nvar de = {\n  addDescription: \"Klicke auf eine freie Stelle, um einen neuen Knoten zu plazieren.\",\n  addEdge: \"Kante hinzuf\\xFCgen\",\n  addNode: \"Knoten hinzuf\\xFCgen\",\n  back: \"Zur\\xFCck\",\n  close: \"Schließen\",\n  createEdgeError: \"Es ist nicht m\\xF6glich, Kanten mit Clustern zu verbinden.\",\n  del: \"L\\xF6sche Auswahl\",\n  deleteClusterError: \"Cluster k\\xF6nnen nicht gel\\xF6scht werden.\",\n  edgeDescription: \"Klicke auf einen Knoten und ziehe die Kante zu einem anderen Knoten, um diese zu verbinden.\",\n  edit: \"Editieren\",\n  editClusterError: \"Cluster k\\xF6nnen nicht editiert werden.\",\n  editEdge: \"Kante editieren\",\n  editEdgeDescription: \"Klicke auf die Verbindungspunkte und ziehe diese auf einen Knoten, um sie zu verbinden.\",\n  editNode: \"Knoten editieren\"\n};\n// Spanish\nvar es = {\n  addDescription: \"Haga clic en un lugar vac\\xEDo para colocar un nuevo nodo.\",\n  addEdge: \"A\\xF1adir arista\",\n  addNode: \"A\\xF1adir nodo\",\n  back: \"Atr\\xE1s\",\n  close: \"Cerrar\",\n  createEdgeError: \"No se puede conectar una arista a un grupo.\",\n  del: \"Eliminar selecci\\xF3n\",\n  deleteClusterError: \"No es posible eliminar grupos.\",\n  edgeDescription: \"Haga clic en un nodo y arrastre la arista hacia otro nodo para conectarlos.\",\n  edit: \"Editar\",\n  editClusterError: \"No es posible editar grupos.\",\n  editEdge: \"Editar arista\",\n  editEdgeDescription: \"Haga clic en un punto de control y arrastrelo a un nodo para conectarlo.\",\n  editNode: \"Editar nodo\"\n};\n//Italiano\nvar it = {\n  addDescription: \"Clicca per aggiungere un nuovo nodo\",\n  addEdge: \"Aggiungi un vertice\",\n  addNode: \"Aggiungi un nodo\",\n  back: \"Indietro\",\n  close: \"Chiudere\",\n  createEdgeError: \"Non si possono collegare vertici ad un cluster\",\n  del: \"Cancella la selezione\",\n  deleteClusterError: \"I cluster non possono essere cancellati\",\n  edgeDescription: \"Clicca su un nodo e trascinalo ad un altro nodo per connetterli.\",\n  edit: \"Modifica\",\n  editClusterError: \"I clusters non possono essere modificati.\",\n  editEdge: \"Modifica il vertice\",\n  editEdgeDescription: \"Clicca sui Punti di controllo e trascinali ad un nodo per connetterli.\",\n  editNode: \"Modifica il nodo\"\n};\n// Dutch\nvar nl = {\n  addDescription: \"Klik op een leeg gebied om een nieuwe node te maken.\",\n  addEdge: \"Link toevoegen\",\n  addNode: \"Node toevoegen\",\n  back: \"Terug\",\n  close: \"Sluiten\",\n  createEdgeError: \"Kan geen link maken naar een cluster.\",\n  del: \"Selectie verwijderen\",\n  deleteClusterError: \"Clusters kunnen niet worden verwijderd.\",\n  edgeDescription: \"Klik op een node en sleep de link naar een andere node om ze te verbinden.\",\n  edit: \"Wijzigen\",\n  editClusterError: \"Clusters kunnen niet worden aangepast.\",\n  editEdge: \"Link wijzigen\",\n  editEdgeDescription: \"Klik op de verbindingspunten en sleep ze naar een node om daarmee te verbinden.\",\n  editNode: \"Node wijzigen\"\n};\n// Portuguese Brazil\nvar pt = {\n  addDescription: \"Clique em um espaço em branco para adicionar um novo nó\",\n  addEdge: \"Adicionar aresta\",\n  addNode: \"Adicionar nó\",\n  back: \"Voltar\",\n  close: \"Fechar\",\n  createEdgeError: \"Não foi possível linkar arestas a um cluster.\",\n  del: \"Remover selecionado\",\n  deleteClusterError: \"Clusters não puderam ser removidos.\",\n  edgeDescription: \"Clique em um nó e arraste a aresta até outro nó para conectá-los\",\n  edit: \"Editar\",\n  editClusterError: \"Clusters não puderam ser editados.\",\n  editEdge: \"Editar aresta\",\n  editEdgeDescription: \"Clique nos pontos de controle e os arraste para um nó para conectá-los\",\n  editNode: \"Editar nó\"\n};\n// Russian\nvar ru = {\n  addDescription: \"Кликните в свободное место, чтобы добавить новый узел.\",\n  addEdge: \"Добавить ребро\",\n  addNode: \"Добавить узел\",\n  back: \"Назад\",\n  close: \"Закрывать\",\n  createEdgeError: \"Невозможно соединить ребра в кластер.\",\n  del: \"Удалить выбранное\",\n  deleteClusterError: \"Кластеры не могут быть удалены\",\n  edgeDescription: \"Кликните на узел и протяните ребро к другому узлу, чтобы соединить их.\",\n  edit: \"Редактировать\",\n  editClusterError: \"Кластеры недоступны для редактирования.\",\n  editEdge: \"Редактировать ребро\",\n  editEdgeDescription: \"Кликните на контрольные точки и перетащите их в узел, чтобы подключиться к нему.\",\n  editNode: \"Редактировать узел\"\n};\n// Chinese\nvar cn = {\n  addDescription: \"单击空白处放置新节点。\",\n  addEdge: \"添加连接线\",\n  addNode: \"添加节点\",\n  back: \"返回\",\n  close: \"關閉\",\n  createEdgeError: \"无法将连接线连接到群集。\",\n  del: \"删除选定\",\n  deleteClusterError: \"无法删除群集。\",\n  edgeDescription: \"单击某个节点并将该连接线拖动到另一个节点以连接它们。\",\n  edit: \"编辑\",\n  editClusterError: \"无法编辑群集。\",\n  editEdge: \"编辑连接线\",\n  editEdgeDescription: \"单击控制节点并将它们拖到节点上连接。\",\n  editNode: \"编辑节点\"\n};\n// Ukrainian\nvar uk = {\n  addDescription: \"Kлікніть на вільне місце, щоб додати новий вузол.\",\n  addEdge: \"Додати край\",\n  addNode: \"Додати вузол\",\n  back: \"Назад\",\n  close: \"Закрити\",\n  createEdgeError: \"Не можливо об'єднати краї в групу.\",\n  del: \"Видалити обране\",\n  deleteClusterError: \"Групи не можуть бути видалені.\",\n  edgeDescription: \"Клікніть на вузол і перетягніть край до іншого вузла, щоб їх з'єднати.\",\n  edit: \"Редагувати\",\n  editClusterError: \"Групи недоступні для редагування.\",\n  editEdge: \"Редагувати край\",\n  editEdgeDescription: \"Клікніть на контрольні точки і перетягніть їх у вузол, щоб підключитися до нього.\",\n  editNode: \"Редагувати вузол\"\n};\n// French\nvar fr = {\n  addDescription: \"Cliquez dans un endroit vide pour placer un nœud.\",\n  addEdge: \"Ajouter un lien\",\n  addNode: \"Ajouter un nœud\",\n  back: \"Retour\",\n  close: \"Fermer\",\n  createEdgeError: \"Impossible de créer un lien vers un cluster.\",\n  del: \"Effacer la sélection\",\n  deleteClusterError: \"Les clusters ne peuvent pas être effacés.\",\n  edgeDescription: \"Cliquez sur un nœud et glissez le lien vers un autre nœud pour les connecter.\",\n  edit: \"Éditer\",\n  editClusterError: \"Les clusters ne peuvent pas être édités.\",\n  editEdge: \"Éditer le lien\",\n  editEdgeDescription: \"Cliquez sur les points de contrôle et glissez-les pour connecter un nœud.\",\n  editNode: \"Éditer le nœud\"\n};\n// Czech\nvar cs = {\n  addDescription: \"Kluknutím do prázdného prostoru můžete přidat nový vrchol.\",\n  addEdge: \"Přidat hranu\",\n  addNode: \"Přidat vrchol\",\n  back: \"Zpět\",\n  close: \"Zavřít\",\n  createEdgeError: \"Nelze připojit hranu ke shluku.\",\n  del: \"Smazat výběr\",\n  deleteClusterError: \"Nelze mazat shluky.\",\n  edgeDescription: \"Přetažením z jednoho vrcholu do druhého můžete spojit tyto vrcholy novou hranou.\",\n  edit: \"Upravit\",\n  editClusterError: \"Nelze upravovat shluky.\",\n  editEdge: \"Upravit hranu\",\n  editEdgeDescription: \"Přetažením kontrolního vrcholu hrany ji můžete připojit k jinému vrcholu.\",\n  editNode: \"Upravit vrchol\"\n};\n\nvar locales = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tcn: cn,\n\tcs: cs,\n\tde: de,\n\ten: en,\n\tes: es,\n\tfr: fr,\n\tit: it,\n\tnl: nl,\n\tpt: pt,\n\tru: ru,\n\tuk: uk\n});\n\n/**\r\n * Normalizes language code into the format used internally.\r\n *\r\n * @param locales - All the available locales.\r\n * @param rawCode - The original code as supplied by the user.\r\n * @returns Language code in the format language-COUNTRY or language, eventually\r\n * fallbacks to en.\r\n */\nfunction normalizeLanguageCode(locales, rawCode) {\n  try {\n    var _rawCode$split = rawCode.split(/[-_ /]/, 2),\n      _rawCode$split2 = _slicedToArray(_rawCode$split, 2),\n      rawLanguage = _rawCode$split2[0],\n      rawCountry = _rawCode$split2[1];\n    var language = rawLanguage != null ? rawLanguage.toLowerCase() : null;\n    var country = rawCountry != null ? rawCountry.toUpperCase() : null;\n    if (language && country) {\n      var code = language + \"-\" + country;\n      if (Object.prototype.hasOwnProperty.call(locales, code)) {\n        return code;\n      } else {\n        var _context;\n        console.warn(_concatInstanceProperty(_context = \"Unknown variant \".concat(country, \" of language \")).call(_context, language, \".\"));\n      }\n    }\n    if (language) {\n      var _code = language;\n      if (Object.prototype.hasOwnProperty.call(locales, _code)) {\n        return _code;\n      } else {\n        console.warn(\"Unknown language \".concat(language));\n      }\n    }\n    console.warn(\"Unknown locale \".concat(rawCode, \", falling back to English.\"));\n    return \"en\";\n  } catch (error) {\n    console.error(error);\n    console.warn(\"Unexpected error while normalizing locale \".concat(rawCode, \", falling back to English.\"));\n    return \"en\";\n  }\n}\n\n/**\n * Associates a canvas to a given image, containing a number of renderings\n * of the image at various sizes.\n *\n * This technique is known as 'mipmapping'.\n *\n * NOTE: Images can also be of type 'data:svg+xml`. This code also works\n *       for svg, but the mipmapping may not be necessary.\n *\n * @param {Image} image\n */\nvar CachedImage = /*#__PURE__*/function () {\n  /**\n   * @ignore\n   */\n  function CachedImage() {\n    _classCallCheck(this, CachedImage);\n    this.NUM_ITERATIONS = 4; // Number of items in the coordinates array\n\n    this.image = new Image();\n    this.canvas = document.createElement(\"canvas\");\n  }\n\n  /**\n   * Called when the image has been successfully loaded.\n   */\n  _createClass(CachedImage, [{\n    key: \"init\",\n    value: function init() {\n      if (this.initialized()) return;\n      this.src = this.image.src; // For same interface with Image\n      var w = this.image.width;\n      var h = this.image.height;\n\n      // Ease external access\n      this.width = w;\n      this.height = h;\n      var h2 = Math.floor(h / 2);\n      var h4 = Math.floor(h / 4);\n      var h8 = Math.floor(h / 8);\n      var h16 = Math.floor(h / 16);\n      var w2 = Math.floor(w / 2);\n      var w4 = Math.floor(w / 4);\n      var w8 = Math.floor(w / 8);\n      var w16 = Math.floor(w / 16);\n\n      // Make canvas as small as possible\n      this.canvas.width = 3 * w4;\n      this.canvas.height = h2;\n\n      // Coordinates and sizes of images contained in the canvas\n      // Values per row:  [top x, left y, width, height]\n\n      this.coordinates = [[0, 0, w2, h2], [w2, 0, w4, h4], [w2, h4, w8, h8], [5 * w8, h4, w16, h16]];\n      this._fillMipMap();\n    }\n\n    /**\n     * @returns {boolean} true if init() has been called, false otherwise.\n     */\n  }, {\n    key: \"initialized\",\n    value: function initialized() {\n      return this.coordinates !== undefined;\n    }\n\n    /**\n     * Redraw main image in various sizes to the context.\n     *\n     * The rationale behind this is to reduce artefacts due to interpolation\n     * at differing zoom levels.\n     *\n     * Source: http://stackoverflow.com/q/18761404/1223531\n     *\n     * This methods takes the resizing out of the drawing loop, in order to\n     * reduce performance overhead.\n     *\n     * TODO: The code assumes that a 2D context can always be gotten. This is\n     *       not necessarily true! OTOH, if not true then usage of this class\n     *       is senseless.\n     *\n     * @private\n     */\n  }, {\n    key: \"_fillMipMap\",\n    value: function _fillMipMap() {\n      var ctx = this.canvas.getContext(\"2d\");\n\n      // First zoom-level comes from the image\n      var to = this.coordinates[0];\n      ctx.drawImage(this.image, to[0], to[1], to[2], to[3]);\n\n      // The rest are copy actions internal to the canvas/context\n      for (var iterations = 1; iterations < this.NUM_ITERATIONS; iterations++) {\n        var from = this.coordinates[iterations - 1];\n        var _to = this.coordinates[iterations];\n        ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], _to[0], _to[1], _to[2], _to[3]);\n      }\n    }\n\n    /**\n     * Draw the image, using the mipmap if necessary.\n     *\n     * MipMap is only used if param factor > 2; otherwise, original bitmap\n     * is resized. This is also used to skip mipmap usage, e.g. by setting factor = 1\n     *\n     * Credits to 'Alex de Mulder' for original implementation.\n     *\n     * @param {CanvasRenderingContext2D} ctx  context on which to draw zoomed image\n     * @param {Float} factor scale factor at which to draw\n     * @param {number} left\n     * @param {number} top\n     * @param {number} width\n     * @param {number} height\n     */\n  }, {\n    key: \"drawImageAtPosition\",\n    value: function drawImageAtPosition(ctx, factor, left, top, width, height) {\n      if (!this.initialized()) return; //can't draw image yet not intialized\n\n      if (factor > 2) {\n        // Determine which zoomed image to use\n        factor *= 0.5;\n        var iterations = 0;\n        while (factor > 2 && iterations < this.NUM_ITERATIONS) {\n          factor *= 0.5;\n          iterations += 1;\n        }\n        if (iterations >= this.NUM_ITERATIONS) {\n          iterations = this.NUM_ITERATIONS - 1;\n        }\n        //console.log(\"iterations: \" + iterations);\n\n        var from = this.coordinates[iterations];\n        ctx.drawImage(this.canvas, from[0], from[1], from[2], from[3], left, top, width, height);\n      } else {\n        // Draw image directly\n        ctx.drawImage(this.image, left, top, width, height);\n      }\n    }\n  }]);\n  return CachedImage;\n}();\n\n/**\n * This callback is a callback that accepts an Image.\n *\n * @callback ImageCallback\n * @param {Image} image\n */\n\n/**\n * This class loads images and keeps them stored.\n *\n * @param {ImageCallback} callback\n */\nvar Images = /*#__PURE__*/function () {\n  /**\n   * @param {ImageCallback} callback\n   */\n  function Images(callback) {\n    _classCallCheck(this, Images);\n    this.images = {};\n    this.imageBroken = {};\n    this.callback = callback;\n  }\n\n  /**\n   * @param {string} url                      The original Url that failed to load, if the broken image is successfully loaded it will be added to the cache using this Url as the key so that subsequent requests for this Url will return the broken image\n   * @param {string} brokenUrl                Url the broken image to try and load\n   * @param {Image} imageToLoadBrokenUrlOn   The image object\n   */\n  _createClass(Images, [{\n    key: \"_tryloadBrokenUrl\",\n    value: function _tryloadBrokenUrl(url, brokenUrl, imageToLoadBrokenUrlOn) {\n      //If these parameters aren't specified then exit the function because nothing constructive can be done\n      if (url === undefined || imageToLoadBrokenUrlOn === undefined) return;\n      if (brokenUrl === undefined) {\n        console.warn(\"No broken url image defined\");\n        return;\n      }\n\n      //Clear the old subscription to the error event and put a new in place that only handle errors in loading the brokenImageUrl\n      imageToLoadBrokenUrlOn.image.onerror = function () {\n        console.error(\"Could not load brokenImage:\", brokenUrl);\n        // cache item will contain empty image, this should be OK for default\n      };\n\n      //Set the source of the image to the brokenUrl, this is actually what kicks off the loading of the broken image\n      imageToLoadBrokenUrlOn.image.src = brokenUrl;\n    }\n\n    /**\n     *\n     * @param {vis.Image} imageToRedrawWith\n     * @private\n     */\n  }, {\n    key: \"_redrawWithImage\",\n    value: function _redrawWithImage(imageToRedrawWith) {\n      if (this.callback) {\n        this.callback(imageToRedrawWith);\n      }\n    }\n\n    /**\n     * @param {string} url          Url of the image\n     * @param {string} brokenUrl    Url of an image to use if the url image is not found\n     * @returns {Image} img          The image object\n     */\n  }, {\n    key: \"load\",\n    value: function load(url, brokenUrl) {\n      var _this = this;\n      //Try and get the image from the cache, if successful then return the cached image\n      var cachedImage = this.images[url];\n      if (cachedImage) return cachedImage;\n\n      //Create a new image\n      var img = new CachedImage();\n\n      // Need to add to cache here, otherwise final return will spawn different copies of the same image,\n      // Also, there will be multiple loads of the same image.\n      this.images[url] = img;\n\n      //Subscribe to the event that is raised if the image loads successfully\n      img.image.onload = function () {\n        // Properly init the cached item and then request a redraw\n        _this._fixImageCoordinates(img.image);\n        img.init();\n        _this._redrawWithImage(img);\n      };\n\n      //Subscribe to the event that is raised if the image fails to load\n      img.image.onerror = function () {\n        console.error(\"Could not load image:\", url);\n        //Try and load the image specified by the brokenUrl using\n        _this._tryloadBrokenUrl(url, brokenUrl, img);\n      };\n\n      //Set the source of the image to the url, this is what actually kicks off the loading of the image\n      img.image.src = url;\n\n      //Return the new image\n      return img;\n    }\n\n    /**\n     * IE11 fix -- thanks dponch!\n     *\n     * Local helper function\n     *\n     * @param {vis.Image} imageToCache\n     * @private\n     */\n  }, {\n    key: \"_fixImageCoordinates\",\n    value: function _fixImageCoordinates(imageToCache) {\n      if (imageToCache.width === 0) {\n        document.body.appendChild(imageToCache);\n        imageToCache.width = imageToCache.offsetWidth;\n        imageToCache.height = imageToCache.offsetHeight;\n        document.body.removeChild(imageToCache);\n      }\n    }\n  }]);\n  return Images;\n}();\n\nvar internalMetadata = {exports: {}};\n\n// FF26- bug: ArrayBuffers are non-extensible, but Object.isExtensible does not report it\nvar fails$9 = fails$w;\n\nvar arrayBufferNonExtensible = fails$9(function () {\n  if (typeof ArrayBuffer == 'function') {\n    var buffer = new ArrayBuffer(8);\n    // eslint-disable-next-line es/no-object-isextensible, es/no-object-defineproperty -- safe\n    if (Object.isExtensible(buffer)) Object.defineProperty(buffer, 'a', { value: 8 });\n  }\n});\n\nvar fails$8 = fails$w;\nvar isObject$6 = isObject$j;\nvar classof$2 = classofRaw$2;\nvar ARRAY_BUFFER_NON_EXTENSIBLE = arrayBufferNonExtensible;\n\n// eslint-disable-next-line es/no-object-isextensible -- safe\nvar $isExtensible = Object.isExtensible;\nvar FAILS_ON_PRIMITIVES$1 = fails$8(function () { $isExtensible(1); });\n\n// `Object.isExtensible` method\n// https://tc39.es/ecma262/#sec-object.isextensible\nvar objectIsExtensible = (FAILS_ON_PRIMITIVES$1 || ARRAY_BUFFER_NON_EXTENSIBLE) ? function isExtensible(it) {\n  if (!isObject$6(it)) return false;\n  if (ARRAY_BUFFER_NON_EXTENSIBLE && classof$2(it) === 'ArrayBuffer') return false;\n  return $isExtensible ? $isExtensible(it) : true;\n} : $isExtensible;\n\nvar fails$7 = fails$w;\n\nvar freezing = !fails$7(function () {\n  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing\n  return Object.isExtensible(Object.preventExtensions({}));\n});\n\nvar $$g = _export;\nvar uncurryThis$4 = functionUncurryThis;\nvar hiddenKeys = hiddenKeys$6;\nvar isObject$5 = isObject$j;\nvar hasOwn$3 = hasOwnProperty_1;\nvar defineProperty$2 = objectDefineProperty.f;\nvar getOwnPropertyNamesModule = objectGetOwnPropertyNames;\nvar getOwnPropertyNamesExternalModule = objectGetOwnPropertyNamesExternal;\nvar isExtensible$1 = objectIsExtensible;\nvar uid = uid$4;\nvar FREEZING$1 = freezing;\n\nvar REQUIRED = false;\nvar METADATA = uid('meta');\nvar id$1 = 0;\n\nvar setMetadata = function (it) {\n  defineProperty$2(it, METADATA, { value: {\n    objectID: 'O' + id$1++, // object ID\n    weakData: {}          // weak collections IDs\n  } });\n};\n\nvar fastKey$1 = function (it, create) {\n  // return a primitive with prefix\n  if (!isObject$5(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!hasOwn$3(it, METADATA)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible$1(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMetadata(it);\n  // return object ID\n  } return it[METADATA].objectID;\n};\n\nvar getWeakData$1 = function (it, create) {\n  if (!hasOwn$3(it, METADATA)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible$1(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMetadata(it);\n  // return the store of weak collections IDs\n  } return it[METADATA].weakData;\n};\n\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZING$1 && REQUIRED && isExtensible$1(it) && !hasOwn$3(it, METADATA)) setMetadata(it);\n  return it;\n};\n\nvar enable = function () {\n  meta.enable = function () { /* empty */ };\n  REQUIRED = true;\n  var getOwnPropertyNames = getOwnPropertyNamesModule.f;\n  var splice = uncurryThis$4([].splice);\n  var test = {};\n  test[METADATA] = 1;\n\n  // prevent exposing of metadata key\n  if (getOwnPropertyNames(test).length) {\n    getOwnPropertyNamesModule.f = function (it) {\n      var result = getOwnPropertyNames(it);\n      for (var i = 0, length = result.length; i < length; i++) {\n        if (result[i] === METADATA) {\n          splice(result, i, 1);\n          break;\n        }\n      } return result;\n    };\n\n    $$g({ target: 'Object', stat: true, forced: true }, {\n      getOwnPropertyNames: getOwnPropertyNamesExternalModule.f\n    });\n  }\n};\n\nvar meta = internalMetadata.exports = {\n  enable: enable,\n  fastKey: fastKey$1,\n  getWeakData: getWeakData$1,\n  onFreeze: onFreeze\n};\n\nhiddenKeys[METADATA] = true;\n\nvar internalMetadataExports = internalMetadata.exports;\n\nvar bind$5 = functionBindContext;\nvar call$1 = functionCall;\nvar anObject$3 = anObject$d;\nvar tryToString$1 = tryToString$6;\nvar isArrayIteratorMethod = isArrayIteratorMethod$2;\nvar lengthOfArrayLike$2 = lengthOfArrayLike$c;\nvar isPrototypeOf$6 = objectIsPrototypeOf;\nvar getIterator = getIterator$2;\nvar getIteratorMethod = getIteratorMethod$9;\nvar iteratorClose = iteratorClose$2;\n\nvar $TypeError$3 = TypeError;\n\nvar Result = function (stopped, result) {\n  this.stopped = stopped;\n  this.result = result;\n};\n\nvar ResultPrototype = Result.prototype;\n\nvar iterate$3 = function (iterable, unboundFunction, options) {\n  var that = options && options.that;\n  var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n  var IS_RECORD = !!(options && options.IS_RECORD);\n  var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n  var INTERRUPTED = !!(options && options.INTERRUPTED);\n  var fn = bind$5(unboundFunction, that);\n  var iterator, iterFn, index, length, result, next, step;\n\n  var stop = function (condition) {\n    if (iterator) iteratorClose(iterator, 'normal', condition);\n    return new Result(true, condition);\n  };\n\n  var callFn = function (value) {\n    if (AS_ENTRIES) {\n      anObject$3(value);\n      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n    } return INTERRUPTED ? fn(value, stop) : fn(value);\n  };\n\n  if (IS_RECORD) {\n    iterator = iterable.iterator;\n  } else if (IS_ITERATOR) {\n    iterator = iterable;\n  } else {\n    iterFn = getIteratorMethod(iterable);\n    if (!iterFn) throw new $TypeError$3(tryToString$1(iterable) + ' is not iterable');\n    // optimisation for array iterators\n    if (isArrayIteratorMethod(iterFn)) {\n      for (index = 0, length = lengthOfArrayLike$2(iterable); length > index; index++) {\n        result = callFn(iterable[index]);\n        if (result && isPrototypeOf$6(ResultPrototype, result)) return result;\n      } return new Result(false);\n    }\n    iterator = getIterator(iterable, iterFn);\n  }\n\n  next = IS_RECORD ? iterable.next : iterator.next;\n  while (!(step = call$1(next, iterator)).done) {\n    try {\n      result = callFn(step.value);\n    } catch (error) {\n      iteratorClose(iterator, 'throw', error);\n    }\n    if (typeof result == 'object' && result && isPrototypeOf$6(ResultPrototype, result)) return result;\n  } return new Result(false);\n};\n\nvar isPrototypeOf$5 = objectIsPrototypeOf;\n\nvar $TypeError$2 = TypeError;\n\nvar anInstance$3 = function (it, Prototype) {\n  if (isPrototypeOf$5(Prototype, it)) return it;\n  throw new $TypeError$2('Incorrect invocation');\n};\n\nvar $$f = _export;\nvar global$5 = global$n;\nvar InternalMetadataModule$1 = internalMetadataExports;\nvar fails$6 = fails$w;\nvar createNonEnumerableProperty = createNonEnumerableProperty$6;\nvar iterate$2 = iterate$3;\nvar anInstance$2 = anInstance$3;\nvar isCallable = isCallable$i;\nvar isObject$4 = isObject$j;\nvar isNullOrUndefined$2 = isNullOrUndefined$6;\nvar setToStringTag = setToStringTag$6;\nvar defineProperty$1 = objectDefineProperty.f;\nvar forEach = arrayIteration.forEach;\nvar DESCRIPTORS$5 = descriptors;\nvar InternalStateModule$2 = internalState;\n\nvar setInternalState$2 = InternalStateModule$2.set;\nvar internalStateGetterFor$2 = InternalStateModule$2.getterFor;\n\nvar collection$3 = function (CONSTRUCTOR_NAME, wrapper, common) {\n  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;\n  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;\n  var ADDER = IS_MAP ? 'set' : 'add';\n  var NativeConstructor = global$5[CONSTRUCTOR_NAME];\n  var NativePrototype = NativeConstructor && NativeConstructor.prototype;\n  var exported = {};\n  var Constructor;\n\n  if (!DESCRIPTORS$5 || !isCallable(NativeConstructor)\n    || !(IS_WEAK || NativePrototype.forEach && !fails$6(function () { new NativeConstructor().entries().next(); }))\n  ) {\n    // create collection constructor\n    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);\n    InternalMetadataModule$1.enable();\n  } else {\n    Constructor = wrapper(function (target, iterable) {\n      setInternalState$2(anInstance$2(target, Prototype), {\n        type: CONSTRUCTOR_NAME,\n        collection: new NativeConstructor()\n      });\n      if (!isNullOrUndefined$2(iterable)) iterate$2(iterable, target[ADDER], { that: target, AS_ENTRIES: IS_MAP });\n    });\n\n    var Prototype = Constructor.prototype;\n\n    var getInternalState = internalStateGetterFor$2(CONSTRUCTOR_NAME);\n\n    forEach(['add', 'clear', 'delete', 'forEach', 'get', 'has', 'set', 'keys', 'values', 'entries'], function (KEY) {\n      var IS_ADDER = KEY === 'add' || KEY === 'set';\n      if (KEY in NativePrototype && !(IS_WEAK && KEY === 'clear')) {\n        createNonEnumerableProperty(Prototype, KEY, function (a, b) {\n          var collection = getInternalState(this).collection;\n          if (!IS_ADDER && IS_WEAK && !isObject$4(a)) return KEY === 'get' ? undefined : false;\n          var result = collection[KEY](a === 0 ? 0 : a, b);\n          return IS_ADDER ? this : result;\n        });\n      }\n    });\n\n    IS_WEAK || defineProperty$1(Prototype, 'size', {\n      configurable: true,\n      get: function () {\n        return getInternalState(this).collection.size;\n      }\n    });\n  }\n\n  setToStringTag(Constructor, CONSTRUCTOR_NAME, false, true);\n\n  exported[CONSTRUCTOR_NAME] = Constructor;\n  $$f({ global: true, forced: true }, exported);\n\n  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);\n\n  return Constructor;\n};\n\nvar defineBuiltIn = defineBuiltIn$5;\n\nvar defineBuiltIns$3 = function (target, src, options) {\n  for (var key in src) {\n    if (options && options.unsafe && target[key]) target[key] = src[key];\n    else defineBuiltIn(target, key, src[key], options);\n  } return target;\n};\n\nvar getBuiltIn$1 = getBuiltIn$c;\nvar defineBuiltInAccessor$1 = defineBuiltInAccessor$3;\nvar wellKnownSymbol = wellKnownSymbol$m;\nvar DESCRIPTORS$4 = descriptors;\n\nvar SPECIES = wellKnownSymbol('species');\n\nvar setSpecies$1 = function (CONSTRUCTOR_NAME) {\n  var Constructor = getBuiltIn$1(CONSTRUCTOR_NAME);\n\n  if (DESCRIPTORS$4 && Constructor && !Constructor[SPECIES]) {\n    defineBuiltInAccessor$1(Constructor, SPECIES, {\n      configurable: true,\n      get: function () { return this; }\n    });\n  }\n};\n\nvar create$4 = objectCreate;\nvar defineBuiltInAccessor = defineBuiltInAccessor$3;\nvar defineBuiltIns$2 = defineBuiltIns$3;\nvar bind$4 = functionBindContext;\nvar anInstance$1 = anInstance$3;\nvar isNullOrUndefined$1 = isNullOrUndefined$6;\nvar iterate$1 = iterate$3;\nvar defineIterator = iteratorDefine;\nvar createIterResultObject = createIterResultObject$3;\nvar setSpecies = setSpecies$1;\nvar DESCRIPTORS$3 = descriptors;\nvar fastKey = internalMetadataExports.fastKey;\nvar InternalStateModule$1 = internalState;\n\nvar setInternalState$1 = InternalStateModule$1.set;\nvar internalStateGetterFor$1 = InternalStateModule$1.getterFor;\n\nvar collectionStrong$2 = {\n  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n    var Constructor = wrapper(function (that, iterable) {\n      anInstance$1(that, Prototype);\n      setInternalState$1(that, {\n        type: CONSTRUCTOR_NAME,\n        index: create$4(null),\n        first: undefined,\n        last: undefined,\n        size: 0\n      });\n      if (!DESCRIPTORS$3) that.size = 0;\n      if (!isNullOrUndefined$1(iterable)) iterate$1(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });\n    });\n\n    var Prototype = Constructor.prototype;\n\n    var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);\n\n    var define = function (that, key, value) {\n      var state = getInternalState(that);\n      var entry = getEntry(that, key);\n      var previous, index;\n      // change existing entry\n      if (entry) {\n        entry.value = value;\n      // create new entry\n      } else {\n        state.last = entry = {\n          index: index = fastKey(key, true),\n          key: key,\n          value: value,\n          previous: previous = state.last,\n          next: undefined,\n          removed: false\n        };\n        if (!state.first) state.first = entry;\n        if (previous) previous.next = entry;\n        if (DESCRIPTORS$3) state.size++;\n        else that.size++;\n        // add to index\n        if (index !== 'F') state.index[index] = entry;\n      } return that;\n    };\n\n    var getEntry = function (that, key) {\n      var state = getInternalState(that);\n      // fast case\n      var index = fastKey(key);\n      var entry;\n      if (index !== 'F') return state.index[index];\n      // frozen object case\n      for (entry = state.first; entry; entry = entry.next) {\n        if (entry.key === key) return entry;\n      }\n    };\n\n    defineBuiltIns$2(Prototype, {\n      // `{ Map, Set }.prototype.clear()` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.clear\n      // https://tc39.es/ecma262/#sec-set.prototype.clear\n      clear: function clear() {\n        var that = this;\n        var state = getInternalState(that);\n        var data = state.index;\n        var entry = state.first;\n        while (entry) {\n          entry.removed = true;\n          if (entry.previous) entry.previous = entry.previous.next = undefined;\n          delete data[entry.index];\n          entry = entry.next;\n        }\n        state.first = state.last = undefined;\n        if (DESCRIPTORS$3) state.size = 0;\n        else that.size = 0;\n      },\n      // `{ Map, Set }.prototype.delete(key)` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.delete\n      // https://tc39.es/ecma262/#sec-set.prototype.delete\n      'delete': function (key) {\n        var that = this;\n        var state = getInternalState(that);\n        var entry = getEntry(that, key);\n        if (entry) {\n          var next = entry.next;\n          var prev = entry.previous;\n          delete state.index[entry.index];\n          entry.removed = true;\n          if (prev) prev.next = next;\n          if (next) next.previous = prev;\n          if (state.first === entry) state.first = next;\n          if (state.last === entry) state.last = prev;\n          if (DESCRIPTORS$3) state.size--;\n          else that.size--;\n        } return !!entry;\n      },\n      // `{ Map, Set }.prototype.forEach(callbackfn, thisArg = undefined)` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.foreach\n      // https://tc39.es/ecma262/#sec-set.prototype.foreach\n      forEach: function forEach(callbackfn /* , that = undefined */) {\n        var state = getInternalState(this);\n        var boundFunction = bind$4(callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n        var entry;\n        while (entry = entry ? entry.next : state.first) {\n          boundFunction(entry.value, entry.key, this);\n          // revert to the last existing entry\n          while (entry && entry.removed) entry = entry.previous;\n        }\n      },\n      // `{ Map, Set}.prototype.has(key)` methods\n      // https://tc39.es/ecma262/#sec-map.prototype.has\n      // https://tc39.es/ecma262/#sec-set.prototype.has\n      has: function has(key) {\n        return !!getEntry(this, key);\n      }\n    });\n\n    defineBuiltIns$2(Prototype, IS_MAP ? {\n      // `Map.prototype.get(key)` method\n      // https://tc39.es/ecma262/#sec-map.prototype.get\n      get: function get(key) {\n        var entry = getEntry(this, key);\n        return entry && entry.value;\n      },\n      // `Map.prototype.set(key, value)` method\n      // https://tc39.es/ecma262/#sec-map.prototype.set\n      set: function set(key, value) {\n        return define(this, key === 0 ? 0 : key, value);\n      }\n    } : {\n      // `Set.prototype.add(value)` method\n      // https://tc39.es/ecma262/#sec-set.prototype.add\n      add: function add(value) {\n        return define(this, value = value === 0 ? 0 : value, value);\n      }\n    });\n    if (DESCRIPTORS$3) defineBuiltInAccessor(Prototype, 'size', {\n      configurable: true,\n      get: function () {\n        return getInternalState(this).size;\n      }\n    });\n    return Constructor;\n  },\n  setStrong: function (Constructor, CONSTRUCTOR_NAME, IS_MAP) {\n    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';\n    var getInternalCollectionState = internalStateGetterFor$1(CONSTRUCTOR_NAME);\n    var getInternalIteratorState = internalStateGetterFor$1(ITERATOR_NAME);\n    // `{ Map, Set }.prototype.{ keys, values, entries, @@iterator }()` methods\n    // https://tc39.es/ecma262/#sec-map.prototype.entries\n    // https://tc39.es/ecma262/#sec-map.prototype.keys\n    // https://tc39.es/ecma262/#sec-map.prototype.values\n    // https://tc39.es/ecma262/#sec-map.prototype-@@iterator\n    // https://tc39.es/ecma262/#sec-set.prototype.entries\n    // https://tc39.es/ecma262/#sec-set.prototype.keys\n    // https://tc39.es/ecma262/#sec-set.prototype.values\n    // https://tc39.es/ecma262/#sec-set.prototype-@@iterator\n    defineIterator(Constructor, CONSTRUCTOR_NAME, function (iterated, kind) {\n      setInternalState$1(this, {\n        type: ITERATOR_NAME,\n        target: iterated,\n        state: getInternalCollectionState(iterated),\n        kind: kind,\n        last: undefined\n      });\n    }, function () {\n      var state = getInternalIteratorState(this);\n      var kind = state.kind;\n      var entry = state.last;\n      // revert to the last existing entry\n      while (entry && entry.removed) entry = entry.previous;\n      // get next entry\n      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {\n        // or finish the iteration\n        state.target = undefined;\n        return createIterResultObject(undefined, true);\n      }\n      // return step by kind\n      if (kind === 'keys') return createIterResultObject(entry.key, false);\n      if (kind === 'values') return createIterResultObject(entry.value, false);\n      return createIterResultObject([entry.key, entry.value], false);\n    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);\n\n    // `{ Map, Set }.prototype[@@species]` accessors\n    // https://tc39.es/ecma262/#sec-get-map-@@species\n    // https://tc39.es/ecma262/#sec-get-set-@@species\n    setSpecies(CONSTRUCTOR_NAME);\n  }\n};\n\nvar collection$2 = collection$3;\nvar collectionStrong$1 = collectionStrong$2;\n\n// `Map` constructor\n// https://tc39.es/ecma262/#sec-map-objects\ncollection$2('Map', function (init) {\n  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };\n}, collectionStrong$1);\n\nvar path$f = path$w;\n\nvar map$2 = path$f.Map;\n\nvar parent$v = map$2;\n\n\nvar map$1 = parent$v;\n\nvar map = map$1;\n\nvar _Map = /*@__PURE__*/getDefaultExportFromCjs(map);\n\n/**\n * This class can store groups and options specific for groups.\n */\nvar Groups = /*#__PURE__*/function () {\n  /**\n   * @ignore\n   */\n  function Groups() {\n    _classCallCheck(this, Groups);\n    this.clear();\n    this._defaultIndex = 0;\n    this._groupIndex = 0;\n    this._defaultGroups = [{\n      border: \"#2B7CE9\",\n      background: \"#97C2FC\",\n      highlight: {\n        border: \"#2B7CE9\",\n        background: \"#D2E5FF\"\n      },\n      hover: {\n        border: \"#2B7CE9\",\n        background: \"#D2E5FF\"\n      }\n    },\n    // 0: blue\n    {\n      border: \"#FFA500\",\n      background: \"#FFFF00\",\n      highlight: {\n        border: \"#FFA500\",\n        background: \"#FFFFA3\"\n      },\n      hover: {\n        border: \"#FFA500\",\n        background: \"#FFFFA3\"\n      }\n    },\n    // 1: yellow\n    {\n      border: \"#FA0A10\",\n      background: \"#FB7E81\",\n      highlight: {\n        border: \"#FA0A10\",\n        background: \"#FFAFB1\"\n      },\n      hover: {\n        border: \"#FA0A10\",\n        background: \"#FFAFB1\"\n      }\n    },\n    // 2: red\n    {\n      border: \"#41A906\",\n      background: \"#7BE141\",\n      highlight: {\n        border: \"#41A906\",\n        background: \"#A1EC76\"\n      },\n      hover: {\n        border: \"#41A906\",\n        background: \"#A1EC76\"\n      }\n    },\n    // 3: green\n    {\n      border: \"#E129F0\",\n      background: \"#EB7DF4\",\n      highlight: {\n        border: \"#E129F0\",\n        background: \"#F0B3F5\"\n      },\n      hover: {\n        border: \"#E129F0\",\n        background: \"#F0B3F5\"\n      }\n    },\n    // 4: magenta\n    {\n      border: \"#7C29F0\",\n      background: \"#AD85E4\",\n      highlight: {\n        border: \"#7C29F0\",\n        background: \"#D3BDF0\"\n      },\n      hover: {\n        border: \"#7C29F0\",\n        background: \"#D3BDF0\"\n      }\n    },\n    // 5: purple\n    {\n      border: \"#C37F00\",\n      background: \"#FFA807\",\n      highlight: {\n        border: \"#C37F00\",\n        background: \"#FFCA66\"\n      },\n      hover: {\n        border: \"#C37F00\",\n        background: \"#FFCA66\"\n      }\n    },\n    // 6: orange\n    {\n      border: \"#4220FB\",\n      background: \"#6E6EFD\",\n      highlight: {\n        border: \"#4220FB\",\n        background: \"#9B9BFD\"\n      },\n      hover: {\n        border: \"#4220FB\",\n        background: \"#9B9BFD\"\n      }\n    },\n    // 7: darkblue\n    {\n      border: \"#FD5A77\",\n      background: \"#FFC0CB\",\n      highlight: {\n        border: \"#FD5A77\",\n        background: \"#FFD1D9\"\n      },\n      hover: {\n        border: \"#FD5A77\",\n        background: \"#FFD1D9\"\n      }\n    },\n    // 8: pink\n    {\n      border: \"#4AD63A\",\n      background: \"#C2FABC\",\n      highlight: {\n        border: \"#4AD63A\",\n        background: \"#E6FFE3\"\n      },\n      hover: {\n        border: \"#4AD63A\",\n        background: \"#E6FFE3\"\n      }\n    },\n    // 9: mint\n\n    {\n      border: \"#990000\",\n      background: \"#EE0000\",\n      highlight: {\n        border: \"#BB0000\",\n        background: \"#FF3333\"\n      },\n      hover: {\n        border: \"#BB0000\",\n        background: \"#FF3333\"\n      }\n    },\n    // 10:bright red\n\n    {\n      border: \"#FF6000\",\n      background: \"#FF6000\",\n      highlight: {\n        border: \"#FF6000\",\n        background: \"#FF6000\"\n      },\n      hover: {\n        border: \"#FF6000\",\n        background: \"#FF6000\"\n      }\n    },\n    // 12: real orange\n    {\n      border: \"#97C2FC\",\n      background: \"#2B7CE9\",\n      highlight: {\n        border: \"#D2E5FF\",\n        background: \"#2B7CE9\"\n      },\n      hover: {\n        border: \"#D2E5FF\",\n        background: \"#2B7CE9\"\n      }\n    },\n    // 13: blue\n    {\n      border: \"#399605\",\n      background: \"#255C03\",\n      highlight: {\n        border: \"#399605\",\n        background: \"#255C03\"\n      },\n      hover: {\n        border: \"#399605\",\n        background: \"#255C03\"\n      }\n    },\n    // 14: green\n    {\n      border: \"#B70054\",\n      background: \"#FF007E\",\n      highlight: {\n        border: \"#B70054\",\n        background: \"#FF007E\"\n      },\n      hover: {\n        border: \"#B70054\",\n        background: \"#FF007E\"\n      }\n    },\n    // 15: magenta\n    {\n      border: \"#AD85E4\",\n      background: \"#7C29F0\",\n      highlight: {\n        border: \"#D3BDF0\",\n        background: \"#7C29F0\"\n      },\n      hover: {\n        border: \"#D3BDF0\",\n        background: \"#7C29F0\"\n      }\n    },\n    // 16: purple\n    {\n      border: \"#4557FA\",\n      background: \"#000EA1\",\n      highlight: {\n        border: \"#6E6EFD\",\n        background: \"#000EA1\"\n      },\n      hover: {\n        border: \"#6E6EFD\",\n        background: \"#000EA1\"\n      }\n    },\n    // 17: darkblue\n    {\n      border: \"#FFC0CB\",\n      background: \"#FD5A77\",\n      highlight: {\n        border: \"#FFD1D9\",\n        background: \"#FD5A77\"\n      },\n      hover: {\n        border: \"#FFD1D9\",\n        background: \"#FD5A77\"\n      }\n    },\n    // 18: pink\n    {\n      border: \"#C2FABC\",\n      background: \"#74D66A\",\n      highlight: {\n        border: \"#E6FFE3\",\n        background: \"#74D66A\"\n      },\n      hover: {\n        border: \"#E6FFE3\",\n        background: \"#74D66A\"\n      }\n    },\n    // 19: mint\n\n    {\n      border: \"#EE0000\",\n      background: \"#990000\",\n      highlight: {\n        border: \"#FF3333\",\n        background: \"#BB0000\"\n      },\n      hover: {\n        border: \"#FF3333\",\n        background: \"#BB0000\"\n      }\n    } // 20:bright red\n    ];\n\n    this.options = {};\n    this.defaultOptions = {\n      useDefaultGroups: true\n    };\n    _Object$assign(this.options, this.defaultOptions);\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(Groups, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var optionFields = [\"useDefaultGroups\"];\n      if (options !== undefined) {\n        for (var groupName in options) {\n          if (Object.prototype.hasOwnProperty.call(options, groupName)) {\n            if (_indexOfInstanceProperty(optionFields).call(optionFields, groupName) === -1) {\n              var group = options[groupName];\n              this.add(groupName, group);\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Clear all groups\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._groups = new _Map();\n      this._groupNames = [];\n    }\n\n    /**\n     * Get group options of a groupname.\n     * If groupname is not found, a new group may be created.\n     *\n     * @param {*}       groupname     Can be a number, string, Date, etc.\n     * @param {boolean} [shouldCreate=true] If true, create a new group\n     * @returns {object} The found or created group\n     */\n  }, {\n    key: \"get\",\n    value: function get(groupname) {\n      var shouldCreate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var group = this._groups.get(groupname);\n      if (group === undefined && shouldCreate) {\n        if (this.options.useDefaultGroups === false && this._groupNames.length > 0) {\n          // create new group\n          var index = this._groupIndex % this._groupNames.length;\n          ++this._groupIndex;\n          group = {};\n          group.color = this._groups.get(this._groupNames[index]);\n          this._groups.set(groupname, group);\n        } else {\n          // create new group\n          var _index = this._defaultIndex % this._defaultGroups.length;\n          this._defaultIndex++;\n          group = {};\n          group.color = this._defaultGroups[_index];\n          this._groups.set(groupname, group);\n        }\n      }\n      return group;\n    }\n\n    /**\n     * Add custom group style.\n     *\n     * @param {string} groupName - The name of the group, a new group will be\n     * created if a group with the same name doesn't exist, otherwise the old\n     * groups style will be overwritten.\n     * @param {object} style - An object containing borderColor, backgroundColor,\n     * etc.\n     * @returns {object} The created group object.\n     */\n  }, {\n    key: \"add\",\n    value: function add(groupName, style) {\n      // Only push group name once to prevent duplicates which would consume more\n      // RAM and also skew the distribution towards more often updated groups,\n      // neither of which is desirable.\n      if (!this._groups.has(groupName)) {\n        this._groupNames.push(groupName);\n      }\n      this._groups.set(groupName, style);\n      return style;\n    }\n  }]);\n  return Groups;\n}();\n\nvar $$e = _export;\n\n// `Number.isNaN` method\n// https://tc39.es/ecma262/#sec-number.isnan\n$$e({ target: 'Number', stat: true }, {\n  isNaN: function isNaN(number) {\n    // eslint-disable-next-line no-self-compare -- NaN check\n    return number !== number;\n  }\n});\n\nvar path$e = path$w;\n\nvar isNan$2 = path$e.Number.isNaN;\n\nvar parent$u = isNan$2;\n\nvar isNan$1 = parent$u;\n\nvar isNan = isNan$1;\n\nvar _Number$isNaN = /*@__PURE__*/getDefaultExportFromCjs(isNan);\n\nvar global$4 = global$n;\n\nvar globalIsFinite = global$4.isFinite;\n\n// `Number.isFinite` method\n// https://tc39.es/ecma262/#sec-number.isfinite\n// eslint-disable-next-line es/no-number-isfinite -- safe\nvar numberIsFinite$1 = Number.isFinite || function isFinite(it) {\n  return typeof it == 'number' && globalIsFinite(it);\n};\n\nvar $$d = _export;\nvar numberIsFinite = numberIsFinite$1;\n\n// `Number.isFinite` method\n// https://tc39.es/ecma262/#sec-number.isfinite\n$$d({ target: 'Number', stat: true }, { isFinite: numberIsFinite });\n\nvar path$d = path$w;\n\nvar _isFinite$2 = path$d.Number.isFinite;\n\nvar parent$t = _isFinite$2;\n\nvar _isFinite$1 = parent$t;\n\nvar _isFinite = _isFinite$1;\n\nvar _Number$isFinite = /*@__PURE__*/getDefaultExportFromCjs(_isFinite);\n\nvar $$c = _export;\nvar $some = arrayIteration.some;\nvar arrayMethodIsStrict$3 = arrayMethodIsStrict$6;\n\nvar STRICT_METHOD$2 = arrayMethodIsStrict$3('some');\n\n// `Array.prototype.some` method\n// https://tc39.es/ecma262/#sec-array.prototype.some\n$$c({ target: 'Array', proto: true, forced: !STRICT_METHOD$2 }, {\n  some: function some(callbackfn /* , thisArg */) {\n    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar entryVirtual$4 = entryVirtual$i;\n\nvar some$3 = entryVirtual$4('Array').some;\n\nvar isPrototypeOf$4 = objectIsPrototypeOf;\nvar method$4 = some$3;\n\nvar ArrayPrototype$4 = Array.prototype;\n\nvar some$2 = function (it) {\n  var own = it.some;\n  return it === ArrayPrototype$4 || (isPrototypeOf$4(ArrayPrototype$4, it) && own === ArrayPrototype$4.some) ? method$4 : own;\n};\n\nvar parent$s = some$2;\n\nvar some$1 = parent$s;\n\nvar some = some$1;\n\nvar _someInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(some);\n\nvar path$c = path$w;\n\nvar getOwnPropertySymbols$2 = path$c.Object.getOwnPropertySymbols;\n\nvar parent$r = getOwnPropertySymbols$2;\n\nvar getOwnPropertySymbols$1 = parent$r;\n\nvar getOwnPropertySymbols = getOwnPropertySymbols$1;\n\nvar _Object$getOwnPropertySymbols = /*@__PURE__*/getDefaultExportFromCjs(getOwnPropertySymbols);\n\nvar getOwnPropertyDescriptor$6 = {exports: {}};\n\nvar $$b = _export;\nvar fails$5 = fails$w;\nvar toIndexedObject$1 = toIndexedObject$a;\nvar nativeGetOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;\nvar DESCRIPTORS$2 = descriptors;\n\nvar FORCED$5 = !DESCRIPTORS$2 || fails$5(function () { nativeGetOwnPropertyDescriptor(1); });\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\n$$b({ target: 'Object', stat: true, forced: FORCED$5, sham: !DESCRIPTORS$2 }, {\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {\n    return nativeGetOwnPropertyDescriptor(toIndexedObject$1(it), key);\n  }\n});\n\nvar path$b = path$w;\n\nvar Object$3 = path$b.Object;\n\nvar getOwnPropertyDescriptor$5 = getOwnPropertyDescriptor$6.exports = function getOwnPropertyDescriptor(it, key) {\n  return Object$3.getOwnPropertyDescriptor(it, key);\n};\n\nif (Object$3.getOwnPropertyDescriptor.sham) getOwnPropertyDescriptor$5.sham = true;\n\nvar getOwnPropertyDescriptorExports = getOwnPropertyDescriptor$6.exports;\n\nvar parent$q = getOwnPropertyDescriptorExports;\n\nvar getOwnPropertyDescriptor$4 = parent$q;\n\nvar getOwnPropertyDescriptor$3 = getOwnPropertyDescriptor$4;\n\nvar _Object$getOwnPropertyDescriptor$1 = /*@__PURE__*/getDefaultExportFromCjs(getOwnPropertyDescriptor$3);\n\nvar $$a = _export;\nvar DESCRIPTORS$1 = descriptors;\nvar ownKeys$4 = ownKeys$5;\nvar toIndexedObject = toIndexedObject$a;\nvar getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;\nvar createProperty = createProperty$6;\n\n// `Object.getOwnPropertyDescriptors` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors\n$$a({ target: 'Object', stat: true, sham: !DESCRIPTORS$1 }, {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {\n    var O = toIndexedObject(object);\n    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule$1.f;\n    var keys = ownKeys$4(O);\n    var result = {};\n    var index = 0;\n    var key, descriptor;\n    while (keys.length > index) {\n      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);\n      if (descriptor !== undefined) createProperty(result, key, descriptor);\n    }\n    return result;\n  }\n});\n\nvar path$a = path$w;\n\nvar getOwnPropertyDescriptors$2 = path$a.Object.getOwnPropertyDescriptors;\n\nvar parent$p = getOwnPropertyDescriptors$2;\n\nvar getOwnPropertyDescriptors$1 = parent$p;\n\nvar getOwnPropertyDescriptors = getOwnPropertyDescriptors$1;\n\nvar _Object$getOwnPropertyDescriptors = /*@__PURE__*/getDefaultExportFromCjs(getOwnPropertyDescriptors);\n\nvar defineProperties$4 = {exports: {}};\n\nvar $$9 = _export;\nvar DESCRIPTORS = descriptors;\nvar defineProperties$3 = objectDefineProperties.f;\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es/no-object-defineproperties -- safe\n$$9({ target: 'Object', stat: true, forced: Object.defineProperties !== defineProperties$3, sham: !DESCRIPTORS }, {\n  defineProperties: defineProperties$3\n});\n\nvar path$9 = path$w;\n\nvar Object$2 = path$9.Object;\n\nvar defineProperties$2 = defineProperties$4.exports = function defineProperties(T, D) {\n  return Object$2.defineProperties(T, D);\n};\n\nif (Object$2.defineProperties.sham) defineProperties$2.sham = true;\n\nvar definePropertiesExports = defineProperties$4.exports;\n\nvar parent$o = definePropertiesExports;\n\nvar defineProperties$1 = parent$o;\n\nvar defineProperties = defineProperties$1;\n\nvar _Object$defineProperties = /*@__PURE__*/getDefaultExportFromCjs(defineProperties);\n\nvar defineProperty = defineProperty$9;\n\nvar _Object$defineProperty = /*@__PURE__*/getDefaultExportFromCjs(defineProperty);\n\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    _Object$defineProperty$1(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nvar global$3 = global$n;\nvar fails$4 = fails$w;\nvar uncurryThis$3 = functionUncurryThis;\nvar toString$1 = toString$a;\nvar trim = stringTrim.trim;\nvar whitespaces = whitespaces$3;\n\nvar charAt = uncurryThis$3(''.charAt);\nvar $parseFloat$1 = global$3.parseFloat;\nvar Symbol$1 = global$3.Symbol;\nvar ITERATOR = Symbol$1 && Symbol$1.iterator;\nvar FORCED$4 = 1 / $parseFloat$1(whitespaces + '-0') !== -Infinity\n  // MS Edge 18- broken with boxed symbols\n  || (ITERATOR && !fails$4(function () { $parseFloat$1(Object(ITERATOR)); }));\n\n// `parseFloat` method\n// https://tc39.es/ecma262/#sec-parsefloat-string\nvar numberParseFloat = FORCED$4 ? function parseFloat(string) {\n  var trimmedString = trim(toString$1(string));\n  var result = $parseFloat$1(trimmedString);\n  return result === 0 && charAt(trimmedString, 0) === '-' ? -0 : result;\n} : $parseFloat$1;\n\nvar $$8 = _export;\nvar $parseFloat = numberParseFloat;\n\n// `parseFloat` method\n// https://tc39.es/ecma262/#sec-parsefloat-string\n$$8({ global: true, forced: parseFloat !== $parseFloat }, {\n  parseFloat: $parseFloat\n});\n\nvar path$8 = path$w;\n\nvar _parseFloat$3 = path$8.parseFloat;\n\nvar parent$n = _parseFloat$3;\n\nvar _parseFloat$2 = parent$n;\n\nvar _parseFloat = _parseFloat$2;\n\nvar _parseFloat$1 = /*@__PURE__*/getDefaultExportFromCjs(_parseFloat);\n\nvar $$7 = _export;\nvar fails$3 = fails$w;\nvar getOwnPropertyNames$3 = objectGetOwnPropertyNamesExternal.f;\n\n// eslint-disable-next-line es/no-object-getownpropertynames -- required for testing\nvar FAILS_ON_PRIMITIVES = fails$3(function () { return !Object.getOwnPropertyNames(1); });\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n$$7({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {\n  getOwnPropertyNames: getOwnPropertyNames$3\n});\n\nvar path$7 = path$w;\n\nvar Object$1 = path$7.Object;\n\nvar getOwnPropertyNames$2 = function getOwnPropertyNames(it) {\n  return Object$1.getOwnPropertyNames(it);\n};\n\nvar parent$m = getOwnPropertyNames$2;\n\nvar getOwnPropertyNames$1 = parent$m;\n\nvar getOwnPropertyNames = getOwnPropertyNames$1;\n\nvar _Object$getOwnPropertyNames = /*@__PURE__*/getDefaultExportFromCjs(getOwnPropertyNames);\n\n/**\n * Helper functions for components\n */\n\n/**\n * Determine values to use for (sub)options of 'chosen'.\n *\n * This option is either a boolean or an object whose values should be examined further.\n * The relevant structures are:\n *\n * - chosen: <boolean value>\n * - chosen: { subOption: <boolean or function> }\n *\n * Where subOption is 'node', 'edge' or 'label'.\n *\n * The intention of this method appears to be to set a specific priority to the options;\n * Since most properties are either bridged or merged into the local options objects, there\n * is not much point in handling them separately.\n * TODO: examine if 'most' in previous sentence can be replaced with 'all'. In that case, we\n *       should be able to get rid of this method.\n *\n * @param {string}  subOption  option within object 'chosen' to consider; either 'node', 'edge' or 'label'\n * @param {object}  pile       array of options objects to consider\n * @returns {boolean | Function}  value for passed subOption of 'chosen' to use\n */\nfunction choosify(subOption, pile) {\n  // allowed values for subOption\n  var allowed = [\"node\", \"edge\", \"label\"];\n  var value = true;\n  var chosen = topMost(pile, \"chosen\");\n  if (typeof chosen === \"boolean\") {\n    value = chosen;\n  } else if (_typeof(chosen) === \"object\") {\n    if (_indexOfInstanceProperty(allowed).call(allowed, subOption) === -1) {\n      throw new Error(\"choosify: subOption '\" + subOption + \"' should be one of \" + \"'\" + allowed.join(\"', '\") + \"'\");\n    }\n    var chosenEdge = topMost(pile, [\"chosen\", subOption]);\n    if (typeof chosenEdge === \"boolean\" || typeof chosenEdge === \"function\") {\n      value = chosenEdge;\n    }\n  }\n  return value;\n}\n\n/**\n * Check if the point falls within the given rectangle.\n *\n * @param {rect} rect\n * @param {point} point\n * @param {rotationPoint} [rotationPoint] if specified, the rotation that applies to the rectangle.\n * @returns {boolean}  true if point within rectangle, false otherwise\n */\nfunction pointInRect(rect, point, rotationPoint) {\n  if (rect.width <= 0 || rect.height <= 0) {\n    return false; // early out\n  }\n\n  if (rotationPoint !== undefined) {\n    // Rotate the point the same amount as the rectangle\n    var tmp = {\n      x: point.x - rotationPoint.x,\n      y: point.y - rotationPoint.y\n    };\n    if (rotationPoint.angle !== 0) {\n      // In order to get the coordinates the same, you need to\n      // rotate in the reverse direction\n      var angle = -rotationPoint.angle;\n      var tmp2 = {\n        x: Math.cos(angle) * tmp.x - Math.sin(angle) * tmp.y,\n        y: Math.sin(angle) * tmp.x + Math.cos(angle) * tmp.y\n      };\n      point = tmp2;\n    } else {\n      point = tmp;\n    }\n\n    // Note that if a rotation is specified, the rectangle coordinates\n    // are **not* the full canvas coordinates. They are relative to the\n    // rotationPoint. Hence, the point coordinates need not be translated\n    // back in this case.\n  }\n\n  var right = rect.x + rect.width;\n  var bottom = rect.y + rect.width;\n  return rect.left < point.x && right > point.x && rect.top < point.y && bottom > point.y;\n}\n\n/**\n * Check if given value is acceptable as a label text.\n *\n * @param {*} text value to check; can be anything at this point\n * @returns {boolean} true if valid label value, false otherwise\n */\nfunction isValidLabel(text) {\n  // Note that this is quite strict: types that *might* be converted to string are disallowed\n  return typeof text === \"string\" && text !== \"\";\n}\n\n/**\n * Returns x, y of self reference circle based on provided angle\n *\n * @param {object} ctx\n * @param {number} angle\n * @param {number} radius\n * @param {VisNode} node\n * @returns {object} x and y coordinates\n */\nfunction getSelfRefCoordinates(ctx, angle, radius, node) {\n  var x = node.x;\n  var y = node.y;\n  if (typeof node.distanceToBorder === \"function\") {\n    //calculating opposite and adjacent\n    //distaneToBorder becomes Hypotenuse.\n    //Formulas sin(a) = Opposite / Hypotenuse and cos(a) = Adjacent / Hypotenuse\n    var toBorderDist = node.distanceToBorder(ctx, angle);\n    var yFromNodeCenter = Math.sin(angle) * toBorderDist;\n    var xFromNodeCenter = Math.cos(angle) * toBorderDist;\n    //xFromNodeCenter is basically x and if xFromNodeCenter equals to the distance to border then it means\n    //that y does not need calculation because it is equal node.height / 2 or node.y\n    //same thing with yFromNodeCenter and if yFromNodeCenter equals to the distance to border then it means\n    //that x is equal node.width / 2 or node.x\n    if (xFromNodeCenter === toBorderDist) {\n      x += toBorderDist;\n      y = node.y;\n    } else if (yFromNodeCenter === toBorderDist) {\n      x = node.x;\n      y -= toBorderDist;\n    } else {\n      x += xFromNodeCenter;\n      y -= yFromNodeCenter;\n    }\n  } else if (node.shape.width > node.shape.height) {\n    x = node.x + node.shape.width * 0.5;\n    y = node.y - radius;\n  } else {\n    x = node.x + radius;\n    y = node.y - node.shape.height * 0.5;\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\n\nvar entryVirtual$3 = entryVirtual$i;\n\nvar values$3 = entryVirtual$3('Array').values;\n\nvar parent$l = values$3;\n\nvar values$2 = parent$l;\n\nvar classof$1 = classof$d;\nvar hasOwn$2 = hasOwnProperty_1;\nvar isPrototypeOf$3 = objectIsPrototypeOf;\nvar method$3 = values$2;\n\nvar ArrayPrototype$3 = Array.prototype;\n\nvar DOMIterables = {\n  DOMTokenList: true,\n  NodeList: true\n};\n\nvar values$1 = function (it) {\n  var own = it.values;\n  return it === ArrayPrototype$3 || (isPrototypeOf$3(ArrayPrototype$3, it) && own === ArrayPrototype$3.values)\n    || hasOwn$2(DOMIterables, classof$1(it)) ? method$3 : own;\n};\n\nvar values = values$1;\n\nvar _valuesInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(values);\n\n/**\n * Callback to determine text dimensions, using the parent label settings.\n *\n * @callback MeasureText\n * @param {text} text\n * @param {text} mod\n * @returns {object} { width, values} width in pixels and font attributes\n */\n/**\n * Helper class for Label which collects results of splitting labels into lines and blocks.\n *\n * @private\n */\nvar LabelAccumulator = /*#__PURE__*/function () {\n  /**\n   * @param {MeasureText} measureText\n   */\n  function LabelAccumulator(measureText) {\n    _classCallCheck(this, LabelAccumulator);\n    this.measureText = measureText;\n    this.current = 0;\n    this.width = 0;\n    this.height = 0;\n    this.lines = [];\n  }\n\n  /**\n   * Append given text to the given line.\n   *\n   * @param {number}  l    index of line to add to\n   * @param {string}  text string to append to line\n   * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']\n   * @private\n   */\n  _createClass(LabelAccumulator, [{\n    key: \"_add\",\n    value: function _add(l, text) {\n      var mod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"normal\";\n      if (this.lines[l] === undefined) {\n        this.lines[l] = {\n          width: 0,\n          height: 0,\n          blocks: []\n        };\n      }\n\n      // We still need to set a block for undefined and empty texts, hence return at this point\n      // This is necessary because we don't know at this point if we're at the\n      // start of an empty line or not.\n      // To compensate, empty blocks are removed in `finalize()`.\n      //\n      // Empty strings should still have a height\n      var tmpText = text;\n      if (text === undefined || text === \"\") tmpText = \" \";\n\n      // Determine width and get the font properties\n      var result = this.measureText(tmpText, mod);\n      var block = _Object$assign({}, _valuesInstanceProperty(result));\n      block.text = text;\n      block.width = result.width;\n      block.mod = mod;\n      if (text === undefined || text === \"\") {\n        block.width = 0;\n      }\n      this.lines[l].blocks.push(block);\n\n      // Update the line width. We need this for determining if a string goes over max width\n      this.lines[l].width += block.width;\n    }\n\n    /**\n     * Returns the width in pixels of the current line.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"curWidth\",\n    value: function curWidth() {\n      var line = this.lines[this.current];\n      if (line === undefined) return 0;\n      return line.width;\n    }\n\n    /**\n     * Add text in block to current line\n     *\n     * @param {string} text\n     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']\n     */\n  }, {\n    key: \"append\",\n    value: function append(text) {\n      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"normal\";\n      this._add(this.current, text, mod);\n    }\n\n    /**\n     * Add text in block to current line and start a new line\n     *\n     * @param {string} text\n     * @param {'bold'|'ital'|'boldital'|'mono'|'normal'} [mod='normal']\n     */\n  }, {\n    key: \"newLine\",\n    value: function newLine(text) {\n      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"normal\";\n      this._add(this.current, text, mod);\n      this.current++;\n    }\n\n    /**\n     * Determine and set the heights of all the lines currently contained in this instance\n     *\n     * Note that width has already been set.\n     *\n     * @private\n     */\n  }, {\n    key: \"determineLineHeights\",\n    value: function determineLineHeights() {\n      for (var k = 0; k < this.lines.length; k++) {\n        var line = this.lines[k];\n\n        // Looking for max height of blocks in line\n        var height = 0;\n        if (line.blocks !== undefined) {\n          // Can happen if text contains e.g. '\\n '\n          for (var l = 0; l < line.blocks.length; l++) {\n            var block = line.blocks[l];\n            if (height < block.height) {\n              height = block.height;\n            }\n          }\n        }\n        line.height = height;\n      }\n    }\n\n    /**\n     * Determine the full size of the label text, as determined by current lines and blocks\n     *\n     * @private\n     */\n  }, {\n    key: \"determineLabelSize\",\n    value: function determineLabelSize() {\n      var width = 0;\n      var height = 0;\n      for (var k = 0; k < this.lines.length; k++) {\n        var line = this.lines[k];\n        if (line.width > width) {\n          width = line.width;\n        }\n        height += line.height;\n      }\n      this.width = width;\n      this.height = height;\n    }\n\n    /**\n     * Remove all empty blocks and empty lines we don't need\n     *\n     * This must be done after the width/height determination,\n     * so that these are set properly for processing here.\n     *\n     * @returns {Array<Line>} Lines with empty blocks (and some empty lines) removed\n     * @private\n     */\n  }, {\n    key: \"removeEmptyBlocks\",\n    value: function removeEmptyBlocks() {\n      var tmpLines = [];\n      for (var k = 0; k < this.lines.length; k++) {\n        var line = this.lines[k];\n\n        // Note: an empty line in between text has width zero but is still relevant to layout.\n        // So we can't use width for testing empty line here\n        if (line.blocks.length === 0) continue;\n\n        // Discard final empty line always\n        if (k === this.lines.length - 1) {\n          if (line.width === 0) continue;\n        }\n        var tmpLine = {};\n        _Object$assign(tmpLine, line);\n        tmpLine.blocks = [];\n        var firstEmptyBlock = void 0;\n        var tmpBlocks = [];\n        for (var l = 0; l < line.blocks.length; l++) {\n          var block = line.blocks[l];\n          if (block.width !== 0) {\n            tmpBlocks.push(block);\n          } else {\n            if (firstEmptyBlock === undefined) {\n              firstEmptyBlock = block;\n            }\n          }\n        }\n\n        // Ensure that there is *some* text present\n        if (tmpBlocks.length === 0 && firstEmptyBlock !== undefined) {\n          tmpBlocks.push(firstEmptyBlock);\n        }\n        tmpLine.blocks = tmpBlocks;\n        tmpLines.push(tmpLine);\n      }\n      return tmpLines;\n    }\n\n    /**\n     * Set the sizes for all lines and the whole thing.\n     *\n     * @returns {{width: (number|*), height: (number|*), lines: Array}}\n     */\n  }, {\n    key: \"finalize\",\n    value: function finalize() {\n      //console.log(JSON.stringify(this.lines, null, 2));\n\n      this.determineLineHeights();\n      this.determineLabelSize();\n      var tmpLines = this.removeEmptyBlocks();\n\n      // Return a simple hash object for further processing.\n      return {\n        width: this.width,\n        height: this.height,\n        lines: tmpLines\n      };\n    }\n  }]);\n  return LabelAccumulator;\n}();\n\n// Hash of prepared regexp's for tags\nvar tagPattern = {\n  // HTML\n  \"<b>\": /<b>/,\n  \"<i>\": /<i>/,\n  \"<code>\": /<code>/,\n  \"</b>\": /<\\/b>/,\n  \"</i>\": /<\\/i>/,\n  \"</code>\": /<\\/code>/,\n  // Markdown\n  \"*\": /\\*/,\n  // bold\n  _: /_/,\n  // ital\n  \"`\": /`/,\n  // mono\n  afterBold: /[^*]/,\n  afterItal: /[^_]/,\n  afterMono: /[^`]/\n};\n\n/**\n * Internal helper class for parsing the markup tags for HTML and Markdown.\n *\n * NOTE: Sequences of tabs and spaces are reduced to single space.\n *       Scan usage of `this.spacing` within method\n */\nvar MarkupAccumulator = /*#__PURE__*/function () {\n  /**\n   * Create an instance\n   *\n   * @param {string} text  text to parse for markup\n   */\n  function MarkupAccumulator(text) {\n    _classCallCheck(this, MarkupAccumulator);\n    this.text = text;\n    this.bold = false;\n    this.ital = false;\n    this.mono = false;\n    this.spacing = false;\n    this.position = 0;\n    this.buffer = \"\";\n    this.modStack = [];\n    this.blocks = [];\n  }\n\n  /**\n   * Return the mod label currently on the top of the stack\n   *\n   * @returns {string}  label of topmost mod\n   * @private\n   */\n  _createClass(MarkupAccumulator, [{\n    key: \"mod\",\n    value: function mod() {\n      return this.modStack.length === 0 ? \"normal\" : this.modStack[0];\n    }\n\n    /**\n     * Return the mod label currently active\n     *\n     * @returns {string}  label of active mod\n     * @private\n     */\n  }, {\n    key: \"modName\",\n    value: function modName() {\n      if (this.modStack.length === 0) return \"normal\";else if (this.modStack[0] === \"mono\") return \"mono\";else {\n        if (this.bold && this.ital) {\n          return \"boldital\";\n        } else if (this.bold) {\n          return \"bold\";\n        } else if (this.ital) {\n          return \"ital\";\n        }\n      }\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: \"emitBlock\",\n    value: function emitBlock() {\n      if (this.spacing) {\n        this.add(\" \");\n        this.spacing = false;\n      }\n      if (this.buffer.length > 0) {\n        this.blocks.push({\n          text: this.buffer,\n          mod: this.modName()\n        });\n        this.buffer = \"\";\n      }\n    }\n\n    /**\n     * Output text to buffer\n     *\n     * @param {string} text  text to add\n     * @private\n     */\n  }, {\n    key: \"add\",\n    value: function add(text) {\n      if (text === \" \") {\n        this.spacing = true;\n      }\n      if (this.spacing) {\n        this.buffer += \" \";\n        this.spacing = false;\n      }\n      if (text != \" \") {\n        this.buffer += text;\n      }\n    }\n\n    /**\n     * Handle parsing of whitespace\n     *\n     * @param {string} ch  the character to check\n     * @returns {boolean} true if the character was processed as whitespace, false otherwise\n     */\n  }, {\n    key: \"parseWS\",\n    value: function parseWS(ch) {\n      if (/[ \\t]/.test(ch)) {\n        if (!this.mono) {\n          this.spacing = true;\n        } else {\n          this.add(ch);\n        }\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @param {string} tagName  label for block type to set\n     * @private\n     */\n  }, {\n    key: \"setTag\",\n    value: function setTag(tagName) {\n      this.emitBlock();\n      this[tagName] = true;\n      this.modStack.unshift(tagName);\n    }\n\n    /**\n     * @param {string} tagName  label for block type to unset\n     * @private\n     */\n  }, {\n    key: \"unsetTag\",\n    value: function unsetTag(tagName) {\n      this.emitBlock();\n      this[tagName] = false;\n      this.modStack.shift();\n    }\n\n    /**\n     * @param {string} tagName label for block type we are currently processing\n     * @param {string|RegExp} tag string to match in text\n     * @returns {boolean} true if the tag was processed, false otherwise\n     */\n  }, {\n    key: \"parseStartTag\",\n    value: function parseStartTag(tagName, tag) {\n      // Note: if 'mono' passed as tagName, there is a double check here. This is OK\n      if (!this.mono && !this[tagName] && this.match(tag)) {\n        this.setTag(tagName);\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @param {string|RegExp} tag\n     * @param {number} [advance=true] if set, advance current position in text\n     * @returns {boolean} true if match at given position, false otherwise\n     * @private\n     */\n  }, {\n    key: \"match\",\n    value: function match(tag) {\n      var advance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var _this$prepareRegExp = this.prepareRegExp(tag),\n        _this$prepareRegExp2 = _slicedToArray(_this$prepareRegExp, 2),\n        regExp = _this$prepareRegExp2[0],\n        length = _this$prepareRegExp2[1];\n      var matched = regExp.test(this.text.substr(this.position, length));\n      if (matched && advance) {\n        this.position += length - 1;\n      }\n      return matched;\n    }\n\n    /**\n     * @param {string} tagName label for block type we are currently processing\n     * @param {string|RegExp} tag string to match in text\n     * @param {RegExp} [nextTag] regular expression to match for characters *following* the current tag\n     * @returns {boolean} true if the tag was processed, false otherwise\n     */\n  }, {\n    key: \"parseEndTag\",\n    value: function parseEndTag(tagName, tag, nextTag) {\n      var checkTag = this.mod() === tagName;\n      if (tagName === \"mono\") {\n        // special handling for 'mono'\n        checkTag = checkTag && this.mono;\n      } else {\n        checkTag = checkTag && !this.mono;\n      }\n      if (checkTag && this.match(tag)) {\n        if (nextTag !== undefined) {\n          // Purpose of the following match is to prevent a direct unset/set of a given tag\n          // E.g. '*bold **still bold*' => '*bold still bold*'\n          if (this.position === this.text.length - 1 || this.match(nextTag, false)) {\n            this.unsetTag(tagName);\n          }\n        } else {\n          this.unsetTag(tagName);\n        }\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * @param {string|RegExp} tag  string to match in text\n     * @param {value} value  string to replace tag with, if found at current position\n     * @returns {boolean} true if the tag was processed, false otherwise\n     */\n  }, {\n    key: \"replace\",\n    value: function replace(tag, value) {\n      if (this.match(tag)) {\n        this.add(value);\n        this.position += length - 1;\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     * Create a regular expression for the tag if it isn't already one.\n     *\n     * The return value is an array `[RegExp, number]`, with exactly two value, where:\n     *  - RegExp is the regular expression to use\n     *  - number is the lenth of the input string to match\n     *\n     * @param {string|RegExp} tag  string to match in text\n     * @returns {Array}  regular expression to use and length of input string to match\n     * @private\n     */\n  }, {\n    key: \"prepareRegExp\",\n    value: function prepareRegExp(tag) {\n      var length;\n      var regExp;\n      if (tag instanceof RegExp) {\n        regExp = tag;\n        length = 1; // ASSUMPTION: regexp only tests one character\n      } else {\n        // use prepared regexp if present\n        var prepared = tagPattern[tag];\n        if (prepared !== undefined) {\n          regExp = prepared;\n        } else {\n          regExp = new RegExp(tag);\n        }\n        length = tag.length;\n      }\n      return [regExp, length];\n    }\n  }]);\n  return MarkupAccumulator;\n}();\n/**\n * Helper class for Label which explodes the label text into lines and blocks within lines\n *\n * @private\n */\nvar LabelSplitter = /*#__PURE__*/function () {\n  /**\n   * @param {CanvasRenderingContext2D} ctx Canvas rendering context\n   * @param {Label} parent reference to the Label instance using current instance\n   * @param {boolean} selected\n   * @param {boolean} hover\n   */\n  function LabelSplitter(ctx, parent, selected, hover) {\n    var _this = this;\n    _classCallCheck(this, LabelSplitter);\n    this.ctx = ctx;\n    this.parent = parent;\n    this.selected = selected;\n    this.hover = hover;\n\n    /**\n     * Callback to determine text width; passed to LabelAccumulator instance\n     *\n     * @param  {string} text string to determine width of\n     * @param  {string} mod  font type to use for this text\n     * @returns {object} { width, values} width in pixels and font attributes\n     */\n    var textWidth = function textWidth(text, mod) {\n      if (text === undefined) return 0;\n\n      // TODO: This can be done more efficiently with caching\n      // This will set the ctx.font correctly, depending on selected/hover and mod - so that ctx.measureText() will be accurate.\n      var values = _this.parent.getFormattingValues(ctx, selected, hover, mod);\n      var width = 0;\n      if (text !== \"\") {\n        var measure = _this.ctx.measureText(text);\n        width = measure.width;\n      }\n      return {\n        width: width,\n        values: values\n      };\n    };\n    this.lines = new LabelAccumulator(textWidth);\n  }\n\n  /**\n   * Split passed text of a label into lines and blocks.\n   *\n   * # NOTE\n   *\n   * The handling of spacing is option dependent:\n   *\n   * - if `font.multi : false`, all spaces are retained\n   * - if `font.multi : true`, every sequence of spaces is compressed to a single space\n   *\n   * This might not be the best way to do it, but this is as it has been working till now.\n   * In order not to break existing functionality, for the time being this behaviour will\n   * be retained in any code changes.\n   *\n   * @param {string} text  text to split\n   * @returns {Array<line>}\n   */\n  _createClass(LabelSplitter, [{\n    key: \"process\",\n    value: function process(text) {\n      if (!isValidLabel(text)) {\n        return this.lines.finalize();\n      }\n      var font = this.parent.fontOptions;\n\n      // Normalize the end-of-line's to a single representation - order important\n      text = text.replace(/\\r\\n/g, \"\\n\"); // Dos EOL's\n      text = text.replace(/\\r/g, \"\\n\"); // Mac EOL's\n\n      // Note that at this point, there can be no \\r's in the text.\n      // This is used later on splitStringIntoLines() to split multifont texts.\n\n      var nlLines = String(text).split(\"\\n\");\n      var lineCount = nlLines.length;\n      if (font.multi) {\n        // Multi-font case: styling tags active\n        for (var i = 0; i < lineCount; i++) {\n          var blocks = this.splitBlocks(nlLines[i], font.multi);\n          // Post: Sequences of tabs and spaces are reduced to single space\n\n          if (blocks === undefined) continue;\n          if (blocks.length === 0) {\n            this.lines.newLine(\"\");\n            continue;\n          }\n          if (font.maxWdt > 0) {\n            // widthConstraint.maximum defined\n            //console.log('Running widthConstraint multi, max: ' + this.fontOptions.maxWdt);\n            for (var j = 0; j < blocks.length; j++) {\n              var mod = blocks[j].mod;\n              var _text = blocks[j].text;\n              this.splitStringIntoLines(_text, mod, true);\n            }\n          } else {\n            // widthConstraint.maximum NOT defined\n            for (var _j = 0; _j < blocks.length; _j++) {\n              var _mod = blocks[_j].mod;\n              var _text2 = blocks[_j].text;\n              this.lines.append(_text2, _mod);\n            }\n          }\n          this.lines.newLine();\n        }\n      } else {\n        // Single-font case\n        if (font.maxWdt > 0) {\n          // widthConstraint.maximum defined\n          // console.log('Running widthConstraint normal, max: ' + this.fontOptions.maxWdt);\n          for (var _i = 0; _i < lineCount; _i++) {\n            this.splitStringIntoLines(nlLines[_i]);\n          }\n        } else {\n          // widthConstraint.maximum NOT defined\n          for (var _i2 = 0; _i2 < lineCount; _i2++) {\n            this.lines.newLine(nlLines[_i2]);\n          }\n        }\n      }\n      return this.lines.finalize();\n    }\n\n    /**\n     * normalize the markup system\n     *\n     * @param {boolean|'md'|'markdown'|'html'} markupSystem\n     * @returns {string}\n     */\n  }, {\n    key: \"decodeMarkupSystem\",\n    value: function decodeMarkupSystem(markupSystem) {\n      var system = \"none\";\n      if (markupSystem === \"markdown\" || markupSystem === \"md\") {\n        system = \"markdown\";\n      } else if (markupSystem === true || markupSystem === \"html\") {\n        system = \"html\";\n      }\n      return system;\n    }\n\n    /**\n     *\n     * @param {string} text\n     * @returns {Array}\n     */\n  }, {\n    key: \"splitHtmlBlocks\",\n    value: function splitHtmlBlocks(text) {\n      var s = new MarkupAccumulator(text);\n      var parseEntities = function parseEntities(ch) {\n        if (/&/.test(ch)) {\n          var parsed = s.replace(s.text, \"&lt;\", \"<\") || s.replace(s.text, \"&amp;\", \"&\");\n          if (!parsed) {\n            s.add(\"&\");\n          }\n          return true;\n        }\n        return false;\n      };\n      while (s.position < s.text.length) {\n        var ch = s.text.charAt(s.position);\n        var parsed = s.parseWS(ch) || /</.test(ch) && (s.parseStartTag(\"bold\", \"<b>\") || s.parseStartTag(\"ital\", \"<i>\") || s.parseStartTag(\"mono\", \"<code>\") || s.parseEndTag(\"bold\", \"</b>\") || s.parseEndTag(\"ital\", \"</i>\") || s.parseEndTag(\"mono\", \"</code>\")) || parseEntities(ch);\n        if (!parsed) {\n          s.add(ch);\n        }\n        s.position++;\n      }\n      s.emitBlock();\n      return s.blocks;\n    }\n\n    /**\n     *\n     * @param {string} text\n     * @returns {Array}\n     */\n  }, {\n    key: \"splitMarkdownBlocks\",\n    value: function splitMarkdownBlocks(text) {\n      var _this2 = this;\n      var s = new MarkupAccumulator(text);\n      var beginable = true;\n      var parseOverride = function parseOverride(ch) {\n        if (/\\\\/.test(ch)) {\n          if (s.position < _this2.text.length + 1) {\n            s.position++;\n            ch = _this2.text.charAt(s.position);\n            if (/ \\t/.test(ch)) {\n              s.spacing = true;\n            } else {\n              s.add(ch);\n              beginable = false;\n            }\n          }\n          return true;\n        }\n        return false;\n      };\n      while (s.position < s.text.length) {\n        var ch = s.text.charAt(s.position);\n        var parsed = s.parseWS(ch) || parseOverride(ch) || (beginable || s.spacing) && (s.parseStartTag(\"bold\", \"*\") || s.parseStartTag(\"ital\", \"_\") || s.parseStartTag(\"mono\", \"`\")) || s.parseEndTag(\"bold\", \"*\", \"afterBold\") || s.parseEndTag(\"ital\", \"_\", \"afterItal\") || s.parseEndTag(\"mono\", \"`\", \"afterMono\");\n        if (!parsed) {\n          s.add(ch);\n          beginable = false;\n        }\n        s.position++;\n      }\n      s.emitBlock();\n      return s.blocks;\n    }\n\n    /**\n     * Explodes a piece of text into single-font blocks using a given markup\n     *\n     * @param {string} text\n     * @param {boolean|'md'|'markdown'|'html'} markupSystem\n     * @returns {Array.<{text: string, mod: string}>}\n     * @private\n     */\n  }, {\n    key: \"splitBlocks\",\n    value: function splitBlocks(text, markupSystem) {\n      var system = this.decodeMarkupSystem(markupSystem);\n      if (system === \"none\") {\n        return [{\n          text: text,\n          mod: \"normal\"\n        }];\n      } else if (system === \"markdown\") {\n        return this.splitMarkdownBlocks(text);\n      } else if (system === \"html\") {\n        return this.splitHtmlBlocks(text);\n      }\n    }\n\n    /**\n     * @param {string} text\n     * @returns {boolean} true if text length over the current max with\n     * @private\n     */\n  }, {\n    key: \"overMaxWidth\",\n    value: function overMaxWidth(text) {\n      var width = this.ctx.measureText(text).width;\n      return this.lines.curWidth() + width > this.parent.fontOptions.maxWdt;\n    }\n\n    /**\n     * Determine the longest part of the sentence which still fits in the\n     * current max width.\n     *\n     * @param {Array} words  Array of strings signifying a text lines\n     * @returns {number}      index of first item in string making string go over max\n     * @private\n     */\n  }, {\n    key: \"getLongestFit\",\n    value: function getLongestFit(words) {\n      var text = \"\";\n      var w = 0;\n      while (w < words.length) {\n        var pre = text === \"\" ? \"\" : \" \";\n        var newText = text + pre + words[w];\n        if (this.overMaxWidth(newText)) break;\n        text = newText;\n        w++;\n      }\n      return w;\n    }\n\n    /**\n     * Determine the longest part of the string which still fits in the\n     * current max width.\n     *\n     * @param {Array} words Array of strings signifying a text lines\n     * @returns {number} index of first item in string making string go over max\n     */\n  }, {\n    key: \"getLongestFitWord\",\n    value: function getLongestFitWord(words) {\n      var w = 0;\n      while (w < words.length) {\n        if (this.overMaxWidth(_sliceInstanceProperty(words).call(words, 0, w))) break;\n        w++;\n      }\n      return w;\n    }\n\n    /**\n     * Split the passed text into lines, according to width constraint (if any).\n     *\n     * The method assumes that the input string is a single line, i.e. without lines break.\n     *\n     * This method retains spaces, if still present (case `font.multi: false`).\n     * A space which falls on an internal line break, will be replaced by a newline.\n     * There is no special handling of tabs; these go along with the flow.\n     *\n     * @param {string} str\n     * @param {string} [mod='normal']\n     * @param {boolean} [appendLast=false]\n     * @private\n     */\n  }, {\n    key: \"splitStringIntoLines\",\n    value: function splitStringIntoLines(str) {\n      var mod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"normal\";\n      var appendLast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      // Set the canvas context font, based upon the current selected/hover state\n      // and the provided mod, so the text measurement performed by getLongestFit\n      // will be accurate - and not just use the font of whoever last used the canvas.\n      this.parent.getFormattingValues(this.ctx, this.selected, this.hover, mod);\n\n      // Still-present spaces are relevant, retain them\n      str = str.replace(/^( +)/g, \"$1\\r\");\n      str = str.replace(/([^\\r][^ ]*)( +)/g, \"$1\\r$2\\r\");\n      var words = str.split(\"\\r\");\n      while (words.length > 0) {\n        var w = this.getLongestFit(words);\n        if (w === 0) {\n          // Special case: the first word is already larger than the max width.\n          var word = words[0];\n\n          // Break the word to the largest part that fits the line\n          var x = this.getLongestFitWord(word);\n          this.lines.newLine(_sliceInstanceProperty(word).call(word, 0, x), mod);\n\n          // Adjust the word, so that the rest will be done next iteration\n          words[0] = _sliceInstanceProperty(word).call(word, x);\n        } else {\n          // skip any space that is replaced by a newline\n          var newW = w;\n          if (words[w - 1] === \" \") {\n            w--;\n          } else if (words[newW] === \" \") {\n            newW++;\n          }\n          var text = _sliceInstanceProperty(words).call(words, 0, w).join(\"\");\n          if (w == words.length && appendLast) {\n            this.lines.append(text, mod);\n          } else {\n            this.lines.newLine(text, mod);\n          }\n\n          // Adjust the word, so that the rest will be done next iteration\n          words = _sliceInstanceProperty(words).call(words, newW);\n        }\n      }\n    }\n  }]);\n  return LabelSplitter;\n}();\n\n/**\n * List of special styles for multi-fonts\n *\n * @private\n */\nvar multiFontStyle = [\"bold\", \"ital\", \"boldital\", \"mono\"];\n\n/**\n * A Label to be used for Nodes or Edges.\n */\nvar Label = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {object} options\n   * @param {boolean} [edgelabel=false]\n   */\n  function Label(body, options) {\n    var edgelabel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    _classCallCheck(this, Label);\n    this.body = body;\n    this.pointToSelf = false;\n    this.baseSize = undefined;\n    this.fontOptions = {}; // instance variable containing the *instance-local* font options\n    this.setOptions(options);\n    this.size = {\n      top: 0,\n      left: 0,\n      width: 0,\n      height: 0,\n      yLine: 0\n    };\n    this.isEdgeLabel = edgelabel;\n  }\n\n  /**\n   * @param {object} options the options of the parent Node-instance\n   */\n  _createClass(Label, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.elementOptions = options; // Reference to the options of the parent Node-instance\n\n      this.initFontOptions(options.font);\n      if (isValidLabel(options.label)) {\n        this.labelDirty = true;\n      } else {\n        // Bad label! Change the option value to prevent bad stuff happening\n        options.label = undefined;\n      }\n      if (options.font !== undefined && options.font !== null) {\n        // font options can be deleted at various levels\n        if (typeof options.font === \"string\") {\n          this.baseSize = this.fontOptions.size;\n        } else if (_typeof(options.font) === \"object\") {\n          var size = options.font.size;\n          if (size !== undefined) {\n            this.baseSize = size;\n          }\n        }\n      }\n    }\n\n    /**\n     * Init the font Options structure.\n     *\n     * Member fontOptions serves as an accumulator for the current font options.\n     * As such, it needs to be completely separated from the node options.\n     *\n     * @param {object} newFontOptions the new font options to process\n     * @private\n     */\n  }, {\n    key: \"initFontOptions\",\n    value: function initFontOptions(newFontOptions) {\n      var _this = this;\n      // Prepare the multi-font option objects.\n      // These will be filled in propagateFonts(), if required\n      forEach$1(multiFontStyle, function (style) {\n        _this.fontOptions[style] = {};\n      });\n\n      // Handle shorthand option, if present\n      if (Label.parseFontString(this.fontOptions, newFontOptions)) {\n        this.fontOptions.vadjust = 0;\n        return;\n      }\n\n      // Copy over the non-multifont options, if specified\n      forEach$1(newFontOptions, function (prop, n) {\n        if (prop !== undefined && prop !== null && _typeof(prop) !== \"object\") {\n          _this.fontOptions[n] = prop;\n        }\n      });\n    }\n\n    /**\n     * If in-variable is a string, parse it as a font specifier.\n     *\n     * Note that following is not done here and have to be done after the call:\n     * - Not all font options are set (vadjust, mod)\n     *\n     * @param {object} outOptions  out-parameter, object in which to store the parse results (if any)\n     * @param {object} inOptions  font options to parse\n     * @returns {boolean} true if font parsed as string, false otherwise\n     * @static\n     */\n  }, {\n    key: \"constrain\",\n    value:\n    /**\n     * Set the width and height constraints based on 'nearest' value\n     *\n     * @param {Array} pile array of option objects to consider\n     * @returns {object} the actual constraint values to use\n     * @private\n     */\n    function constrain(pile) {\n      // NOTE: constrainWidth and  constrainHeight never set!\n      // NOTE: for edge labels, only 'maxWdt' set\n      // Node labels can set all the fields\n      var fontOptions = {\n        constrainWidth: false,\n        maxWdt: -1,\n        minWdt: -1,\n        constrainHeight: false,\n        minHgt: -1,\n        valign: \"middle\"\n      };\n      var widthConstraint = topMost(pile, \"widthConstraint\");\n      if (typeof widthConstraint === \"number\") {\n        fontOptions.maxWdt = Number(widthConstraint);\n        fontOptions.minWdt = Number(widthConstraint);\n      } else if (_typeof(widthConstraint) === \"object\") {\n        var widthConstraintMaximum = topMost(pile, [\"widthConstraint\", \"maximum\"]);\n        if (typeof widthConstraintMaximum === \"number\") {\n          fontOptions.maxWdt = Number(widthConstraintMaximum);\n        }\n        var widthConstraintMinimum = topMost(pile, [\"widthConstraint\", \"minimum\"]);\n        if (typeof widthConstraintMinimum === \"number\") {\n          fontOptions.minWdt = Number(widthConstraintMinimum);\n        }\n      }\n      var heightConstraint = topMost(pile, \"heightConstraint\");\n      if (typeof heightConstraint === \"number\") {\n        fontOptions.minHgt = Number(heightConstraint);\n      } else if (_typeof(heightConstraint) === \"object\") {\n        var heightConstraintMinimum = topMost(pile, [\"heightConstraint\", \"minimum\"]);\n        if (typeof heightConstraintMinimum === \"number\") {\n          fontOptions.minHgt = Number(heightConstraintMinimum);\n        }\n        var heightConstraintValign = topMost(pile, [\"heightConstraint\", \"valign\"]);\n        if (typeof heightConstraintValign === \"string\") {\n          if (heightConstraintValign === \"top\" || heightConstraintValign === \"bottom\") {\n            fontOptions.valign = heightConstraintValign;\n          }\n        }\n      }\n      return fontOptions;\n    }\n\n    /**\n     * Set options and update internal state\n     *\n     * @param {object} options  options to set\n     * @param {Array}  pile     array of option objects to consider for option 'chosen'\n     */\n  }, {\n    key: \"update\",\n    value: function update(options, pile) {\n      this.setOptions(options, true);\n      this.propagateFonts(pile);\n      deepExtend(this.fontOptions, this.constrain(pile));\n      this.fontOptions.chooser = choosify(\"label\", pile);\n    }\n\n    /**\n     * When margins are set in an element, adjust sizes is called to remove them\n     * from the width/height constraints. This must be done prior to label sizing.\n     *\n     * @param {{top: number, right: number, bottom: number, left: number}} margins\n     */\n  }, {\n    key: \"adjustSizes\",\n    value: function adjustSizes(margins) {\n      var widthBias = margins ? margins.right + margins.left : 0;\n      if (this.fontOptions.constrainWidth) {\n        this.fontOptions.maxWdt -= widthBias;\n        this.fontOptions.minWdt -= widthBias;\n      }\n      var heightBias = margins ? margins.top + margins.bottom : 0;\n      if (this.fontOptions.constrainHeight) {\n        this.fontOptions.minHgt -= heightBias;\n      }\n    }\n\n    /////////////////////////////////////////////////////////\n    // Methods for handling options piles\n    // Eventually, these will be moved to a separate class\n    /////////////////////////////////////////////////////////\n\n    /**\n     * Add the font members of the passed list of option objects to the pile.\n     *\n     * @param {Pile} dstPile  pile of option objects add to\n     * @param {Pile} srcPile  pile of option objects to take font options from\n     * @private\n     */\n  }, {\n    key: \"addFontOptionsToPile\",\n    value: function addFontOptionsToPile(dstPile, srcPile) {\n      for (var i = 0; i < srcPile.length; ++i) {\n        this.addFontToPile(dstPile, srcPile[i]);\n      }\n    }\n\n    /**\n     * Add given font option object to the list of objects (the 'pile') to consider for determining\n     * multi-font option values.\n     *\n     * @param {Pile} pile  pile of option objects to use\n     * @param {object} options  instance to add to pile\n     * @private\n     */\n  }, {\n    key: \"addFontToPile\",\n    value: function addFontToPile(pile, options) {\n      if (options === undefined) return;\n      if (options.font === undefined || options.font === null) return;\n      var item = options.font;\n      pile.push(item);\n    }\n\n    /**\n     * Collect all own-property values from the font pile that aren't multi-font option objectss.\n     *\n     * @param {Pile} pile  pile of option objects to use\n     * @returns {object} object with all current own basic font properties\n     * @private\n     */\n  }, {\n    key: \"getBasicOptions\",\n    value: function getBasicOptions(pile) {\n      var ret = {};\n\n      // Scans the whole pile to get all options present\n      for (var n = 0; n < pile.length; ++n) {\n        var fontOptions = pile[n];\n\n        // Convert shorthand if necessary\n        var tmpShorthand = {};\n        if (Label.parseFontString(tmpShorthand, fontOptions)) {\n          fontOptions = tmpShorthand;\n        }\n        forEach$1(fontOptions, function (opt, name) {\n          if (opt === undefined) return; // multi-font option need not be present\n          if (Object.prototype.hasOwnProperty.call(ret, name)) return; // Keep first value we encounter\n\n          if (_indexOfInstanceProperty(multiFontStyle).call(multiFontStyle, name) !== -1) {\n            // Skip multi-font properties but we do need the structure\n            ret[name] = {};\n          } else {\n            ret[name] = opt;\n          }\n        });\n      }\n      return ret;\n    }\n\n    /**\n     * Return the value for given option for the given multi-font.\n     *\n     * All available option objects are trawled in the set order to construct the option values.\n     *\n     * ---------------------------------------------------------------------\n     * ## Traversal of pile for multi-fonts\n     *\n     * The determination of multi-font option values is a special case, because any values not\n     * present in the multi-font options should by definition be taken from the main font options,\n     * i.e. from the current 'parent' object of the multi-font option.\n     *\n     * ### Search order for multi-fonts\n     *\n     * 'bold' used as example:\n     *\n     *   - search in option group 'bold' in local properties\n     *   - search in main font option group in local properties\n     *\n     * ---------------------------------------------------------------------\n     *\n     * @param {Pile} pile  pile of option objects to use\n     * @param {MultiFontStyle} multiName sub path for the multi-font\n     * @param {string} option  the option to search for, for the given multi-font\n     * @returns {string|number} the value for the given option\n     * @private\n     */\n  }, {\n    key: \"getFontOption\",\n    value: function getFontOption(pile, multiName, option) {\n      var multiFont;\n\n      // Search multi font in local properties\n      for (var n = 0; n < pile.length; ++n) {\n        var fontOptions = pile[n];\n        if (Object.prototype.hasOwnProperty.call(fontOptions, multiName)) {\n          multiFont = fontOptions[multiName];\n          if (multiFont === undefined || multiFont === null) continue;\n\n          // Convert shorthand if necessary\n          // TODO: inefficient to do this conversion every time; find a better way.\n          var tmpShorthand = {};\n          if (Label.parseFontString(tmpShorthand, multiFont)) {\n            multiFont = tmpShorthand;\n          }\n          if (Object.prototype.hasOwnProperty.call(multiFont, option)) {\n            return multiFont[option];\n          }\n        }\n      }\n\n      // Option is not mentioned in the multi font options; take it from the parent font options.\n      // These have already been converted with getBasicOptions(), so use the converted values.\n      if (Object.prototype.hasOwnProperty.call(this.fontOptions, option)) {\n        return this.fontOptions[option];\n      }\n\n      // A value **must** be found; you should never get here.\n      throw new Error(\"Did not find value for multi-font for property: '\" + option + \"'\");\n    }\n\n    /**\n     * Return all options values for the given multi-font.\n     *\n     * All available option objects are trawled in the set order to construct the option values.\n     *\n     * @param {Pile} pile  pile of option objects to use\n     * @param {MultiFontStyle} multiName sub path for the mod-font\n     * @returns {MultiFontOptions}\n     * @private\n     */\n  }, {\n    key: \"getFontOptions\",\n    value: function getFontOptions(pile, multiName) {\n      var result = {};\n      var optionNames = [\"color\", \"size\", \"face\", \"mod\", \"vadjust\"]; // List of allowed options per multi-font\n\n      for (var i = 0; i < optionNames.length; ++i) {\n        var mod = optionNames[i];\n        result[mod] = this.getFontOption(pile, multiName, mod);\n      }\n      return result;\n    }\n\n    /////////////////////////////////////////////////////////\n    // End methods for handling options piles\n    /////////////////////////////////////////////////////////\n\n    /**\n     * Collapse the font options for the multi-font to single objects, from\n     * the chain of option objects passed (the 'pile').\n     *\n     * @param {Pile} pile  sequence of option objects to consider.\n     *                     First item in list assumed to be the newly set options.\n     */\n  }, {\n    key: \"propagateFonts\",\n    value: function propagateFonts(pile) {\n      var _this2 = this;\n      var fontPile = []; // sequence of font objects to consider, order important\n\n      // Note that this.elementOptions is not used here.\n      this.addFontOptionsToPile(fontPile, pile);\n      this.fontOptions = this.getBasicOptions(fontPile);\n\n      // We set multifont values even if multi === false, for consistency (things break otherwise)\n      var _loop = function _loop() {\n        var mod = multiFontStyle[i];\n        var modOptions = _this2.fontOptions[mod];\n        var tmpMultiFontOptions = _this2.getFontOptions(fontPile, mod);\n\n        // Copy over found values\n        forEach$1(tmpMultiFontOptions, function (option, n) {\n          modOptions[n] = option;\n        });\n        modOptions.size = Number(modOptions.size);\n        modOptions.vadjust = Number(modOptions.vadjust);\n      };\n      for (var i = 0; i < multiFontStyle.length; ++i) {\n        _loop();\n      }\n    }\n\n    /**\n     * Main function. This is called from anything that wants to draw a label.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x\n     * @param {number} y\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {string} [baseline='middle']\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover) {\n      var baseline = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"middle\";\n      // if no label, return\n      if (this.elementOptions.label === undefined) return;\n\n      // check if we have to render the label\n      var viewFontSize = this.fontOptions.size * this.body.view.scale;\n      if (this.elementOptions.label && viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) return;\n\n      // This ensures that there will not be HUGE letters on screen\n      // by setting an upper limit on the visible text size (regardless of zoomLevel)\n      if (viewFontSize >= this.elementOptions.scaling.label.maxVisible) {\n        viewFontSize = Number(this.elementOptions.scaling.label.maxVisible) / this.body.view.scale;\n      }\n\n      // update the size cache if required\n      this.calculateLabelSize(ctx, selected, hover, x, y, baseline);\n      this._drawBackground(ctx);\n      this._drawText(ctx, x, this.size.yLine, baseline, viewFontSize);\n    }\n\n    /**\n     * Draws the label background\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @private\n     */\n  }, {\n    key: \"_drawBackground\",\n    value: function _drawBackground(ctx) {\n      if (this.fontOptions.background !== undefined && this.fontOptions.background !== \"none\") {\n        ctx.fillStyle = this.fontOptions.background;\n        var size = this.getSize();\n        ctx.fillRect(size.left, size.top, size.width, size.height);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x\n     * @param {number} y\n     * @param {string} [baseline='middle']\n     * @param {number} viewFontSize\n     * @private\n     */\n  }, {\n    key: \"_drawText\",\n    value: function _drawText(ctx, x, y) {\n      var baseline = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"middle\";\n      var viewFontSize = arguments.length > 4 ? arguments[4] : undefined;\n      var _this$_setAlignment = this._setAlignment(ctx, x, y, baseline);\n      var _this$_setAlignment2 = _slicedToArray(_this$_setAlignment, 2);\n      x = _this$_setAlignment2[0];\n      y = _this$_setAlignment2[1];\n      ctx.textAlign = \"left\";\n      x = x - this.size.width / 2; // Shift label 1/2-distance to the left\n      if (this.fontOptions.valign && this.size.height > this.size.labelHeight) {\n        if (this.fontOptions.valign === \"top\") {\n          y -= (this.size.height - this.size.labelHeight) / 2;\n        }\n        if (this.fontOptions.valign === \"bottom\") {\n          y += (this.size.height - this.size.labelHeight) / 2;\n        }\n      }\n\n      // draw the text\n      for (var i = 0; i < this.lineCount; i++) {\n        var line = this.lines[i];\n        if (line && line.blocks) {\n          var width = 0;\n          if (this.isEdgeLabel || this.fontOptions.align === \"center\") {\n            width += (this.size.width - line.width) / 2;\n          } else if (this.fontOptions.align === \"right\") {\n            width += this.size.width - line.width;\n          }\n          for (var j = 0; j < line.blocks.length; j++) {\n            var block = line.blocks[j];\n            ctx.font = block.font;\n            var _this$_getColor = this._getColor(block.color, viewFontSize, block.strokeColor),\n              _this$_getColor2 = _slicedToArray(_this$_getColor, 2),\n              fontColor = _this$_getColor2[0],\n              strokeColor = _this$_getColor2[1];\n            if (block.strokeWidth > 0) {\n              ctx.lineWidth = block.strokeWidth;\n              ctx.strokeStyle = strokeColor;\n              ctx.lineJoin = \"round\";\n            }\n            ctx.fillStyle = fontColor;\n            if (block.strokeWidth > 0) {\n              ctx.strokeText(block.text, x + width, y + block.vadjust);\n            }\n            ctx.fillText(block.text, x + width, y + block.vadjust);\n            width += block.width;\n          }\n          y += line.height;\n        }\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x\n     * @param {number} y\n     * @param {string} baseline\n     * @returns {Array.<number>}\n     * @private\n     */\n  }, {\n    key: \"_setAlignment\",\n    value: function _setAlignment(ctx, x, y, baseline) {\n      // check for label alignment (for edges)\n      // TODO: make alignment for nodes\n      if (this.isEdgeLabel && this.fontOptions.align !== \"horizontal\" && this.pointToSelf === false) {\n        x = 0;\n        y = 0;\n        var lineMargin = 2;\n        if (this.fontOptions.align === \"top\") {\n          ctx.textBaseline = \"alphabetic\";\n          y -= 2 * lineMargin; // distance from edge, required because we use alphabetic. Alphabetic has less difference between browsers\n        } else if (this.fontOptions.align === \"bottom\") {\n          ctx.textBaseline = \"hanging\";\n          y += 2 * lineMargin; // distance from edge, required because we use hanging. Hanging has less difference between browsers\n        } else {\n          ctx.textBaseline = \"middle\";\n        }\n      } else {\n        ctx.textBaseline = baseline;\n      }\n      return [x, y];\n    }\n\n    /**\n     * fade in when relative scale is between threshold and threshold - 1.\n     * If the relative scale would be smaller than threshold -1 the draw function would have returned before coming here.\n     *\n     * @param {string} color  The font color to use\n     * @param {number} viewFontSize\n     * @param {string} initialStrokeColor\n     * @returns {Array.<string>} An array containing the font color and stroke color\n     * @private\n     */\n  }, {\n    key: \"_getColor\",\n    value: function _getColor(color, viewFontSize, initialStrokeColor) {\n      var fontColor = color || \"#000000\";\n      var strokeColor = initialStrokeColor || \"#ffffff\";\n      if (viewFontSize <= this.elementOptions.scaling.label.drawThreshold) {\n        var opacity = Math.max(0, Math.min(1, 1 - (this.elementOptions.scaling.label.drawThreshold - viewFontSize)));\n        fontColor = overrideOpacity(fontColor, opacity);\n        strokeColor = overrideOpacity(strokeColor, opacity);\n      }\n      return [fontColor, strokeColor];\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @returns {{width: number, height: number}}\n     */\n  }, {\n    key: \"getTextSize\",\n    value: function getTextSize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this._processLabel(ctx, selected, hover);\n      return {\n        width: this.size.width,\n        height: this.size.height,\n        lineCount: this.lineCount\n      };\n    }\n\n    /**\n     * Get the current dimensions of the label\n     *\n     * @returns {rect}\n     */\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      var lineMargin = 2;\n      var x = this.size.left; // default values which might be overridden below\n      var y = this.size.top - 0.5 * lineMargin; // idem\n\n      if (this.isEdgeLabel) {\n        var x2 = -this.size.width * 0.5;\n        switch (this.fontOptions.align) {\n          case \"middle\":\n            x = x2;\n            y = -this.size.height * 0.5;\n            break;\n          case \"top\":\n            x = x2;\n            y = -(this.size.height + lineMargin);\n            break;\n          case \"bottom\":\n            x = x2;\n            y = lineMargin;\n            break;\n        }\n      }\n      var ret = {\n        left: x,\n        top: y,\n        width: this.size.width,\n        height: this.size.height\n      };\n      return ret;\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {number} [x=0]\n     * @param {number} [y=0]\n     * @param {'middle'|'hanging'} [baseline='middle']\n     */\n  }, {\n    key: \"calculateLabelSize\",\n    value: function calculateLabelSize(ctx, selected, hover) {\n      var x = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var y = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n      var baseline = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : \"middle\";\n      this._processLabel(ctx, selected, hover);\n      this.size.left = x - this.size.width * 0.5;\n      this.size.top = y - this.size.height * 0.5;\n      this.size.yLine = y + (1 - this.lineCount) * 0.5 * this.fontOptions.size;\n      if (baseline === \"hanging\") {\n        this.size.top += 0.5 * this.fontOptions.size;\n        this.size.top += 4; // distance from node, required because we use hanging. Hanging has less difference between browsers\n        this.size.yLine += 4; // distance from node\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {string} mod\n     * @returns {{color, size, face, mod, vadjust, strokeWidth: *, strokeColor: (*|string|allOptions.edges.font.strokeColor|{string}|allOptions.nodes.font.strokeColor|Array)}}\n     */\n  }, {\n    key: \"getFormattingValues\",\n    value: function getFormattingValues(ctx, selected, hover, mod) {\n      var getValue = function getValue(fontOptions, mod, option) {\n        if (mod === \"normal\") {\n          if (option === \"mod\") return \"\";\n          return fontOptions[option];\n        }\n        if (fontOptions[mod][option] !== undefined) {\n          // Grumbl leaving out test on undefined equals false for \"\"\n          return fontOptions[mod][option];\n        } else {\n          // Take from parent font option\n          return fontOptions[option];\n        }\n      };\n      var values = {\n        color: getValue(this.fontOptions, mod, \"color\"),\n        size: getValue(this.fontOptions, mod, \"size\"),\n        face: getValue(this.fontOptions, mod, \"face\"),\n        mod: getValue(this.fontOptions, mod, \"mod\"),\n        vadjust: getValue(this.fontOptions, mod, \"vadjust\"),\n        strokeWidth: this.fontOptions.strokeWidth,\n        strokeColor: this.fontOptions.strokeColor\n      };\n      if (selected || hover) {\n        if (mod === \"normal\" && this.fontOptions.chooser === true && this.elementOptions.labelHighlightBold) {\n          values.mod = \"bold\";\n        } else {\n          if (typeof this.fontOptions.chooser === \"function\") {\n            this.fontOptions.chooser(values, this.elementOptions.id, selected, hover);\n          }\n        }\n      }\n      var fontString = \"\";\n      if (values.mod !== undefined && values.mod !== \"\") {\n        // safeguard for undefined - this happened\n        fontString += values.mod + \" \";\n      }\n      fontString += values.size + \"px \" + values.face;\n      ctx.font = fontString.replace(/\"/g, \"\");\n      values.font = ctx.font;\n      values.height = values.size;\n      return values;\n    }\n\n    /**\n     *\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @returns {boolean}\n     */\n  }, {\n    key: \"differentState\",\n    value: function differentState(selected, hover) {\n      return selected !== this.selectedState || hover !== this.hoverState;\n    }\n\n    /**\n     * This explodes the passed text into lines and determines the width, height and number of lines.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {string} inText  the text to explode\n     * @returns {{width, height, lines}|*}\n     * @private\n     */\n  }, {\n    key: \"_processLabelText\",\n    value: function _processLabelText(ctx, selected, hover, inText) {\n      var splitter = new LabelSplitter(ctx, this, selected, hover);\n      return splitter.process(inText);\n    }\n\n    /**\n     * This explodes the label string into lines and sets the width, height and number of lines.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @private\n     */\n  }, {\n    key: \"_processLabel\",\n    value: function _processLabel(ctx, selected, hover) {\n      if (this.labelDirty === false && !this.differentState(selected, hover)) return;\n      var state = this._processLabelText(ctx, selected, hover, this.elementOptions.label);\n      if (this.fontOptions.minWdt > 0 && state.width < this.fontOptions.minWdt) {\n        state.width = this.fontOptions.minWdt;\n      }\n      this.size.labelHeight = state.height;\n      if (this.fontOptions.minHgt > 0 && state.height < this.fontOptions.minHgt) {\n        state.height = this.fontOptions.minHgt;\n      }\n      this.lines = state.lines;\n      this.lineCount = state.lines.length;\n      this.size.width = state.width;\n      this.size.height = state.height;\n      this.selectedState = selected;\n      this.hoverState = hover;\n      this.labelDirty = false;\n    }\n\n    /**\n     * Check if this label is visible\n     *\n     * @returns {boolean} true if this label will be show, false otherwise\n     */\n  }, {\n    key: \"visible\",\n    value: function visible() {\n      if (this.size.width === 0 || this.size.height === 0 || this.elementOptions.label === undefined) {\n        return false; // nothing to display\n      }\n\n      var viewFontSize = this.fontOptions.size * this.body.view.scale;\n      if (viewFontSize < this.elementOptions.scaling.label.drawThreshold - 1) {\n        return false; // Too small or too far away to show\n      }\n\n      return true;\n    }\n  }], [{\n    key: \"parseFontString\",\n    value: function parseFontString(outOptions, inOptions) {\n      if (!inOptions || typeof inOptions !== \"string\") return false;\n      var newOptionsArray = inOptions.split(\" \");\n      outOptions.size = +newOptionsArray[0].replace(\"px\", \"\");\n      outOptions.face = newOptionsArray[1];\n      outOptions.color = newOptionsArray[2];\n      return true;\n    }\n  }]);\n  return Label;\n}();\n\nvar isConstructor = isConstructor$4;\nvar tryToString = tryToString$6;\n\nvar $TypeError$1 = TypeError;\n\n// `Assert: IsConstructor(argument) is true`\nvar aConstructor$1 = function (argument) {\n  if (isConstructor(argument)) return argument;\n  throw new $TypeError$1(tryToString(argument) + ' is not a constructor');\n};\n\nvar $$6 = _export;\nvar getBuiltIn = getBuiltIn$c;\nvar apply = functionApply;\nvar bind$3 = functionBind;\nvar aConstructor = aConstructor$1;\nvar anObject$2 = anObject$d;\nvar isObject$3 = isObject$j;\nvar create$3 = objectCreate;\nvar fails$2 = fails$w;\n\nvar nativeConstruct = getBuiltIn('Reflect', 'construct');\nvar ObjectPrototype = Object.prototype;\nvar push$1 = [].push;\n\n// `Reflect.construct` method\n// https://tc39.es/ecma262/#sec-reflect.construct\n// MS Edge supports only 2 arguments and argumentsList argument is optional\n// FF Nightly sets third argument as `new.target`, but does not create `this` from it\nvar NEW_TARGET_BUG = fails$2(function () {\n  function F() { /* empty */ }\n  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);\n});\n\nvar ARGS_BUG = !fails$2(function () {\n  nativeConstruct(function () { /* empty */ });\n});\n\nvar FORCED$3 = NEW_TARGET_BUG || ARGS_BUG;\n\n$$6({ target: 'Reflect', stat: true, forced: FORCED$3, sham: FORCED$3 }, {\n  construct: function construct(Target, args /* , newTarget */) {\n    aConstructor(Target);\n    anObject$2(args);\n    var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);\n    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);\n    if (Target === newTarget) {\n      // w/o altered newTarget, optimization for 0-4 arguments\n      switch (args.length) {\n        case 0: return new Target();\n        case 1: return new Target(args[0]);\n        case 2: return new Target(args[0], args[1]);\n        case 3: return new Target(args[0], args[1], args[2]);\n        case 4: return new Target(args[0], args[1], args[2], args[3]);\n      }\n      // w/o altered newTarget, lot of arguments case\n      var $args = [null];\n      apply(push$1, $args, args);\n      return new (apply(bind$3, Target, $args))();\n    }\n    // with altered newTarget, not support built-in constructors\n    var proto = newTarget.prototype;\n    var instance = create$3(isObject$3(proto) ? proto : ObjectPrototype);\n    var result = apply(Target, instance, args);\n    return isObject$3(result) ? result : instance;\n  }\n});\n\nvar path$6 = path$w;\n\nvar construct$2 = path$6.Reflect.construct;\n\nvar parent$k = construct$2;\n\nvar construct$1 = parent$k;\n\nvar construct = construct$1;\n\nvar _Reflect$construct = /*@__PURE__*/getDefaultExportFromCjs(construct);\n\nvar parent$j = create$6;\n\nvar create$2 = parent$j;\n\nvar parent$i = create$2;\n\nvar create$1 = parent$i;\n\nvar create = create$1;\n\nvar _Object$create = /*@__PURE__*/getDefaultExportFromCjs(create);\n\nvar $$5 = _export;\nvar setPrototypeOf$5 = objectSetPrototypeOf;\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n$$5({ target: 'Object', stat: true }, {\n  setPrototypeOf: setPrototypeOf$5\n});\n\nvar path$5 = path$w;\n\nvar setPrototypeOf$4 = path$5.Object.setPrototypeOf;\n\nvar parent$h = setPrototypeOf$4;\n\nvar setPrototypeOf$3 = parent$h;\n\nvar parent$g = setPrototypeOf$3;\n\nvar setPrototypeOf$2 = parent$g;\n\nvar parent$f = setPrototypeOf$2;\n\nvar setPrototypeOf$1 = parent$f;\n\nvar setPrototypeOf = setPrototypeOf$1;\n\nvar _Object$setPrototypeOf = /*@__PURE__*/getDefaultExportFromCjs(setPrototypeOf);\n\nvar parent$e = bind$9;\n\nvar bind$2 = parent$e;\n\nvar parent$d = bind$2;\n\nvar bind$1 = parent$d;\n\nvar bind = bind$1;\n\nvar _bindInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(bind);\n\nfunction _setPrototypeOf(o, p) {\n  var _context;\n  _setPrototypeOf = _Object$setPrototypeOf ? _bindInstanceProperty(_context = _Object$setPrototypeOf).call(_context) : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = _Object$create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  _Object$defineProperty$1(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\n\nvar parent$c = getPrototypeOf$5;\n\nvar getPrototypeOf$3 = parent$c;\n\nvar parent$b = getPrototypeOf$3;\n\nvar getPrototypeOf$2 = parent$b;\n\nvar getPrototypeOf$1 = getPrototypeOf$2;\n\nvar _Object$getPrototypeOf = /*@__PURE__*/getDefaultExportFromCjs(getPrototypeOf$1);\n\nfunction _getPrototypeOf(o) {\n  var _context;\n  _getPrototypeOf = _Object$setPrototypeOf ? _bindInstanceProperty(_context = _Object$getPrototypeOf).call(_context) : function _getPrototypeOf(o) {\n    return o.__proto__ || _Object$getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\n/**\n * The Base class for all Nodes.\n */\nvar NodeBase = /*#__PURE__*/function () {\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function NodeBase(options, body, labelModule) {\n    _classCallCheck(this, NodeBase);\n    this.body = body;\n    this.labelModule = labelModule;\n    this.setOptions(options);\n    this.top = undefined;\n    this.left = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.radius = undefined;\n    this.margin = undefined;\n    this.refreshNeeded = true;\n    this.boundingBox = {\n      top: 0,\n      left: 0,\n      right: 0,\n      bottom: 0\n    };\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(NodeBase, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n\n    /**\n     *\n     * @param {Label} labelModule\n     * @private\n     */\n  }, {\n    key: \"_setMargins\",\n    value: function _setMargins(labelModule) {\n      this.margin = {};\n      if (this.options.margin) {\n        if (_typeof(this.options.margin) == \"object\") {\n          this.margin.top = this.options.margin.top;\n          this.margin.right = this.options.margin.right;\n          this.margin.bottom = this.options.margin.bottom;\n          this.margin.left = this.options.margin.left;\n        } else {\n          this.margin.top = this.options.margin;\n          this.margin.right = this.options.margin;\n          this.margin.bottom = this.options.margin;\n          this.margin.left = this.options.margin;\n        }\n      }\n      labelModule.adjustSizes(this.margin);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_distanceToBorder\",\n    value: function _distanceToBorder(ctx, angle) {\n      var borderWidth = this.options.borderWidth;\n      if (ctx) {\n        this.resize(ctx);\n      }\n      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"enableShadow\",\n    value: function enableShadow(ctx, values) {\n      if (values.shadow) {\n        ctx.shadowColor = values.shadowColor;\n        ctx.shadowBlur = values.shadowSize;\n        ctx.shadowOffsetX = values.shadowX;\n        ctx.shadowOffsetY = values.shadowY;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"disableShadow\",\n    value: function disableShadow(ctx, values) {\n      if (values.shadow) {\n        ctx.shadowColor = \"rgba(0,0,0,0)\";\n        ctx.shadowBlur = 0;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"enableBorderDashes\",\n    value: function enableBorderDashes(ctx, values) {\n      if (values.borderDashes !== false) {\n        if (ctx.setLineDash !== undefined) {\n          var dashes = values.borderDashes;\n          if (dashes === true) {\n            dashes = [5, 15];\n          }\n          ctx.setLineDash(dashes);\n        } else {\n          console.warn(\"setLineDash is not supported in this browser. The dashed borders cannot be used.\");\n          this.options.shapeProperties.borderDashes = false;\n          values.borderDashes = false;\n        }\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"disableBorderDashes\",\n    value: function disableBorderDashes(ctx, values) {\n      if (values.borderDashes !== false) {\n        if (ctx.setLineDash !== undefined) {\n          ctx.setLineDash([0]);\n        } else {\n          console.warn(\"setLineDash is not supported in this browser. The dashed borders cannot be used.\");\n          this.options.shapeProperties.borderDashes = false;\n          values.borderDashes = false;\n        }\n      }\n    }\n\n    /**\n     * Determine if the shape of a node needs to be recalculated.\n     *\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @returns {boolean}\n     * @protected\n     */\n  }, {\n    key: \"needsRefresh\",\n    value: function needsRefresh(selected, hover) {\n      if (this.refreshNeeded === true) {\n        // This is probably not the best location to reset this member.\n        // However, in the current logic, it is the most convenient one.\n        this.refreshNeeded = false;\n        return true;\n      }\n      return this.width === undefined || this.labelModule.differentState(selected, hover);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"initContextForDraw\",\n    value: function initContextForDraw(ctx, values) {\n      var borderWidth = values.borderWidth / this.body.view.scale;\n      ctx.lineWidth = Math.min(this.width, borderWidth);\n      ctx.strokeStyle = values.borderColor;\n      ctx.fillStyle = values.color;\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"performStroke\",\n    value: function performStroke(ctx, values) {\n      var borderWidth = values.borderWidth / this.body.view.scale;\n\n      //draw dashed border if enabled, save and restore is required for firefox not to crash on unix.\n      ctx.save();\n      // if borders are zero width, they will be drawn with width 1 by default. This prevents that\n      if (borderWidth > 0) {\n        this.enableBorderDashes(ctx, values);\n        //draw the border\n        ctx.stroke();\n        //disable dashed border for other elements\n        this.disableBorderDashes(ctx, values);\n      }\n      ctx.restore();\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"performFill\",\n    value: function performFill(ctx, values) {\n      ctx.save();\n      ctx.fillStyle = values.color;\n      // draw shadow if enabled\n      this.enableShadow(ctx, values);\n      // draw the background\n      _fillInstanceProperty(ctx).call(ctx);\n      // disable shadows for other elements.\n      this.disableShadow(ctx, values);\n      ctx.restore();\n      this.performStroke(ctx, values);\n    }\n\n    /**\n     *\n     * @param {number} margin\n     * @private\n     */\n  }, {\n    key: \"_addBoundingBoxMargin\",\n    value: function _addBoundingBoxMargin(margin) {\n      this.boundingBox.left -= margin;\n      this.boundingBox.top -= margin;\n      this.boundingBox.bottom += margin;\n      this.boundingBox.right += margin;\n    }\n\n    /**\n     * Actual implementation of this method call.\n     *\n     * Doing it like this makes it easier to override\n     * in the child classes.\n     *\n     * @param {number} x width\n     * @param {number} y height\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @private\n     */\n  }, {\n    key: \"_updateBoundingBox\",\n    value: function _updateBoundingBox(x, y, ctx, selected, hover) {\n      if (ctx !== undefined) {\n        this.resize(ctx, selected, hover);\n      }\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this.boundingBox.left = this.left;\n      this.boundingBox.top = this.top;\n      this.boundingBox.bottom = this.top + this.height;\n      this.boundingBox.right = this.left + this.width;\n    }\n\n    /**\n     * Default implementation of this method call.\n     * This acts as a stub which can be overridden.\n     *\n     * @param {number} x width\n     * @param {number} y height\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     */\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y, ctx, selected, hover) {\n      this._updateBoundingBox(x, y, ctx, selected, hover);\n    }\n\n    /**\n     * Determine the dimensions to use for nodes with an internal label\n     *\n     * Currently, these are: Circle, Ellipse, Database, Box\n     * The other nodes have external labels, and will not call this method\n     *\n     * If there is no label, decent default values are supplied.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} [selected]\n     * @param {boolean} [hover]\n     * @returns {{width:number, height:number}}\n     */\n  }, {\n    key: \"getDimensionsFromLabel\",\n    value: function getDimensionsFromLabel(ctx, selected, hover) {\n      // NOTE: previously 'textSize' was not put in 'this' for Ellipse\n      // TODO: examine the consequences.\n      this.textSize = this.labelModule.getTextSize(ctx, selected, hover);\n      var width = this.textSize.width;\n      var height = this.textSize.height;\n      var DEFAULT_SIZE = 14;\n      if (width === 0) {\n        // This happens when there is no label text set\n        width = DEFAULT_SIZE; // use a decent default\n        height = DEFAULT_SIZE; // if width zero, then height also always zero\n      }\n\n      return {\n        width: width,\n        height: height\n      };\n    }\n  }]);\n  return NodeBase;\n}();\n\nfunction _createSuper$s(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$s(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$s() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Box Node/Cluster shape.\n *\n * @augments NodeBase\n */\nvar Box$1 = /*#__PURE__*/function (_NodeBase) {\n  _inherits(Box, _NodeBase);\n  var _super = _createSuper$s(Box);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Box(options, body, labelModule) {\n    var _this;\n    _classCallCheck(this, Box);\n    _this = _super.call(this, options, body, labelModule);\n    _this._setMargins(labelModule);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n  _createClass(Box, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n        this.width = dimensions.width + this.margin.right + this.margin.left;\n        this.height = dimensions.height + this.margin.top + this.margin.bottom;\n        this.radius = this.width / 2;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this.initContextForDraw(ctx, values);\n      drawRoundRect(ctx, this.left, this.top, this.width, this.height, values.borderRadius);\n      this.performFill(ctx, values);\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);\n    }\n\n    /**\n     *\n     * @param {number} x width\n     * @param {number} y height\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {boolean} selected\n     * @param {boolean} hover\n     */\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y, ctx, selected, hover) {\n      this._updateBoundingBox(x, y, ctx, selected, hover);\n      var borderRadius = this.options.shapeProperties.borderRadius; // only effective for box\n      this._addBoundingBoxMargin(borderRadius);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n      var borderWidth = this.options.borderWidth;\n      return Math.min(Math.abs(this.width / 2 / Math.cos(angle)), Math.abs(this.height / 2 / Math.sin(angle))) + borderWidth;\n    }\n  }]);\n  return Box;\n}(NodeBase);\n\nfunction _createSuper$r(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$r(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$r() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * NOTE: This is a bad base class\n *\n * Child classes are:\n *\n *   Image       - uses *only* image methods\n *   Circle      - uses *only* _drawRawCircle\n *   CircleImage - uses all\n *\n * TODO: Refactor, move _drawRawCircle to different module, derive Circle from NodeBase\n *       Rename this to ImageBase\n *       Consolidate common code in Image and CircleImage to base class\n *\n * @augments NodeBase\n */\nvar CircleImageBase = /*#__PURE__*/function (_NodeBase) {\n  _inherits(CircleImageBase, _NodeBase);\n  var _super = _createSuper$r(CircleImageBase);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function CircleImageBase(options, body, labelModule) {\n    var _this;\n    _classCallCheck(this, CircleImageBase);\n    _this = _super.call(this, options, body, labelModule);\n    _this.labelOffset = 0;\n    _this.selected = false;\n    return _this;\n  }\n\n  /**\n   *\n   * @param {object} options\n   * @param {object} [imageObj]\n   * @param {object} [imageObjAlt]\n   */\n  _createClass(CircleImageBase, [{\n    key: \"setOptions\",\n    value: function setOptions(options, imageObj, imageObjAlt) {\n      this.options = options;\n      if (!(imageObj === undefined && imageObjAlt === undefined)) {\n        this.setImages(imageObj, imageObjAlt);\n      }\n    }\n\n    /**\n     * Set the images for this node.\n     *\n     * The images can be updated after the initial setting of options;\n     * therefore, this method needs to be reentrant.\n     *\n     * For correct working in error cases, it is necessary to properly set\n     * field 'nodes.brokenImage' in the options.\n     *\n     * @param {Image} imageObj  required; main image to show for this node\n     * @param {Image|undefined} imageObjAlt optional; image to show when node is selected\n     */\n  }, {\n    key: \"setImages\",\n    value: function setImages(imageObj, imageObjAlt) {\n      if (imageObjAlt && this.selected) {\n        this.imageObj = imageObjAlt;\n        this.imageObjAlt = imageObj;\n      } else {\n        this.imageObj = imageObj;\n        this.imageObjAlt = imageObjAlt;\n      }\n    }\n\n    /**\n     * Set selection and switch between the base and the selected image.\n     *\n     * Do the switch only if imageObjAlt exists.\n     *\n     * @param {boolean} selected value of new selected state for current node\n     */\n  }, {\n    key: \"switchImages\",\n    value: function switchImages(selected) {\n      var selection_changed = selected && !this.selected || !selected && this.selected;\n      this.selected = selected; // Remember new selection\n\n      if (this.imageObjAlt !== undefined && selection_changed) {\n        var imageTmp = this.imageObj;\n        this.imageObj = this.imageObjAlt;\n        this.imageObjAlt = imageTmp;\n      }\n    }\n\n    /**\n     * Returns Image Padding from node options\n     *\n     * @returns {{top: number,left: number,bottom: number,right: number}} image padding inside this shape\n     * @private\n     */\n  }, {\n    key: \"_getImagePadding\",\n    value: function _getImagePadding() {\n      var imgPadding = {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      };\n      if (this.options.imagePadding) {\n        var optImgPadding = this.options.imagePadding;\n        if (_typeof(optImgPadding) == \"object\") {\n          imgPadding.top = optImgPadding.top;\n          imgPadding.right = optImgPadding.right;\n          imgPadding.bottom = optImgPadding.bottom;\n          imgPadding.left = optImgPadding.left;\n        } else {\n          imgPadding.top = optImgPadding;\n          imgPadding.right = optImgPadding;\n          imgPadding.bottom = optImgPadding;\n          imgPadding.left = optImgPadding;\n        }\n      }\n      return imgPadding;\n    }\n\n    /**\n     * Adjust the node dimensions for a loaded image.\n     *\n     * Pre: this.imageObj is valid\n     */\n  }, {\n    key: \"_resizeImage\",\n    value: function _resizeImage() {\n      var width, height;\n      if (this.options.shapeProperties.useImageSize === false) {\n        // Use the size property\n        var ratio_width = 1;\n        var ratio_height = 1;\n\n        // Only calculate the proper ratio if both width and height not zero\n        if (this.imageObj.width && this.imageObj.height) {\n          if (this.imageObj.width > this.imageObj.height) {\n            ratio_width = this.imageObj.width / this.imageObj.height;\n          } else {\n            ratio_height = this.imageObj.height / this.imageObj.width;\n          }\n        }\n        width = this.options.size * 2 * ratio_width;\n        height = this.options.size * 2 * ratio_height;\n      } else {\n        // Use the image size with image padding\n        var imgPadding = this._getImagePadding();\n        width = this.imageObj.width + imgPadding.left + imgPadding.right;\n        height = this.imageObj.height + imgPadding.top + imgPadding.bottom;\n      }\n      this.width = width;\n      this.height = height;\n      this.radius = 0.5 * this.width;\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {ArrowOptions} values\n     * @private\n     */\n  }, {\n    key: \"_drawRawCircle\",\n    value: function _drawRawCircle(ctx, x, y, values) {\n      this.initContextForDraw(ctx, values);\n      drawCircle(ctx, x, y, values.size);\n      this.performFill(ctx, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {ArrowOptions} values\n     * @private\n     */\n  }, {\n    key: \"_drawImageAtPosition\",\n    value: function _drawImageAtPosition(ctx, values) {\n      if (this.imageObj.width != 0) {\n        // draw the image\n        ctx.globalAlpha = values.opacity !== undefined ? values.opacity : 1;\n\n        // draw shadow if enabled\n        this.enableShadow(ctx, values);\n        var factor = 1;\n        if (this.options.shapeProperties.interpolation === true) {\n          factor = this.imageObj.width / this.width / this.body.view.scale;\n        }\n        var imgPadding = this._getImagePadding();\n        var imgPosLeft = this.left + imgPadding.left;\n        var imgPosTop = this.top + imgPadding.top;\n        var imgWidth = this.width - imgPadding.left - imgPadding.right;\n        var imgHeight = this.height - imgPadding.top - imgPadding.bottom;\n        this.imageObj.drawImageAtPosition(ctx, factor, imgPosLeft, imgPosTop, imgWidth, imgHeight);\n\n        // disable shadows for other elements.\n        this.disableShadow(ctx, values);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @private\n     */\n  }, {\n    key: \"_drawImageLabel\",\n    value: function _drawImageLabel(ctx, x, y, selected, hover) {\n      var offset = 0;\n      if (this.height !== undefined) {\n        offset = this.height * 0.5;\n        var labelDimensions = this.labelModule.getTextSize(ctx, selected, hover);\n        if (labelDimensions.lineCount >= 1) {\n          offset += labelDimensions.height / 2;\n        }\n      }\n      var yLabel = y + offset;\n      if (this.options.label) {\n        this.labelOffset = offset;\n      }\n      this.labelModule.draw(ctx, x, yLabel, selected, hover, \"hanging\");\n    }\n  }]);\n  return CircleImageBase;\n}(NodeBase);\n\nfunction _createSuper$q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$q(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$q() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Circle Node/Cluster shape.\n *\n * @augments CircleImageBase\n */\nvar Circle$1 = /*#__PURE__*/function (_CircleImageBase) {\n  _inherits(Circle, _CircleImageBase);\n  var _super = _createSuper$q(Circle);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Circle(options, body, labelModule) {\n    var _this;\n    _classCallCheck(this, Circle);\n    _this = _super.call(this, options, body, labelModule);\n    _this._setMargins(labelModule);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n  _createClass(Circle, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n        var diameter = Math.max(dimensions.width + this.margin.right + this.margin.left, dimensions.height + this.margin.top + this.margin.bottom);\n        this.options.size = diameter / 2; // NOTE: this size field only set here, not in Ellipse, Database, Box\n        this.width = diameter;\n        this.height = diameter;\n        this.radius = this.width / 2;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this._drawRawCircle(ctx, x, y, values);\n      this.updateBoundingBox(x, y);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, y, selected, hover);\n    }\n\n    /**\n     *\n     * @param {number} x width\n     * @param {number} y height\n     */\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      this.boundingBox.top = y - this.options.size;\n      this.boundingBox.left = x - this.options.size;\n      this.boundingBox.right = x + this.options.size;\n      this.boundingBox.bottom = y + this.options.size;\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n      return this.width * 0.5;\n    }\n  }]);\n  return Circle;\n}(CircleImageBase);\n\nfunction _createSuper$p(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$p(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$p() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A CircularImage Node/Cluster shape.\n *\n * @augments CircleImageBase\n */\nvar CircularImage = /*#__PURE__*/function (_CircleImageBase) {\n  _inherits(CircularImage, _CircleImageBase);\n  var _super = _createSuper$p(CircularImage);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   * @param {Image} imageObj\n   * @param {Image} imageObjAlt\n   */\n  function CircularImage(options, body, labelModule, imageObj, imageObjAlt) {\n    var _this;\n    _classCallCheck(this, CircularImage);\n    _this = _super.call(this, options, body, labelModule);\n    _this.setImages(imageObj, imageObjAlt);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n  _createClass(CircularImage, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n      var imageAbsent = this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined;\n      if (imageAbsent) {\n        var diameter = this.options.size * 2;\n        this.width = diameter;\n        this.height = diameter;\n        this.radius = 0.5 * this.width;\n        return;\n      }\n\n      // At this point, an image is present, i.e. this.imageObj is valid.\n      if (this.needsRefresh(selected, hover)) {\n        this._resizeImage();\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.switchImages(selected);\n      this.resize();\n      var labelX = x,\n        labelY = y;\n      if (this.options.shapeProperties.coordinateOrigin === \"top-left\") {\n        this.left = x;\n        this.top = y;\n        labelX += this.width / 2;\n        labelY += this.height / 2;\n      } else {\n        this.left = x - this.width / 2;\n        this.top = y - this.height / 2;\n      }\n\n      // draw the background circle. IMPORTANT: the stroke in this method is used by the clip method below.\n      this._drawRawCircle(ctx, labelX, labelY, values);\n\n      // now we draw in the circle, we save so we can revert the clip operation after drawing.\n      ctx.save();\n      // clip is used to use the stroke in drawRawCircle as an area that we can draw in.\n      ctx.clip();\n      // draw the image\n      this._drawImageAtPosition(ctx, values);\n      // restore so we can again draw on the full canvas\n      ctx.restore();\n      this._drawImageLabel(ctx, labelX, labelY, selected, hover);\n      this.updateBoundingBox(x, y);\n    }\n\n    // TODO: compare with Circle.updateBoundingBox(), consolidate? More stuff is happening here\n    /**\n     *\n     * @param {number} x width\n     * @param {number} y height\n     */\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      if (this.options.shapeProperties.coordinateOrigin === \"top-left\") {\n        this.boundingBox.top = y;\n        this.boundingBox.left = x;\n        this.boundingBox.right = x + this.options.size * 2;\n        this.boundingBox.bottom = y + this.options.size * 2;\n      } else {\n        this.boundingBox.top = y - this.options.size;\n        this.boundingBox.left = x - this.options.size;\n        this.boundingBox.right = x + this.options.size;\n        this.boundingBox.bottom = y + this.options.size;\n      }\n\n      // TODO: compare with Image.updateBoundingBox(), consolidate?\n      this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n      this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n      this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n      return this.width * 0.5;\n    }\n  }]);\n  return CircularImage;\n}(CircleImageBase);\n\nfunction _createSuper$o(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$o(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$o() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * Base class for constructing Node/Cluster Shapes.\n *\n * @augments NodeBase\n */\nvar ShapeBase = /*#__PURE__*/function (_NodeBase) {\n  _inherits(ShapeBase, _NodeBase);\n  var _super = _createSuper$o(ShapeBase);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function ShapeBase(options, body, labelModule) {\n    _classCallCheck(this, ShapeBase);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   * @param {object} [values={size: this.options.size}]\n   */\n  _createClass(ShapeBase, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n      var values = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n        size: this.options.size\n      };\n      if (this.needsRefresh(selected, hover)) {\n        var _this$customSizeWidth, _this$customSizeHeigh;\n        this.labelModule.getTextSize(ctx, selected, hover);\n        var size = 2 * values.size;\n        this.width = (_this$customSizeWidth = this.customSizeWidth) !== null && _this$customSizeWidth !== void 0 ? _this$customSizeWidth : size;\n        this.height = (_this$customSizeHeigh = this.customSizeHeight) !== null && _this$customSizeHeigh !== void 0 ? _this$customSizeHeigh : size;\n        this.radius = 0.5 * this.width;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {string} shape\n     * @param {number} sizeMultiplier - Unused! TODO: Remove next major release\n     * @param {number} x\n     * @param {number} y\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     * @private\n     * @returns {object} Callbacks to draw later on higher layers.\n     */\n  }, {\n    key: \"_drawShape\",\n    value: function _drawShape(ctx, shape, sizeMultiplier, x, y, selected, hover, values) {\n      var _this = this;\n      this.resize(ctx, selected, hover, values);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this.initContextForDraw(ctx, values);\n      getShape(shape)(ctx, x, y, values.size);\n      this.performFill(ctx, values);\n      if (this.options.icon !== undefined) {\n        if (this.options.icon.code !== undefined) {\n          ctx.font = (selected ? \"bold \" : \"\") + this.height / 2 + \"px \" + (this.options.icon.face || \"FontAwesome\");\n          ctx.fillStyle = this.options.icon.color || \"black\";\n          ctx.textAlign = \"center\";\n          ctx.textBaseline = \"middle\";\n          ctx.fillText(this.options.icon.code, x, y);\n        }\n      }\n      return {\n        drawExternalLabel: function drawExternalLabel() {\n          if (_this.options.label !== undefined) {\n            // Need to call following here in order to ensure value for\n            // `this.labelModule.size.height`.\n            _this.labelModule.calculateLabelSize(ctx, selected, hover, x, y, \"hanging\");\n            var yLabel = y + 0.5 * _this.height + 0.5 * _this.labelModule.size.height;\n            _this.labelModule.draw(ctx, x, yLabel, selected, hover, \"hanging\");\n          }\n          _this.updateBoundingBox(x, y);\n        }\n      };\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     */\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      this.boundingBox.top = y - this.options.size;\n      this.boundingBox.left = x - this.options.size;\n      this.boundingBox.right = x + this.options.size;\n      this.boundingBox.bottom = y + this.options.size;\n      if (this.options.label !== undefined && this.labelModule.size.width > 0) {\n        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height);\n      }\n    }\n  }]);\n  return ShapeBase;\n}(NodeBase);\n\nfunction ownKeys$3(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor$1(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$3(e) { for (var r = 1; r < arguments.length; r++) { var _context, _context2; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context = ownKeys$3(Object(t), !0)).call(_context, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context2 = ownKeys$3(Object(t))).call(_context2, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor$1(t, r)); }); } return e; }\nfunction _createSuper$n(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$n(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$n() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A CustomShape Node/Cluster shape.\n *\n * @augments ShapeBase\n */\nvar CustomShape = /*#__PURE__*/function (_ShapeBase) {\n  _inherits(CustomShape, _ShapeBase);\n  var _super = _createSuper$n(CustomShape);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   * @param {Function} ctxRenderer\n   */\n  function CustomShape(options, body, labelModule, ctxRenderer) {\n    var _this;\n    _classCallCheck(this, CustomShape);\n    _this = _super.call(this, options, body, labelModule, ctxRenderer);\n    _this.ctxRenderer = ctxRenderer;\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   * @returns {object} Callbacks to draw later on different layers.\n   */\n  _createClass(CustomShape, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover, values);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n\n      // Guard right away because someone may just draw in the function itself.\n      ctx.save();\n      var drawLater = this.ctxRenderer({\n        ctx: ctx,\n        id: this.options.id,\n        x: x,\n        y: y,\n        state: {\n          selected: selected,\n          hover: hover\n        },\n        style: _objectSpread$3({}, values),\n        label: this.options.label\n      });\n      // Render the node shape bellow arrows.\n      if (drawLater.drawNode != null) {\n        drawLater.drawNode();\n      }\n      ctx.restore();\n      if (drawLater.drawExternalLabel) {\n        // Guard the external label (above arrows) drawing function.\n        var drawExternalLabel = drawLater.drawExternalLabel;\n        drawLater.drawExternalLabel = function () {\n          ctx.save();\n          drawExternalLabel();\n          ctx.restore();\n        };\n      }\n      if (drawLater.nodeDimensions) {\n        this.customSizeWidth = drawLater.nodeDimensions.width;\n        this.customSizeHeight = drawLater.nodeDimensions.height;\n      }\n      return drawLater;\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return CustomShape;\n}(ShapeBase);\n\nfunction _createSuper$m(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$m(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$m() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Database Node/Cluster shape.\n *\n * @augments NodeBase\n */\nvar Database = /*#__PURE__*/function (_NodeBase) {\n  _inherits(Database, _NodeBase);\n  var _super = _createSuper$m(Database);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Database(options, body, labelModule) {\n    var _this;\n    _classCallCheck(this, Database);\n    _this = _super.call(this, options, body, labelModule);\n    _this._setMargins(labelModule);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} selected\n   * @param {boolean} hover\n   */\n  _createClass(Database, [{\n    key: \"resize\",\n    value: function resize(ctx, selected, hover) {\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n        var size = dimensions.width + this.margin.right + this.margin.left;\n        this.width = size;\n        this.height = size;\n        this.radius = this.width / 2;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this.initContextForDraw(ctx, values);\n      drawDatabase(ctx, x - this.width / 2, y - this.height / 2, this.width, this.height);\n      this.performFill(ctx, values);\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);\n    }\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Database;\n}(NodeBase);\n\nfunction _createSuper$l(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$l(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$l() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Diamond Node/Cluster shape.\n *\n * @augments ShapeBase\n */\nvar Diamond$1 = /*#__PURE__*/function (_ShapeBase) {\n  _inherits(Diamond, _ShapeBase);\n  var _super = _createSuper$l(Diamond);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Diamond(options, body, labelModule) {\n    _classCallCheck(this, Diamond);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n  _createClass(Diamond, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"diamond\", 4, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Diamond;\n}(ShapeBase);\n\nfunction _createSuper$k(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$k(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$k() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Dot Node/Cluster shape.\n *\n * @augments ShapeBase\n */\nvar Dot = /*#__PURE__*/function (_ShapeBase) {\n  _inherits(Dot, _ShapeBase);\n  var _super = _createSuper$k(Dot);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Dot(options, body, labelModule) {\n    _classCallCheck(this, Dot);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n  _createClass(Dot, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"circle\", 2, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n      return this.options.size;\n    }\n  }]);\n  return Dot;\n}(ShapeBase);\n\nfunction _createSuper$j(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$j(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$j() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * Am Ellipse Node/Cluster shape.\n *\n * @augments NodeBase\n */\nvar Ellipse = /*#__PURE__*/function (_NodeBase) {\n  _inherits(Ellipse, _NodeBase);\n  var _super = _createSuper$j(Ellipse);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Ellipse(options, body, labelModule) {\n    _classCallCheck(this, Ellipse);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n  _createClass(Ellipse, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n      if (this.needsRefresh(selected, hover)) {\n        var dimensions = this.getDimensionsFromLabel(ctx, selected, hover);\n        this.height = dimensions.height * 2;\n        this.width = dimensions.width + dimensions.height;\n        this.radius = 0.5 * this.width;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width * 0.5;\n      this.top = y - this.height * 0.5;\n      this.initContextForDraw(ctx, values);\n      drawEllipse(ctx, this.left, this.top, this.width, this.height);\n      this.performFill(ctx, values);\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n      this.labelModule.draw(ctx, x, y, selected, hover);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      if (ctx) {\n        this.resize(ctx);\n      }\n      var a = this.width * 0.5;\n      var b = this.height * 0.5;\n      var w = Math.sin(angle) * a;\n      var h = Math.cos(angle) * b;\n      return a * b / Math.sqrt(w * w + h * h);\n    }\n  }]);\n  return Ellipse;\n}(NodeBase);\n\nfunction _createSuper$i(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$i(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$i() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * An icon replacement for the default Node shape.\n *\n * @augments NodeBase\n */\nvar Icon = /*#__PURE__*/function (_NodeBase) {\n  _inherits(Icon, _NodeBase);\n  var _super = _createSuper$i(Icon);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Icon(options, body, labelModule) {\n    var _this;\n    _classCallCheck(this, Icon);\n    _this = _super.call(this, options, body, labelModule);\n    _this._setMargins(labelModule);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx - Unused.\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n  _createClass(Icon, [{\n    key: \"resize\",\n    value: function resize(ctx, selected, hover) {\n      if (this.needsRefresh(selected, hover)) {\n        this.iconSize = {\n          width: Number(this.options.icon.size),\n          height: Number(this.options.icon.size)\n        };\n        this.width = this.iconSize.width + this.margin.right + this.margin.left;\n        this.height = this.iconSize.height + this.margin.top + this.margin.bottom;\n        this.radius = 0.5 * this.width;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     * @returns {object} Callbacks to draw later on higher layers.\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      var _this2 = this;\n      this.resize(ctx, selected, hover);\n      this.options.icon.size = this.options.icon.size || 50;\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n      this._icon(ctx, x, y, selected, hover, values);\n      return {\n        drawExternalLabel: function drawExternalLabel() {\n          if (_this2.options.label !== undefined) {\n            var iconTextSpacing = 5;\n            _this2.labelModule.draw(ctx, _this2.left + _this2.iconSize.width / 2 + _this2.margin.left, y + _this2.height / 2 + iconTextSpacing, selected);\n          }\n          _this2.updateBoundingBox(x, y);\n        }\n      };\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     */\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      this.boundingBox.top = y - this.options.icon.size * 0.5;\n      this.boundingBox.left = x - this.options.icon.size * 0.5;\n      this.boundingBox.right = x + this.options.icon.size * 0.5;\n      this.boundingBox.bottom = y + this.options.icon.size * 0.5;\n      if (this.options.label !== undefined && this.labelModule.size.width > 0) {\n        var iconTextSpacing = 5;\n        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelModule.size.height + iconTextSpacing);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover - Unused\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"_icon\",\n    value: function _icon(ctx, x, y, selected, hover, values) {\n      var iconSize = Number(this.options.icon.size);\n      if (this.options.icon.code !== undefined) {\n        ctx.font = [this.options.icon.weight != null ? this.options.icon.weight : selected ? \"bold\" : \"\",\n        // If the weight is forced (for example to make Font Awesome 5 work\n        // properly) substitute slightly bigger size for bold font face.\n        (this.options.icon.weight != null && selected ? 5 : 0) + iconSize + \"px\", this.options.icon.face].join(\" \");\n\n        // draw icon\n        ctx.fillStyle = this.options.icon.color || \"black\";\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n\n        // draw shadow if enabled\n        this.enableShadow(ctx, values);\n        ctx.fillText(this.options.icon.code, x, y);\n\n        // disable shadows for other elements.\n        this.disableShadow(ctx, values);\n      } else {\n        console.error(\"When using the icon shape, you need to define the code in the icon options object. This can be done per node or globally.\");\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Icon;\n}(NodeBase);\n\nfunction _createSuper$h(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$h(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$h() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * An image-based replacement for the default Node shape.\n *\n * @augments CircleImageBase\n */\nvar Image$2 = /*#__PURE__*/function (_CircleImageBase) {\n  _inherits(Image, _CircleImageBase);\n  var _super = _createSuper$h(Image);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   * @param {Image} imageObj\n   * @param {Image} imageObjAlt\n   */\n  function Image(options, body, labelModule, imageObj, imageObjAlt) {\n    var _this;\n    _classCallCheck(this, Image);\n    _this = _super.call(this, options, body, labelModule);\n    _this.setImages(imageObj, imageObjAlt);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx - Unused.\n   * @param {boolean} [selected]\n   * @param {boolean} [hover]\n   */\n  _createClass(Image, [{\n    key: \"resize\",\n    value: function resize(ctx) {\n      var selected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.selected;\n      var hover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.hover;\n      var imageAbsent = this.imageObj.src === undefined || this.imageObj.width === undefined || this.imageObj.height === undefined;\n      if (imageAbsent) {\n        var side = this.options.size * 2;\n        this.width = side;\n        this.height = side;\n        return;\n      }\n      if (this.needsRefresh(selected, hover)) {\n        this._resizeImage();\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      ctx.save();\n      this.switchImages(selected);\n      this.resize();\n      var labelX = x,\n        labelY = y;\n      if (this.options.shapeProperties.coordinateOrigin === \"top-left\") {\n        this.left = x;\n        this.top = y;\n        labelX += this.width / 2;\n        labelY += this.height / 2;\n      } else {\n        this.left = x - this.width / 2;\n        this.top = y - this.height / 2;\n      }\n      if (this.options.shapeProperties.useBorderWithImage === true) {\n        var neutralborderWidth = this.options.borderWidth;\n        var selectionLineWidth = this.options.borderWidthSelected || 2 * this.options.borderWidth;\n        var borderWidth = (selected ? selectionLineWidth : neutralborderWidth) / this.body.view.scale;\n        ctx.lineWidth = Math.min(this.width, borderWidth);\n        ctx.beginPath();\n        var strokeStyle = selected ? this.options.color.highlight.border : hover ? this.options.color.hover.border : this.options.color.border;\n        var fillStyle = selected ? this.options.color.highlight.background : hover ? this.options.color.hover.background : this.options.color.background;\n        if (values.opacity !== undefined) {\n          strokeStyle = overrideOpacity(strokeStyle, values.opacity);\n          fillStyle = overrideOpacity(fillStyle, values.opacity);\n        }\n        // setup the line properties.\n        ctx.strokeStyle = strokeStyle;\n\n        // set a fillstyle\n        ctx.fillStyle = fillStyle;\n\n        // draw a rectangle to form the border around. This rectangle is filled so the opacity of a picture (in future vis releases?) can be used to tint the image\n        ctx.rect(this.left - 0.5 * ctx.lineWidth, this.top - 0.5 * ctx.lineWidth, this.width + ctx.lineWidth, this.height + ctx.lineWidth);\n        _fillInstanceProperty(ctx).call(ctx);\n        this.performStroke(ctx, values);\n        ctx.closePath();\n      }\n      this._drawImageAtPosition(ctx, values);\n      this._drawImageLabel(ctx, labelX, labelY, selected, hover);\n      this.updateBoundingBox(x, y);\n      ctx.restore();\n    }\n\n    /**\n     *\n     * @param {number} x\n     * @param {number} y\n     */\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(x, y) {\n      this.resize();\n      if (this.options.shapeProperties.coordinateOrigin === \"top-left\") {\n        this.left = x;\n        this.top = y;\n      } else {\n        this.left = x - this.width / 2;\n        this.top = y - this.height / 2;\n      }\n      this.boundingBox.left = this.left;\n      this.boundingBox.top = this.top;\n      this.boundingBox.bottom = this.top + this.height;\n      this.boundingBox.right = this.left + this.width;\n      if (this.options.label !== undefined && this.labelModule.size.width > 0) {\n        this.boundingBox.left = Math.min(this.boundingBox.left, this.labelModule.size.left);\n        this.boundingBox.right = Math.max(this.boundingBox.right, this.labelModule.size.left + this.labelModule.size.width);\n        this.boundingBox.bottom = Math.max(this.boundingBox.bottom, this.boundingBox.bottom + this.labelOffset);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Image;\n}(CircleImageBase);\n\nfunction _createSuper$g(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$g(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$g() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Square Node/Cluster shape.\n *\n * @augments ShapeBase\n */\nvar Square = /*#__PURE__*/function (_ShapeBase) {\n  _inherits(Square, _ShapeBase);\n  var _super = _createSuper$g(Square);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Square(options, body, labelModule) {\n    _classCallCheck(this, Square);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n  _createClass(Square, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"square\", 2, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Square;\n}(ShapeBase);\n\nfunction _createSuper$f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$f(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$f() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Hexagon Node/Cluster shape.\n *\n * @augments ShapeBase\n */\nvar Hexagon = /*#__PURE__*/function (_ShapeBase) {\n  _inherits(Hexagon, _ShapeBase);\n  var _super = _createSuper$f(Hexagon);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Hexagon(options, body, labelModule) {\n    _classCallCheck(this, Hexagon);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n  _createClass(Hexagon, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"hexagon\", 4, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Hexagon;\n}(ShapeBase);\n\nfunction _createSuper$e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$e(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$e() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Star Node/Cluster shape.\n *\n * @augments ShapeBase\n */\nvar Star = /*#__PURE__*/function (_ShapeBase) {\n  _inherits(Star, _ShapeBase);\n  var _super = _createSuper$e(Star);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Star(options, body, labelModule) {\n    _classCallCheck(this, Star);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x width\n   * @param {number} y height\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n  _createClass(Star, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"star\", 4, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Star;\n}(ShapeBase);\n\nfunction _createSuper$d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$d(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$d() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A text-based replacement for the default Node shape.\n *\n * @augments NodeBase\n */\nvar Text = /*#__PURE__*/function (_NodeBase) {\n  _inherits(Text, _NodeBase);\n  var _super = _createSuper$d(Text);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Text(options, body, labelModule) {\n    var _this;\n    _classCallCheck(this, Text);\n    _this = _super.call(this, options, body, labelModule);\n    _this._setMargins(labelModule);\n    return _this;\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {boolean} selected\n   * @param {boolean} hover\n   */\n  _createClass(Text, [{\n    key: \"resize\",\n    value: function resize(ctx, selected, hover) {\n      if (this.needsRefresh(selected, hover)) {\n        this.textSize = this.labelModule.getTextSize(ctx, selected, hover);\n        this.width = this.textSize.width + this.margin.right + this.margin.left;\n        this.height = this.textSize.height + this.margin.top + this.margin.bottom;\n        this.radius = 0.5 * this.width;\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} x width\n     * @param {number} y height\n     * @param {boolean} selected\n     * @param {boolean} hover\n     * @param {ArrowOptions} values\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      this.resize(ctx, selected, hover);\n      this.left = x - this.width / 2;\n      this.top = y - this.height / 2;\n\n      // draw shadow if enabled\n      this.enableShadow(ctx, values);\n      this.labelModule.draw(ctx, this.left + this.textSize.width / 2 + this.margin.left, this.top + this.textSize.height / 2 + this.margin.top, selected, hover);\n\n      // disable shadows for other elements.\n      this.disableShadow(ctx, values);\n      this.updateBoundingBox(x, y, ctx, selected, hover);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Text;\n}(NodeBase);\n\nfunction _createSuper$c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$c(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$c() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Triangle Node/Cluster shape.\n *\n * @augments ShapeBase\n */\nvar Triangle$1 = /*#__PURE__*/function (_ShapeBase) {\n  _inherits(Triangle, _ShapeBase);\n  var _super = _createSuper$c(Triangle);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function Triangle(options, body, labelModule) {\n    _classCallCheck(this, Triangle);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x\n   * @param {number} y\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n  _createClass(Triangle, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"triangle\", 3, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return Triangle;\n}(ShapeBase);\n\nfunction _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$b() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A downward facing Triangle Node/Cluster shape.\n *\n * @augments ShapeBase\n */\nvar TriangleDown = /*#__PURE__*/function (_ShapeBase) {\n  _inherits(TriangleDown, _ShapeBase);\n  var _super = _createSuper$b(TriangleDown);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Label} labelModule\n   */\n  function TriangleDown(options, body, labelModule) {\n    _classCallCheck(this, TriangleDown);\n    return _super.call(this, options, body, labelModule);\n  }\n\n  /**\n   *\n   * @param {CanvasRenderingContext2D} ctx\n   * @param {number} x\n   * @param {number} y\n   * @param {boolean} selected\n   * @param {boolean} hover\n   * @param {ArrowOptions} values\n   * @returns {object} Callbacks to draw later on higher layers.\n   */\n  _createClass(TriangleDown, [{\n    key: \"draw\",\n    value: function draw(ctx, x, y, selected, hover, values) {\n      return this._drawShape(ctx, \"triangleDown\", 3, x, y, selected, hover, values);\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {number} angle\n     * @returns {number}\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this._distanceToBorder(ctx, angle);\n    }\n  }]);\n  return TriangleDown;\n}(ShapeBase);\n\nfunction ownKeys$2(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor$1(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$2(e) { for (var r = 1; r < arguments.length; r++) { var _context5, _context6; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context5 = ownKeys$2(Object(t), !0)).call(_context5, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context6 = ownKeys$2(Object(t))).call(_context6, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor$1(t, r)); }); } return e; }\n\n/**\n * A node. A node can be connected to other nodes via one or multiple edges.\n */\nvar Node = /*#__PURE__*/function () {\n  /**\n   *\n   * @param {object} options An object containing options for the node. All\n   *                            options are optional, except for the id.\n   *                              {number} id     Id of the node. Required\n   *                              {string} label  Text label for the node\n   *                              {number} x      Horizontal position of the node\n   *                              {number} y      Vertical position of the node\n   *                              {string} shape  Node shape\n   *                              {string} image  An image url\n   *                              {string} title  A title text, can be HTML\n   *                              {anytype} group A group name or number\n   * @param {object} body               Shared state of current network instance\n   * @param {Network.Images} imagelist  A list with images. Only needed when the node has an image\n   * @param {Groups} grouplist          A list with groups. Needed for retrieving group options\n   * @param {object} globalOptions      Current global node options; these serve as defaults for the node instance\n   * @param {object} defaultOptions     Global default options for nodes; note that this is also the prototype\n   *                                    for parameter `globalOptions`.\n   */\n  function Node(options, body, imagelist, grouplist, globalOptions, defaultOptions) {\n    _classCallCheck(this, Node);\n    this.options = bridgeObject(globalOptions);\n    this.globalOptions = globalOptions;\n    this.defaultOptions = defaultOptions;\n    this.body = body;\n    this.edges = []; // all edges connected to this node\n\n    // set defaults for the options\n    this.id = undefined;\n    this.imagelist = imagelist;\n    this.grouplist = grouplist;\n\n    // state options\n    this.x = undefined;\n    this.y = undefined;\n    this.baseSize = this.options.size;\n    this.baseFontSize = this.options.font.size;\n    this.predefinedPosition = false; // used to check if initial fit should just take the range or approximate\n    this.selected = false;\n    this.hover = false;\n    this.labelModule = new Label(this.body, this.options, false /* Not edge label */);\n\n    this.setOptions(options);\n  }\n\n  /**\n   * Attach a edge to the node\n   *\n   * @param {Edge} edge\n   */\n  _createClass(Node, [{\n    key: \"attachEdge\",\n    value: function attachEdge(edge) {\n      var _context;\n      if (_indexOfInstanceProperty(_context = this.edges).call(_context, edge) === -1) {\n        this.edges.push(edge);\n      }\n    }\n\n    /**\n     * Detach a edge from the node\n     *\n     * @param {Edge} edge\n     */\n  }, {\n    key: \"detachEdge\",\n    value: function detachEdge(edge) {\n      var _context2;\n      var index = _indexOfInstanceProperty(_context2 = this.edges).call(_context2, edge);\n      if (index != -1) {\n        var _context3;\n        _spliceInstanceProperty(_context3 = this.edges).call(_context3, index, 1);\n      }\n    }\n\n    /**\n     * Set or overwrite options for the node\n     *\n     * @param {object} options an object with options\n     * @returns {null|boolean}\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var currentShape = this.options.shape;\n      if (!options) {\n        return; // Note that the return value will be 'undefined'! This is OK.\n      }\n\n      // Save the color for later.\n      // This is necessary in order to prevent local color from being overwritten by group color.\n      // TODO: To prevent such workarounds the way options are handled should be rewritten from scratch.\n      // This is not the only problem with current options handling.\n      if (typeof options.color !== \"undefined\") {\n        this._localColor = options.color;\n      }\n\n      // basic options\n      if (options.id !== undefined) {\n        this.id = options.id;\n      }\n      if (this.id === undefined) {\n        throw new Error(\"Node must have an id\");\n      }\n      Node.checkMass(options, this.id);\n\n      // set these options locally\n      // clear x and y positions\n      if (options.x !== undefined) {\n        if (options.x === null) {\n          this.x = undefined;\n          this.predefinedPosition = false;\n        } else {\n          this.x = _parseInt$1(options.x);\n          this.predefinedPosition = true;\n        }\n      }\n      if (options.y !== undefined) {\n        if (options.y === null) {\n          this.y = undefined;\n          this.predefinedPosition = false;\n        } else {\n          this.y = _parseInt$1(options.y);\n          this.predefinedPosition = true;\n        }\n      }\n      if (options.size !== undefined) {\n        this.baseSize = options.size;\n      }\n      if (options.value !== undefined) {\n        options.value = _parseFloat$1(options.value);\n      }\n\n      // this transforms all shorthands into fully defined options\n      Node.parseOptions(this.options, options, true, this.globalOptions, this.grouplist);\n      var pile = [options, this.options, this.defaultOptions];\n      this.chooser = choosify(\"node\", pile);\n      this._load_images();\n      this.updateLabelModule(options);\n\n      // Need to set local opacity after `this.updateLabelModule(options);` because `this.updateLabelModule(options);` overrites local opacity with group opacity\n      if (options.opacity !== undefined && Node.checkOpacity(options.opacity)) {\n        this.options.opacity = options.opacity;\n      }\n      this.updateShape(currentShape);\n      return options.hidden !== undefined || options.physics !== undefined;\n    }\n\n    /**\n     * Load the images from the options, for the nodes that need them.\n     *\n     * Images are always loaded, even if they are not used in the current shape.\n     * The user may switch to an image shape later on.\n     *\n     * @private\n     */\n  }, {\n    key: \"_load_images\",\n    value: function _load_images() {\n      if (this.options.shape === \"circularImage\" || this.options.shape === \"image\") {\n        if (this.options.image === undefined) {\n          throw new Error(\"Option image must be defined for node type '\" + this.options.shape + \"'\");\n        }\n      }\n      if (this.options.image === undefined) {\n        return;\n      }\n      if (this.imagelist === undefined) {\n        throw new Error(\"Internal Error: No images provided\");\n      }\n      if (typeof this.options.image === \"string\") {\n        this.imageObj = this.imagelist.load(this.options.image, this.options.brokenImage, this.id);\n      } else {\n        if (this.options.image.unselected === undefined) {\n          throw new Error(\"No unselected image provided\");\n        }\n        this.imageObj = this.imagelist.load(this.options.image.unselected, this.options.brokenImage, this.id);\n        if (this.options.image.selected !== undefined) {\n          this.imageObjAlt = this.imagelist.load(this.options.image.selected, this.options.brokenImage, this.id);\n        } else {\n          this.imageObjAlt = undefined;\n        }\n      }\n    }\n\n    /**\n     * Check that opacity is only between 0 and 1\n     *\n     * @param {number} opacity\n     * @returns {boolean}\n     */\n  }, {\n    key: \"getFormattingValues\",\n    value:\n    /**\n     *\n     * @returns {{color: *, borderWidth: *, borderColor: *, size: *, borderDashes: (boolean|Array|allOptions.nodes.shapeProperties.borderDashes|{boolean, array}), borderRadius: (number|allOptions.nodes.shapeProperties.borderRadius|{number}|Array), shadow: *, shadowColor: *, shadowSize: *, shadowX: *, shadowY: *}}\n     */\n    function getFormattingValues() {\n      var values = {\n        color: this.options.color.background,\n        opacity: this.options.opacity,\n        borderWidth: this.options.borderWidth,\n        borderColor: this.options.color.border,\n        size: this.options.size,\n        borderDashes: this.options.shapeProperties.borderDashes,\n        borderRadius: this.options.shapeProperties.borderRadius,\n        shadow: this.options.shadow.enabled,\n        shadowColor: this.options.shadow.color,\n        shadowSize: this.options.shadow.size,\n        shadowX: this.options.shadow.x,\n        shadowY: this.options.shadow.y\n      };\n      if (this.selected || this.hover) {\n        if (this.chooser === true) {\n          if (this.selected) {\n            if (this.options.borderWidthSelected != null) {\n              values.borderWidth = this.options.borderWidthSelected;\n            } else {\n              values.borderWidth *= 2;\n            }\n            values.color = this.options.color.highlight.background;\n            values.borderColor = this.options.color.highlight.border;\n            values.shadow = this.options.shadow.enabled;\n          } else if (this.hover) {\n            values.color = this.options.color.hover.background;\n            values.borderColor = this.options.color.hover.border;\n            values.shadow = this.options.shadow.enabled;\n          }\n        } else if (typeof this.chooser === \"function\") {\n          this.chooser(values, this.options.id, this.selected, this.hover);\n          if (values.shadow === false) {\n            if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {\n              values.shadow = true;\n            }\n          }\n        }\n      } else {\n        values.shadow = this.options.shadow.enabled;\n      }\n      if (this.options.opacity !== undefined) {\n        var opacity = this.options.opacity;\n        values.borderColor = overrideOpacity(values.borderColor, opacity);\n        values.color = overrideOpacity(values.color, opacity);\n        values.shadowColor = overrideOpacity(values.shadowColor, opacity);\n      }\n      return values;\n    }\n\n    /**\n     *\n     * @param {object} options\n     */\n  }, {\n    key: \"updateLabelModule\",\n    value: function updateLabelModule(options) {\n      if (this.options.label === undefined || this.options.label === null) {\n        this.options.label = \"\";\n      }\n      Node.updateGroupOptions(this.options, _objectSpread$2(_objectSpread$2({}, options), {}, {\n        color: options && options.color || this._localColor || undefined\n      }), this.grouplist);\n\n      //\n      // Note:The prototype chain for this.options is:\n      //\n      // this.options ->    NodesHandler.options    -> NodesHandler.defaultOptions\n      //                 (also: this.globalOptions)\n      //\n      // Note that the prototypes are mentioned explicitly in the pile list below;\n      // WE DON'T WANT THE ORDER OF THE PROTOTYPES!!!! At least, not for font handling of labels.\n      // This is a good indication that the prototype usage of options is deficient.\n      //\n      var currentGroup = this.grouplist.get(this.options.group, false);\n      var pile = [options,\n      // new options\n      this.options,\n      // current node options, see comment above for prototype\n      currentGroup,\n      // group options, if any\n      this.globalOptions,\n      // Currently set global node options\n      this.defaultOptions // Default global node options\n      ];\n\n      this.labelModule.update(this.options, pile);\n      if (this.labelModule.baseSize !== undefined) {\n        this.baseFontSize = this.labelModule.baseSize;\n      }\n    }\n\n    /**\n     *\n     * @param {string} currentShape\n     */\n  }, {\n    key: \"updateShape\",\n    value: function updateShape(currentShape) {\n      if (currentShape === this.options.shape && this.shape) {\n        this.shape.setOptions(this.options, this.imageObj, this.imageObjAlt);\n      } else {\n        // choose draw method depending on the shape\n        switch (this.options.shape) {\n          case \"box\":\n            this.shape = new Box$1(this.options, this.body, this.labelModule);\n            break;\n          case \"circle\":\n            this.shape = new Circle$1(this.options, this.body, this.labelModule);\n            break;\n          case \"circularImage\":\n            this.shape = new CircularImage(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);\n            break;\n          case \"custom\":\n            this.shape = new CustomShape(this.options, this.body, this.labelModule, this.options.ctxRenderer);\n            break;\n          case \"database\":\n            this.shape = new Database(this.options, this.body, this.labelModule);\n            break;\n          case \"diamond\":\n            this.shape = new Diamond$1(this.options, this.body, this.labelModule);\n            break;\n          case \"dot\":\n            this.shape = new Dot(this.options, this.body, this.labelModule);\n            break;\n          case \"ellipse\":\n            this.shape = new Ellipse(this.options, this.body, this.labelModule);\n            break;\n          case \"icon\":\n            this.shape = new Icon(this.options, this.body, this.labelModule);\n            break;\n          case \"image\":\n            this.shape = new Image$2(this.options, this.body, this.labelModule, this.imageObj, this.imageObjAlt);\n            break;\n          case \"square\":\n            this.shape = new Square(this.options, this.body, this.labelModule);\n            break;\n          case \"hexagon\":\n            this.shape = new Hexagon(this.options, this.body, this.labelModule);\n            break;\n          case \"star\":\n            this.shape = new Star(this.options, this.body, this.labelModule);\n            break;\n          case \"text\":\n            this.shape = new Text(this.options, this.body, this.labelModule);\n            break;\n          case \"triangle\":\n            this.shape = new Triangle$1(this.options, this.body, this.labelModule);\n            break;\n          case \"triangleDown\":\n            this.shape = new TriangleDown(this.options, this.body, this.labelModule);\n            break;\n          default:\n            this.shape = new Ellipse(this.options, this.body, this.labelModule);\n            break;\n        }\n      }\n      this.needsRefresh();\n    }\n\n    /**\n     * select this node\n     */\n  }, {\n    key: \"select\",\n    value: function select() {\n      this.selected = true;\n      this.needsRefresh();\n    }\n\n    /**\n     * unselect this node\n     */\n  }, {\n    key: \"unselect\",\n    value: function unselect() {\n      this.selected = false;\n      this.needsRefresh();\n    }\n\n    /**\n     * Reset the calculated size of the node, forces it to recalculate its size\n     */\n  }, {\n    key: \"needsRefresh\",\n    value: function needsRefresh() {\n      this.shape.refreshNeeded = true;\n    }\n\n    /**\n     * get the title of this node.\n     *\n     * @returns {string} title    The title of the node, or undefined when no title\n     *                           has been set.\n     */\n  }, {\n    key: \"getTitle\",\n    value: function getTitle() {\n      return this.options.title;\n    }\n\n    /**\n     * Calculate the distance to the border of the Node\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     * @param {number} angle        Angle in radians\n     * @returns {number} distance   Distance to the border in pixels\n     */\n  }, {\n    key: \"distanceToBorder\",\n    value: function distanceToBorder(ctx, angle) {\n      return this.shape.distanceToBorder(ctx, angle);\n    }\n\n    /**\n     * Check if this node has a fixed x and y position\n     *\n     * @returns {boolean}      true if fixed, false if not\n     */\n  }, {\n    key: \"isFixed\",\n    value: function isFixed() {\n      return this.options.fixed.x && this.options.fixed.y;\n    }\n\n    /**\n     * check if this node is selecte\n     *\n     * @returns {boolean} selected   True if node is selected, else false\n     */\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return this.selected;\n    }\n\n    /**\n     * Retrieve the value of the node. Can be undefined\n     *\n     * @returns {number} value\n     */\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.options.value;\n    }\n\n    /**\n     * Get the current dimensions of the label\n     *\n     * @returns {rect}\n     */\n  }, {\n    key: \"getLabelSize\",\n    value: function getLabelSize() {\n      return this.labelModule.size();\n    }\n\n    /**\n     * Adjust the value range of the node. The node will adjust it's size\n     * based on its value.\n     *\n     * @param {number} min\n     * @param {number} max\n     * @param {number} total\n     */\n  }, {\n    key: \"setValueRange\",\n    value: function setValueRange(min, max, total) {\n      if (this.options.value !== undefined) {\n        var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);\n        var sizeDiff = this.options.scaling.max - this.options.scaling.min;\n        if (this.options.scaling.label.enabled === true) {\n          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;\n          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;\n        }\n        this.options.size = this.options.scaling.min + scale * sizeDiff;\n      } else {\n        this.options.size = this.baseSize;\n        this.options.font.size = this.baseFontSize;\n      }\n      this.updateLabelModule();\n    }\n\n    /**\n     * Draw this node in the given canvas\n     * The 2d context of a HTML canvas can be retrieved by canvas.getContext(\"2d\");\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     * @returns {object} Callbacks to draw later on higher layers.\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      var values = this.getFormattingValues();\n      return this.shape.draw(ctx, this.x, this.y, this.selected, this.hover, values) || {};\n    }\n\n    /**\n     * Update the bounding box of the shape\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     */\n  }, {\n    key: \"updateBoundingBox\",\n    value: function updateBoundingBox(ctx) {\n      this.shape.updateBoundingBox(this.x, this.y, ctx);\n    }\n\n    /**\n     * Recalculate the size of this node in the given canvas\n     * The 2d context of a HTML canvas can be retrieved by canvas.getContext(\"2d\");\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     */\n  }, {\n    key: \"resize\",\n    value: function resize(ctx) {\n      var values = this.getFormattingValues();\n      this.shape.resize(ctx, this.selected, this.hover, values);\n    }\n\n    /**\n     * Determine all visual elements of this node instance, in which the given\n     * point falls within the bounding shape.\n     *\n     * @param {point} point\n     * @returns {Array.<nodeClickItem|nodeLabelClickItem>} list with the items which are on the point\n     */\n  }, {\n    key: \"getItemsOnPoint\",\n    value: function getItemsOnPoint(point) {\n      var ret = [];\n      if (this.labelModule.visible()) {\n        if (pointInRect(this.labelModule.getSize(), point)) {\n          ret.push({\n            nodeId: this.id,\n            labelId: 0\n          });\n        }\n      }\n      if (pointInRect(this.shape.boundingBox, point)) {\n        ret.push({\n          nodeId: this.id\n        });\n      }\n      return ret;\n    }\n\n    /**\n     * Check if this object is overlapping with the provided object\n     *\n     * @param {object} obj   an object with parameters left, top, right, bottom\n     * @returns {boolean}     True if location is located on node\n     */\n  }, {\n    key: \"isOverlappingWith\",\n    value: function isOverlappingWith(obj) {\n      return this.shape.left < obj.right && this.shape.left + this.shape.width > obj.left && this.shape.top < obj.bottom && this.shape.top + this.shape.height > obj.top;\n    }\n\n    /**\n     * Check if this object is overlapping with the provided object\n     *\n     * @param {object} obj   an object with parameters left, top, right, bottom\n     * @returns {boolean}     True if location is located on node\n     */\n  }, {\n    key: \"isBoundingBoxOverlappingWith\",\n    value: function isBoundingBoxOverlappingWith(obj) {\n      return this.shape.boundingBox.left < obj.right && this.shape.boundingBox.right > obj.left && this.shape.boundingBox.top < obj.bottom && this.shape.boundingBox.bottom > obj.top;\n    }\n\n    /**\n     * Check valid values for mass\n     *\n     * The mass may not be negative or zero. If it is, reset to 1\n     *\n     * @param {object} options\n     * @param {Node.id} id\n     * @static\n     */\n  }], [{\n    key: \"checkOpacity\",\n    value: function checkOpacity(opacity) {\n      return 0 <= opacity && opacity <= 1;\n    }\n\n    /**\n     * Check that origin is 'center' or 'top-left'\n     *\n     * @param {string} origin\n     * @returns {boolean}\n     */\n  }, {\n    key: \"checkCoordinateOrigin\",\n    value: function checkCoordinateOrigin(origin) {\n      return origin === undefined || origin === \"center\" || origin === \"top-left\";\n    }\n\n    /**\n     * Copy group option values into the node options.\n     *\n     * The group options override the global node options, so the copy of group options\n     *  must happen *after* the global node options have been set.\n     *\n     * This method must also be called also if the global node options have changed and the group options did not.\n     *\n     * @param {object} parentOptions\n     * @param {object} newOptions  new values for the options, currently only passed in for check\n     * @param {object} groupList\n     */\n  }, {\n    key: \"updateGroupOptions\",\n    value: function updateGroupOptions(parentOptions, newOptions, groupList) {\n      var _context4;\n      if (groupList === undefined) return; // No groups, nothing to do\n\n      var group = parentOptions.group;\n\n      // paranoia: the selected group is already merged into node options, check.\n      if (newOptions !== undefined && newOptions.group !== undefined && group !== newOptions.group) {\n        throw new Error(\"updateGroupOptions: group values in options don't match.\");\n      }\n      var hasGroup = typeof group === \"number\" || typeof group === \"string\" && group != \"\";\n      if (!hasGroup) return; // current node has no group, no need to merge\n\n      var groupObj = groupList.get(group);\n      if (groupObj.opacity !== undefined && newOptions.opacity === undefined) {\n        if (!Node.checkOpacity(groupObj.opacity)) {\n          console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + groupObj.opacity);\n          groupObj.opacity = undefined;\n        }\n      }\n\n      // Skip any new option to avoid them being overridden by the group options.\n      var skipProperties = _filterInstanceProperty(_context4 = _Object$getOwnPropertyNames(newOptions)).call(_context4, function (p) {\n        return newOptions[p] != null;\n      });\n      // Always skip merging group font options into parent; these are required to be distinct for labels\n      skipProperties.push(\"font\");\n      selectiveNotDeepExtend(skipProperties, parentOptions, groupObj);\n\n      // the color object needs to be completely defined.\n      // Since groups can partially overwrite the colors, we parse it again, just in case.\n      parentOptions.color = parseColor(parentOptions.color);\n    }\n\n    /**\n     * This process all possible shorthands in the new options and makes sure that the parentOptions are fully defined.\n     * Static so it can also be used by the handler.\n     *\n     * @param {object} parentOptions\n     * @param {object} newOptions\n     * @param {boolean} [allowDeletion=false]\n     * @param {object} [globalOptions={}]\n     * @param {object} [groupList]\n     * @static\n     */\n  }, {\n    key: \"parseOptions\",\n    value: function parseOptions(parentOptions, newOptions) {\n      var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var groupList = arguments.length > 4 ? arguments[4] : undefined;\n      var fields = [\"color\", \"fixed\", \"shadow\"];\n      selectiveNotDeepExtend(fields, parentOptions, newOptions, allowDeletion);\n      Node.checkMass(newOptions);\n      if (parentOptions.opacity !== undefined) {\n        if (!Node.checkOpacity(parentOptions.opacity)) {\n          console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + parentOptions.opacity);\n          parentOptions.opacity = undefined;\n        }\n      }\n      if (newOptions.opacity !== undefined) {\n        if (!Node.checkOpacity(newOptions.opacity)) {\n          console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + newOptions.opacity);\n          newOptions.opacity = undefined;\n        }\n      }\n      if (newOptions.shapeProperties && !Node.checkCoordinateOrigin(newOptions.shapeProperties.coordinateOrigin)) {\n        console.error(\"Invalid option for node coordinateOrigin, found: \" + newOptions.shapeProperties.coordinateOrigin);\n      }\n\n      // merge the shadow options into the parent.\n      mergeOptions(parentOptions, newOptions, \"shadow\", globalOptions);\n\n      // individual shape newOptions\n      if (newOptions.color !== undefined && newOptions.color !== null) {\n        var parsedColor = parseColor(newOptions.color);\n        fillIfDefined(parentOptions.color, parsedColor);\n      } else if (allowDeletion === true && newOptions.color === null) {\n        parentOptions.color = bridgeObject(globalOptions.color); // set the object back to the global options\n      }\n\n      // handle the fixed options\n      if (newOptions.fixed !== undefined && newOptions.fixed !== null) {\n        if (typeof newOptions.fixed === \"boolean\") {\n          parentOptions.fixed.x = newOptions.fixed;\n          parentOptions.fixed.y = newOptions.fixed;\n        } else {\n          if (newOptions.fixed.x !== undefined && typeof newOptions.fixed.x === \"boolean\") {\n            parentOptions.fixed.x = newOptions.fixed.x;\n          }\n          if (newOptions.fixed.y !== undefined && typeof newOptions.fixed.y === \"boolean\") {\n            parentOptions.fixed.y = newOptions.fixed.y;\n          }\n        }\n      }\n      if (allowDeletion === true && newOptions.font === null) {\n        parentOptions.font = bridgeObject(globalOptions.font); // set the object back to the global options\n      }\n\n      Node.updateGroupOptions(parentOptions, newOptions, groupList);\n\n      // handle the scaling options, specifically the label part\n      if (newOptions.scaling !== undefined) {\n        mergeOptions(parentOptions.scaling, newOptions.scaling, \"label\", globalOptions.scaling);\n      }\n    }\n  }, {\n    key: \"checkMass\",\n    value: function checkMass(options, id) {\n      if (options.mass !== undefined && options.mass <= 0) {\n        var strId = \"\";\n        if (id !== undefined) {\n          strId = \" in node id: \" + id;\n        }\n        console.error(\"%cNegative or zero mass disallowed\" + strId + \", setting mass to 1.\", VALIDATOR_PRINT_STYLE);\n        options.mass = 1;\n      }\n    }\n  }]);\n  return Node;\n}();\n\nfunction _createForOfIteratorHelper$5(o, allowArrayLike) { var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$5(o, minLen) { var _context4; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$5(o, minLen); var n = _sliceInstanceProperty(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return _Array$from$1(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }\nfunction _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n/**\n * Handler for Nodes\n */\nvar NodesHandler = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Images} images\n   * @param {Array.<Group>} groups\n   * @param {LayoutEngine} layoutEngine\n   */\n  function NodesHandler(body, images, groups, layoutEngine) {\n    var _context,\n      _this = this;\n    _classCallCheck(this, NodesHandler);\n    this.body = body;\n    this.images = images;\n    this.groups = groups;\n    this.layoutEngine = layoutEngine;\n\n    // create the node API in the body container\n    this.body.functions.createNode = _bindInstanceProperty$1(_context = this.create).call(_context, this);\n    this.nodesListeners = {\n      add: function add(event, params) {\n        _this.add(params.items);\n      },\n      update: function update(event, params) {\n        _this.update(params.items, params.data, params.oldData);\n      },\n      remove: function remove(event, params) {\n        _this.remove(params.items);\n      }\n    };\n    this.defaultOptions = {\n      borderWidth: 1,\n      borderWidthSelected: undefined,\n      brokenImage: undefined,\n      color: {\n        border: \"#2B7CE9\",\n        background: \"#97C2FC\",\n        highlight: {\n          border: \"#2B7CE9\",\n          background: \"#D2E5FF\"\n        },\n        hover: {\n          border: \"#2B7CE9\",\n          background: \"#D2E5FF\"\n        }\n      },\n      opacity: undefined,\n      // number between 0 and 1\n      fixed: {\n        x: false,\n        y: false\n      },\n      font: {\n        color: \"#343434\",\n        size: 14,\n        // px\n        face: \"arial\",\n        background: \"none\",\n        strokeWidth: 0,\n        // px\n        strokeColor: \"#ffffff\",\n        align: \"center\",\n        vadjust: 0,\n        multi: false,\n        bold: {\n          mod: \"bold\"\n        },\n        boldital: {\n          mod: \"bold italic\"\n        },\n        ital: {\n          mod: \"italic\"\n        },\n        mono: {\n          mod: \"\",\n          size: 15,\n          // px\n          face: \"monospace\",\n          vadjust: 2\n        }\n      },\n      group: undefined,\n      hidden: false,\n      icon: {\n        face: \"FontAwesome\",\n        //'FontAwesome',\n        code: undefined,\n        //'\\uf007',\n        size: 50,\n        //50,\n        color: \"#2B7CE9\" //'#aa00ff'\n      },\n\n      image: undefined,\n      // --> URL\n      imagePadding: {\n        // only for image shape\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      },\n      label: undefined,\n      labelHighlightBold: true,\n      level: undefined,\n      margin: {\n        top: 5,\n        right: 5,\n        bottom: 5,\n        left: 5\n      },\n      mass: 1,\n      physics: true,\n      scaling: {\n        min: 10,\n        max: 30,\n        label: {\n          enabled: false,\n          min: 14,\n          max: 30,\n          maxVisible: 30,\n          drawThreshold: 5\n        },\n        customScalingFunction: function customScalingFunction(min, max, total, value) {\n          if (max === min) {\n            return 0.5;\n          } else {\n            var scale = 1 / (max - min);\n            return Math.max(0, (value - min) * scale);\n          }\n        }\n      },\n      shadow: {\n        enabled: false,\n        color: \"rgba(0,0,0,0.5)\",\n        size: 10,\n        x: 5,\n        y: 5\n      },\n      shape: \"ellipse\",\n      shapeProperties: {\n        borderDashes: false,\n        // only for borders\n        borderRadius: 6,\n        // only for box shape\n        interpolation: true,\n        // only for image and circularImage shapes\n        useImageSize: false,\n        // only for image and circularImage shapes\n        useBorderWithImage: false,\n        // only for image shape\n        coordinateOrigin: \"center\" // only for image and circularImage shapes\n      },\n\n      size: 25,\n      title: undefined,\n      value: undefined,\n      x: undefined,\n      y: undefined\n    };\n\n    // Protect from idiocy\n    if (this.defaultOptions.mass <= 0) {\n      throw \"Internal error: mass in defaultOptions of NodesHandler may not be zero or negative\";\n    }\n    this.options = bridgeObject(this.defaultOptions);\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n  _createClass(NodesHandler, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _context2,\n        _context3,\n        _this2 = this;\n      // refresh the nodes. Used when reverting from hierarchical layout\n      this.body.emitter.on(\"refreshNodes\", _bindInstanceProperty$1(_context2 = this.refresh).call(_context2, this));\n      this.body.emitter.on(\"refresh\", _bindInstanceProperty$1(_context3 = this.refresh).call(_context3, this));\n      this.body.emitter.on(\"destroy\", function () {\n        forEach$1(_this2.nodesListeners, function (callback, event) {\n          if (_this2.body.data.nodes) _this2.body.data.nodes.off(event, callback);\n        });\n        delete _this2.body.functions.createNode;\n        delete _this2.nodesListeners.add;\n        delete _this2.nodesListeners.update;\n        delete _this2.nodesListeners.remove;\n        delete _this2.nodesListeners;\n      });\n    }\n\n    /**\n     *\n     * @param {object} options\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        Node.parseOptions(this.options, options);\n\n        // Need to set opacity here because Node.parseOptions is also used for groups,\n        // if you set opacity in Node.parseOptions it overwrites group opacity.\n        if (options.opacity !== undefined) {\n          if (_Number$isNaN(options.opacity) || !_Number$isFinite(options.opacity) || options.opacity < 0 || options.opacity > 1) {\n            console.error(\"Invalid option for node opacity. Value must be between 0 and 1, found: \" + options.opacity);\n          } else {\n            this.options.opacity = options.opacity;\n          }\n        }\n\n        // update the shape in all nodes\n        if (options.shape !== undefined) {\n          for (var nodeId in this.body.nodes) {\n            if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {\n              this.body.nodes[nodeId].updateShape();\n            }\n          }\n        }\n\n        // Update the labels of nodes if any relevant options changed.\n        if (typeof options.font !== \"undefined\" || typeof options.widthConstraint !== \"undefined\" || typeof options.heightConstraint !== \"undefined\") {\n          for (var _i = 0, _Object$keys$1 = _Object$keys(this.body.nodes); _i < _Object$keys$1.length; _i++) {\n            var _nodeId = _Object$keys$1[_i];\n            this.body.nodes[_nodeId].updateLabelModule();\n            this.body.nodes[_nodeId].needsRefresh();\n          }\n        }\n\n        // update the shape size in all nodes\n        if (options.size !== undefined) {\n          for (var _nodeId2 in this.body.nodes) {\n            if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {\n              this.body.nodes[_nodeId2].needsRefresh();\n            }\n          }\n        }\n\n        // update the state of the variables if needed\n        if (options.hidden !== undefined || options.physics !== undefined) {\n          this.body.emitter.emit(\"_dataChanged\");\n        }\n      }\n    }\n\n    /**\n     * Set a data set with nodes for the network\n     *\n     * @param {Array | DataSet | DataView} nodes         The data containing the nodes.\n     * @param {boolean} [doNotEmit=false] - Suppress data changed event.\n     * @private\n     */\n  }, {\n    key: \"setData\",\n    value: function setData(nodes) {\n      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var oldNodesData = this.body.data.nodes;\n      if ((0,vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.isDataViewLike)(\"id\", nodes)) {\n        this.body.data.nodes = nodes;\n      } else if (_Array$isArray(nodes)) {\n        this.body.data.nodes = new vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.DataSet();\n        this.body.data.nodes.add(nodes);\n      } else if (!nodes) {\n        this.body.data.nodes = new vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.DataSet();\n      } else {\n        throw new TypeError(\"Array or DataSet expected\");\n      }\n      if (oldNodesData) {\n        // unsubscribe from old dataset\n        forEach$1(this.nodesListeners, function (callback, event) {\n          oldNodesData.off(event, callback);\n        });\n      }\n\n      // remove drawn nodes\n      this.body.nodes = {};\n      if (this.body.data.nodes) {\n        // subscribe to new dataset\n        var me = this;\n        forEach$1(this.nodesListeners, function (callback, event) {\n          me.body.data.nodes.on(event, callback);\n        });\n\n        // draw all new nodes\n        var ids = this.body.data.nodes.getIds();\n        this.add(ids, true);\n      }\n      if (doNotEmit === false) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n\n    /**\n     * Add nodes\n     *\n     * @param {number[] | string[]} ids\n     * @param {boolean} [doNotEmit=false]\n     * @private\n     */\n  }, {\n    key: \"add\",\n    value: function add(ids) {\n      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var id;\n      var newNodes = [];\n      for (var i = 0; i < ids.length; i++) {\n        id = ids[i];\n        var properties = this.body.data.nodes.get(id);\n        var node = this.create(properties);\n        newNodes.push(node);\n        this.body.nodes[id] = node; // note: this may replace an existing node\n      }\n\n      this.layoutEngine.positionInitially(newNodes);\n      if (doNotEmit === false) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n\n    /**\n     * Update existing nodes, or create them when not yet existing\n     *\n     * @param {number[] | string[]} ids id's of changed nodes\n     * @param {Array} changedData array with changed data\n     * @param {Array|undefined} oldData optional; array with previous data\n     * @private\n     */\n  }, {\n    key: \"update\",\n    value: function update(ids, changedData, oldData) {\n      var nodes = this.body.nodes;\n      var dataChanged = false;\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        var node = nodes[id];\n        var data = changedData[i];\n        if (node !== undefined) {\n          // update node\n          if (node.setOptions(data)) {\n            dataChanged = true;\n          }\n        } else {\n          dataChanged = true;\n          // create node\n          node = this.create(data);\n          nodes[id] = node;\n        }\n      }\n      if (!dataChanged && oldData !== undefined) {\n        // Check for any changes which should trigger a layout recalculation\n        // For now, this is just 'level' for hierarchical layout\n        // Assumption: old and new data arranged in same order; at time of writing, this holds.\n        dataChanged = _someInstanceProperty(changedData).call(changedData, function (newValue, index) {\n          var oldValue = oldData[index];\n          return oldValue && oldValue.level !== newValue.level;\n        });\n      }\n      if (dataChanged === true) {\n        this.body.emitter.emit(\"_dataChanged\");\n      } else {\n        this.body.emitter.emit(\"_dataUpdated\");\n      }\n    }\n\n    /**\n     * Remove existing nodes. If nodes do not exist, the method will just ignore it.\n     *\n     * @param {number[] | string[]} ids\n     * @private\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(ids) {\n      var nodes = this.body.nodes;\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        delete nodes[id];\n      }\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n\n    /**\n     * create a node\n     *\n     * @param {object} properties\n     * @param {class} [constructorClass=Node.default]\n     * @returns {*}\n     */\n  }, {\n    key: \"create\",\n    value: function create(properties) {\n      var constructorClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Node;\n      return new constructorClass(properties, this.body, this.images, this.groups, this.options, this.defaultOptions);\n    }\n\n    /**\n     *\n     * @param {boolean} [clearPositions=false]\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var _this3 = this;\n      var clearPositions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      forEach$1(this.body.nodes, function (node, nodeId) {\n        var data = _this3.body.data.nodes.get(nodeId);\n        if (data !== undefined) {\n          if (clearPositions === true) {\n            node.setOptions({\n              x: null,\n              y: null\n            });\n          }\n          node.setOptions({\n            fixed: false\n          });\n          node.setOptions(data);\n        }\n      });\n    }\n\n    /**\n     * Returns the positions of the nodes.\n     *\n     * @param {Array.<Node.id> | string} [ids]  --> optional, can be array of nodeIds, can be string\n     * @returns {{}}\n     */\n  }, {\n    key: \"getPositions\",\n    value: function getPositions(ids) {\n      var dataArray = {};\n      if (ids !== undefined) {\n        if (_Array$isArray(ids) === true) {\n          for (var i = 0; i < ids.length; i++) {\n            if (this.body.nodes[ids[i]] !== undefined) {\n              var node = this.body.nodes[ids[i]];\n              dataArray[ids[i]] = {\n                x: Math.round(node.x),\n                y: Math.round(node.y)\n              };\n            }\n          }\n        } else {\n          if (this.body.nodes[ids] !== undefined) {\n            var _node = this.body.nodes[ids];\n            dataArray[ids] = {\n              x: Math.round(_node.x),\n              y: Math.round(_node.y)\n            };\n          }\n        }\n      } else {\n        for (var _i2 = 0; _i2 < this.body.nodeIndices.length; _i2++) {\n          var _node2 = this.body.nodes[this.body.nodeIndices[_i2]];\n          dataArray[this.body.nodeIndices[_i2]] = {\n            x: Math.round(_node2.x),\n            y: Math.round(_node2.y)\n          };\n        }\n      }\n      return dataArray;\n    }\n\n    /**\n     * Retrieves the x y position of a specific id.\n     *\n     * @param {string} id The id to retrieve.\n     * @throws {TypeError} If no id is included.\n     * @throws {ReferenceError} If an invalid id is provided.\n     * @returns {{ x: number, y: number }} Returns X, Y canvas position of the node with given id.\n     */\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(id) {\n      if (id == undefined) {\n        throw new TypeError(\"No id was specified for getPosition method.\");\n      } else if (this.body.nodes[id] == undefined) {\n        throw new ReferenceError(\"NodeId provided for getPosition does not exist. Provided: \".concat(id));\n      } else {\n        return {\n          x: Math.round(this.body.nodes[id].x),\n          y: Math.round(this.body.nodes[id].y)\n        };\n      }\n    }\n\n    /**\n     * Load the XY positions of the nodes into the dataset.\n     */\n  }, {\n    key: \"storePositions\",\n    value: function storePositions() {\n      // todo: add support for clusters and hierarchical.\n      var dataArray = [];\n      var dataset = this.body.data.nodes.getDataSet();\n      var _iterator = _createForOfIteratorHelper$5(dataset.get()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var dsNode = _step.value;\n          var id = dsNode.id;\n          var bodyNode = this.body.nodes[id];\n          var x = Math.round(bodyNode.x);\n          var y = Math.round(bodyNode.y);\n          if (dsNode.x !== x || dsNode.y !== y) {\n            dataArray.push({\n              id: id,\n              x: x,\n              y: y\n            });\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      dataset.update(dataArray);\n    }\n\n    /**\n     * get the bounding box of a node.\n     *\n     * @param {Node.id} nodeId\n     * @returns {j|*}\n     */\n  }, {\n    key: \"getBoundingBox\",\n    value: function getBoundingBox(nodeId) {\n      if (this.body.nodes[nodeId] !== undefined) {\n        return this.body.nodes[nodeId].shape.boundingBox;\n      }\n    }\n\n    /**\n     * Get the Ids of nodes connected to this node.\n     *\n     * @param {Node.id} nodeId\n     * @param {'to'|'from'|undefined} direction values 'from' and 'to' select respectively parent and child nodes only.\n     *                                          Any other value returns both parent and child nodes.\n     * @returns {Array}\n     */\n  }, {\n    key: \"getConnectedNodes\",\n    value: function getConnectedNodes(nodeId, direction) {\n      var nodeList = [];\n      if (this.body.nodes[nodeId] !== undefined) {\n        var node = this.body.nodes[nodeId];\n        var nodeObj = {}; // used to quickly check if node already exists\n        for (var i = 0; i < node.edges.length; i++) {\n          var edge = node.edges[i];\n          if (direction !== \"to\" && edge.toId == node.id) {\n            // these are double equals since ids can be numeric or string\n            if (nodeObj[edge.fromId] === undefined) {\n              nodeList.push(edge.fromId);\n              nodeObj[edge.fromId] = true;\n            }\n          } else if (direction !== \"from\" && edge.fromId == node.id) {\n            // these are double equals since ids can be numeric or string\n            if (nodeObj[edge.toId] === undefined) {\n              nodeList.push(edge.toId);\n              nodeObj[edge.toId] = true;\n            }\n          }\n        }\n      }\n      return nodeList;\n    }\n\n    /**\n     * Get the ids of the edges connected to this node.\n     *\n     * @param {Node.id} nodeId\n     * @returns {*}\n     */\n  }, {\n    key: \"getConnectedEdges\",\n    value: function getConnectedEdges(nodeId) {\n      var edgeList = [];\n      if (this.body.nodes[nodeId] !== undefined) {\n        var node = this.body.nodes[nodeId];\n        for (var i = 0; i < node.edges.length; i++) {\n          edgeList.push(node.edges[i].id);\n        }\n      } else {\n        console.error(\"NodeId provided for getConnectedEdges does not exist. Provided: \", nodeId);\n      }\n      return edgeList;\n    }\n\n    /**\n     * Move a node.\n     *\n     * @param {Node.id} nodeId\n     * @param {number} x\n     * @param {number} y\n     */\n  }, {\n    key: \"moveNode\",\n    value: function moveNode(nodeId, x, y) {\n      var _this4 = this;\n      if (this.body.nodes[nodeId] !== undefined) {\n        this.body.nodes[nodeId].x = Number(x);\n        this.body.nodes[nodeId].y = Number(y);\n        _setTimeout(function () {\n          _this4.body.emitter.emit(\"startSimulation\");\n        }, 0);\n      } else {\n        console.error(\"Node id supplied to moveNode does not exist. Provided: \", nodeId);\n      }\n    }\n  }]);\n  return NodesHandler;\n}();\n\nvar hasOwn$1 = hasOwnProperty_1;\n\nvar isDataDescriptor$1 = function (descriptor) {\n  return descriptor !== undefined && (hasOwn$1(descriptor, 'value') || hasOwn$1(descriptor, 'writable'));\n};\n\nvar $$4 = _export;\nvar call = functionCall;\nvar isObject$2 = isObject$j;\nvar anObject$1 = anObject$d;\nvar isDataDescriptor = isDataDescriptor$1;\nvar getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;\nvar getPrototypeOf = objectGetPrototypeOf;\n\n// `Reflect.get` method\n// https://tc39.es/ecma262/#sec-reflect.get\nfunction get$5(target, propertyKey /* , receiver */) {\n  var receiver = arguments.length < 3 ? target : arguments[2];\n  var descriptor, prototype;\n  if (anObject$1(target) === receiver) return target[propertyKey];\n  descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey);\n  if (descriptor) return isDataDescriptor(descriptor)\n    ? descriptor.value\n    : descriptor.get === undefined ? undefined : call(descriptor.get, receiver);\n  if (isObject$2(prototype = getPrototypeOf(target))) return get$5(prototype, propertyKey, receiver);\n}\n\n$$4({ target: 'Reflect', stat: true }, {\n  get: get$5\n});\n\nvar path$4 = path$w;\n\nvar get$4 = path$4.Reflect.get;\n\nvar parent$a = get$4;\n\nvar get$3 = parent$a;\n\nvar parent$9 = get$3;\n\nvar get$2 = parent$9;\n\nvar parent$8 = get$2;\n\nvar get$1 = parent$8;\n\nvar get = get$1;\n\nvar _Reflect$get = /*@__PURE__*/getDefaultExportFromCjs(get);\n\nvar parent$7 = getOwnPropertyDescriptor$4;\n\nvar getOwnPropertyDescriptor$2 = parent$7;\n\nvar parent$6 = getOwnPropertyDescriptor$2;\n\nvar getOwnPropertyDescriptor$1 = parent$6;\n\nvar getOwnPropertyDescriptor = getOwnPropertyDescriptor$1;\n\nvar _Object$getOwnPropertyDescriptor = /*@__PURE__*/getDefaultExportFromCjs(getOwnPropertyDescriptor);\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}\n\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && _Reflect$get) {\n    var _context;\n    _get = _bindInstanceProperty(_context = _Reflect$get).call(_context);\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n      if (!base) return;\n      var desc = _Object$getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}\n\nvar $$3 = _export;\n\n// eslint-disable-next-line es/no-math-hypot -- required for testing\nvar $hypot = Math.hypot;\nvar abs = Math.abs;\nvar sqrt = Math.sqrt;\n\n// Chrome 77 bug\n// https://bugs.chromium.org/p/v8/issues/detail?id=9546\nvar FORCED$2 = !!$hypot && $hypot(Infinity, NaN) !== Infinity;\n\n// `Math.hypot` method\n// https://tc39.es/ecma262/#sec-math.hypot\n$$3({ target: 'Math', stat: true, arity: 2, forced: FORCED$2 }, {\n  // eslint-disable-next-line no-unused-vars -- required for `.length`\n  hypot: function hypot(value1, value2) {\n    var sum = 0;\n    var i = 0;\n    var aLen = arguments.length;\n    var larg = 0;\n    var arg, div;\n    while (i < aLen) {\n      arg = abs(arguments[i++]);\n      if (larg < arg) {\n        div = larg / arg;\n        sum = sum * div * div + 1;\n        larg = arg;\n      } else if (arg > 0) {\n        div = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * sqrt(sum);\n  }\n});\n\nvar path$3 = path$w;\n\nvar hypot$2 = path$3.Math.hypot;\n\nvar parent$5 = hypot$2;\n\nvar hypot$1 = parent$5;\n\nvar hypot = hypot$1;\n\nvar _Math$hypot = /*@__PURE__*/getDefaultExportFromCjs(hypot);\n\nfunction _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$a() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\r\n * Common methods for endpoints\r\n *\r\n * @class\r\n */\nvar EndPoint = /*#__PURE__*/function () {\n  function EndPoint() {\n    _classCallCheck(this, EndPoint);\n  }\n  _createClass(EndPoint, null, [{\n    key: \"transform\",\n    value:\n    /**\r\n     * Apply transformation on points for display.\r\n     *\r\n     * The following is done:\r\n     * - rotate by the specified angle\r\n     * - multiply the (normalized) coordinates by the passed length\r\n     * - offset by the target coordinates\r\n     *\r\n     * @param points - The point(s) to be transformed.\r\n     * @param arrowData - The data determining the result of the transformation.\r\n     */\n    function transform(points, arrowData) {\n      if (!_Array$isArray(points)) {\n        points = [points];\n      }\n      var x = arrowData.point.x;\n      var y = arrowData.point.y;\n      var angle = arrowData.angle;\n      var length = arrowData.length;\n      for (var i = 0; i < points.length; ++i) {\n        var p = points[i];\n        var xt = p.x * Math.cos(angle) - p.y * Math.sin(angle);\n        var yt = p.x * Math.sin(angle) + p.y * Math.cos(angle);\n        p.x = x + length * xt;\n        p.y = y + length * yt;\n      }\n    }\n    /**\r\n     * Draw a closed path using the given real coordinates.\r\n     *\r\n     * @param ctx - The path will be rendered into this context.\r\n     * @param points - The points of the path.\r\n     */\n  }, {\n    key: \"drawPath\",\n    value: function drawPath(ctx, points) {\n      ctx.beginPath();\n      ctx.moveTo(points[0].x, points[0].y);\n      for (var i = 1; i < points.length; ++i) {\n        ctx.lineTo(points[i].x, points[i].y);\n      }\n      ctx.closePath();\n    }\n  }]);\n  return EndPoint;\n}();\n/**\r\n * Drawing methods for the arrow endpoint.\r\n */\nvar Image$1 = /*#__PURE__*/function (_EndPoint) {\n  _inherits(Image, _EndPoint);\n  var _super = _createSuper$a(Image);\n  function Image() {\n    _classCallCheck(this, Image);\n    return _super.apply(this, arguments);\n  }\n  _createClass(Image, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns False as there is no way to fill an image.\r\n     */\n    function draw(ctx, arrowData) {\n      if (arrowData.image) {\n        ctx.save();\n        ctx.translate(arrowData.point.x, arrowData.point.y);\n        ctx.rotate(Math.PI / 2 + arrowData.angle);\n        var width = arrowData.imageWidth != null ? arrowData.imageWidth : arrowData.image.width;\n        var height = arrowData.imageHeight != null ? arrowData.imageHeight : arrowData.image.height;\n        arrowData.image.drawImageAtPosition(ctx, 1,\n        // scale\n        -width / 2,\n        // x\n        0,\n        // y\n        width, height);\n        ctx.restore();\n      }\n      return false;\n    }\n  }]);\n  return Image;\n}(EndPoint);\n/**\r\n * Drawing methods for the arrow endpoint.\r\n */\nvar Arrow = /*#__PURE__*/function (_EndPoint2) {\n  _inherits(Arrow, _EndPoint2);\n  var _super2 = _createSuper$a(Arrow);\n  function Arrow() {\n    _classCallCheck(this, Arrow);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(Arrow, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{\n        x: 0,\n        y: 0\n      }, {\n        x: -1,\n        y: 0.3\n      }, {\n        x: -0.9,\n        y: 0\n      }, {\n        x: -1,\n        y: -0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Arrow;\n}(EndPoint);\n/**\r\n * Drawing methods for the crow endpoint.\r\n */\nvar Crow = /*#__PURE__*/function () {\n  function Crow() {\n    _classCallCheck(this, Crow);\n  }\n  _createClass(Crow, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{\n        x: -1,\n        y: 0\n      }, {\n        x: 0,\n        y: 0.3\n      }, {\n        x: -0.4,\n        y: 0\n      }, {\n        x: 0,\n        y: -0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Crow;\n}();\n/**\r\n * Drawing methods for the curve endpoint.\r\n */\nvar Curve = /*#__PURE__*/function () {\n  function Curve() {\n    _classCallCheck(this, Curve);\n  }\n  _createClass(Curve, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var point = {\n        x: -0.4,\n        y: 0\n      };\n      EndPoint.transform(point, arrowData);\n      // Update endpoint style for drawing transparent arc.\n      ctx.strokeStyle = ctx.fillStyle;\n      ctx.fillStyle = \"rgba(0, 0, 0, 0)\";\n      // Define curve endpoint as semicircle.\n      var pi = Math.PI;\n      var startAngle = arrowData.angle - pi / 2;\n      var endAngle = arrowData.angle + pi / 2;\n      ctx.beginPath();\n      ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);\n      ctx.stroke();\n      return true;\n    }\n  }]);\n  return Curve;\n}();\n/**\r\n * Drawing methods for the inverted curve endpoint.\r\n */\nvar InvertedCurve = /*#__PURE__*/function () {\n  function InvertedCurve() {\n    _classCallCheck(this, InvertedCurve);\n  }\n  _createClass(InvertedCurve, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var point = {\n        x: -0.3,\n        y: 0\n      };\n      EndPoint.transform(point, arrowData);\n      // Update endpoint style for drawing transparent arc.\n      ctx.strokeStyle = ctx.fillStyle;\n      ctx.fillStyle = \"rgba(0, 0, 0, 0)\";\n      // Define inverted curve endpoint as semicircle.\n      var pi = Math.PI;\n      var startAngle = arrowData.angle + pi / 2;\n      var endAngle = arrowData.angle + 3 * pi / 2;\n      ctx.beginPath();\n      ctx.arc(point.x, point.y, arrowData.length * 0.4, startAngle, endAngle, false);\n      ctx.stroke();\n      return true;\n    }\n  }]);\n  return InvertedCurve;\n}();\n/**\r\n * Drawing methods for the trinagle endpoint.\r\n */\nvar Triangle = /*#__PURE__*/function () {\n  function Triangle() {\n    _classCallCheck(this, Triangle);\n  }\n  _createClass(Triangle, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{\n        x: 0.02,\n        y: 0\n      }, {\n        x: -1,\n        y: 0.3\n      }, {\n        x: -1,\n        y: -0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Triangle;\n}();\n/**\r\n * Drawing methods for the inverted trinagle endpoint.\r\n */\nvar InvertedTriangle = /*#__PURE__*/function () {\n  function InvertedTriangle() {\n    _classCallCheck(this, InvertedTriangle);\n  }\n  _createClass(InvertedTriangle, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{\n        x: 0,\n        y: 0.3\n      }, {\n        x: 0,\n        y: -0.3\n      }, {\n        x: -1,\n        y: 0\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return InvertedTriangle;\n}();\n/**\r\n * Drawing methods for the circle endpoint.\r\n */\nvar Circle = /*#__PURE__*/function () {\n  function Circle() {\n    _classCallCheck(this, Circle);\n  }\n  _createClass(Circle, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      var point = {\n        x: -0.4,\n        y: 0\n      };\n      EndPoint.transform(point, arrowData);\n      drawCircle(ctx, point.x, point.y, arrowData.length * 0.4);\n      return true;\n    }\n  }]);\n  return Circle;\n}();\n/**\r\n * Drawing methods for the bar endpoint.\r\n */\nvar Bar = /*#__PURE__*/function () {\n  function Bar() {\n    _classCallCheck(this, Bar);\n  }\n  _createClass(Bar, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      /*\r\n      var points = [\r\n        {x:0, y:0.5},\r\n        {x:0, y:-0.5}\r\n      ];\r\n           EndPoint.transform(points, arrowData);\r\n      ctx.beginPath();\r\n      ctx.moveTo(points[0].x, points[0].y);\r\n      ctx.lineTo(points[1].x, points[1].y);\r\n      ctx.stroke();\r\n      */\n      var points = [{\n        x: 0,\n        y: 0.5\n      }, {\n        x: 0,\n        y: -0.5\n      }, {\n        x: -0.15,\n        y: -0.5\n      }, {\n        x: -0.15,\n        y: 0.5\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Bar;\n}();\n/**\r\n * Drawing methods for the box endpoint.\r\n */\nvar Box = /*#__PURE__*/function () {\n  function Box() {\n    _classCallCheck(this, Box);\n  }\n  _createClass(Box, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      var points = [{\n        x: 0,\n        y: 0.3\n      }, {\n        x: 0,\n        y: -0.3\n      }, {\n        x: -0.6,\n        y: -0.3\n      }, {\n        x: -0.6,\n        y: 0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Box;\n}();\n/**\r\n * Drawing methods for the diamond endpoint.\r\n */\nvar Diamond = /*#__PURE__*/function () {\n  function Diamond() {\n    _classCallCheck(this, Diamond);\n  }\n  _createClass(Diamond, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      var points = [{\n        x: 0,\n        y: 0\n      }, {\n        x: -0.5,\n        y: -0.3\n      }, {\n        x: -1,\n        y: 0\n      }, {\n        x: -0.5,\n        y: 0.3\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Diamond;\n}();\n/**\r\n * Drawing methods for the vee endpoint.\r\n */\nvar Vee = /*#__PURE__*/function () {\n  function Vee() {\n    _classCallCheck(this, Vee);\n  }\n  _createClass(Vee, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw this shape at the end of a line.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True because ctx.fill() can be used to fill the arrow.\r\n     */\n    function draw(ctx, arrowData) {\n      // Normalized points of closed path, in the order that they should be drawn.\n      // (0, 0) is the attachment point, and the point around which should be rotated\n      var points = [{\n        x: -1,\n        y: 0.3\n      }, {\n        x: -0.5,\n        y: 0\n      }, {\n        x: -1,\n        y: -0.3\n      }, {\n        x: 0,\n        y: 0\n      }];\n      EndPoint.transform(points, arrowData);\n      EndPoint.drawPath(ctx, points);\n      return true;\n    }\n  }]);\n  return Vee;\n}();\n/**\r\n * Drawing methods for the endpoints.\r\n */\nvar EndPoints = /*#__PURE__*/function () {\n  function EndPoints() {\n    _classCallCheck(this, EndPoints);\n  }\n  _createClass(EndPoints, null, [{\n    key: \"draw\",\n    value:\n    /**\r\n     * Draw an endpoint.\r\n     *\r\n     * @param ctx - The shape will be rendered into this context.\r\n     * @param arrowData - The data determining the shape.\r\n     * @returns True if ctx.fill() can be used to fill the arrow, false otherwise.\r\n     */\n    function draw(ctx, arrowData) {\n      var type;\n      if (arrowData.type) {\n        type = arrowData.type.toLowerCase();\n      }\n      switch (type) {\n        case \"image\":\n          return Image$1.draw(ctx, arrowData);\n        case \"circle\":\n          return Circle.draw(ctx, arrowData);\n        case \"box\":\n          return Box.draw(ctx, arrowData);\n        case \"crow\":\n          return Crow.draw(ctx, arrowData);\n        case \"curve\":\n          return Curve.draw(ctx, arrowData);\n        case \"diamond\":\n          return Diamond.draw(ctx, arrowData);\n        case \"inv_curve\":\n          return InvertedCurve.draw(ctx, arrowData);\n        case \"triangle\":\n          return Triangle.draw(ctx, arrowData);\n        case \"inv_triangle\":\n          return InvertedTriangle.draw(ctx, arrowData);\n        case \"bar\":\n          return Bar.draw(ctx, arrowData);\n        case \"vee\":\n          return Vee.draw(ctx, arrowData);\n        case \"arrow\": // fall-through\n        default:\n          return Arrow.draw(ctx, arrowData);\n      }\n    }\n  }]);\n  return EndPoints;\n}();\n\nfunction ownKeys$1(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor$1(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var _context2, _context3; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context2 = ownKeys$1(Object(t), !0)).call(_context2, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context3 = ownKeys$1(Object(t))).call(_context3, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor$1(t, r)); }); } return e; }\n/**\r\n * The Base Class for all edges.\r\n */\nvar EdgeBase = /*#__PURE__*/function () {\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param _body - The body of the network.\r\n   * @param _labelModule - Label module.\r\n   */\n  function EdgeBase(options, _body, _labelModule) {\n    _classCallCheck(this, EdgeBase);\n    this._body = _body;\n    this._labelModule = _labelModule;\n    this.color = {};\n    this.colorDirty = true;\n    this.hoverWidth = 1.5;\n    this.selectionWidth = 2;\n    this.setOptions(options);\n    this.fromPoint = this.from;\n    this.toPoint = this.to;\n  }\n  /** @inheritDoc */\n  _createClass(EdgeBase, [{\n    key: \"connect\",\n    value: function connect() {\n      this.from = this._body.nodes[this.options.from];\n      this.to = this._body.nodes[this.options.to];\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      return false;\n    }\n    /**\r\n     * Set new edge options.\r\n     *\r\n     * @param options - The new edge options object.\r\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n      this.from = this._body.nodes[this.options.from];\n      this.to = this._body.nodes[this.options.to];\n      this.id = this.options.id;\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"drawLine\",\n    value: function drawLine(ctx, values, _selected, _hover) {\n      var viaNode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.getViaNode();\n      // set style\n      ctx.strokeStyle = this.getColor(ctx, values);\n      ctx.lineWidth = values.width;\n      if (values.dashes !== false) {\n        this._drawDashedLine(ctx, values, viaNode);\n      } else {\n        this._drawLine(ctx, values, viaNode);\n      }\n    }\n    /**\r\n     * Draw a line with given style between two nodes through supplied node(s).\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values like color, opacity or shadow.\r\n     * @param viaNode - Additional control point(s) for the edge.\r\n     * @param fromPoint - TODO: Seems ignored, remove?\r\n     * @param toPoint - TODO: Seems ignored, remove?\r\n     */\n  }, {\n    key: \"_drawLine\",\n    value: function _drawLine(ctx, values, viaNode, fromPoint, toPoint) {\n      if (this.from != this.to) {\n        // draw line\n        this._line(ctx, values, viaNode, fromPoint, toPoint);\n      } else {\n        var _this$_getCircleData = this._getCircleData(ctx),\n          _this$_getCircleData2 = _slicedToArray(_this$_getCircleData, 3),\n          x = _this$_getCircleData2[0],\n          y = _this$_getCircleData2[1],\n          radius = _this$_getCircleData2[2];\n        this._circle(ctx, values, x, y, radius);\n      }\n    }\n    /**\r\n     * Draw a dashed line with given style between two nodes through supplied node(s).\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values like color, opacity or shadow.\r\n     * @param viaNode - Additional control point(s) for the edge.\r\n     * @param _fromPoint - Ignored (TODO: remove in the future).\r\n     * @param _toPoint - Ignored (TODO: remove in the future).\r\n     */\n  }, {\n    key: \"_drawDashedLine\",\n    value: function _drawDashedLine(ctx, values, viaNode, _fromPoint, _toPoint) {\n      ctx.lineCap = \"round\";\n      var pattern = _Array$isArray(values.dashes) ? values.dashes : [5, 5];\n      // only firefox and chrome support this method, else we use the legacy one.\n      if (ctx.setLineDash !== undefined) {\n        ctx.save();\n        // set dash settings for chrome or firefox\n        ctx.setLineDash(pattern);\n        ctx.lineDashOffset = 0;\n        // draw the line\n        if (this.from != this.to) {\n          // draw line\n          this._line(ctx, values, viaNode);\n        } else {\n          var _this$_getCircleData3 = this._getCircleData(ctx),\n            _this$_getCircleData4 = _slicedToArray(_this$_getCircleData3, 3),\n            x = _this$_getCircleData4[0],\n            y = _this$_getCircleData4[1],\n            radius = _this$_getCircleData4[2];\n          this._circle(ctx, values, x, y, radius);\n        }\n        // restore the dash settings.\n        ctx.setLineDash([0]);\n        ctx.lineDashOffset = 0;\n        ctx.restore();\n      } else {\n        // unsupporting smooth lines\n        if (this.from != this.to) {\n          // draw line\n          drawDashedLine(ctx, this.from.x, this.from.y, this.to.x, this.to.y, pattern);\n        } else {\n          var _this$_getCircleData5 = this._getCircleData(ctx),\n            _this$_getCircleData6 = _slicedToArray(_this$_getCircleData5, 3),\n            _x = _this$_getCircleData6[0],\n            _y = _this$_getCircleData6[1],\n            _radius = _this$_getCircleData6[2];\n          this._circle(ctx, values, _x, _y, _radius);\n        }\n        // draw shadow if enabled\n        this.enableShadow(ctx, values);\n        ctx.stroke();\n        // disable shadows for other elements.\n        this.disableShadow(ctx, values);\n      }\n    }\n    /**\r\n     * Find the intersection between the border of the node and the edge.\r\n     *\r\n     * @param node - The node (either from or to node of the edge).\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param options - Additional options.\r\n     * @returns Cartesian coordinates of the intersection between the border of the node and the edge.\r\n     */\n  }, {\n    key: \"findBorderPosition\",\n    value: function findBorderPosition(node, ctx, options) {\n      if (this.from != this.to) {\n        return this._findBorderPosition(node, ctx, options);\n      } else {\n        return this._findBorderPositionCircle(node, ctx, options);\n      }\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"findBorderPositions\",\n    value: function findBorderPositions(ctx) {\n      if (this.from != this.to) {\n        return {\n          from: this._findBorderPosition(this.from, ctx),\n          to: this._findBorderPosition(this.to, ctx)\n        };\n      } else {\n        var _context;\n        var _this$_getCircleData$ = _sliceInstanceProperty(_context = this._getCircleData(ctx)).call(_context, 0, 2),\n          _this$_getCircleData$2 = _slicedToArray(_this$_getCircleData$, 2),\n          x = _this$_getCircleData$2[0],\n          y = _this$_getCircleData$2[1];\n        return {\n          from: this._findBorderPositionCircle(this.from, ctx, {\n            x: x,\n            y: y,\n            low: 0.25,\n            high: 0.6,\n            direction: -1\n          }),\n          to: this._findBorderPositionCircle(this.from, ctx, {\n            x: x,\n            y: y,\n            low: 0.6,\n            high: 0.8,\n            direction: 1\n          })\n        };\n      }\n    }\n    /**\r\n     * Compute the center point and radius of an edge connected to the same node at both ends.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @returns `[x, y, radius]`\r\n     */\n  }, {\n    key: \"_getCircleData\",\n    value: function _getCircleData(ctx) {\n      var radius = this.options.selfReference.size;\n      if (ctx !== undefined) {\n        if (this.from.shape.width === undefined) {\n          this.from.shape.resize(ctx);\n        }\n      }\n      // get circle coordinates\n      var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, radius, this.from);\n      return [coordinates.x, coordinates.y, radius];\n    }\n    /**\r\n     * Get a point on a circle.\r\n     *\r\n     * @param x - Center of the circle on the x axis.\r\n     * @param y - Center of the circle on the y axis.\r\n     * @param radius - Radius of the circle.\r\n     * @param position - Value between 0 (line start) and 1 (line end).\r\n     * @returns Cartesian coordinates of requested point on the circle.\r\n     */\n  }, {\n    key: \"_pointOnCircle\",\n    value: function _pointOnCircle(x, y, radius, position) {\n      var angle = position * 2 * Math.PI;\n      return {\n        x: x + radius * Math.cos(angle),\n        y: y - radius * Math.sin(angle)\n      };\n    }\n    /**\r\n     * Find the intersection between the border of the node and the edge.\r\n     *\r\n     * @remarks\r\n     * This function uses binary search to look for the point where the circle crosses the border of the node.\r\n     * @param nearNode - The node (either from or to node of the edge).\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param options - Additional options.\r\n     * @returns Cartesian coordinates of the intersection between the border of the node and the edge.\r\n     */\n  }, {\n    key: \"_findBorderPositionCircle\",\n    value: function _findBorderPositionCircle(nearNode, ctx, options) {\n      var x = options.x;\n      var y = options.y;\n      var low = options.low;\n      var high = options.high;\n      var direction = options.direction;\n      var maxIterations = 10;\n      var radius = this.options.selfReference.size;\n      var threshold = 0.05;\n      var pos;\n      var middle = (low + high) * 0.5;\n      var endPointOffset = 0;\n      if (this.options.arrowStrikethrough === true) {\n        if (direction === -1) {\n          endPointOffset = this.options.endPointOffset.from;\n        } else if (direction === 1) {\n          endPointOffset = this.options.endPointOffset.to;\n        }\n      }\n      var iteration = 0;\n      do {\n        middle = (low + high) * 0.5;\n        pos = this._pointOnCircle(x, y, radius, middle);\n        var angle = Math.atan2(nearNode.y - pos.y, nearNode.x - pos.x);\n        var distanceToBorder = nearNode.distanceToBorder(ctx, angle) + endPointOffset;\n        var distanceToPoint = Math.sqrt(Math.pow(pos.x - nearNode.x, 2) + Math.pow(pos.y - nearNode.y, 2));\n        var difference = distanceToBorder - distanceToPoint;\n        if (Math.abs(difference) < threshold) {\n          break; // found\n        } else if (difference > 0) {\n          // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.\n          if (direction > 0) {\n            low = middle;\n          } else {\n            high = middle;\n          }\n        } else {\n          if (direction > 0) {\n            high = middle;\n          } else {\n            low = middle;\n          }\n        }\n        ++iteration;\n      } while (low <= high && iteration < maxIterations);\n      return _objectSpread$1(_objectSpread$1({}, pos), {}, {\n        t: middle\n      });\n    }\n    /**\r\n     * Get the line width of the edge. Depends on width and whether one of the connected nodes is selected.\r\n     *\r\n     * @param selected - Determines wheter the line is selected.\r\n     * @param hover - Determines wheter the line is being hovered, only applies if selected is false.\r\n     * @returns The width of the line.\r\n     */\n  }, {\n    key: \"getLineWidth\",\n    value: function getLineWidth(selected, hover) {\n      if (selected === true) {\n        return Math.max(this.selectionWidth, 0.3 / this._body.view.scale);\n      } else if (hover === true) {\n        return Math.max(this.hoverWidth, 0.3 / this._body.view.scale);\n      } else {\n        return Math.max(this.options.width, 0.3 / this._body.view.scale);\n      }\n    }\n    /**\r\n     * Compute the color or gradient for given edge.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values like color, opacity or shadow.\r\n     * @param _selected - Ignored (TODO: remove in the future).\r\n     * @param _hover - Ignored (TODO: remove in the future).\r\n     * @returns Color string if single color is inherited or gradient if two.\r\n     */\n  }, {\n    key: \"getColor\",\n    value: function getColor(ctx, values) {\n      if (values.inheritsColor !== false) {\n        // when this is a loop edge, just use the 'from' method\n        if (values.inheritsColor === \"both\" && this.from.id !== this.to.id) {\n          var grd = ctx.createLinearGradient(this.from.x, this.from.y, this.to.x, this.to.y);\n          var fromColor = this.from.options.color.highlight.border;\n          var toColor = this.to.options.color.highlight.border;\n          if (this.from.selected === false && this.to.selected === false) {\n            fromColor = overrideOpacity(this.from.options.color.border, values.opacity);\n            toColor = overrideOpacity(this.to.options.color.border, values.opacity);\n          } else if (this.from.selected === true && this.to.selected === false) {\n            toColor = this.to.options.color.border;\n          } else if (this.from.selected === false && this.to.selected === true) {\n            fromColor = this.from.options.color.border;\n          }\n          grd.addColorStop(0, fromColor);\n          grd.addColorStop(1, toColor);\n          // -------------------- this returns -------------------- //\n          return grd;\n        }\n        if (values.inheritsColor === \"to\") {\n          return overrideOpacity(this.to.options.color.border, values.opacity);\n        } else {\n          // \"from\"\n          return overrideOpacity(this.from.options.color.border, values.opacity);\n        }\n      } else {\n        return overrideOpacity(values.color, values.opacity);\n      }\n    }\n    /**\r\n     * Draw a line from a node to itself, a circle.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values like color, opacity or shadow.\r\n     * @param x - Center of the circle on the x axis.\r\n     * @param y - Center of the circle on the y axis.\r\n     * @param radius - Radius of the circle.\r\n     */\n  }, {\n    key: \"_circle\",\n    value: function _circle(ctx, values, x, y, radius) {\n      // draw shadow if enabled\n      this.enableShadow(ctx, values);\n      //full circle\n      var angleFrom = 0;\n      var angleTo = Math.PI * 2;\n      if (!this.options.selfReference.renderBehindTheNode) {\n        //render only parts which are not overlaping with parent node\n        //need to find x,y of from point and x,y to point\n        //calculating radians\n        var low = this.options.selfReference.angle;\n        var high = this.options.selfReference.angle + Math.PI;\n        var pointTFrom = this._findBorderPositionCircle(this.from, ctx, {\n          x: x,\n          y: y,\n          low: low,\n          high: high,\n          direction: -1\n        });\n        var pointTTo = this._findBorderPositionCircle(this.from, ctx, {\n          x: x,\n          y: y,\n          low: low,\n          high: high,\n          direction: 1\n        });\n        angleFrom = Math.atan2(pointTFrom.y - y, pointTFrom.x - x);\n        angleTo = Math.atan2(pointTTo.y - y, pointTTo.x - x);\n      }\n      // draw a circle\n      ctx.beginPath();\n      ctx.arc(x, y, radius, angleFrom, angleTo, false);\n      ctx.stroke();\n      // disable shadows for other elements.\n      this.disableShadow(ctx, values);\n    }\n    /**\r\n     * @inheritDoc\r\n     * @remarks\r\n     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment\r\n     */\n  }, {\n    key: \"getDistanceToEdge\",\n    value: function getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      if (this.from != this.to) {\n        return this._getDistanceToEdge(x1, y1, x2, y2, x3, y3);\n      } else {\n        var _this$_getCircleData7 = this._getCircleData(undefined),\n          _this$_getCircleData8 = _slicedToArray(_this$_getCircleData7, 3),\n          x = _this$_getCircleData8[0],\n          y = _this$_getCircleData8[1],\n          radius = _this$_getCircleData8[2];\n        var dx = x - x3;\n        var dy = y - y3;\n        return Math.abs(Math.sqrt(dx * dx + dy * dy) - radius);\n      }\n    }\n    /**\r\n     * Calculate the distance between a point (x3, y3) and a line segment from (x1, y1) to (x2, y2).\r\n     *\r\n     * @param x1 - First end of the line segment on the x axis.\r\n     * @param y1 - First end of the line segment on the y axis.\r\n     * @param x2 - Second end of the line segment on the x axis.\r\n     * @param y2 - Second end of the line segment on the y axis.\r\n     * @param x3 - Position of the point on the x axis.\r\n     * @param y3 - Position of the point on the y axis.\r\n     * @returns The distance between the line segment and the point.\r\n     */\n  }, {\n    key: \"_getDistanceToLine\",\n    value: function _getDistanceToLine(x1, y1, x2, y2, x3, y3) {\n      var px = x2 - x1;\n      var py = y2 - y1;\n      var something = px * px + py * py;\n      var u = ((x3 - x1) * px + (y3 - y1) * py) / something;\n      if (u > 1) {\n        u = 1;\n      } else if (u < 0) {\n        u = 0;\n      }\n      var x = x1 + u * px;\n      var y = y1 + u * py;\n      var dx = x - x3;\n      var dy = y - y3;\n      //# Note: If the actual distance does not matter,\n      //# if you only want to compare what this function\n      //# returns to other results of this function, you\n      //# can just return the squared distance instead\n      //# (i.e. remove the sqrt) to gain a little performance\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getArrowData\",\n    value: function getArrowData(ctx, position, viaNode, _selected, _hover, values) {\n      // set lets\n      var angle;\n      var arrowPoint;\n      var node1;\n      var node2;\n      var reversed;\n      var scaleFactor;\n      var type;\n      var lineWidth = values.width;\n      if (position === \"from\") {\n        node1 = this.from;\n        node2 = this.to;\n        reversed = values.fromArrowScale < 0;\n        scaleFactor = Math.abs(values.fromArrowScale);\n        type = values.fromArrowType;\n      } else if (position === \"to\") {\n        node1 = this.to;\n        node2 = this.from;\n        reversed = values.toArrowScale < 0;\n        scaleFactor = Math.abs(values.toArrowScale);\n        type = values.toArrowType;\n      } else {\n        node1 = this.to;\n        node2 = this.from;\n        reversed = values.middleArrowScale < 0;\n        scaleFactor = Math.abs(values.middleArrowScale);\n        type = values.middleArrowType;\n      }\n      var length = 15 * scaleFactor + 3 * lineWidth; // 3* lineWidth is the width of the edge.\n      // if not connected to itself\n      if (node1 != node2) {\n        var approximateEdgeLength = _Math$hypot(node1.x - node2.x, node1.y - node2.y);\n        var relativeLength = length / approximateEdgeLength;\n        if (position !== \"middle\") {\n          // draw arrow head\n          if (this.options.smooth.enabled === true) {\n            var pointT = this._findBorderPosition(node1, ctx, {\n              via: viaNode\n            });\n            var guidePos = this.getPoint(pointT.t + relativeLength * (position === \"from\" ? 1 : -1), viaNode);\n            angle = Math.atan2(pointT.y - guidePos.y, pointT.x - guidePos.x);\n            arrowPoint = pointT;\n          } else {\n            angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);\n            arrowPoint = this._findBorderPosition(node1, ctx);\n          }\n        } else {\n          // Negative half length reverses arrow direction.\n          var halfLength = (reversed ? -relativeLength : relativeLength) / 2;\n          var guidePos1 = this.getPoint(0.5 + halfLength, viaNode);\n          var guidePos2 = this.getPoint(0.5 - halfLength, viaNode);\n          angle = Math.atan2(guidePos1.y - guidePos2.y, guidePos1.x - guidePos2.x);\n          arrowPoint = this.getPoint(0.5, viaNode);\n        }\n      } else {\n        // draw circle\n        var _this$_getCircleData9 = this._getCircleData(ctx),\n          _this$_getCircleData10 = _slicedToArray(_this$_getCircleData9, 3),\n          x = _this$_getCircleData10[0],\n          y = _this$_getCircleData10[1],\n          radius = _this$_getCircleData10[2];\n        if (position === \"from\") {\n          var low = this.options.selfReference.angle;\n          var high = this.options.selfReference.angle + Math.PI;\n          var _pointT = this._findBorderPositionCircle(this.from, ctx, {\n            x: x,\n            y: y,\n            low: low,\n            high: high,\n            direction: -1\n          });\n          angle = _pointT.t * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;\n          arrowPoint = _pointT;\n        } else if (position === \"to\") {\n          var _low = this.options.selfReference.angle;\n          var _high = this.options.selfReference.angle + Math.PI;\n          var _pointT2 = this._findBorderPositionCircle(this.from, ctx, {\n            x: x,\n            y: y,\n            low: _low,\n            high: _high,\n            direction: 1\n          });\n          angle = _pointT2.t * -2 * Math.PI + 1.5 * Math.PI - 1.1 * Math.PI;\n          arrowPoint = _pointT2;\n        } else {\n          var pos = this.options.selfReference.angle / (2 * Math.PI);\n          arrowPoint = this._pointOnCircle(x, y, radius, pos);\n          angle = pos * -2 * Math.PI + 1.5 * Math.PI + 0.1 * Math.PI;\n        }\n      }\n      var xi = arrowPoint.x - length * 0.9 * Math.cos(angle);\n      var yi = arrowPoint.y - length * 0.9 * Math.sin(angle);\n      var arrowCore = {\n        x: xi,\n        y: yi\n      };\n      return {\n        point: arrowPoint,\n        core: arrowCore,\n        angle: angle,\n        length: length,\n        type: type\n      };\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"drawArrowHead\",\n    value: function drawArrowHead(ctx, values, _selected, _hover, arrowData) {\n      // set style\n      ctx.strokeStyle = this.getColor(ctx, values);\n      ctx.fillStyle = ctx.strokeStyle;\n      ctx.lineWidth = values.width;\n      var canFill = EndPoints.draw(ctx, arrowData);\n      if (canFill) {\n        // draw shadow if enabled\n        this.enableShadow(ctx, values);\n        _fillInstanceProperty(ctx).call(ctx);\n        // disable shadows for other elements.\n        this.disableShadow(ctx, values);\n      }\n    }\n    /**\r\n     * Set the shadow formatting values in the context if enabled, do nothing otherwise.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values for the shadow.\r\n     */\n  }, {\n    key: \"enableShadow\",\n    value: function enableShadow(ctx, values) {\n      if (values.shadow === true) {\n        ctx.shadowColor = values.shadowColor;\n        ctx.shadowBlur = values.shadowSize;\n        ctx.shadowOffsetX = values.shadowX;\n        ctx.shadowOffsetY = values.shadowY;\n      }\n    }\n    /**\r\n     * Reset the shadow formatting values in the context if enabled, do nothing otherwise.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values for the shadow.\r\n     */\n  }, {\n    key: \"disableShadow\",\n    value: function disableShadow(ctx, values) {\n      if (values.shadow === true) {\n        ctx.shadowColor = \"rgba(0,0,0,0)\";\n        ctx.shadowBlur = 0;\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n      }\n    }\n    /**\r\n     * Render the background according to the formatting values.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Formatting values for the background.\r\n     */\n  }, {\n    key: \"drawBackground\",\n    value: function drawBackground(ctx, values) {\n      if (values.background !== false) {\n        // save original line attrs\n        var origCtxAttr = {\n          strokeStyle: ctx.strokeStyle,\n          lineWidth: ctx.lineWidth,\n          dashes: ctx.dashes\n        };\n        ctx.strokeStyle = values.backgroundColor;\n        ctx.lineWidth = values.backgroundSize;\n        this.setStrokeDashed(ctx, values.backgroundDashes);\n        ctx.stroke();\n        // restore original line attrs\n        ctx.strokeStyle = origCtxAttr.strokeStyle;\n        ctx.lineWidth = origCtxAttr.lineWidth;\n        ctx.dashes = origCtxAttr.dashes;\n        this.setStrokeDashed(ctx, values.dashes);\n      }\n    }\n    /**\r\n     * Set the line dash pattern if supported. Logs a warning to the console if it isn't supported.\r\n     *\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param dashes - The pattern [line, space, line…], true for default dashed line or false for normal line.\r\n     */\n  }, {\n    key: \"setStrokeDashed\",\n    value: function setStrokeDashed(ctx, dashes) {\n      if (dashes !== false) {\n        if (ctx.setLineDash !== undefined) {\n          var pattern = _Array$isArray(dashes) ? dashes : [5, 5];\n          ctx.setLineDash(pattern);\n        } else {\n          console.warn(\"setLineDash is not supported in this browser. The dashed stroke cannot be used.\");\n        }\n      } else {\n        if (ctx.setLineDash !== undefined) {\n          ctx.setLineDash([]);\n        } else {\n          console.warn(\"setLineDash is not supported in this browser. The dashed stroke cannot be used.\");\n        }\n      }\n    }\n  }]);\n  return EdgeBase;\n}();\n\nfunction ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = _filterInstanceProperty(o).call(o, function (r) { return _Object$getOwnPropertyDescriptor$1(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var _context, _context2; var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? _forEachInstanceProperty(_context = ownKeys(Object(t), !0)).call(_context, function (r) { _defineProperty(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : _forEachInstanceProperty(_context2 = ownKeys(Object(t))).call(_context2, function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor$1(t, r)); }); } return e; }\nfunction _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$9() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\r\n * The Base Class for all Bezier edges.\r\n * Bezier curves are used to model smooth gradual curves in paths between nodes.\r\n */\nvar BezierEdgeBase = /*#__PURE__*/function (_EdgeBase) {\n  _inherits(BezierEdgeBase, _EdgeBase);\n  var _super = _createSuper$9(BezierEdgeBase);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n  function BezierEdgeBase(options, body, labelModule) {\n    _classCallCheck(this, BezierEdgeBase);\n    return _super.call(this, options, body, labelModule);\n  }\n  /**\r\n   * Find the intersection between the border of the node and the edge.\r\n   *\r\n   * @remarks\r\n   * This function uses binary search to look for the point where the bezier curve crosses the border of the node.\r\n   * @param nearNode - The node (either from or to node of the edge).\r\n   * @param ctx - The context that will be used for rendering.\r\n   * @param viaNode - Additional node(s) the edge passes through.\r\n   * @returns Cartesian coordinates of the intersection between the border of the node and the edge.\r\n   */\n  _createClass(BezierEdgeBase, [{\n    key: \"_findBorderPositionBezier\",\n    value: function _findBorderPositionBezier(nearNode, ctx) {\n      var viaNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._getViaCoordinates();\n      var maxIterations = 10;\n      var threshold = 0.2;\n      var from = false;\n      var high = 1;\n      var low = 0;\n      var node = this.to;\n      var pos;\n      var middle;\n      var endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.to : 0;\n      if (nearNode.id === this.from.id) {\n        node = this.from;\n        from = true;\n        endPointOffset = this.options.endPointOffset ? this.options.endPointOffset.from : 0;\n      }\n      if (this.options.arrowStrikethrough === false) {\n        endPointOffset = 0;\n      }\n      var iteration = 0;\n      do {\n        middle = (low + high) * 0.5;\n        pos = this.getPoint(middle, viaNode);\n        var angle = Math.atan2(node.y - pos.y, node.x - pos.x);\n        var distanceToBorder = node.distanceToBorder(ctx, angle) + endPointOffset;\n        var distanceToPoint = Math.sqrt(Math.pow(pos.x - node.x, 2) + Math.pow(pos.y - node.y, 2));\n        var difference = distanceToBorder - distanceToPoint;\n        if (Math.abs(difference) < threshold) {\n          break; // found\n        } else if (difference < 0) {\n          // distance to nodes is larger than distance to border --> t needs to be bigger if we're looking at the to node.\n          if (from === false) {\n            low = middle;\n          } else {\n            high = middle;\n          }\n        } else {\n          if (from === false) {\n            high = middle;\n          } else {\n            low = middle;\n          }\n        }\n        ++iteration;\n      } while (low <= high && iteration < maxIterations);\n      return _objectSpread(_objectSpread({}, pos), {}, {\n        t: middle\n      });\n    }\n    /**\r\n     * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).\r\n     *\r\n     * @remarks\r\n     * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment\r\n     * @param x1 - First end of the line segment on the x axis.\r\n     * @param y1 - First end of the line segment on the y axis.\r\n     * @param x2 - Second end of the line segment on the x axis.\r\n     * @param y2 - Second end of the line segment on the y axis.\r\n     * @param x3 - Position of the point on the x axis.\r\n     * @param y3 - Position of the point on the y axis.\r\n     * @param via - The control point for the edge.\r\n     * @returns The distance between the line segment and the point.\r\n     */\n  }, {\n    key: \"_getDistanceToBezierEdge\",\n    value: function _getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, via) {\n      // x3,y3 is the point\n      var minDistance = 1e9;\n      var distance;\n      var i, t, x, y;\n      var lastX = x1;\n      var lastY = y1;\n      for (i = 1; i < 10; i++) {\n        t = 0.1 * i;\n        x = Math.pow(1 - t, 2) * x1 + 2 * t * (1 - t) * via.x + Math.pow(t, 2) * x2;\n        y = Math.pow(1 - t, 2) * y1 + 2 * t * (1 - t) * via.y + Math.pow(t, 2) * y2;\n        if (i > 0) {\n          distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);\n          minDistance = distance < minDistance ? distance : minDistance;\n        }\n        lastX = x;\n        lastY = y;\n      }\n      return minDistance;\n    }\n    /**\r\n     * Render a bezier curve between two nodes.\r\n     *\r\n     * @remarks\r\n     * The method accepts zero, one or two control points.\r\n     * Passing zero control points just draws a straight line.\r\n     * @param ctx - The context that will be used for rendering.\r\n     * @param values - Style options for edge drawing.\r\n     * @param viaNode1 - First control point for curve drawing.\r\n     * @param viaNode2 - Second control point for curve drawing.\r\n     */\n  }, {\n    key: \"_bezierCurve\",\n    value: function _bezierCurve(ctx, values, viaNode1, viaNode2) {\n      ctx.beginPath();\n      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);\n      if (viaNode1 != null && viaNode1.x != null) {\n        if (viaNode2 != null && viaNode2.x != null) {\n          ctx.bezierCurveTo(viaNode1.x, viaNode1.y, viaNode2.x, viaNode2.y, this.toPoint.x, this.toPoint.y);\n        } else {\n          ctx.quadraticCurveTo(viaNode1.x, viaNode1.y, this.toPoint.x, this.toPoint.y);\n        }\n      } else {\n        // fallback to normal straight edge\n        ctx.lineTo(this.toPoint.x, this.toPoint.y);\n      }\n      // draw a background\n      this.drawBackground(ctx, values);\n      // draw shadow if enabled\n      this.enableShadow(ctx, values);\n      ctx.stroke();\n      this.disableShadow(ctx, values);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return this._getViaCoordinates();\n    }\n  }]);\n  return BezierEdgeBase;\n}(EdgeBase);\n\nfunction _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$8() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\r\n * A Dynamic Bezier Edge. Bezier curves are used to model smooth gradual\r\n * curves in paths between nodes. The Dynamic piece refers to how the curve\r\n * reacts to physics changes.\r\n *\r\n * @augments BezierEdgeBase\r\n */\nvar BezierEdgeDynamic = /*#__PURE__*/function (_BezierEdgeBase) {\n  _inherits(BezierEdgeDynamic, _BezierEdgeBase);\n  var _super = _createSuper$8(BezierEdgeDynamic);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n  function BezierEdgeDynamic(options, body, labelModule) {\n    var _this;\n    _classCallCheck(this, BezierEdgeDynamic);\n    //this.via = undefined; // Here for completeness but not allowed to defined before super() is invoked.\n    _this = _super.call(this, options, body, labelModule); // --> this calls the setOptions below\n    _this.via = _this.via; // constructor → super → super → setOptions → setupSupportNode\n    _this._boundFunction = function () {\n      _this.positionBezierNode();\n    };\n    _this._body.emitter.on(\"_repositionBezierNodes\", _this._boundFunction);\n    return _this;\n  }\n  /** @inheritDoc */\n  _createClass(BezierEdgeDynamic, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      _get(_getPrototypeOf(BezierEdgeDynamic.prototype), \"setOptions\", this).call(this, options);\n      // check if the physics has changed.\n      var physicsChange = false;\n      if (this.options.physics !== options.physics) {\n        physicsChange = true;\n      }\n      // set the options and the to and from nodes\n      this.options = options;\n      this.id = this.options.id;\n      this.from = this._body.nodes[this.options.from];\n      this.to = this._body.nodes[this.options.to];\n      // setup the support node and connect\n      this.setupSupportNode();\n      this.connect();\n      // when we change the physics state of the edge, we reposition the support node.\n      if (physicsChange === true) {\n        this.via.setOptions({\n          physics: this.options.physics\n        });\n        this.positionBezierNode();\n      }\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      this.from = this._body.nodes[this.options.from];\n      this.to = this._body.nodes[this.options.to];\n      if (this.from === undefined || this.to === undefined || this.options.physics === false) {\n        this.via.setOptions({\n          physics: false\n        });\n      } else {\n        // fix weird behaviour where a self referencing node has physics enabled\n        if (this.from.id === this.to.id) {\n          this.via.setOptions({\n            physics: false\n          });\n        } else {\n          this.via.setOptions({\n            physics: true\n          });\n        }\n      }\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      this._body.emitter.off(\"_repositionBezierNodes\", this._boundFunction);\n      if (this.via !== undefined) {\n        delete this._body.nodes[this.via.id];\n        this.via = undefined;\n        return true;\n      }\n      return false;\n    }\n    /**\r\n     * Create and add a support node if not already present.\r\n     *\r\n     * @remarks\r\n     * Bezier curves require an anchor point to calculate the smooth flow.\r\n     * These points are nodes.\r\n     * These nodes are invisible but are used for the force calculation.\r\n     *\r\n     * The changed data is not called, if needed, it is returned by the main edge constructor.\r\n     */\n  }, {\n    key: \"setupSupportNode\",\n    value: function setupSupportNode() {\n      if (this.via === undefined) {\n        var nodeId = \"edgeId:\" + this.id;\n        var node = this._body.functions.createNode({\n          id: nodeId,\n          shape: \"circle\",\n          physics: true,\n          hidden: true\n        });\n        this._body.nodes[nodeId] = node;\n        this.via = node;\n        this.via.parentEdgeId = this.id;\n        this.positionBezierNode();\n      }\n    }\n    /**\r\n     * Position bezier node.\r\n     */\n  }, {\n    key: \"positionBezierNode\",\n    value: function positionBezierNode() {\n      if (this.via !== undefined && this.from !== undefined && this.to !== undefined) {\n        this.via.x = 0.5 * (this.from.x + this.to.x);\n        this.via.y = 0.5 * (this.from.y + this.to.y);\n      } else if (this.via !== undefined) {\n        this.via.x = 0;\n        this.via.y = 0;\n      }\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_line\",\n    value: function _line(ctx, values, viaNode) {\n      this._bezierCurve(ctx, values, viaNode);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_getViaCoordinates\",\n    value: function _getViaCoordinates() {\n      return this.via;\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return this.via;\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(position) {\n      var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.via;\n      if (this.from === this.to) {\n        var _this$_getCircleData = this._getCircleData(),\n          _this$_getCircleData2 = _slicedToArray(_this$_getCircleData, 3),\n          cx = _this$_getCircleData2[0],\n          cy = _this$_getCircleData2[1],\n          cr = _this$_getCircleData2[2];\n        var a = 2 * Math.PI * (1 - position);\n        return {\n          x: cx + cr * Math.sin(a),\n          y: cy + cr - cr * (1 - Math.cos(a))\n        };\n      } else {\n        return {\n          x: Math.pow(1 - position, 2) * this.fromPoint.x + 2 * position * (1 - position) * viaNode.x + Math.pow(position, 2) * this.toPoint.x,\n          y: Math.pow(1 - position, 2) * this.fromPoint.y + 2 * position * (1 - position) * viaNode.y + Math.pow(position, 2) * this.toPoint.y\n        };\n      }\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_findBorderPosition\",\n    value: function _findBorderPosition(nearNode, ctx) {\n      return this._findBorderPositionBezier(nearNode, ctx, this.via);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_getDistanceToEdge\",\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      // x3,y3 is the point\n      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, this.via);\n    }\n  }]);\n  return BezierEdgeDynamic;\n}(BezierEdgeBase);\n\nfunction _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$7() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\r\n * A Static Bezier Edge. Bezier curves are used to model smooth gradual curves in paths between nodes.\r\n */\nvar BezierEdgeStatic = /*#__PURE__*/function (_BezierEdgeBase) {\n  _inherits(BezierEdgeStatic, _BezierEdgeBase);\n  var _super = _createSuper$7(BezierEdgeStatic);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n  function BezierEdgeStatic(options, body, labelModule) {\n    _classCallCheck(this, BezierEdgeStatic);\n    return _super.call(this, options, body, labelModule);\n  }\n  /** @inheritDoc */\n  _createClass(BezierEdgeStatic, [{\n    key: \"_line\",\n    value: function _line(ctx, values, viaNode) {\n      this._bezierCurve(ctx, values, viaNode);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return this._getViaCoordinates();\n    }\n    /**\r\n     * Compute the coordinates of the via node.\r\n     *\r\n     * @remarks\r\n     * We do not use the to and fromPoints here to make the via nodes the same as edges without arrows.\r\n     * @returns Cartesian coordinates of the via node.\r\n     */\n  }, {\n    key: \"_getViaCoordinates\",\n    value: function _getViaCoordinates() {\n      // Assumption: x/y coordinates in from/to always defined\n      var factor = this.options.smooth.roundness;\n      var type = this.options.smooth.type;\n      var dx = Math.abs(this.from.x - this.to.x);\n      var dy = Math.abs(this.from.y - this.to.y);\n      if (type === \"discrete\" || type === \"diagonalCross\") {\n        var stepX;\n        var stepY;\n        if (dx <= dy) {\n          stepX = stepY = factor * dy;\n        } else {\n          stepX = stepY = factor * dx;\n        }\n        if (this.from.x > this.to.x) {\n          stepX = -stepX;\n        }\n        if (this.from.y >= this.to.y) {\n          stepY = -stepY;\n        }\n        var xVia = this.from.x + stepX;\n        var yVia = this.from.y + stepY;\n        if (type === \"discrete\") {\n          if (dx <= dy) {\n            xVia = dx < factor * dy ? this.from.x : xVia;\n          } else {\n            yVia = dy < factor * dx ? this.from.y : yVia;\n          }\n        }\n        return {\n          x: xVia,\n          y: yVia\n        };\n      } else if (type === \"straightCross\") {\n        var _stepX = (1 - factor) * dx;\n        var _stepY = (1 - factor) * dy;\n        if (dx <= dy) {\n          // up - down\n          _stepX = 0;\n          if (this.from.y < this.to.y) {\n            _stepY = -_stepY;\n          }\n        } else {\n          // left - right\n          if (this.from.x < this.to.x) {\n            _stepX = -_stepX;\n          }\n          _stepY = 0;\n        }\n        return {\n          x: this.to.x + _stepX,\n          y: this.to.y + _stepY\n        };\n      } else if (type === \"horizontal\") {\n        var _stepX2 = (1 - factor) * dx;\n        if (this.from.x < this.to.x) {\n          _stepX2 = -_stepX2;\n        }\n        return {\n          x: this.to.x + _stepX2,\n          y: this.from.y\n        };\n      } else if (type === \"vertical\") {\n        var _stepY2 = (1 - factor) * dy;\n        if (this.from.y < this.to.y) {\n          _stepY2 = -_stepY2;\n        }\n        return {\n          x: this.from.x,\n          y: this.to.y + _stepY2\n        };\n      } else if (type === \"curvedCW\") {\n        dx = this.to.x - this.from.x;\n        dy = this.from.y - this.to.y;\n        var radius = Math.sqrt(dx * dx + dy * dy);\n        var pi = Math.PI;\n        var originalAngle = Math.atan2(dy, dx);\n        var myAngle = (originalAngle + (factor * 0.5 + 0.5) * pi) % (2 * pi);\n        return {\n          x: this.from.x + (factor * 0.5 + 0.5) * radius * Math.sin(myAngle),\n          y: this.from.y + (factor * 0.5 + 0.5) * radius * Math.cos(myAngle)\n        };\n      } else if (type === \"curvedCCW\") {\n        dx = this.to.x - this.from.x;\n        dy = this.from.y - this.to.y;\n        var _radius = Math.sqrt(dx * dx + dy * dy);\n        var _pi = Math.PI;\n        var _originalAngle = Math.atan2(dy, dx);\n        var _myAngle = (_originalAngle + (-factor * 0.5 + 0.5) * _pi) % (2 * _pi);\n        return {\n          x: this.from.x + (factor * 0.5 + 0.5) * _radius * Math.sin(_myAngle),\n          y: this.from.y + (factor * 0.5 + 0.5) * _radius * Math.cos(_myAngle)\n        };\n      } else {\n        // continuous\n        var _stepX3;\n        var _stepY3;\n        if (dx <= dy) {\n          _stepX3 = _stepY3 = factor * dy;\n        } else {\n          _stepX3 = _stepY3 = factor * dx;\n        }\n        if (this.from.x > this.to.x) {\n          _stepX3 = -_stepX3;\n        }\n        if (this.from.y >= this.to.y) {\n          _stepY3 = -_stepY3;\n        }\n        var _xVia = this.from.x + _stepX3;\n        var _yVia = this.from.y + _stepY3;\n        if (dx <= dy) {\n          if (this.from.x <= this.to.x) {\n            _xVia = this.to.x < _xVia ? this.to.x : _xVia;\n          } else {\n            _xVia = this.to.x > _xVia ? this.to.x : _xVia;\n          }\n        } else {\n          if (this.from.y >= this.to.y) {\n            _yVia = this.to.y > _yVia ? this.to.y : _yVia;\n          } else {\n            _yVia = this.to.y < _yVia ? this.to.y : _yVia;\n          }\n        }\n        return {\n          x: _xVia,\n          y: _yVia\n        };\n      }\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_findBorderPosition\",\n    value: function _findBorderPosition(nearNode, ctx) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this._findBorderPositionBezier(nearNode, ctx, options.via);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_getDistanceToEdge\",\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      var viaNode = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates();\n      // x3,y3 is the point\n      return this._getDistanceToBezierEdge(x1, y1, x2, y2, x3, y3, viaNode);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(position) {\n      var viaNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates();\n      var t = position;\n      var x = Math.pow(1 - t, 2) * this.fromPoint.x + 2 * t * (1 - t) * viaNode.x + Math.pow(t, 2) * this.toPoint.x;\n      var y = Math.pow(1 - t, 2) * this.fromPoint.y + 2 * t * (1 - t) * viaNode.y + Math.pow(t, 2) * this.toPoint.y;\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }]);\n  return BezierEdgeStatic;\n}(BezierEdgeBase);\n\nfunction _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$6() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\r\n * A Base Class for all Cubic Bezier Edges. Bezier curves are used to model\r\n * smooth gradual curves in paths between nodes.\r\n *\r\n * @augments BezierEdgeBase\r\n */\nvar CubicBezierEdgeBase = /*#__PURE__*/function (_BezierEdgeBase) {\n  _inherits(CubicBezierEdgeBase, _BezierEdgeBase);\n  var _super = _createSuper$6(CubicBezierEdgeBase);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n  function CubicBezierEdgeBase(options, body, labelModule) {\n    _classCallCheck(this, CubicBezierEdgeBase);\n    return _super.call(this, options, body, labelModule);\n  }\n  /**\r\n   * Calculate the distance between a point (x3,y3) and a line segment from (x1,y1) to (x2,y2).\r\n   *\r\n   * @remarks\r\n   * http://stackoverflow.com/questions/849211/shortest-distancae-between-a-point-and-a-line-segment\r\n   * https://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n   * @param x1 - First end of the line segment on the x axis.\r\n   * @param y1 - First end of the line segment on the y axis.\r\n   * @param x2 - Second end of the line segment on the x axis.\r\n   * @param y2 - Second end of the line segment on the y axis.\r\n   * @param x3 - Position of the point on the x axis.\r\n   * @param y3 - Position of the point on the y axis.\r\n   * @param via1 - The first point this edge passes through.\r\n   * @param via2 - The second point this edge passes through.\r\n   * @returns The distance between the line segment and the point.\r\n   */\n  _createClass(CubicBezierEdgeBase, [{\n    key: \"_getDistanceToBezierEdge2\",\n    value: function _getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2) {\n      // x3,y3 is the point\n      var minDistance = 1e9;\n      var lastX = x1;\n      var lastY = y1;\n      var vec = [0, 0, 0, 0];\n      for (var i = 1; i < 10; i++) {\n        var t = 0.1 * i;\n        vec[0] = Math.pow(1 - t, 3);\n        vec[1] = 3 * t * Math.pow(1 - t, 2);\n        vec[2] = 3 * Math.pow(t, 2) * (1 - t);\n        vec[3] = Math.pow(t, 3);\n        var x = vec[0] * x1 + vec[1] * via1.x + vec[2] * via2.x + vec[3] * x2;\n        var y = vec[0] * y1 + vec[1] * via1.y + vec[2] * via2.y + vec[3] * y2;\n        if (i > 0) {\n          var distance = this._getDistanceToLine(lastX, lastY, x, y, x3, y3);\n          minDistance = distance < minDistance ? distance : minDistance;\n        }\n        lastX = x;\n        lastY = y;\n      }\n      return minDistance;\n    }\n  }]);\n  return CubicBezierEdgeBase;\n}(BezierEdgeBase);\n\nfunction _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$5() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\r\n * A Cubic Bezier Edge. Bezier curves are used to model smooth gradual curves in paths between nodes.\r\n */\nvar CubicBezierEdge = /*#__PURE__*/function (_CubicBezierEdgeBase) {\n  _inherits(CubicBezierEdge, _CubicBezierEdgeBase);\n  var _super = _createSuper$5(CubicBezierEdge);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n  function CubicBezierEdge(options, body, labelModule) {\n    _classCallCheck(this, CubicBezierEdge);\n    return _super.call(this, options, body, labelModule);\n  }\n  /** @inheritDoc */\n  _createClass(CubicBezierEdge, [{\n    key: \"_line\",\n    value: function _line(ctx, values, viaNodes) {\n      // get the coordinates of the support points.\n      var via1 = viaNodes[0];\n      var via2 = viaNodes[1];\n      this._bezierCurve(ctx, values, via1, via2);\n    }\n    /**\r\n     * Compute the additional points the edge passes through.\r\n     *\r\n     * @returns Cartesian coordinates of the points the edge passes through.\r\n     */\n  }, {\n    key: \"_getViaCoordinates\",\n    value: function _getViaCoordinates() {\n      var dx = this.from.x - this.to.x;\n      var dy = this.from.y - this.to.y;\n      var x1;\n      var y1;\n      var x2;\n      var y2;\n      var roundness = this.options.smooth.roundness;\n      // horizontal if x > y or if direction is forced or if direction is horizontal\n      if ((Math.abs(dx) > Math.abs(dy) || this.options.smooth.forceDirection === true || this.options.smooth.forceDirection === \"horizontal\") && this.options.smooth.forceDirection !== \"vertical\") {\n        y1 = this.from.y;\n        y2 = this.to.y;\n        x1 = this.from.x - roundness * dx;\n        x2 = this.to.x + roundness * dx;\n      } else {\n        y1 = this.from.y - roundness * dy;\n        y2 = this.to.y + roundness * dy;\n        x1 = this.from.x;\n        x2 = this.to.x;\n      }\n      return [{\n        x: x1,\n        y: y1\n      }, {\n        x: x2,\n        y: y2\n      }];\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return this._getViaCoordinates();\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_findBorderPosition\",\n    value: function _findBorderPosition(nearNode, ctx) {\n      return this._findBorderPositionBezier(nearNode, ctx);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_getDistanceToEdge\",\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      var _ref = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : this._getViaCoordinates(),\n        _ref2 = _slicedToArray(_ref, 2),\n        via1 = _ref2[0],\n        via2 = _ref2[1];\n      // x3,y3 is the point\n      return this._getDistanceToBezierEdge2(x1, y1, x2, y2, x3, y3, via1, via2);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(position) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._getViaCoordinates(),\n        _ref4 = _slicedToArray(_ref3, 2),\n        via1 = _ref4[0],\n        via2 = _ref4[1];\n      var t = position;\n      var vec = [Math.pow(1 - t, 3), 3 * t * Math.pow(1 - t, 2), 3 * Math.pow(t, 2) * (1 - t), Math.pow(t, 3)];\n      var x = vec[0] * this.fromPoint.x + vec[1] * via1.x + vec[2] * via2.x + vec[3] * this.toPoint.x;\n      var y = vec[0] * this.fromPoint.y + vec[1] * via1.y + vec[2] * via2.y + vec[3] * this.toPoint.y;\n      return {\n        x: x,\n        y: y\n      };\n    }\n  }]);\n  return CubicBezierEdge;\n}(CubicBezierEdgeBase);\n\nfunction _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$4() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\r\n * A Straight Edge.\r\n */\nvar StraightEdge = /*#__PURE__*/function (_EdgeBase) {\n  _inherits(StraightEdge, _EdgeBase);\n  var _super = _createSuper$4(StraightEdge);\n  /**\r\n   * Create a new instance.\r\n   *\r\n   * @param options - The options object of given edge.\r\n   * @param body - The body of the network.\r\n   * @param labelModule - Label module.\r\n   */\n  function StraightEdge(options, body, labelModule) {\n    _classCallCheck(this, StraightEdge);\n    return _super.call(this, options, body, labelModule);\n  }\n  /** @inheritDoc */\n  _createClass(StraightEdge, [{\n    key: \"_line\",\n    value: function _line(ctx, values) {\n      // draw a straight line\n      ctx.beginPath();\n      ctx.moveTo(this.fromPoint.x, this.fromPoint.y);\n      ctx.lineTo(this.toPoint.x, this.toPoint.y);\n      // draw shadow if enabled\n      this.enableShadow(ctx, values);\n      ctx.stroke();\n      this.disableShadow(ctx, values);\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getViaNode\",\n    value: function getViaNode() {\n      return undefined;\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(position) {\n      return {\n        x: (1 - position) * this.fromPoint.x + position * this.toPoint.x,\n        y: (1 - position) * this.fromPoint.y + position * this.toPoint.y\n      };\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_findBorderPosition\",\n    value: function _findBorderPosition(nearNode, ctx) {\n      var node1 = this.to;\n      var node2 = this.from;\n      if (nearNode.id === this.from.id) {\n        node1 = this.from;\n        node2 = this.to;\n      }\n      var angle = Math.atan2(node1.y - node2.y, node1.x - node2.x);\n      var dx = node1.x - node2.x;\n      var dy = node1.y - node2.y;\n      var edgeSegmentLength = Math.sqrt(dx * dx + dy * dy);\n      var toBorderDist = nearNode.distanceToBorder(ctx, angle);\n      var toBorderPoint = (edgeSegmentLength - toBorderDist) / edgeSegmentLength;\n      return {\n        x: (1 - toBorderPoint) * node2.x + toBorderPoint * node1.x,\n        y: (1 - toBorderPoint) * node2.y + toBorderPoint * node1.y,\n        t: 0\n      };\n    }\n    /** @inheritDoc */\n  }, {\n    key: \"_getDistanceToEdge\",\n    value: function _getDistanceToEdge(x1, y1, x2, y2, x3, y3) {\n      // x3,y3 is the point\n      return this._getDistanceToLine(x1, y1, x2, y2, x3, y3);\n    }\n  }]);\n  return StraightEdge;\n}(EdgeBase);\n\n/**\n * An edge connects two nodes and has a specific direction.\n */\nvar Edge = /*#__PURE__*/function () {\n  /**\n   * @param {object} options        values specific to this edge, must contain at least 'from' and 'to'\n   * @param {object} body           shared state from Network instance\n   * @param {Network.Images} imagelist  A list with images. Only needed when the edge has image arrows.\n   * @param {object} globalOptions  options from the EdgesHandler instance\n   * @param {object} defaultOptions default options from the EdgeHandler instance. Value and reference are constant\n   */\n  function Edge(options, body, imagelist, globalOptions, defaultOptions) {\n    _classCallCheck(this, Edge);\n    if (body === undefined) {\n      throw new Error(\"No body provided\");\n    }\n\n    // Since globalOptions is constant in values as well as reference,\n    // Following needs to be done only once.\n\n    this.options = bridgeObject(globalOptions);\n    this.globalOptions = globalOptions;\n    this.defaultOptions = defaultOptions;\n    this.body = body;\n    this.imagelist = imagelist;\n\n    // initialize variables\n    this.id = undefined;\n    this.fromId = undefined;\n    this.toId = undefined;\n    this.selected = false;\n    this.hover = false;\n    this.labelDirty = true;\n    this.baseWidth = this.options.width;\n    this.baseFontSize = this.options.font.size;\n    this.from = undefined; // a node\n    this.to = undefined; // a node\n\n    this.edgeType = undefined;\n    this.connected = false;\n    this.labelModule = new Label(this.body, this.options, true /* It's an edge label */);\n\n    this.setOptions(options);\n  }\n\n  /**\n   * Set or overwrite options for the edge\n   *\n   * @param {object} options  an object with options\n   * @returns {undefined|boolean} undefined if no options, true if layout affecting data changed, false otherwise.\n   */\n  _createClass(Edge, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (!options) {\n        return;\n      }\n\n      // Following options if changed affect the layout.\n      var affectsLayout = typeof options.physics !== \"undefined\" && this.options.physics !== options.physics || typeof options.hidden !== \"undefined\" && (this.options.hidden || false) !== (options.hidden || false) || typeof options.from !== \"undefined\" && this.options.from !== options.from || typeof options.to !== \"undefined\" && this.options.to !== options.to;\n      Edge.parseOptions(this.options, options, true, this.globalOptions);\n      if (options.id !== undefined) {\n        this.id = options.id;\n      }\n      if (options.from !== undefined) {\n        this.fromId = options.from;\n      }\n      if (options.to !== undefined) {\n        this.toId = options.to;\n      }\n      if (options.title !== undefined) {\n        this.title = options.title;\n      }\n      if (options.value !== undefined) {\n        options.value = _parseFloat$1(options.value);\n      }\n      var pile = [options, this.options, this.defaultOptions];\n      this.chooser = choosify(\"edge\", pile);\n\n      // update label Module\n      this.updateLabelModule(options);\n\n      // Update edge type, this if changed affects the layout.\n      affectsLayout = this.updateEdgeType() || affectsLayout;\n\n      // if anything has been updates, reset the selection width and the hover width\n      this._setInteractionWidths();\n\n      // A node is connected when it has a from and to node that both exist in the network.body.nodes.\n      this.connect();\n      return affectsLayout;\n    }\n\n    /**\n     *\n     * @param {object} parentOptions\n     * @param {object} newOptions\n     * @param {boolean} [allowDeletion=false]\n     * @param {object} [globalOptions={}]\n     * @param {boolean} [copyFromGlobals=false]\n     */\n  }, {\n    key: \"getFormattingValues\",\n    value:\n    /**\n     *\n     * @returns {ArrowOptions}\n     */\n    function getFormattingValues() {\n      var toArrow = this.options.arrows.to === true || this.options.arrows.to.enabled === true;\n      var fromArrow = this.options.arrows.from === true || this.options.arrows.from.enabled === true;\n      var middleArrow = this.options.arrows.middle === true || this.options.arrows.middle.enabled === true;\n      var inheritsColor = this.options.color.inherit;\n      var values = {\n        toArrow: toArrow,\n        toArrowScale: this.options.arrows.to.scaleFactor,\n        toArrowType: this.options.arrows.to.type,\n        toArrowSrc: this.options.arrows.to.src,\n        toArrowImageWidth: this.options.arrows.to.imageWidth,\n        toArrowImageHeight: this.options.arrows.to.imageHeight,\n        middleArrow: middleArrow,\n        middleArrowScale: this.options.arrows.middle.scaleFactor,\n        middleArrowType: this.options.arrows.middle.type,\n        middleArrowSrc: this.options.arrows.middle.src,\n        middleArrowImageWidth: this.options.arrows.middle.imageWidth,\n        middleArrowImageHeight: this.options.arrows.middle.imageHeight,\n        fromArrow: fromArrow,\n        fromArrowScale: this.options.arrows.from.scaleFactor,\n        fromArrowType: this.options.arrows.from.type,\n        fromArrowSrc: this.options.arrows.from.src,\n        fromArrowImageWidth: this.options.arrows.from.imageWidth,\n        fromArrowImageHeight: this.options.arrows.from.imageHeight,\n        arrowStrikethrough: this.options.arrowStrikethrough,\n        color: inheritsColor ? undefined : this.options.color.color,\n        inheritsColor: inheritsColor,\n        opacity: this.options.color.opacity,\n        hidden: this.options.hidden,\n        length: this.options.length,\n        shadow: this.options.shadow.enabled,\n        shadowColor: this.options.shadow.color,\n        shadowSize: this.options.shadow.size,\n        shadowX: this.options.shadow.x,\n        shadowY: this.options.shadow.y,\n        dashes: this.options.dashes,\n        width: this.options.width,\n        background: this.options.background.enabled,\n        backgroundColor: this.options.background.color,\n        backgroundSize: this.options.background.size,\n        backgroundDashes: this.options.background.dashes\n      };\n      if (this.selected || this.hover) {\n        if (this.chooser === true) {\n          if (this.selected) {\n            var selectedWidth = this.options.selectionWidth;\n            if (typeof selectedWidth === \"function\") {\n              values.width = selectedWidth(values.width);\n            } else if (typeof selectedWidth === \"number\") {\n              values.width += selectedWidth;\n            }\n            values.width = Math.max(values.width, 0.3 / this.body.view.scale);\n            values.color = this.options.color.highlight;\n            values.shadow = this.options.shadow.enabled;\n          } else if (this.hover) {\n            var hoverWidth = this.options.hoverWidth;\n            if (typeof hoverWidth === \"function\") {\n              values.width = hoverWidth(values.width);\n            } else if (typeof hoverWidth === \"number\") {\n              values.width += hoverWidth;\n            }\n            values.width = Math.max(values.width, 0.3 / this.body.view.scale);\n            values.color = this.options.color.hover;\n            values.shadow = this.options.shadow.enabled;\n          }\n        } else if (typeof this.chooser === \"function\") {\n          this.chooser(values, this.options.id, this.selected, this.hover);\n          if (values.color !== undefined) {\n            values.inheritsColor = false;\n          }\n          if (values.shadow === false) {\n            if (values.shadowColor !== this.options.shadow.color || values.shadowSize !== this.options.shadow.size || values.shadowX !== this.options.shadow.x || values.shadowY !== this.options.shadow.y) {\n              values.shadow = true;\n            }\n          }\n        }\n      } else {\n        values.shadow = this.options.shadow.enabled;\n        values.width = Math.max(values.width, 0.3 / this.body.view.scale);\n      }\n      return values;\n    }\n\n    /**\n     * update the options in the label module\n     *\n     * @param {object} options\n     */\n  }, {\n    key: \"updateLabelModule\",\n    value: function updateLabelModule(options) {\n      var pile = [options, this.options, this.globalOptions,\n      // Currently set global edge options\n      this.defaultOptions];\n      this.labelModule.update(this.options, pile);\n      if (this.labelModule.baseSize !== undefined) {\n        this.baseFontSize = this.labelModule.baseSize;\n      }\n    }\n\n    /**\n     * update the edge type, set the options\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"updateEdgeType\",\n    value: function updateEdgeType() {\n      var smooth = this.options.smooth;\n      var dataChanged = false;\n      var changeInType = true;\n      if (this.edgeType !== undefined) {\n        if (this.edgeType instanceof BezierEdgeDynamic && smooth.enabled === true && smooth.type === \"dynamic\" || this.edgeType instanceof CubicBezierEdge && smooth.enabled === true && smooth.type === \"cubicBezier\" || this.edgeType instanceof BezierEdgeStatic && smooth.enabled === true && smooth.type !== \"dynamic\" && smooth.type !== \"cubicBezier\" || this.edgeType instanceof StraightEdge && smooth.type.enabled === false) {\n          changeInType = false;\n        }\n        if (changeInType === true) {\n          dataChanged = this.cleanup();\n        }\n      }\n      if (changeInType === true) {\n        if (smooth.enabled === true) {\n          if (smooth.type === \"dynamic\") {\n            dataChanged = true;\n            this.edgeType = new BezierEdgeDynamic(this.options, this.body, this.labelModule);\n          } else if (smooth.type === \"cubicBezier\") {\n            this.edgeType = new CubicBezierEdge(this.options, this.body, this.labelModule);\n          } else {\n            this.edgeType = new BezierEdgeStatic(this.options, this.body, this.labelModule);\n          }\n        } else {\n          this.edgeType = new StraightEdge(this.options, this.body, this.labelModule);\n        }\n      } else {\n        // if nothing changes, we just set the options.\n        this.edgeType.setOptions(this.options);\n      }\n      return dataChanged;\n    }\n\n    /**\n     * Connect an edge to its nodes\n     */\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      this.disconnect();\n      this.from = this.body.nodes[this.fromId] || undefined;\n      this.to = this.body.nodes[this.toId] || undefined;\n      this.connected = this.from !== undefined && this.to !== undefined;\n      if (this.connected === true) {\n        this.from.attachEdge(this);\n        this.to.attachEdge(this);\n      } else {\n        if (this.from) {\n          this.from.detachEdge(this);\n        }\n        if (this.to) {\n          this.to.detachEdge(this);\n        }\n      }\n      this.edgeType.connect();\n    }\n\n    /**\n     * Disconnect an edge from its nodes\n     */\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (this.from) {\n        this.from.detachEdge(this);\n        this.from = undefined;\n      }\n      if (this.to) {\n        this.to.detachEdge(this);\n        this.to = undefined;\n      }\n      this.connected = false;\n    }\n\n    /**\n     * get the title of this edge.\n     *\n     * @returns {string} title    The title of the edge, or undefined when no title\n     *                           has been set.\n     */\n  }, {\n    key: \"getTitle\",\n    value: function getTitle() {\n      return this.title;\n    }\n\n    /**\n     * check if this node is selecte\n     *\n     * @returns {boolean} selected   True if node is selected, else false\n     */\n  }, {\n    key: \"isSelected\",\n    value: function isSelected() {\n      return this.selected;\n    }\n\n    /**\n     * Retrieve the value of the edge. Can be undefined\n     *\n     * @returns {number} value\n     */\n  }, {\n    key: \"getValue\",\n    value: function getValue() {\n      return this.options.value;\n    }\n\n    /**\n     * Adjust the value range of the edge. The edge will adjust it's width\n     * based on its value.\n     *\n     * @param {number} min\n     * @param {number} max\n     * @param {number} total\n     */\n  }, {\n    key: \"setValueRange\",\n    value: function setValueRange(min, max, total) {\n      if (this.options.value !== undefined) {\n        var scale = this.options.scaling.customScalingFunction(min, max, total, this.options.value);\n        var widthDiff = this.options.scaling.max - this.options.scaling.min;\n        if (this.options.scaling.label.enabled === true) {\n          var fontDiff = this.options.scaling.label.max - this.options.scaling.label.min;\n          this.options.font.size = this.options.scaling.label.min + scale * fontDiff;\n        }\n        this.options.width = this.options.scaling.min + scale * widthDiff;\n      } else {\n        this.options.width = this.baseWidth;\n        this.options.font.size = this.baseFontSize;\n      }\n      this._setInteractionWidths();\n      this.updateLabelModule();\n    }\n\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_setInteractionWidths\",\n    value: function _setInteractionWidths() {\n      if (typeof this.options.hoverWidth === \"function\") {\n        this.edgeType.hoverWidth = this.options.hoverWidth(this.options.width);\n      } else {\n        this.edgeType.hoverWidth = this.options.hoverWidth + this.options.width;\n      }\n      if (typeof this.options.selectionWidth === \"function\") {\n        this.edgeType.selectionWidth = this.options.selectionWidth(this.options.width);\n      } else {\n        this.edgeType.selectionWidth = this.options.selectionWidth + this.options.width;\n      }\n    }\n\n    /**\n     * Redraw a edge\n     * Draw this edge in the given canvas\n     * The 2d context of a HTML canvas can be retrieved by canvas.getContext(\"2d\");\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     */\n  }, {\n    key: \"draw\",\n    value: function draw(ctx) {\n      var values = this.getFormattingValues();\n      if (values.hidden) {\n        return;\n      }\n\n      // get the via node from the edge type\n      var viaNode = this.edgeType.getViaNode();\n\n      // draw line and label\n      this.edgeType.drawLine(ctx, values, this.selected, this.hover, viaNode);\n      this.drawLabel(ctx, viaNode);\n    }\n\n    /**\n     * Redraw arrows\n     * Draw this arrows in the given canvas\n     * The 2d context of a HTML canvas can be retrieved by canvas.getContext(\"2d\");\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     */\n  }, {\n    key: \"drawArrows\",\n    value: function drawArrows(ctx) {\n      var values = this.getFormattingValues();\n      if (values.hidden) {\n        return;\n      }\n\n      // get the via node from the edge type\n      var viaNode = this.edgeType.getViaNode();\n      var arrowData = {};\n\n      // restore edge targets to defaults\n      this.edgeType.fromPoint = this.edgeType.from;\n      this.edgeType.toPoint = this.edgeType.to;\n\n      // from and to arrows give a different end point for edges. we set them here\n      if (values.fromArrow) {\n        arrowData.from = this.edgeType.getArrowData(ctx, \"from\", viaNode, this.selected, this.hover, values);\n        if (values.arrowStrikethrough === false) this.edgeType.fromPoint = arrowData.from.core;\n        if (values.fromArrowSrc) {\n          arrowData.from.image = this.imagelist.load(values.fromArrowSrc);\n        }\n        if (values.fromArrowImageWidth) {\n          arrowData.from.imageWidth = values.fromArrowImageWidth;\n        }\n        if (values.fromArrowImageHeight) {\n          arrowData.from.imageHeight = values.fromArrowImageHeight;\n        }\n      }\n      if (values.toArrow) {\n        arrowData.to = this.edgeType.getArrowData(ctx, \"to\", viaNode, this.selected, this.hover, values);\n        if (values.arrowStrikethrough === false) this.edgeType.toPoint = arrowData.to.core;\n        if (values.toArrowSrc) {\n          arrowData.to.image = this.imagelist.load(values.toArrowSrc);\n        }\n        if (values.toArrowImageWidth) {\n          arrowData.to.imageWidth = values.toArrowImageWidth;\n        }\n        if (values.toArrowImageHeight) {\n          arrowData.to.imageHeight = values.toArrowImageHeight;\n        }\n      }\n\n      // the middle arrow depends on the line, which can depend on the to and from arrows so we do this one lastly.\n      if (values.middleArrow) {\n        arrowData.middle = this.edgeType.getArrowData(ctx, \"middle\", viaNode, this.selected, this.hover, values);\n        if (values.middleArrowSrc) {\n          arrowData.middle.image = this.imagelist.load(values.middleArrowSrc);\n        }\n        if (values.middleArrowImageWidth) {\n          arrowData.middle.imageWidth = values.middleArrowImageWidth;\n        }\n        if (values.middleArrowImageHeight) {\n          arrowData.middle.imageHeight = values.middleArrowImageHeight;\n        }\n      }\n      if (values.fromArrow) {\n        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.from);\n      }\n      if (values.middleArrow) {\n        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.middle);\n      }\n      if (values.toArrow) {\n        this.edgeType.drawArrowHead(ctx, values, this.selected, this.hover, arrowData.to);\n      }\n    }\n\n    /**\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {Node} viaNode\n     */\n  }, {\n    key: \"drawLabel\",\n    value: function drawLabel(ctx, viaNode) {\n      if (this.options.label !== undefined) {\n        // set style\n        var node1 = this.from;\n        var node2 = this.to;\n        if (this.labelModule.differentState(this.selected, this.hover)) {\n          this.labelModule.getTextSize(ctx, this.selected, this.hover);\n        }\n        var point;\n        if (node1.id != node2.id) {\n          this.labelModule.pointToSelf = false;\n          point = this.edgeType.getPoint(0.5, viaNode);\n          ctx.save();\n          var rotationPoint = this._getRotation(ctx);\n          if (rotationPoint.angle != 0) {\n            ctx.translate(rotationPoint.x, rotationPoint.y);\n            ctx.rotate(rotationPoint.angle);\n          }\n\n          // draw the label\n          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);\n\n          /*\n          // Useful debug code: draw a border around the label\n          // This should **not** be enabled in production!\n          var size = this.labelModule.getSize();; // ;; intentional so lint catches it\n          ctx.strokeStyle = \"#ff0000\";\n          ctx.strokeRect(size.left, size.top, size.width, size.height);\n          // End  debug code\n          */\n\n          ctx.restore();\n        } else {\n          // Ignore the orientations.\n          this.labelModule.pointToSelf = true;\n\n          // get circle coordinates\n          var coordinates = getSelfRefCoordinates(ctx, this.options.selfReference.angle, this.options.selfReference.size, node1);\n          point = this._pointOnCircle(coordinates.x, coordinates.y, this.options.selfReference.size, this.options.selfReference.angle);\n          this.labelModule.draw(ctx, point.x, point.y, this.selected, this.hover);\n        }\n      }\n    }\n\n    /**\n     * Determine all visual elements of this edge instance, in which the given\n     * point falls within the bounding shape.\n     *\n     * @param {point} point\n     * @returns {Array.<edgeClickItem|edgeLabelClickItem>} list with the items which are on the point\n     */\n  }, {\n    key: \"getItemsOnPoint\",\n    value: function getItemsOnPoint(point) {\n      var ret = [];\n      if (this.labelModule.visible()) {\n        var rotationPoint = this._getRotation();\n        if (pointInRect(this.labelModule.getSize(), point, rotationPoint)) {\n          ret.push({\n            edgeId: this.id,\n            labelId: 0\n          });\n        }\n      }\n      var obj = {\n        left: point.x,\n        top: point.y\n      };\n      if (this.isOverlappingWith(obj)) {\n        ret.push({\n          edgeId: this.id\n        });\n      }\n      return ret;\n    }\n\n    /**\n     * Check if this object is overlapping with the provided object\n     *\n     * @param {object} obj   an object with parameters left, top\n     * @returns {boolean}     True if location is located on the edge\n     */\n  }, {\n    key: \"isOverlappingWith\",\n    value: function isOverlappingWith(obj) {\n      if (this.connected) {\n        var distMax = 10;\n        var xFrom = this.from.x;\n        var yFrom = this.from.y;\n        var xTo = this.to.x;\n        var yTo = this.to.y;\n        var xObj = obj.left;\n        var yObj = obj.top;\n        var dist = this.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, xObj, yObj);\n        return dist < distMax;\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * Determine the rotation point, if any.\n     *\n     * @param {CanvasRenderingContext2D} [ctx] if passed, do a recalculation of the label size\n     * @returns {rotationPoint} the point to rotate around and the angle in radians to rotate\n     * @private\n     */\n  }, {\n    key: \"_getRotation\",\n    value: function _getRotation(ctx) {\n      var viaNode = this.edgeType.getViaNode();\n      var point = this.edgeType.getPoint(0.5, viaNode);\n      if (ctx !== undefined) {\n        this.labelModule.calculateLabelSize(ctx, this.selected, this.hover, point.x, point.y);\n      }\n      var ret = {\n        x: point.x,\n        y: this.labelModule.size.yLine,\n        angle: 0\n      };\n      if (!this.labelModule.visible()) {\n        return ret; // Don't even bother doing the atan2, there's nothing to draw\n      }\n\n      if (this.options.font.align === \"horizontal\") {\n        return ret; // No need to calculate angle\n      }\n\n      var dy = this.from.y - this.to.y;\n      var dx = this.from.x - this.to.x;\n      var angle = Math.atan2(dy, dx); // radians\n\n      // rotate so that label is readable\n      if (angle < -1 && dx < 0 || angle > 0 && dx < 0) {\n        angle += Math.PI;\n      }\n      ret.angle = angle;\n      return ret;\n    }\n\n    /**\n     * Get a point on a circle\n     *\n     * @param {number} x\n     * @param {number} y\n     * @param {number} radius\n     * @param {number} angle\n     * @returns {object} point\n     * @private\n     */\n  }, {\n    key: \"_pointOnCircle\",\n    value: function _pointOnCircle(x, y, radius, angle) {\n      return {\n        x: x + radius * Math.cos(angle),\n        y: y - radius * Math.sin(angle)\n      };\n    }\n\n    /**\n     * Sets selected state to true\n     */\n  }, {\n    key: \"select\",\n    value: function select() {\n      this.selected = true;\n    }\n\n    /**\n     * Sets selected state to false\n     */\n  }, {\n    key: \"unselect\",\n    value: function unselect() {\n      this.selected = false;\n    }\n\n    /**\n     * cleans all required things on delete\n     *\n     * @returns {*}\n     */\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      return this.edgeType.cleanup();\n    }\n\n    /**\n     * Remove edge from the list and perform necessary cleanup.\n     */\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      this.cleanup();\n      this.disconnect();\n      delete this.body.edges[this.id];\n    }\n\n    /**\n     * Check if both connecting nodes exist\n     *\n     * @returns {boolean}\n     */\n  }, {\n    key: \"endPointsValid\",\n    value: function endPointsValid() {\n      return this.body.nodes[this.fromId] !== undefined && this.body.nodes[this.toId] !== undefined;\n    }\n  }], [{\n    key: \"parseOptions\",\n    value: function parseOptions(parentOptions, newOptions) {\n      var allowDeletion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var globalOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var copyFromGlobals = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var fields = [\"endPointOffset\", \"arrowStrikethrough\", \"id\", \"from\", \"hidden\", \"hoverWidth\", \"labelHighlightBold\", \"length\", \"line\", \"opacity\", \"physics\", \"scaling\", \"selectionWidth\", \"selfReferenceSize\", \"selfReference\", \"to\", \"title\", \"value\", \"width\", \"font\", \"chosen\", \"widthConstraint\"];\n\n      // only deep extend the items in the field array. These do not have shorthand.\n      selectiveDeepExtend(fields, parentOptions, newOptions, allowDeletion);\n\n      // Only use endPointOffset values (from and to) if it's valid values\n      if (newOptions.endPointOffset !== undefined && newOptions.endPointOffset.from !== undefined) {\n        if (_Number$isFinite(newOptions.endPointOffset.from)) {\n          parentOptions.endPointOffset.from = newOptions.endPointOffset.from;\n        } else {\n          parentOptions.endPointOffset.from = globalOptions.endPointOffset.from !== undefined ? globalOptions.endPointOffset.from : 0;\n          console.error(\"endPointOffset.from is not a valid number\");\n        }\n      }\n      if (newOptions.endPointOffset !== undefined && newOptions.endPointOffset.to !== undefined) {\n        if (_Number$isFinite(newOptions.endPointOffset.to)) {\n          parentOptions.endPointOffset.to = newOptions.endPointOffset.to;\n        } else {\n          parentOptions.endPointOffset.to = globalOptions.endPointOffset.to !== undefined ? globalOptions.endPointOffset.to : 0;\n          console.error(\"endPointOffset.to is not a valid number\");\n        }\n      }\n\n      // Only copy label if it's a legal value.\n      if (isValidLabel(newOptions.label)) {\n        parentOptions.label = newOptions.label;\n      } else if (!isValidLabel(parentOptions.label)) {\n        parentOptions.label = undefined;\n      }\n      mergeOptions(parentOptions, newOptions, \"smooth\", globalOptions);\n      mergeOptions(parentOptions, newOptions, \"shadow\", globalOptions);\n      mergeOptions(parentOptions, newOptions, \"background\", globalOptions);\n      if (newOptions.dashes !== undefined && newOptions.dashes !== null) {\n        parentOptions.dashes = newOptions.dashes;\n      } else if (allowDeletion === true && newOptions.dashes === null) {\n        parentOptions.dashes = _Object$create$1(globalOptions.dashes); // this sets the pointer of the option back to the global option.\n      }\n\n      // set the scaling newOptions\n      if (newOptions.scaling !== undefined && newOptions.scaling !== null) {\n        if (newOptions.scaling.min !== undefined) {\n          parentOptions.scaling.min = newOptions.scaling.min;\n        }\n        if (newOptions.scaling.max !== undefined) {\n          parentOptions.scaling.max = newOptions.scaling.max;\n        }\n        mergeOptions(parentOptions.scaling, newOptions.scaling, \"label\", globalOptions.scaling);\n      } else if (allowDeletion === true && newOptions.scaling === null) {\n        parentOptions.scaling = _Object$create$1(globalOptions.scaling); // this sets the pointer of the option back to the global option.\n      }\n\n      // handle multiple input cases for arrows\n      if (newOptions.arrows !== undefined && newOptions.arrows !== null) {\n        if (typeof newOptions.arrows === \"string\") {\n          var arrows = newOptions.arrows.toLowerCase();\n          parentOptions.arrows.to.enabled = _indexOfInstanceProperty(arrows).call(arrows, \"to\") != -1;\n          parentOptions.arrows.middle.enabled = _indexOfInstanceProperty(arrows).call(arrows, \"middle\") != -1;\n          parentOptions.arrows.from.enabled = _indexOfInstanceProperty(arrows).call(arrows, \"from\") != -1;\n        } else if (_typeof(newOptions.arrows) === \"object\") {\n          mergeOptions(parentOptions.arrows, newOptions.arrows, \"to\", globalOptions.arrows);\n          mergeOptions(parentOptions.arrows, newOptions.arrows, \"middle\", globalOptions.arrows);\n          mergeOptions(parentOptions.arrows, newOptions.arrows, \"from\", globalOptions.arrows);\n        } else {\n          throw new Error(\"The arrow newOptions can only be an object or a string. Refer to the documentation. You used:\" + _JSON$stringify(newOptions.arrows));\n        }\n      } else if (allowDeletion === true && newOptions.arrows === null) {\n        parentOptions.arrows = _Object$create$1(globalOptions.arrows); // this sets the pointer of the option back to the global option.\n      }\n\n      // handle multiple input cases for color\n      if (newOptions.color !== undefined && newOptions.color !== null) {\n        var fromColor = isString(newOptions.color) ? {\n          color: newOptions.color,\n          highlight: newOptions.color,\n          hover: newOptions.color,\n          inherit: false,\n          opacity: 1\n        } : newOptions.color;\n        var toColor = parentOptions.color;\n\n        // If passed, fill in values from default options - required in the case of no prototype bridging\n        if (copyFromGlobals) {\n          deepExtend(toColor, globalOptions.color, false, allowDeletion);\n        } else {\n          // Clear local properties - need to do it like this in order to retain prototype bridges\n          for (var i in toColor) {\n            if (Object.prototype.hasOwnProperty.call(toColor, i)) {\n              delete toColor[i];\n            }\n          }\n        }\n        if (isString(toColor)) {\n          toColor.color = toColor;\n          toColor.highlight = toColor;\n          toColor.hover = toColor;\n          toColor.inherit = false;\n          if (fromColor.opacity === undefined) {\n            toColor.opacity = 1.0; // set default\n          }\n        } else {\n          var colorsDefined = false;\n          if (fromColor.color !== undefined) {\n            toColor.color = fromColor.color;\n            colorsDefined = true;\n          }\n          if (fromColor.highlight !== undefined) {\n            toColor.highlight = fromColor.highlight;\n            colorsDefined = true;\n          }\n          if (fromColor.hover !== undefined) {\n            toColor.hover = fromColor.hover;\n            colorsDefined = true;\n          }\n          if (fromColor.inherit !== undefined) {\n            toColor.inherit = fromColor.inherit;\n          }\n          if (fromColor.opacity !== undefined) {\n            toColor.opacity = Math.min(1, Math.max(0, fromColor.opacity));\n          }\n          if (colorsDefined === true) {\n            toColor.inherit = false;\n          } else {\n            if (toColor.inherit === undefined) {\n              toColor.inherit = \"from\"; // Set default\n            }\n          }\n        }\n      } else if (allowDeletion === true && newOptions.color === null) {\n        parentOptions.color = bridgeObject(globalOptions.color); // set the object back to the global options\n      }\n\n      if (allowDeletion === true && newOptions.font === null) {\n        parentOptions.font = bridgeObject(globalOptions.font); // set the object back to the global options\n      }\n\n      if (Object.prototype.hasOwnProperty.call(newOptions, \"selfReferenceSize\")) {\n        console.warn(\"The selfReferenceSize property has been deprecated. Please use selfReference property instead. The selfReference can be set like thise selfReference:{size:30, angle:Math.PI / 4}\");\n        parentOptions.selfReference.size = newOptions.selfReferenceSize;\n      }\n    }\n  }]);\n  return Edge;\n}();\n\n/**\n * Handler for Edges\n */\nvar EdgesHandler = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Array.<Image>} images\n   * @param {Array.<Group>} groups\n   */\n  function EdgesHandler(body, images, groups) {\n    var _context,\n      _this = this;\n    _classCallCheck(this, EdgesHandler);\n    this.body = body;\n    this.images = images;\n    this.groups = groups;\n\n    // create the edge API in the body container\n    this.body.functions.createEdge = _bindInstanceProperty$1(_context = this.create).call(_context, this);\n    this.edgesListeners = {\n      add: function add(event, params) {\n        _this.add(params.items);\n      },\n      update: function update(event, params) {\n        _this.update(params.items);\n      },\n      remove: function remove(event, params) {\n        _this.remove(params.items);\n      }\n    };\n    this.options = {};\n    this.defaultOptions = {\n      arrows: {\n        to: {\n          enabled: false,\n          scaleFactor: 1,\n          type: \"arrow\"\n        },\n        // boolean / {arrowScaleFactor:1} / {enabled: false, arrowScaleFactor:1}\n        middle: {\n          enabled: false,\n          scaleFactor: 1,\n          type: \"arrow\"\n        },\n        from: {\n          enabled: false,\n          scaleFactor: 1,\n          type: \"arrow\"\n        }\n      },\n      endPointOffset: {\n        from: 0,\n        to: 0\n      },\n      arrowStrikethrough: true,\n      color: {\n        color: \"#848484\",\n        highlight: \"#848484\",\n        hover: \"#848484\",\n        inherit: \"from\",\n        opacity: 1.0\n      },\n      dashes: false,\n      font: {\n        color: \"#343434\",\n        size: 14,\n        // px\n        face: \"arial\",\n        background: \"none\",\n        strokeWidth: 2,\n        // px\n        strokeColor: \"#ffffff\",\n        align: \"horizontal\",\n        multi: false,\n        vadjust: 0,\n        bold: {\n          mod: \"bold\"\n        },\n        boldital: {\n          mod: \"bold italic\"\n        },\n        ital: {\n          mod: \"italic\"\n        },\n        mono: {\n          mod: \"\",\n          size: 15,\n          // px\n          face: \"courier new\",\n          vadjust: 2\n        }\n      },\n      hidden: false,\n      hoverWidth: 1.5,\n      label: undefined,\n      labelHighlightBold: true,\n      length: undefined,\n      physics: true,\n      scaling: {\n        min: 1,\n        max: 15,\n        label: {\n          enabled: true,\n          min: 14,\n          max: 30,\n          maxVisible: 30,\n          drawThreshold: 5\n        },\n        customScalingFunction: function customScalingFunction(min, max, total, value) {\n          if (max === min) {\n            return 0.5;\n          } else {\n            var scale = 1 / (max - min);\n            return Math.max(0, (value - min) * scale);\n          }\n        }\n      },\n      selectionWidth: 1.5,\n      selfReference: {\n        size: 20,\n        angle: Math.PI / 4,\n        renderBehindTheNode: true\n      },\n      shadow: {\n        enabled: false,\n        color: \"rgba(0,0,0,0.5)\",\n        size: 10,\n        x: 5,\n        y: 5\n      },\n      background: {\n        enabled: false,\n        color: \"rgba(111,111,111,1)\",\n        size: 10,\n        dashes: false\n      },\n      smooth: {\n        enabled: true,\n        type: \"dynamic\",\n        forceDirection: \"none\",\n        roundness: 0.5\n      },\n      title: undefined,\n      width: 1,\n      value: undefined\n    };\n    deepExtend(this.options, this.defaultOptions);\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n  _createClass(EdgesHandler, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this2 = this,\n        _context2,\n        _context3;\n      // this allows external modules to force all dynamic curves to turn static.\n      this.body.emitter.on(\"_forceDisableDynamicCurves\", function (type) {\n        var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        if (type === \"dynamic\") {\n          type = \"continuous\";\n        }\n        var dataChanged = false;\n        for (var edgeId in _this2.body.edges) {\n          if (Object.prototype.hasOwnProperty.call(_this2.body.edges, edgeId)) {\n            var edge = _this2.body.edges[edgeId];\n            var edgeData = _this2.body.data.edges.get(edgeId);\n\n            // only forcibly remove the smooth curve if the data has been set of the edge has the smooth curves defined.\n            // this is because a change in the global would not affect these curves.\n            if (edgeData != null) {\n              var smoothOptions = edgeData.smooth;\n              if (smoothOptions !== undefined) {\n                if (smoothOptions.enabled === true && smoothOptions.type === \"dynamic\") {\n                  if (type === undefined) {\n                    edge.setOptions({\n                      smooth: false\n                    });\n                  } else {\n                    edge.setOptions({\n                      smooth: {\n                        type: type\n                      }\n                    });\n                  }\n                  dataChanged = true;\n                }\n              }\n            }\n          }\n        }\n        if (emit === true && dataChanged === true) {\n          _this2.body.emitter.emit(\"_dataChanged\");\n        }\n      });\n\n      // this is called when options of EXISTING nodes or edges have changed.\n      //\n      // NOTE: Not true, called when options have NOT changed, for both existing as well as new nodes.\n      //       See update() for logic.\n      // TODO: Verify and examine the consequences of this. It might still trigger when\n      //       non-option fields have changed, but then reconnecting edges is still useless.\n      //       Alternatively, it might also be called when edges are removed.\n      //\n      this.body.emitter.on(\"_dataUpdated\", function () {\n        _this2.reconnectEdges();\n      });\n\n      // refresh the edges. Used when reverting from hierarchical layout\n      this.body.emitter.on(\"refreshEdges\", _bindInstanceProperty$1(_context2 = this.refresh).call(_context2, this));\n      this.body.emitter.on(\"refresh\", _bindInstanceProperty$1(_context3 = this.refresh).call(_context3, this));\n      this.body.emitter.on(\"destroy\", function () {\n        forEach$1(_this2.edgesListeners, function (callback, event) {\n          if (_this2.body.data.edges) _this2.body.data.edges.off(event, callback);\n        });\n        delete _this2.body.functions.createEdge;\n        delete _this2.edgesListeners.add;\n        delete _this2.edgesListeners.update;\n        delete _this2.edgesListeners.remove;\n        delete _this2.edgesListeners;\n      });\n    }\n\n    /**\n     *\n     * @param {object} options\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        // use the parser from the Edge class to fill in all shorthand notations\n        Edge.parseOptions(this.options, options, true, this.defaultOptions, true);\n\n        // update smooth settings in all edges\n        var dataChanged = false;\n        if (options.smooth !== undefined) {\n          for (var edgeId in this.body.edges) {\n            if (Object.prototype.hasOwnProperty.call(this.body.edges, edgeId)) {\n              dataChanged = this.body.edges[edgeId].updateEdgeType() || dataChanged;\n            }\n          }\n        }\n\n        // update fonts in all edges\n        if (options.font !== undefined) {\n          for (var _edgeId in this.body.edges) {\n            if (Object.prototype.hasOwnProperty.call(this.body.edges, _edgeId)) {\n              this.body.edges[_edgeId].updateLabelModule();\n            }\n          }\n        }\n\n        // update the state of the variables if needed\n        if (options.hidden !== undefined || options.physics !== undefined || dataChanged === true) {\n          this.body.emitter.emit(\"_dataChanged\");\n        }\n      }\n    }\n\n    /**\n     * Load edges by reading the data table\n     *\n     * @param {Array | DataSet | DataView} edges    The data containing the edges.\n     * @param {boolean} [doNotEmit=false] - Suppress data changed event.\n     * @private\n     */\n  }, {\n    key: \"setData\",\n    value: function setData(edges) {\n      var _this3 = this;\n      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var oldEdgesData = this.body.data.edges;\n      if ((0,vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.isDataViewLike)(\"id\", edges)) {\n        this.body.data.edges = edges;\n      } else if (_Array$isArray(edges)) {\n        this.body.data.edges = new vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.DataSet();\n        this.body.data.edges.add(edges);\n      } else if (!edges) {\n        this.body.data.edges = new vis_data_peer_esm_vis_data_js__WEBPACK_IMPORTED_MODULE_0__.DataSet();\n      } else {\n        throw new TypeError(\"Array or DataSet expected\");\n      }\n\n      // TODO: is this null or undefined or false?\n      if (oldEdgesData) {\n        // unsubscribe from old dataset\n        forEach$1(this.edgesListeners, function (callback, event) {\n          oldEdgesData.off(event, callback);\n        });\n      }\n\n      // remove drawn edges\n      this.body.edges = {};\n\n      // TODO: is this null or undefined or false?\n      if (this.body.data.edges) {\n        // subscribe to new dataset\n        forEach$1(this.edgesListeners, function (callback, event) {\n          _this3.body.data.edges.on(event, callback);\n        });\n\n        // draw all new nodes\n        var ids = this.body.data.edges.getIds();\n        this.add(ids, true);\n      }\n      this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\");\n      if (doNotEmit === false) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n\n    /**\n     * Add edges\n     *\n     * @param {number[] | string[]} ids\n     * @param {boolean} [doNotEmit=false]\n     * @private\n     */\n  }, {\n    key: \"add\",\n    value: function add(ids) {\n      var doNotEmit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var edges = this.body.edges;\n      var edgesData = this.body.data.edges;\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        var oldEdge = edges[id];\n        if (oldEdge) {\n          oldEdge.disconnect();\n        }\n        var data = edgesData.get(id, {\n          showInternalIds: true\n        });\n        edges[id] = this.create(data);\n      }\n      this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\");\n      if (doNotEmit === false) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n\n    /**\n     * Update existing edges, or create them when not yet existing\n     *\n     * @param {number[] | string[]} ids\n     * @private\n     */\n  }, {\n    key: \"update\",\n    value: function update(ids) {\n      var edges = this.body.edges;\n      var edgesData = this.body.data.edges;\n      var dataChanged = false;\n      for (var i = 0; i < ids.length; i++) {\n        var id = ids[i];\n        var data = edgesData.get(id);\n        var edge = edges[id];\n        if (edge !== undefined) {\n          // update edge\n          edge.disconnect();\n          dataChanged = edge.setOptions(data) || dataChanged; // if a support node is added, data can be changed.\n          edge.connect();\n        } else {\n          // create edge\n          this.body.edges[id] = this.create(data);\n          dataChanged = true;\n        }\n      }\n      if (dataChanged === true) {\n        this.body.emitter.emit(\"_adjustEdgesForHierarchicalLayout\");\n        this.body.emitter.emit(\"_dataChanged\");\n      } else {\n        this.body.emitter.emit(\"_dataUpdated\");\n      }\n    }\n\n    /**\n     * Remove existing edges. Non existing ids will be ignored\n     *\n     * @param {number[] | string[]} ids\n     * @param {boolean} [emit=true]\n     * @private\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(ids) {\n      var emit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (ids.length === 0) return; // early out\n\n      var edges = this.body.edges;\n      forEach$1(ids, function (id) {\n        var edge = edges[id];\n        if (edge !== undefined) {\n          edge.remove();\n        }\n      });\n      if (emit) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n\n    /**\n     * Refreshes Edge Handler\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var _this4 = this;\n      forEach$1(this.body.edges, function (edge, edgeId) {\n        var data = _this4.body.data.edges.get(edgeId);\n        if (data !== undefined) {\n          edge.setOptions(data);\n        }\n      });\n    }\n\n    /**\n     *\n     * @param {object} properties\n     * @returns {Edge}\n     */\n  }, {\n    key: \"create\",\n    value: function create(properties) {\n      return new Edge(properties, this.body, this.images, this.options, this.defaultOptions);\n    }\n\n    /**\n     * Reconnect all edges\n     *\n     * @private\n     */\n  }, {\n    key: \"reconnectEdges\",\n    value: function reconnectEdges() {\n      var id;\n      var nodes = this.body.nodes;\n      var edges = this.body.edges;\n      for (id in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, id)) {\n          nodes[id].edges = [];\n        }\n      }\n      for (id in edges) {\n        if (Object.prototype.hasOwnProperty.call(edges, id)) {\n          var edge = edges[id];\n          edge.from = null;\n          edge.to = null;\n          edge.connect();\n        }\n      }\n    }\n\n    /**\n     *\n     * @param {Edge.id} edgeId\n     * @returns {Array}\n     */\n  }, {\n    key: \"getConnectedNodes\",\n    value: function getConnectedNodes(edgeId) {\n      var nodeList = [];\n      if (this.body.edges[edgeId] !== undefined) {\n        var edge = this.body.edges[edgeId];\n        if (edge.fromId !== undefined) {\n          nodeList.push(edge.fromId);\n        }\n        if (edge.toId !== undefined) {\n          nodeList.push(edge.toId);\n        }\n      }\n      return nodeList;\n    }\n\n    /**\n     * There is no direct relation between the nodes and the edges DataSet,\n     * so the right place to do call this is in the handler for event `_dataUpdated`.\n     */\n  }, {\n    key: \"_updateState\",\n    value: function _updateState() {\n      this._addMissingEdges();\n      this._removeInvalidEdges();\n    }\n\n    /**\n     * Scan for missing nodes and remove corresponding edges, if any.\n     *\n     * @private\n     */\n  }, {\n    key: \"_removeInvalidEdges\",\n    value: function _removeInvalidEdges() {\n      var _this5 = this;\n      var edgesToDelete = [];\n      forEach$1(this.body.edges, function (edge, id) {\n        var toNode = _this5.body.nodes[edge.toId];\n        var fromNode = _this5.body.nodes[edge.fromId];\n\n        // Skip clustering edges here, let the Clustering module handle those\n        if (toNode !== undefined && toNode.isCluster === true || fromNode !== undefined && fromNode.isCluster === true) {\n          return;\n        }\n        if (toNode === undefined || fromNode === undefined) {\n          edgesToDelete.push(id);\n        }\n      });\n      this.remove(edgesToDelete, false);\n    }\n\n    /**\n     * add all edges from dataset that are not in the cached state\n     *\n     * @private\n     */\n  }, {\n    key: \"_addMissingEdges\",\n    value: function _addMissingEdges() {\n      var edgesData = this.body.data.edges;\n      if (edgesData === undefined || edgesData === null) {\n        return; // No edges DataSet yet; can happen on startup\n      }\n\n      var edges = this.body.edges;\n      var addIds = [];\n      _forEachInstanceProperty(edgesData).call(edgesData, function (edgeData, edgeId) {\n        var edge = edges[edgeId];\n        if (edge === undefined) {\n          addIds.push(edgeId);\n        }\n      });\n      this.add(addIds, true);\n    }\n  }]);\n  return EdgesHandler;\n}();\n\n/**\n * Barnes Hut Solver\n */\nvar BarnesHutSolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function BarnesHutSolver(body, physicsBody, options) {\n    _classCallCheck(this, BarnesHutSolver);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.barnesHutTree;\n    this.setOptions(options);\n    this._rng = Alea(\"BARNES HUT SOLVER\");\n\n    // debug: show grid\n    // this.body.emitter.on(\"afterDrawing\", (ctx) => {this._debug(ctx,'#ff0000')})\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(BarnesHutSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n      this.thetaInversed = 1 / this.options.theta;\n\n      // if 1 then min distance = 0.5, if 0.5 then min distance = 0.5 + 0.5*node.shape.radius\n      this.overlapAvoidanceFactor = 1 - Math.max(0, Math.min(1, this.options.avoidOverlap));\n    }\n\n    /**\n     * This function calculates the forces the nodes apply on each other based on a gravitational model.\n     * The Barnes Hut method is used to speed up this N-body simulation.\n     *\n     * @private\n     */\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      if (this.options.gravitationalConstant !== 0 && this.physicsBody.physicsNodeIndices.length > 0) {\n        var node;\n        var nodes = this.body.nodes;\n        var nodeIndices = this.physicsBody.physicsNodeIndices;\n        var nodeCount = nodeIndices.length;\n\n        // create the tree\n        var barnesHutTree = this._formBarnesHutTree(nodes, nodeIndices);\n\n        // for debugging\n        this.barnesHutTree = barnesHutTree;\n\n        // place the nodes one by one recursively\n        for (var i = 0; i < nodeCount; i++) {\n          node = nodes[nodeIndices[i]];\n          if (node.options.mass > 0) {\n            // starting with root is irrelevant, it never passes the BarnesHutSolver condition\n            this._getForceContributions(barnesHutTree.root, node);\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {object} parentBranch\n     * @param {Node} node\n     * @private\n     */\n  }, {\n    key: \"_getForceContributions\",\n    value: function _getForceContributions(parentBranch, node) {\n      this._getForceContribution(parentBranch.children.NW, node);\n      this._getForceContribution(parentBranch.children.NE, node);\n      this._getForceContribution(parentBranch.children.SW, node);\n      this._getForceContribution(parentBranch.children.SE, node);\n    }\n\n    /**\n     * This function traverses the barnesHutTree. It checks when it can approximate distant nodes with their center of mass.\n     * If a region contains a single node, we check if it is not itself, then we apply the force.\n     *\n     * @param {object} parentBranch\n     * @param {Node} node\n     * @private\n     */\n  }, {\n    key: \"_getForceContribution\",\n    value: function _getForceContribution(parentBranch, node) {\n      // we get no force contribution from an empty region\n      if (parentBranch.childrenCount > 0) {\n        // get the distance from the center of mass to the node.\n        var dx = parentBranch.centerOfMass.x - node.x;\n        var dy = parentBranch.centerOfMass.y - node.y;\n        var distance = Math.sqrt(dx * dx + dy * dy);\n\n        // BarnesHutSolver condition\n        // original condition : s/d < theta = passed  ===  d/s > 1/theta = passed\n        // calcSize = 1/s --> d * 1/s > 1/theta = passed\n        if (distance * parentBranch.calcSize > this.thetaInversed) {\n          this._calculateForces(distance, dx, dy, node, parentBranch);\n        } else {\n          // Did not pass the condition, go into children if available\n          if (parentBranch.childrenCount === 4) {\n            this._getForceContributions(parentBranch, node);\n          } else {\n            // parentBranch must have only one node, if it was empty we wouldnt be here\n            if (parentBranch.children.data.id != node.id) {\n              // if it is not self\n              this._calculateForces(distance, dx, dy, node, parentBranch);\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * Calculate the forces based on the distance.\n     *\n     * @param {number} distance\n     * @param {number} dx\n     * @param {number} dy\n     * @param {Node} node\n     * @param {object} parentBranch\n     * @private\n     */\n  }, {\n    key: \"_calculateForces\",\n    value: function _calculateForces(distance, dx, dy, node, parentBranch) {\n      if (distance === 0) {\n        distance = 0.1;\n        dx = distance;\n      }\n      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {\n        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);\n      }\n\n      // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines\n      // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce\n      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass / Math.pow(distance, 3);\n      var fx = dx * gravityForce;\n      var fy = dy * gravityForce;\n      this.physicsBody.forces[node.id].x += fx;\n      this.physicsBody.forces[node.id].y += fy;\n    }\n\n    /**\n     * This function constructs the barnesHut tree recursively. It creates the root, splits it and starts placing the nodes.\n     *\n     * @param {Array.<Node>} nodes\n     * @param {Array.<number>} nodeIndices\n     * @returns {{root: {centerOfMass: {x: number, y: number}, mass: number, range: {minX: number, maxX: number, minY: number, maxY: number}, size: number, calcSize: number, children: {data: null}, maxWidth: number, level: number, childrenCount: number}}} BarnesHutTree\n     * @private\n     */\n  }, {\n    key: \"_formBarnesHutTree\",\n    value: function _formBarnesHutTree(nodes, nodeIndices) {\n      var node;\n      var nodeCount = nodeIndices.length;\n      var minX = nodes[nodeIndices[0]].x;\n      var minY = nodes[nodeIndices[0]].y;\n      var maxX = nodes[nodeIndices[0]].x;\n      var maxY = nodes[nodeIndices[0]].y;\n\n      // get the range of the nodes\n      for (var i = 1; i < nodeCount; i++) {\n        var _node = nodes[nodeIndices[i]];\n        var x = _node.x;\n        var y = _node.y;\n        if (_node.options.mass > 0) {\n          if (x < minX) {\n            minX = x;\n          }\n          if (x > maxX) {\n            maxX = x;\n          }\n          if (y < minY) {\n            minY = y;\n          }\n          if (y > maxY) {\n            maxY = y;\n          }\n        }\n      }\n      // make the range a square\n      var sizeDiff = Math.abs(maxX - minX) - Math.abs(maxY - minY); // difference between X and Y\n      if (sizeDiff > 0) {\n        minY -= 0.5 * sizeDiff;\n        maxY += 0.5 * sizeDiff;\n      } // xSize > ySize\n      else {\n        minX += 0.5 * sizeDiff;\n        maxX -= 0.5 * sizeDiff;\n      } // xSize < ySize\n\n      var minimumTreeSize = 1e-5;\n      var rootSize = Math.max(minimumTreeSize, Math.abs(maxX - minX));\n      var halfRootSize = 0.5 * rootSize;\n      var centerX = 0.5 * (minX + maxX),\n        centerY = 0.5 * (minY + maxY);\n\n      // construct the barnesHutTree\n      var barnesHutTree = {\n        root: {\n          centerOfMass: {\n            x: 0,\n            y: 0\n          },\n          mass: 0,\n          range: {\n            minX: centerX - halfRootSize,\n            maxX: centerX + halfRootSize,\n            minY: centerY - halfRootSize,\n            maxY: centerY + halfRootSize\n          },\n          size: rootSize,\n          calcSize: 1 / rootSize,\n          children: {\n            data: null\n          },\n          maxWidth: 0,\n          level: 0,\n          childrenCount: 4\n        }\n      };\n      this._splitBranch(barnesHutTree.root);\n\n      // place the nodes one by one recursively\n      for (var _i = 0; _i < nodeCount; _i++) {\n        node = nodes[nodeIndices[_i]];\n        if (node.options.mass > 0) {\n          this._placeInTree(barnesHutTree.root, node);\n        }\n      }\n\n      // make global\n      return barnesHutTree;\n    }\n\n    /**\n     * this updates the mass of a branch. this is increased by adding a node.\n     *\n     * @param {object} parentBranch\n     * @param {Node} node\n     * @private\n     */\n  }, {\n    key: \"_updateBranchMass\",\n    value: function _updateBranchMass(parentBranch, node) {\n      var centerOfMass = parentBranch.centerOfMass;\n      var totalMass = parentBranch.mass + node.options.mass;\n      var totalMassInv = 1 / totalMass;\n      centerOfMass.x = centerOfMass.x * parentBranch.mass + node.x * node.options.mass;\n      centerOfMass.x *= totalMassInv;\n      centerOfMass.y = centerOfMass.y * parentBranch.mass + node.y * node.options.mass;\n      centerOfMass.y *= totalMassInv;\n      parentBranch.mass = totalMass;\n      var biggestSize = Math.max(Math.max(node.height, node.radius), node.width);\n      parentBranch.maxWidth = parentBranch.maxWidth < biggestSize ? biggestSize : parentBranch.maxWidth;\n    }\n\n    /**\n     * determine in which branch the node will be placed.\n     *\n     * @param {object} parentBranch\n     * @param {Node} node\n     * @param {boolean} skipMassUpdate\n     * @private\n     */\n  }, {\n    key: \"_placeInTree\",\n    value: function _placeInTree(parentBranch, node, skipMassUpdate) {\n      if (skipMassUpdate != true || skipMassUpdate === undefined) {\n        // update the mass of the branch.\n        this._updateBranchMass(parentBranch, node);\n      }\n      var range = parentBranch.children.NW.range;\n      var region;\n      if (range.maxX > node.x) {\n        // in NW or SW\n        if (range.maxY > node.y) {\n          region = \"NW\";\n        } else {\n          region = \"SW\";\n        }\n      } else {\n        // in NE or SE\n        if (range.maxY > node.y) {\n          region = \"NE\";\n        } else {\n          region = \"SE\";\n        }\n      }\n      this._placeInRegion(parentBranch, node, region);\n    }\n\n    /**\n     * actually place the node in a region (or branch)\n     *\n     * @param {object} parentBranch\n     * @param {Node} node\n     * @param {'NW'| 'NE' | 'SW' | 'SE'} region\n     * @private\n     */\n  }, {\n    key: \"_placeInRegion\",\n    value: function _placeInRegion(parentBranch, node, region) {\n      var children = parentBranch.children[region];\n      switch (children.childrenCount) {\n        case 0:\n          // place node here\n          children.children.data = node;\n          children.childrenCount = 1;\n          this._updateBranchMass(children, node);\n          break;\n        case 1:\n          // convert into children\n          // if there are two nodes exactly overlapping (on init, on opening of cluster etc.)\n          // we move one node a little bit and we do not put it in the tree.\n          if (children.children.data.x === node.x && children.children.data.y === node.y) {\n            node.x += this._rng();\n            node.y += this._rng();\n          } else {\n            this._splitBranch(children);\n            this._placeInTree(children, node);\n          }\n          break;\n        case 4:\n          // place in branch\n          this._placeInTree(children, node);\n          break;\n      }\n    }\n\n    /**\n     * this function splits a branch into 4 sub branches. If the branch contained a node, we place it in the subbranch\n     * after the split is complete.\n     *\n     * @param {object} parentBranch\n     * @private\n     */\n  }, {\n    key: \"_splitBranch\",\n    value: function _splitBranch(parentBranch) {\n      // if the branch is shaded with a node, replace the node in the new subset.\n      var containedNode = null;\n      if (parentBranch.childrenCount === 1) {\n        containedNode = parentBranch.children.data;\n        parentBranch.mass = 0;\n        parentBranch.centerOfMass.x = 0;\n        parentBranch.centerOfMass.y = 0;\n      }\n      parentBranch.childrenCount = 4;\n      parentBranch.children.data = null;\n      this._insertRegion(parentBranch, \"NW\");\n      this._insertRegion(parentBranch, \"NE\");\n      this._insertRegion(parentBranch, \"SW\");\n      this._insertRegion(parentBranch, \"SE\");\n      if (containedNode != null) {\n        this._placeInTree(parentBranch, containedNode);\n      }\n    }\n\n    /**\n     * This function subdivides the region into four new segments.\n     * Specifically, this inserts a single new segment.\n     * It fills the children section of the parentBranch\n     *\n     * @param {object} parentBranch\n     * @param {'NW'| 'NE' | 'SW' | 'SE'} region\n     * @private\n     */\n  }, {\n    key: \"_insertRegion\",\n    value: function _insertRegion(parentBranch, region) {\n      var minX, maxX, minY, maxY;\n      var childSize = 0.5 * parentBranch.size;\n      switch (region) {\n        case \"NW\":\n          minX = parentBranch.range.minX;\n          maxX = parentBranch.range.minX + childSize;\n          minY = parentBranch.range.minY;\n          maxY = parentBranch.range.minY + childSize;\n          break;\n        case \"NE\":\n          minX = parentBranch.range.minX + childSize;\n          maxX = parentBranch.range.maxX;\n          minY = parentBranch.range.minY;\n          maxY = parentBranch.range.minY + childSize;\n          break;\n        case \"SW\":\n          minX = parentBranch.range.minX;\n          maxX = parentBranch.range.minX + childSize;\n          minY = parentBranch.range.minY + childSize;\n          maxY = parentBranch.range.maxY;\n          break;\n        case \"SE\":\n          minX = parentBranch.range.minX + childSize;\n          maxX = parentBranch.range.maxX;\n          minY = parentBranch.range.minY + childSize;\n          maxY = parentBranch.range.maxY;\n          break;\n      }\n      parentBranch.children[region] = {\n        centerOfMass: {\n          x: 0,\n          y: 0\n        },\n        mass: 0,\n        range: {\n          minX: minX,\n          maxX: maxX,\n          minY: minY,\n          maxY: maxY\n        },\n        size: 0.5 * parentBranch.size,\n        calcSize: 2 * parentBranch.calcSize,\n        children: {\n          data: null\n        },\n        maxWidth: 0,\n        level: parentBranch.level + 1,\n        childrenCount: 0\n      };\n    }\n\n    //---------------------------  DEBUGGING BELOW  ---------------------------//\n\n    /**\n     * This function is for debugging purposed, it draws the tree.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {string} color\n     * @private\n     */\n  }, {\n    key: \"_debug\",\n    value: function _debug(ctx, color) {\n      if (this.barnesHutTree !== undefined) {\n        ctx.lineWidth = 1;\n        this._drawBranch(this.barnesHutTree.root, ctx, color);\n      }\n    }\n\n    /**\n     * This function is for debugging purposes. It draws the branches recursively.\n     *\n     * @param {object} branch\n     * @param {CanvasRenderingContext2D} ctx\n     * @param {string} color\n     * @private\n     */\n  }, {\n    key: \"_drawBranch\",\n    value: function _drawBranch(branch, ctx, color) {\n      if (color === undefined) {\n        color = \"#FF0000\";\n      }\n      if (branch.childrenCount === 4) {\n        this._drawBranch(branch.children.NW, ctx);\n        this._drawBranch(branch.children.NE, ctx);\n        this._drawBranch(branch.children.SE, ctx);\n        this._drawBranch(branch.children.SW, ctx);\n      }\n      ctx.strokeStyle = color;\n      ctx.beginPath();\n      ctx.moveTo(branch.range.minX, branch.range.minY);\n      ctx.lineTo(branch.range.maxX, branch.range.minY);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(branch.range.maxX, branch.range.minY);\n      ctx.lineTo(branch.range.maxX, branch.range.maxY);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(branch.range.maxX, branch.range.maxY);\n      ctx.lineTo(branch.range.minX, branch.range.maxY);\n      ctx.stroke();\n      ctx.beginPath();\n      ctx.moveTo(branch.range.minX, branch.range.maxY);\n      ctx.lineTo(branch.range.minX, branch.range.minY);\n      ctx.stroke();\n\n      /*\n       if (branch.mass > 0) {\n       ctx.circle(branch.centerOfMass.x, branch.centerOfMass.y, 3*branch.mass);\n       ctx.stroke();\n       }\n       */\n    }\n  }]);\n  return BarnesHutSolver;\n}();\n\n/**\n * Repulsion Solver\n */\nvar RepulsionSolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function RepulsionSolver(body, physicsBody, options) {\n    _classCallCheck(this, RepulsionSolver);\n    this._rng = Alea(\"REPULSION SOLVER\");\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(RepulsionSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n\n    /**\n     * Calculate the forces the nodes apply on each other based on a repulsion field.\n     * This field is linearly approximated.\n     *\n     * @private\n     */\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var dx, dy, distance, fx, fy, repulsingForce, node1, node2;\n      var nodes = this.body.nodes;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces;\n\n      // repulsing forces between nodes\n      var nodeDistance = this.options.nodeDistance;\n\n      // approximation constants\n      var a = -2 / 3 / nodeDistance;\n      var b = 4 / 3;\n\n      // we loop from i over all but the last entree in the array\n      // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j\n      for (var i = 0; i < nodeIndices.length - 1; i++) {\n        node1 = nodes[nodeIndices[i]];\n        for (var j = i + 1; j < nodeIndices.length; j++) {\n          node2 = nodes[nodeIndices[j]];\n          dx = node2.x - node1.x;\n          dy = node2.y - node1.y;\n          distance = Math.sqrt(dx * dx + dy * dy);\n\n          // same condition as BarnesHutSolver, making sure nodes are never 100% overlapping.\n          if (distance === 0) {\n            distance = 0.1 * this._rng();\n            dx = distance;\n          }\n          if (distance < 2 * nodeDistance) {\n            if (distance < 0.5 * nodeDistance) {\n              repulsingForce = 1.0;\n            } else {\n              repulsingForce = a * distance + b; // linear approx of  1 / (1 + Math.exp((distance / nodeDistance - 1) * steepness))\n            }\n\n            repulsingForce = repulsingForce / distance;\n            fx = dx * repulsingForce;\n            fy = dy * repulsingForce;\n            forces[node1.id].x -= fx;\n            forces[node1.id].y -= fy;\n            forces[node2.id].x += fx;\n            forces[node2.id].y += fy;\n          }\n        }\n      }\n    }\n  }]);\n  return RepulsionSolver;\n}();\n\n/**\n * Hierarchical Repulsion Solver\n */\nvar HierarchicalRepulsionSolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function HierarchicalRepulsionSolver(body, physicsBody, options) {\n    _classCallCheck(this, HierarchicalRepulsionSolver);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(HierarchicalRepulsionSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n      this.overlapAvoidanceFactor = Math.max(0, Math.min(1, this.options.avoidOverlap || 0));\n    }\n\n    /**\n     * Calculate the forces the nodes apply on each other based on a repulsion field.\n     * This field is linearly approximated.\n     *\n     * @private\n     */\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var nodes = this.body.nodes;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces;\n\n      // repulsing forces between nodes\n      var nodeDistance = this.options.nodeDistance;\n\n      // we loop from i over all but the last entree in the array\n      // j loops from i+1 to the last. This way we do not double count any of the indices, nor i === j\n      for (var i = 0; i < nodeIndices.length - 1; i++) {\n        var node1 = nodes[nodeIndices[i]];\n        for (var j = i + 1; j < nodeIndices.length; j++) {\n          var node2 = nodes[nodeIndices[j]];\n\n          // nodes only affect nodes on their level\n          if (node1.level === node2.level) {\n            var theseNodesDistance = nodeDistance + this.overlapAvoidanceFactor * ((node1.shape.radius || 0) / 2 + (node2.shape.radius || 0) / 2);\n            var dx = node2.x - node1.x;\n            var dy = node2.y - node1.y;\n            var distance = Math.sqrt(dx * dx + dy * dy);\n            var steepness = 0.05;\n            var repulsingForce = void 0;\n            if (distance < theseNodesDistance) {\n              repulsingForce = -Math.pow(steepness * distance, 2) + Math.pow(steepness * theseNodesDistance, 2);\n            } else {\n              repulsingForce = 0;\n            }\n            // normalize force with\n            if (distance !== 0) {\n              repulsingForce = repulsingForce / distance;\n            }\n            var fx = dx * repulsingForce;\n            var fy = dy * repulsingForce;\n            forces[node1.id].x -= fx;\n            forces[node1.id].y -= fy;\n            forces[node2.id].x += fx;\n            forces[node2.id].y += fy;\n          }\n        }\n      }\n    }\n  }]);\n  return HierarchicalRepulsionSolver;\n}();\n\n/**\n * Spring Solver\n */\nvar SpringSolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function SpringSolver(body, physicsBody, options) {\n    _classCallCheck(this, SpringSolver);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(SpringSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n\n    /**\n     * This function calculates the springforces on the nodes, accounting for the support nodes.\n     *\n     * @private\n     */\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var edgeLength, edge;\n      var edgeIndices = this.physicsBody.physicsEdgeIndices;\n      var edges = this.body.edges;\n      var node1, node2, node3;\n\n      // forces caused by the edges, modelled as springs\n      for (var i = 0; i < edgeIndices.length; i++) {\n        edge = edges[edgeIndices[i]];\n        if (edge.connected === true && edge.toId !== edge.fromId) {\n          // only calculate forces if nodes are in the same sector\n          if (this.body.nodes[edge.toId] !== undefined && this.body.nodes[edge.fromId] !== undefined) {\n            if (edge.edgeType.via !== undefined) {\n              edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;\n              node1 = edge.to;\n              node2 = edge.edgeType.via;\n              node3 = edge.from;\n              this._calculateSpringForce(node1, node2, 0.5 * edgeLength);\n              this._calculateSpringForce(node2, node3, 0.5 * edgeLength);\n            } else {\n              // the * 1.5 is here so the edge looks as large as a smooth edge. It does not initially because the smooth edges use\n              // the support nodes which exert a repulsive force on the to and from nodes, making the edge appear larger.\n              edgeLength = edge.options.length === undefined ? this.options.springLength * 1.5 : edge.options.length;\n              this._calculateSpringForce(edge.from, edge.to, edgeLength);\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * This is the code actually performing the calculation for the function above.\n     *\n     * @param {Node} node1\n     * @param {Node} node2\n     * @param {number} edgeLength\n     * @private\n     */\n  }, {\n    key: \"_calculateSpringForce\",\n    value: function _calculateSpringForce(node1, node2, edgeLength) {\n      var dx = node1.x - node2.x;\n      var dy = node1.y - node2.y;\n      var distance = Math.max(Math.sqrt(dx * dx + dy * dy), 0.01);\n\n      // the 1/distance is so the fx and fy can be calculated without sine or cosine.\n      var springForce = this.options.springConstant * (edgeLength - distance) / distance;\n      var fx = dx * springForce;\n      var fy = dy * springForce;\n\n      // handle the case where one node is not part of the physcis\n      if (this.physicsBody.forces[node1.id] !== undefined) {\n        this.physicsBody.forces[node1.id].x += fx;\n        this.physicsBody.forces[node1.id].y += fy;\n      }\n      if (this.physicsBody.forces[node2.id] !== undefined) {\n        this.physicsBody.forces[node2.id].x -= fx;\n        this.physicsBody.forces[node2.id].y -= fy;\n      }\n    }\n  }]);\n  return SpringSolver;\n}();\n\n/**\n * Hierarchical Spring Solver\n */\nvar HierarchicalSpringSolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function HierarchicalSpringSolver(body, physicsBody, options) {\n    _classCallCheck(this, HierarchicalSpringSolver);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(HierarchicalSpringSolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n\n    /**\n     * This function calculates the springforces on the nodes, accounting for the support nodes.\n     *\n     * @private\n     */\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var edgeLength, edge;\n      var dx, dy, fx, fy, springForce, distance;\n      var edges = this.body.edges;\n      var factor = 0.5;\n      var edgeIndices = this.physicsBody.physicsEdgeIndices;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces;\n\n      // initialize the spring force counters\n      for (var i = 0; i < nodeIndices.length; i++) {\n        var nodeId = nodeIndices[i];\n        forces[nodeId].springFx = 0;\n        forces[nodeId].springFy = 0;\n      }\n\n      // forces caused by the edges, modelled as springs\n      for (var _i = 0; _i < edgeIndices.length; _i++) {\n        edge = edges[edgeIndices[_i]];\n        if (edge.connected === true) {\n          edgeLength = edge.options.length === undefined ? this.options.springLength : edge.options.length;\n          dx = edge.from.x - edge.to.x;\n          dy = edge.from.y - edge.to.y;\n          distance = Math.sqrt(dx * dx + dy * dy);\n          distance = distance === 0 ? 0.01 : distance;\n\n          // the 1/distance is so the fx and fy can be calculated without sine or cosine.\n          springForce = this.options.springConstant * (edgeLength - distance) / distance;\n          fx = dx * springForce;\n          fy = dy * springForce;\n          if (edge.to.level != edge.from.level) {\n            if (forces[edge.toId] !== undefined) {\n              forces[edge.toId].springFx -= fx;\n              forces[edge.toId].springFy -= fy;\n            }\n            if (forces[edge.fromId] !== undefined) {\n              forces[edge.fromId].springFx += fx;\n              forces[edge.fromId].springFy += fy;\n            }\n          } else {\n            if (forces[edge.toId] !== undefined) {\n              forces[edge.toId].x -= factor * fx;\n              forces[edge.toId].y -= factor * fy;\n            }\n            if (forces[edge.fromId] !== undefined) {\n              forces[edge.fromId].x += factor * fx;\n              forces[edge.fromId].y += factor * fy;\n            }\n          }\n        }\n      }\n\n      // normalize spring forces\n      springForce = 1;\n      var springFx, springFy;\n      for (var _i2 = 0; _i2 < nodeIndices.length; _i2++) {\n        var _nodeId = nodeIndices[_i2];\n        springFx = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFx));\n        springFy = Math.min(springForce, Math.max(-springForce, forces[_nodeId].springFy));\n        forces[_nodeId].x += springFx;\n        forces[_nodeId].y += springFy;\n      }\n\n      // retain energy balance\n      var totalFx = 0;\n      var totalFy = 0;\n      for (var _i3 = 0; _i3 < nodeIndices.length; _i3++) {\n        var _nodeId2 = nodeIndices[_i3];\n        totalFx += forces[_nodeId2].x;\n        totalFy += forces[_nodeId2].y;\n      }\n      var correctionFx = totalFx / nodeIndices.length;\n      var correctionFy = totalFy / nodeIndices.length;\n      for (var _i4 = 0; _i4 < nodeIndices.length; _i4++) {\n        var _nodeId3 = nodeIndices[_i4];\n        forces[_nodeId3].x -= correctionFx;\n        forces[_nodeId3].y -= correctionFy;\n      }\n    }\n  }]);\n  return HierarchicalSpringSolver;\n}();\n\n/**\n * Central Gravity Solver\n */\nvar CentralGravitySolver = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function CentralGravitySolver(body, physicsBody, options) {\n    _classCallCheck(this, CentralGravitySolver);\n    this.body = body;\n    this.physicsBody = physicsBody;\n    this.setOptions(options);\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(CentralGravitySolver, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      this.options = options;\n    }\n\n    /**\n     * Calculates forces for each node\n     */\n  }, {\n    key: \"solve\",\n    value: function solve() {\n      var dx, dy, distance, node;\n      var nodes = this.body.nodes;\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var forces = this.physicsBody.forces;\n      for (var i = 0; i < nodeIndices.length; i++) {\n        var nodeId = nodeIndices[i];\n        node = nodes[nodeId];\n        dx = -node.x;\n        dy = -node.y;\n        distance = Math.sqrt(dx * dx + dy * dy);\n        this._calculateForces(distance, dx, dy, forces, node);\n      }\n    }\n\n    /**\n     * Calculate the forces based on the distance.\n     *\n     * @param {number} distance\n     * @param {number} dx\n     * @param {number} dy\n     * @param {Object<Node.id, vis.Node>} forces\n     * @param {Node} node\n     * @private\n     */\n  }, {\n    key: \"_calculateForces\",\n    value: function _calculateForces(distance, dx, dy, forces, node) {\n      var gravityForce = distance === 0 ? 0 : this.options.centralGravity / distance;\n      forces[node.id].x = dx * gravityForce;\n      forces[node.id].y = dy * gravityForce;\n    }\n  }]);\n  return CentralGravitySolver;\n}();\n\nfunction _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$3() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * @augments BarnesHutSolver\n */\nvar ForceAtlas2BasedRepulsionSolver = /*#__PURE__*/function (_BarnesHutSolver) {\n  _inherits(ForceAtlas2BasedRepulsionSolver, _BarnesHutSolver);\n  var _super = _createSuper$3(ForceAtlas2BasedRepulsionSolver);\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function ForceAtlas2BasedRepulsionSolver(body, physicsBody, options) {\n    var _this;\n    _classCallCheck(this, ForceAtlas2BasedRepulsionSolver);\n    _this = _super.call(this, body, physicsBody, options);\n    _this._rng = Alea(\"FORCE ATLAS 2 BASED REPULSION SOLVER\");\n    return _this;\n  }\n\n  /**\n   * Calculate the forces based on the distance.\n   *\n   * @param {number} distance\n   * @param {number} dx\n   * @param {number} dy\n   * @param {Node} node\n   * @param {object} parentBranch\n   * @private\n   */\n  _createClass(ForceAtlas2BasedRepulsionSolver, [{\n    key: \"_calculateForces\",\n    value: function _calculateForces(distance, dx, dy, node, parentBranch) {\n      if (distance === 0) {\n        distance = 0.1 * this._rng();\n        dx = distance;\n      }\n      if (this.overlapAvoidanceFactor < 1 && node.shape.radius) {\n        distance = Math.max(0.1 + this.overlapAvoidanceFactor * node.shape.radius, distance - node.shape.radius);\n      }\n      var degree = node.edges.length + 1;\n      // the dividing by the distance cubed instead of squared allows us to get the fx and fy components without sines and cosines\n      // it is shorthand for gravityforce with distance squared and fx = dx/distance * gravityForce\n      var gravityForce = this.options.gravitationalConstant * parentBranch.mass * node.options.mass * degree / Math.pow(distance, 2);\n      var fx = dx * gravityForce;\n      var fy = dy * gravityForce;\n      this.physicsBody.forces[node.id].x += fx;\n      this.physicsBody.forces[node.id].y += fy;\n    }\n  }]);\n  return ForceAtlas2BasedRepulsionSolver;\n}(BarnesHutSolver);\n\nfunction _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$2() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * @augments CentralGravitySolver\n */\nvar ForceAtlas2BasedCentralGravitySolver = /*#__PURE__*/function (_CentralGravitySolver) {\n  _inherits(ForceAtlas2BasedCentralGravitySolver, _CentralGravitySolver);\n  var _super = _createSuper$2(ForceAtlas2BasedCentralGravitySolver);\n  /**\n   * @param {object} body\n   * @param {{physicsNodeIndices: Array, physicsEdgeIndices: Array, forces: {}, velocities: {}}} physicsBody\n   * @param {object} options\n   */\n  function ForceAtlas2BasedCentralGravitySolver(body, physicsBody, options) {\n    _classCallCheck(this, ForceAtlas2BasedCentralGravitySolver);\n    return _super.call(this, body, physicsBody, options);\n  }\n\n  /**\n   * Calculate the forces based on the distance.\n   *\n   * @param {number} distance\n   * @param {number} dx\n   * @param {number} dy\n   * @param {Object<Node.id, Node>} forces\n   * @param {Node} node\n   * @private\n   */\n  _createClass(ForceAtlas2BasedCentralGravitySolver, [{\n    key: \"_calculateForces\",\n    value: function _calculateForces(distance, dx, dy, forces, node) {\n      if (distance > 0) {\n        var degree = node.edges.length + 1;\n        var gravityForce = this.options.centralGravity * degree * node.options.mass;\n        forces[node.id].x = dx * gravityForce;\n        forces[node.id].y = dy * gravityForce;\n      }\n    }\n  }]);\n  return ForceAtlas2BasedCentralGravitySolver;\n}(CentralGravitySolver);\n\n/**\n * The physics engine\n */\nvar PhysicsEngine = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   */\n  function PhysicsEngine(body) {\n    _classCallCheck(this, PhysicsEngine);\n    this.body = body;\n    this.physicsBody = {\n      physicsNodeIndices: [],\n      physicsEdgeIndices: [],\n      forces: {},\n      velocities: {}\n    };\n    this.physicsEnabled = true;\n    this.simulationInterval = 1000 / 60;\n    this.requiresTimeout = true;\n    this.previousStates = {};\n    this.referenceState = {};\n    this.freezeCache = {};\n    this.renderTimer = undefined;\n\n    // parameters for the adaptive timestep\n    this.adaptiveTimestep = false;\n    this.adaptiveTimestepEnabled = false;\n    this.adaptiveCounter = 0;\n    this.adaptiveInterval = 3;\n    this.stabilized = false;\n    this.startedStabilization = false;\n    this.stabilizationIterations = 0;\n    this.ready = false; // will be set to true if the stabilize\n\n    // default options\n    this.options = {};\n    this.defaultOptions = {\n      enabled: true,\n      barnesHut: {\n        theta: 0.5,\n        gravitationalConstant: -2000,\n        centralGravity: 0.3,\n        springLength: 95,\n        springConstant: 0.04,\n        damping: 0.09,\n        avoidOverlap: 0\n      },\n      forceAtlas2Based: {\n        theta: 0.5,\n        gravitationalConstant: -50,\n        centralGravity: 0.01,\n        springConstant: 0.08,\n        springLength: 100,\n        damping: 0.4,\n        avoidOverlap: 0\n      },\n      repulsion: {\n        centralGravity: 0.2,\n        springLength: 200,\n        springConstant: 0.05,\n        nodeDistance: 100,\n        damping: 0.09,\n        avoidOverlap: 0\n      },\n      hierarchicalRepulsion: {\n        centralGravity: 0.0,\n        springLength: 100,\n        springConstant: 0.01,\n        nodeDistance: 120,\n        damping: 0.09\n      },\n      maxVelocity: 50,\n      minVelocity: 0.75,\n      // px/s\n      solver: \"barnesHut\",\n      stabilization: {\n        enabled: true,\n        iterations: 1000,\n        // maximum number of iteration to stabilize\n        updateInterval: 50,\n        onlyDynamicEdges: false,\n        fit: true\n      },\n      timestep: 0.5,\n      adaptiveTimestep: true,\n      wind: {\n        x: 0,\n        y: 0\n      }\n    };\n    _Object$assign(this.options, this.defaultOptions);\n    this.timestep = 0.5;\n    this.layoutFailed = false;\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n  _createClass(PhysicsEngine, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this = this;\n      this.body.emitter.on(\"initPhysics\", function () {\n        _this.initPhysics();\n      });\n      this.body.emitter.on(\"_layoutFailed\", function () {\n        _this.layoutFailed = true;\n      });\n      this.body.emitter.on(\"resetPhysics\", function () {\n        _this.stopSimulation();\n        _this.ready = false;\n      });\n      this.body.emitter.on(\"disablePhysics\", function () {\n        _this.physicsEnabled = false;\n        _this.stopSimulation();\n      });\n      this.body.emitter.on(\"restorePhysics\", function () {\n        _this.setOptions(_this.options);\n        if (_this.ready === true) {\n          _this.startSimulation();\n        }\n      });\n      this.body.emitter.on(\"startSimulation\", function () {\n        if (_this.ready === true) {\n          _this.startSimulation();\n        }\n      });\n      this.body.emitter.on(\"stopSimulation\", function () {\n        _this.stopSimulation();\n      });\n      this.body.emitter.on(\"destroy\", function () {\n        _this.stopSimulation(false);\n        _this.body.emitter.off();\n      });\n      this.body.emitter.on(\"_dataChanged\", function () {\n        // Nodes and/or edges have been added or removed, update shortcut lists.\n        _this.updatePhysicsData();\n      });\n\n      // debug: show forces\n      // this.body.emitter.on(\"afterDrawing\", (ctx) => {this._drawForces(ctx);});\n    }\n\n    /**\n     * set the physics options\n     *\n     * @param {object} options\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        if (options === false) {\n          this.options.enabled = false;\n          this.physicsEnabled = false;\n          this.stopSimulation();\n        } else if (options === true) {\n          this.options.enabled = true;\n          this.physicsEnabled = true;\n          this.startSimulation();\n        } else {\n          this.physicsEnabled = true;\n          selectiveNotDeepExtend([\"stabilization\"], this.options, options);\n          mergeOptions(this.options, options, \"stabilization\");\n          if (options.enabled === undefined) {\n            this.options.enabled = true;\n          }\n          if (this.options.enabled === false) {\n            this.physicsEnabled = false;\n            this.stopSimulation();\n          }\n          var wind = this.options.wind;\n          if (wind) {\n            if (typeof wind.x !== \"number\" || _Number$isNaN(wind.x)) {\n              wind.x = 0;\n            }\n            if (typeof wind.y !== \"number\" || _Number$isNaN(wind.y)) {\n              wind.y = 0;\n            }\n          }\n\n          // set the timestep\n          this.timestep = this.options.timestep;\n        }\n      }\n      this.init();\n    }\n\n    /**\n     * configure the engine.\n     */\n  }, {\n    key: \"init\",\n    value: function init() {\n      var options;\n      if (this.options.solver === \"forceAtlas2Based\") {\n        options = this.options.forceAtlas2Based;\n        this.nodesSolver = new ForceAtlas2BasedRepulsionSolver(this.body, this.physicsBody, options);\n        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);\n        this.gravitySolver = new ForceAtlas2BasedCentralGravitySolver(this.body, this.physicsBody, options);\n      } else if (this.options.solver === \"repulsion\") {\n        options = this.options.repulsion;\n        this.nodesSolver = new RepulsionSolver(this.body, this.physicsBody, options);\n        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);\n        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);\n      } else if (this.options.solver === \"hierarchicalRepulsion\") {\n        options = this.options.hierarchicalRepulsion;\n        this.nodesSolver = new HierarchicalRepulsionSolver(this.body, this.physicsBody, options);\n        this.edgesSolver = new HierarchicalSpringSolver(this.body, this.physicsBody, options);\n        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);\n      } else {\n        // barnesHut\n        options = this.options.barnesHut;\n        this.nodesSolver = new BarnesHutSolver(this.body, this.physicsBody, options);\n        this.edgesSolver = new SpringSolver(this.body, this.physicsBody, options);\n        this.gravitySolver = new CentralGravitySolver(this.body, this.physicsBody, options);\n      }\n      this.modelOptions = options;\n    }\n\n    /**\n     * initialize the engine\n     */\n  }, {\n    key: \"initPhysics\",\n    value: function initPhysics() {\n      if (this.physicsEnabled === true && this.options.enabled === true) {\n        if (this.options.stabilization.enabled === true) {\n          this.stabilize();\n        } else {\n          this.stabilized = false;\n          this.ready = true;\n          this.body.emitter.emit(\"fit\", {}, this.layoutFailed); // if the layout failed, we use the approximation for the zoom\n          this.startSimulation();\n        }\n      } else {\n        this.ready = true;\n        this.body.emitter.emit(\"fit\");\n      }\n    }\n\n    /**\n     * Start the simulation\n     */\n  }, {\n    key: \"startSimulation\",\n    value: function startSimulation() {\n      if (this.physicsEnabled === true && this.options.enabled === true) {\n        this.stabilized = false;\n\n        // when visible, adaptivity is disabled.\n        this.adaptiveTimestep = false;\n\n        // this sets the width of all nodes initially which could be required for the avoidOverlap\n        this.body.emitter.emit(\"_resizeNodes\");\n        if (this.viewFunction === undefined) {\n          var _context;\n          this.viewFunction = _bindInstanceProperty$1(_context = this.simulationStep).call(_context, this);\n          this.body.emitter.on(\"initRedraw\", this.viewFunction);\n          this.body.emitter.emit(\"_startRendering\");\n        }\n      } else {\n        this.body.emitter.emit(\"_redraw\");\n      }\n    }\n\n    /**\n     * Stop the simulation, force stabilization.\n     *\n     * @param {boolean} [emit=true]\n     */\n  }, {\n    key: \"stopSimulation\",\n    value: function stopSimulation() {\n      var emit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.stabilized = true;\n      if (emit === true) {\n        this._emitStabilized();\n      }\n      if (this.viewFunction !== undefined) {\n        this.body.emitter.off(\"initRedraw\", this.viewFunction);\n        this.viewFunction = undefined;\n        if (emit === true) {\n          this.body.emitter.emit(\"_stopRendering\");\n        }\n      }\n    }\n\n    /**\n     * The viewFunction inserts this step into each render loop. It calls the physics tick and handles the cleanup at stabilized.\n     *\n     */\n  }, {\n    key: \"simulationStep\",\n    value: function simulationStep() {\n      // check if the physics have settled\n      var startTime = _Date$now();\n      this.physicsTick();\n      var physicsTime = _Date$now() - startTime;\n\n      // run double speed if it is a little graph\n      if ((physicsTime < 0.4 * this.simulationInterval || this.runDoubleSpeed === true) && this.stabilized === false) {\n        this.physicsTick();\n\n        // this makes sure there is no jitter. The decision is taken once to run it at double speed.\n        this.runDoubleSpeed = true;\n      }\n      if (this.stabilized === true) {\n        this.stopSimulation();\n      }\n    }\n\n    /**\n     * trigger the stabilized event.\n     *\n     * @param {number} [amountOfIterations=this.stabilizationIterations]\n     * @private\n     */\n  }, {\n    key: \"_emitStabilized\",\n    value: function _emitStabilized() {\n      var _this2 = this;\n      var amountOfIterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.stabilizationIterations;\n      if (this.stabilizationIterations > 1 || this.startedStabilization === true) {\n        _setTimeout(function () {\n          _this2.body.emitter.emit(\"stabilized\", {\n            iterations: amountOfIterations\n          });\n          _this2.startedStabilization = false;\n          _this2.stabilizationIterations = 0;\n        }, 0);\n      }\n    }\n\n    /**\n     * Calculate the forces for one physics iteration and move the nodes.\n     *\n     * @private\n     */\n  }, {\n    key: \"physicsStep\",\n    value: function physicsStep() {\n      this.gravitySolver.solve();\n      this.nodesSolver.solve();\n      this.edgesSolver.solve();\n      this.moveNodes();\n    }\n\n    /**\n     * Make dynamic adjustments to the timestep, based on current state.\n     *\n     * Helper function for physicsTick().\n     *\n     * @private\n     */\n  }, {\n    key: \"adjustTimeStep\",\n    value: function adjustTimeStep() {\n      var factor = 1.2; // Factor for increasing the timestep on success.\n\n      // we compare the two steps. if it is acceptable we double the step.\n      if (this._evaluateStepQuality() === true) {\n        this.timestep = factor * this.timestep;\n      } else {\n        // if not, we decrease the step to a minimum of the options timestep.\n        // if the decreased timestep is smaller than the options step, we do not reset the counter\n        // we assume that the options timestep is stable enough.\n        if (this.timestep / factor < this.options.timestep) {\n          this.timestep = this.options.timestep;\n        } else {\n          // if the timestep was larger than 2 times the option one we check the adaptivity again to ensure\n          // that large instabilities do not form.\n          this.adaptiveCounter = -1; // check again next iteration\n          this.timestep = Math.max(this.options.timestep, this.timestep / factor);\n        }\n      }\n    }\n\n    /**\n     * A single simulation step (or 'tick') in the physics simulation\n     *\n     * @private\n     */\n  }, {\n    key: \"physicsTick\",\n    value: function physicsTick() {\n      this._startStabilizing(); // this ensures that there is no start event when the network is already stable.\n      if (this.stabilized === true) return;\n\n      // adaptivity means the timestep adapts to the situation, only applicable for stabilization\n      if (this.adaptiveTimestep === true && this.adaptiveTimestepEnabled === true) {\n        // timestep remains stable for \"interval\" iterations.\n        var doAdaptive = this.adaptiveCounter % this.adaptiveInterval === 0;\n        if (doAdaptive) {\n          // first the big step and revert.\n          this.timestep = 2 * this.timestep;\n          this.physicsStep();\n          this.revert(); // saves the reference state\n\n          // now the normal step. Since this is the last step, it is the more stable one and we will take this.\n          this.timestep = 0.5 * this.timestep;\n\n          // since it's half the step, we do it twice.\n          this.physicsStep();\n          this.physicsStep();\n          this.adjustTimeStep();\n        } else {\n          this.physicsStep(); // normal step, keeping timestep constant\n        }\n\n        this.adaptiveCounter += 1;\n      } else {\n        // case for the static timestep, we reset it to the one in options and take a normal step.\n        this.timestep = this.options.timestep;\n        this.physicsStep();\n      }\n      if (this.stabilized === true) this.revert();\n      this.stabilizationIterations++;\n    }\n\n    /**\n     * Nodes and edges can have the physics toggles on or off. A collection of indices is created here so we can skip the check all the time.\n     *\n     * @private\n     */\n  }, {\n    key: \"updatePhysicsData\",\n    value: function updatePhysicsData() {\n      this.physicsBody.forces = {};\n      this.physicsBody.physicsNodeIndices = [];\n      this.physicsBody.physicsEdgeIndices = [];\n      var nodes = this.body.nodes;\n      var edges = this.body.edges;\n\n      // get node indices for physics\n      for (var nodeId in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n          if (nodes[nodeId].options.physics === true) {\n            this.physicsBody.physicsNodeIndices.push(nodes[nodeId].id);\n          }\n        }\n      }\n\n      // get edge indices for physics\n      for (var edgeId in edges) {\n        if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {\n          if (edges[edgeId].options.physics === true) {\n            this.physicsBody.physicsEdgeIndices.push(edges[edgeId].id);\n          }\n        }\n      }\n\n      // get the velocity and the forces vector\n      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {\n        var _nodeId = this.physicsBody.physicsNodeIndices[i];\n        this.physicsBody.forces[_nodeId] = {\n          x: 0,\n          y: 0\n        };\n\n        // forces can be reset because they are recalculated. Velocities have to persist.\n        if (this.physicsBody.velocities[_nodeId] === undefined) {\n          this.physicsBody.velocities[_nodeId] = {\n            x: 0,\n            y: 0\n          };\n        }\n      }\n\n      // clean deleted nodes from the velocity vector\n      for (var _nodeId2 in this.physicsBody.velocities) {\n        if (nodes[_nodeId2] === undefined) {\n          delete this.physicsBody.velocities[_nodeId2];\n        }\n      }\n    }\n\n    /**\n     * Revert the simulation one step. This is done so after stabilization, every new start of the simulation will also say stabilized.\n     */\n  }, {\n    key: \"revert\",\n    value: function revert() {\n      var nodeIds = _Object$keys(this.previousStates);\n      var nodes = this.body.nodes;\n      var velocities = this.physicsBody.velocities;\n      this.referenceState = {};\n      for (var i = 0; i < nodeIds.length; i++) {\n        var nodeId = nodeIds[i];\n        if (nodes[nodeId] !== undefined) {\n          if (nodes[nodeId].options.physics === true) {\n            this.referenceState[nodeId] = {\n              positions: {\n                x: nodes[nodeId].x,\n                y: nodes[nodeId].y\n              }\n            };\n            velocities[nodeId].x = this.previousStates[nodeId].vx;\n            velocities[nodeId].y = this.previousStates[nodeId].vy;\n            nodes[nodeId].x = this.previousStates[nodeId].x;\n            nodes[nodeId].y = this.previousStates[nodeId].y;\n          }\n        } else {\n          delete this.previousStates[nodeId];\n        }\n      }\n    }\n\n    /**\n     * This compares the reference state to the current state\n     *\n     * @returns {boolean}\n     * @private\n     */\n  }, {\n    key: \"_evaluateStepQuality\",\n    value: function _evaluateStepQuality() {\n      var dx, dy, dpos;\n      var nodes = this.body.nodes;\n      var reference = this.referenceState;\n      var posThreshold = 0.3;\n      for (var nodeId in this.referenceState) {\n        if (Object.prototype.hasOwnProperty.call(this.referenceState, nodeId) && nodes[nodeId] !== undefined) {\n          dx = nodes[nodeId].x - reference[nodeId].positions.x;\n          dy = nodes[nodeId].y - reference[nodeId].positions.y;\n          dpos = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          if (dpos > posThreshold) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * move the nodes one timestep and check if they are stabilized\n     */\n  }, {\n    key: \"moveNodes\",\n    value: function moveNodes() {\n      var nodeIndices = this.physicsBody.physicsNodeIndices;\n      var maxNodeVelocity = 0;\n      var averageNodeVelocity = 0;\n\n      // the velocity threshold (energy in the system) for the adaptivity toggle\n      var velocityAdaptiveThreshold = 5;\n      for (var i = 0; i < nodeIndices.length; i++) {\n        var nodeId = nodeIndices[i];\n        var nodeVelocity = this._performStep(nodeId);\n        // stabilized is true if stabilized is true and velocity is smaller than vmin --> all nodes must be stabilized\n        maxNodeVelocity = Math.max(maxNodeVelocity, nodeVelocity);\n        averageNodeVelocity += nodeVelocity;\n      }\n\n      // evaluating the stabilized and adaptiveTimestepEnabled conditions\n      this.adaptiveTimestepEnabled = averageNodeVelocity / nodeIndices.length < velocityAdaptiveThreshold;\n      this.stabilized = maxNodeVelocity < this.options.minVelocity;\n    }\n\n    /**\n     * Calculate new velocity for a coordinate direction\n     *\n     * @param {number} v  velocity for current coordinate\n     * @param {number} f  regular force for current coordinate\n     * @param {number} m  mass of current node\n     * @returns {number} new velocity for current coordinate\n     * @private\n     */\n  }, {\n    key: \"calculateComponentVelocity\",\n    value: function calculateComponentVelocity(v, f, m) {\n      var df = this.modelOptions.damping * v; // damping force\n      var a = (f - df) / m; // acceleration\n\n      v += a * this.timestep;\n\n      // Put a limit on the velocities if it is really high\n      var maxV = this.options.maxVelocity || 1e9;\n      if (Math.abs(v) > maxV) {\n        v = v > 0 ? maxV : -maxV;\n      }\n      return v;\n    }\n\n    /**\n     * Perform the actual step\n     *\n     * @param {Node.id} nodeId\n     * @returns {number} the new velocity of given node\n     * @private\n     */\n  }, {\n    key: \"_performStep\",\n    value: function _performStep(nodeId) {\n      var node = this.body.nodes[nodeId];\n      var force = this.physicsBody.forces[nodeId];\n      if (this.options.wind) {\n        force.x += this.options.wind.x;\n        force.y += this.options.wind.y;\n      }\n      var velocity = this.physicsBody.velocities[nodeId];\n\n      // store the state so we can revert\n      this.previousStates[nodeId] = {\n        x: node.x,\n        y: node.y,\n        vx: velocity.x,\n        vy: velocity.y\n      };\n      if (node.options.fixed.x === false) {\n        velocity.x = this.calculateComponentVelocity(velocity.x, force.x, node.options.mass);\n        node.x += velocity.x * this.timestep;\n      } else {\n        force.x = 0;\n        velocity.x = 0;\n      }\n      if (node.options.fixed.y === false) {\n        velocity.y = this.calculateComponentVelocity(velocity.y, force.y, node.options.mass);\n        node.y += velocity.y * this.timestep;\n      } else {\n        force.y = 0;\n        velocity.y = 0;\n      }\n      var totalVelocity = Math.sqrt(Math.pow(velocity.x, 2) + Math.pow(velocity.y, 2));\n      return totalVelocity;\n    }\n\n    /**\n     * When initializing and stabilizing, we can freeze nodes with a predefined position.\n     * This greatly speeds up stabilization because only the supportnodes for the smoothCurves have to settle.\n     *\n     * @private\n     */\n  }, {\n    key: \"_freezeNodes\",\n    value: function _freezeNodes() {\n      var nodes = this.body.nodes;\n      for (var id in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, id)) {\n          if (nodes[id].x && nodes[id].y) {\n            var fixed = nodes[id].options.fixed;\n            this.freezeCache[id] = {\n              x: fixed.x,\n              y: fixed.y\n            };\n            fixed.x = true;\n            fixed.y = true;\n          }\n        }\n      }\n    }\n\n    /**\n     * Unfreezes the nodes that have been frozen by _freezeDefinedNodes.\n     *\n     * @private\n     */\n  }, {\n    key: \"_restoreFrozenNodes\",\n    value: function _restoreFrozenNodes() {\n      var nodes = this.body.nodes;\n      for (var id in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, id)) {\n          if (this.freezeCache[id] !== undefined) {\n            nodes[id].options.fixed.x = this.freezeCache[id].x;\n            nodes[id].options.fixed.y = this.freezeCache[id].y;\n          }\n        }\n      }\n      this.freezeCache = {};\n    }\n\n    /**\n     * Find a stable position for all nodes\n     *\n     * @param {number} [iterations=this.options.stabilization.iterations]\n     */\n  }, {\n    key: \"stabilize\",\n    value: function stabilize() {\n      var _this3 = this;\n      var iterations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.stabilization.iterations;\n      if (typeof iterations !== \"number\") {\n        iterations = this.options.stabilization.iterations;\n        console.error(\"The stabilize method needs a numeric amount of iterations. Switching to default: \", iterations);\n      }\n      if (this.physicsBody.physicsNodeIndices.length === 0) {\n        this.ready = true;\n        return;\n      }\n\n      // enable adaptive timesteps\n      this.adaptiveTimestep = this.options.adaptiveTimestep;\n\n      // this sets the width of all nodes initially which could be required for the avoidOverlap\n      this.body.emitter.emit(\"_resizeNodes\");\n      this.stopSimulation(); // stop the render loop\n      this.stabilized = false;\n\n      // block redraw requests\n      this.body.emitter.emit(\"_blockRedraw\");\n      this.targetIterations = iterations;\n\n      // start the stabilization\n      if (this.options.stabilization.onlyDynamicEdges === true) {\n        this._freezeNodes();\n      }\n      this.stabilizationIterations = 0;\n      _setTimeout(function () {\n        return _this3._stabilizationBatch();\n      }, 0);\n    }\n\n    /**\n     * If not already stabilizing, start it and emit a start event.\n     *\n     * @returns {boolean} true if stabilization started with this call\n     * @private\n     */\n  }, {\n    key: \"_startStabilizing\",\n    value: function _startStabilizing() {\n      if (this.startedStabilization === true) return false;\n      this.body.emitter.emit(\"startStabilizing\");\n      this.startedStabilization = true;\n      return true;\n    }\n\n    /**\n     * One batch of stabilization\n     *\n     * @private\n     */\n  }, {\n    key: \"_stabilizationBatch\",\n    value: function _stabilizationBatch() {\n      var _this4 = this;\n      var running = function running() {\n        return _this4.stabilized === false && _this4.stabilizationIterations < _this4.targetIterations;\n      };\n      var sendProgress = function sendProgress() {\n        _this4.body.emitter.emit(\"stabilizationProgress\", {\n          iterations: _this4.stabilizationIterations,\n          total: _this4.targetIterations\n        });\n      };\n      if (this._startStabilizing()) {\n        sendProgress(); // Ensure that there is at least one start event.\n      }\n\n      var count = 0;\n      while (running() && count < this.options.stabilization.updateInterval) {\n        this.physicsTick();\n        count++;\n      }\n      sendProgress();\n      if (running()) {\n        var _context2;\n        _setTimeout(_bindInstanceProperty$1(_context2 = this._stabilizationBatch).call(_context2, this), 0);\n      } else {\n        this._finalizeStabilization();\n      }\n    }\n\n    /**\n     * Wrap up the stabilization, fit and emit the events.\n     *\n     * @private\n     */\n  }, {\n    key: \"_finalizeStabilization\",\n    value: function _finalizeStabilization() {\n      this.body.emitter.emit(\"_allowRedraw\");\n      if (this.options.stabilization.fit === true) {\n        this.body.emitter.emit(\"fit\");\n      }\n      if (this.options.stabilization.onlyDynamicEdges === true) {\n        this._restoreFrozenNodes();\n      }\n      this.body.emitter.emit(\"stabilizationIterationsDone\");\n      this.body.emitter.emit(\"_requestRedraw\");\n      if (this.stabilized === true) {\n        this._emitStabilized();\n      } else {\n        this.startSimulation();\n      }\n      this.ready = true;\n    }\n\n    //---------------------------  DEBUGGING BELOW  ---------------------------//\n\n    /**\n     * Debug function that display arrows for the forces currently active in the network.\n     *\n     * Use this when debugging only.\n     *\n     * @param {CanvasRenderingContext2D} ctx\n     * @private\n     */\n  }, {\n    key: \"_drawForces\",\n    value: function _drawForces(ctx) {\n      for (var i = 0; i < this.physicsBody.physicsNodeIndices.length; i++) {\n        var index = this.physicsBody.physicsNodeIndices[i];\n        var node = this.body.nodes[index];\n        var force = this.physicsBody.forces[index];\n        var factor = 20;\n        var colorFactor = 0.03;\n        var forceSize = Math.sqrt(Math.pow(force.x, 2) + Math.pow(force.x, 2));\n        var size = Math.min(Math.max(5, forceSize), 15);\n        var arrowSize = 3 * size;\n        var color = HSVToHex((180 - Math.min(1, Math.max(0, colorFactor * forceSize)) * 180) / 360, 1, 1);\n        var point = {\n          x: node.x + factor * force.x,\n          y: node.y + factor * force.y\n        };\n        ctx.lineWidth = size;\n        ctx.strokeStyle = color;\n        ctx.beginPath();\n        ctx.moveTo(node.x, node.y);\n        ctx.lineTo(point.x, point.y);\n        ctx.stroke();\n        var angle = Math.atan2(force.y, force.x);\n        ctx.fillStyle = color;\n        EndPoints.draw(ctx, {\n          type: \"arrow\",\n          point: point,\n          angle: angle,\n          length: arrowSize\n        });\n        _fillInstanceProperty(ctx).call(ctx);\n      }\n    }\n  }]);\n  return PhysicsEngine;\n}();\n\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nconst randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nvar native = {\n  randomUUID\n};\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\n/**\n * Utility Class\n */\nvar NetworkUtil = /*#__PURE__*/function () {\n  /**\n   * @ignore\n   */\n  function NetworkUtil() {\n    _classCallCheck(this, NetworkUtil);\n  }\n\n  /**\n   * Find the center position of the network considering the bounding boxes\n   *\n   * @param {Array.<Node>} allNodes\n   * @param {Array.<Node>} [specificNodes=[]]\n   * @returns {{minX: number, maxX: number, minY: number, maxY: number}}\n   * @static\n   */\n  _createClass(NetworkUtil, null, [{\n    key: \"getRange\",\n    value: function getRange(allNodes) {\n      var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var minY = 1e9,\n        maxY = -1e9,\n        minX = 1e9,\n        maxX = -1e9,\n        node;\n      if (specificNodes.length > 0) {\n        for (var i = 0; i < specificNodes.length; i++) {\n          node = allNodes[specificNodes[i]];\n          if (minX > node.shape.boundingBox.left) {\n            minX = node.shape.boundingBox.left;\n          }\n          if (maxX < node.shape.boundingBox.right) {\n            maxX = node.shape.boundingBox.right;\n          }\n          if (minY > node.shape.boundingBox.top) {\n            minY = node.shape.boundingBox.top;\n          } // top is negative, bottom is positive\n          if (maxY < node.shape.boundingBox.bottom) {\n            maxY = node.shape.boundingBox.bottom;\n          } // top is negative, bottom is positive\n        }\n      }\n\n      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {\n        minY = 0, maxY = 0, minX = 0, maxX = 0;\n      }\n      return {\n        minX: minX,\n        maxX: maxX,\n        minY: minY,\n        maxY: maxY\n      };\n    }\n\n    /**\n     * Find the center position of the network\n     *\n     * @param {Array.<Node>} allNodes\n     * @param {Array.<Node>} [specificNodes=[]]\n     * @returns {{minX: number, maxX: number, minY: number, maxY: number}}\n     * @static\n     */\n  }, {\n    key: \"getRangeCore\",\n    value: function getRangeCore(allNodes) {\n      var specificNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var minY = 1e9,\n        maxY = -1e9,\n        minX = 1e9,\n        maxX = -1e9,\n        node;\n      if (specificNodes.length > 0) {\n        for (var i = 0; i < specificNodes.length; i++) {\n          node = allNodes[specificNodes[i]];\n          if (minX > node.x) {\n            minX = node.x;\n          }\n          if (maxX < node.x) {\n            maxX = node.x;\n          }\n          if (minY > node.y) {\n            minY = node.y;\n          } // top is negative, bottom is positive\n          if (maxY < node.y) {\n            maxY = node.y;\n          } // top is negative, bottom is positive\n        }\n      }\n\n      if (minX === 1e9 && maxX === -1e9 && minY === 1e9 && maxY === -1e9) {\n        minY = 0, maxY = 0, minX = 0, maxX = 0;\n      }\n      return {\n        minX: minX,\n        maxX: maxX,\n        minY: minY,\n        maxY: maxY\n      };\n    }\n\n    /**\n     * @param {object} range = {minX: minX, maxX: maxX, minY: minY, maxY: maxY};\n     * @returns {{x: number, y: number}}\n     * @static\n     */\n  }, {\n    key: \"findCenter\",\n    value: function findCenter(range) {\n      return {\n        x: 0.5 * (range.maxX + range.minX),\n        y: 0.5 * (range.maxY + range.minY)\n      };\n    }\n\n    /**\n     * This returns a clone of the options or options of the edge or node to be used for construction of new edges or check functions for new nodes.\n     *\n     * @param {vis.Item} item\n     * @param {'node'|undefined} type\n     * @returns {{}}\n     * @static\n     */\n  }, {\n    key: \"cloneOptions\",\n    value: function cloneOptions(item, type) {\n      var clonedOptions = {};\n      if (type === undefined || type === \"node\") {\n        deepExtend(clonedOptions, item.options, true);\n        clonedOptions.x = item.x;\n        clonedOptions.y = item.y;\n        clonedOptions.amountOfConnections = item.edges.length;\n      } else {\n        deepExtend(clonedOptions, item.options, true);\n      }\n      return clonedOptions;\n    }\n  }]);\n  return NetworkUtil;\n}();\n\nfunction _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct$1() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * A Cluster is a special Node that allows a group of Nodes positioned closely together\n * to be represented by a single Cluster Node.\n *\n * @augments Node\n */\nvar Cluster = /*#__PURE__*/function (_Node) {\n  _inherits(Cluster, _Node);\n  var _super = _createSuper$1(Cluster);\n  /**\n   * @param {object} options\n   * @param {object} body\n   * @param {Array.<HTMLImageElement>}imagelist\n   * @param {Array} grouplist\n   * @param {object} globalOptions\n   * @param {object} defaultOptions     Global default options for nodes\n   */\n  function Cluster(options, body, imagelist, grouplist, globalOptions, defaultOptions) {\n    var _this;\n    _classCallCheck(this, Cluster);\n    _this = _super.call(this, options, body, imagelist, grouplist, globalOptions, defaultOptions);\n    _this.isCluster = true;\n    _this.containedNodes = {};\n    _this.containedEdges = {};\n    return _this;\n  }\n\n  /**\n   * Transfer child cluster data to current and disconnect the child cluster.\n   *\n   * Please consult the header comment in 'Clustering.js' for the fields set here.\n   *\n   * @param {string|number} childClusterId  id of child cluster to open\n   */\n  _createClass(Cluster, [{\n    key: \"_openChildCluster\",\n    value: function _openChildCluster(childClusterId) {\n      var _this2 = this;\n      var childCluster = this.body.nodes[childClusterId];\n      if (this.containedNodes[childClusterId] === undefined) {\n        throw new Error(\"node with id: \" + childClusterId + \" not in current cluster\");\n      }\n      if (!childCluster.isCluster) {\n        throw new Error(\"node with id: \" + childClusterId + \" is not a cluster\");\n      }\n\n      // Disconnect child cluster from current cluster\n      delete this.containedNodes[childClusterId];\n      forEach$1(childCluster.edges, function (edge) {\n        delete _this2.containedEdges[edge.id];\n      });\n\n      // Transfer nodes and edges\n      forEach$1(childCluster.containedNodes, function (node, nodeId) {\n        _this2.containedNodes[nodeId] = node;\n      });\n      childCluster.containedNodes = {};\n      forEach$1(childCluster.containedEdges, function (edge, edgeId) {\n        _this2.containedEdges[edgeId] = edge;\n      });\n      childCluster.containedEdges = {};\n\n      // Transfer edges within cluster edges which are clustered\n      forEach$1(childCluster.edges, function (clusterEdge) {\n        forEach$1(_this2.edges, function (parentClusterEdge) {\n          var _context, _context2;\n          // Assumption: a clustered edge can only be present in a single clustering edge\n          // Not tested here\n          var index = _indexOfInstanceProperty(_context = parentClusterEdge.clusteringEdgeReplacingIds).call(_context, clusterEdge.id);\n          if (index === -1) return;\n          forEach$1(clusterEdge.clusteringEdgeReplacingIds, function (srcId) {\n            parentClusterEdge.clusteringEdgeReplacingIds.push(srcId);\n\n            // Maintain correct bookkeeping for transferred edge\n            _this2.body.edges[srcId].edgeReplacedById = parentClusterEdge.id;\n          });\n\n          // Remove cluster edge from parent cluster edge\n          _spliceInstanceProperty(_context2 = parentClusterEdge.clusteringEdgeReplacingIds).call(_context2, index, 1);\n        });\n      });\n      childCluster.edges = [];\n    }\n  }]);\n  return Cluster;\n}(Node);\n\n/**\n * The clustering engine\n */\nvar ClusterEngine = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   */\n  function ClusterEngine(body) {\n    var _this = this;\n    _classCallCheck(this, ClusterEngine);\n    this.body = body;\n    this.clusteredNodes = {}; // key: node id, value: { clusterId: <id of cluster>, node: <node instance>}\n    this.clusteredEdges = {}; // key: edge id, value: restore information for given edge\n\n    this.options = {};\n    this.defaultOptions = {};\n    _Object$assign(this.options, this.defaultOptions);\n    this.body.emitter.on(\"_resetData\", function () {\n      _this.clusteredNodes = {};\n      _this.clusteredEdges = {};\n    });\n  }\n\n  /**\n   *\n   * @param {number} hubsize\n   * @param {object} options\n   */\n  _createClass(ClusterEngine, [{\n    key: \"clusterByHubsize\",\n    value: function clusterByHubsize(hubsize, options) {\n      if (hubsize === undefined) {\n        hubsize = this._getHubSize();\n      } else if (_typeof(hubsize) === \"object\") {\n        options = this._checkOptions(hubsize);\n        hubsize = this._getHubSize();\n      }\n      var nodesToCluster = [];\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var node = this.body.nodes[this.body.nodeIndices[i]];\n        if (node.edges.length >= hubsize) {\n          nodesToCluster.push(node.id);\n        }\n      }\n      for (var _i = 0; _i < nodesToCluster.length; _i++) {\n        this.clusterByConnection(nodesToCluster[_i], options, true);\n      }\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n\n    /**\n     * loop over all nodes, check if they adhere to the condition and cluster if needed.\n     *\n     * @param {object} options\n     * @param {boolean} [refreshData=true]\n     */\n  }, {\n    key: \"cluster\",\n    value: function cluster() {\n      var _this2 = this;\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (options.joinCondition === undefined) {\n        throw new Error(\"Cannot call clusterByNodeData without a joinCondition function in the options.\");\n      }\n\n      // check if the options object is fine, append if needed\n      options = this._checkOptions(options);\n      var childNodesObj = {};\n      var childEdgesObj = {};\n\n      // collect the nodes that will be in the cluster\n      forEach$1(this.body.nodes, function (node, nodeId) {\n        if (node.options && options.joinCondition(node.options) === true) {\n          childNodesObj[nodeId] = node;\n\n          // collect the edges that will be in the cluster\n          forEach$1(node.edges, function (edge) {\n            if (_this2.clusteredEdges[edge.id] === undefined) {\n              childEdgesObj[edge.id] = edge;\n            }\n          });\n        }\n      });\n      this._cluster(childNodesObj, childEdgesObj, options, refreshData);\n    }\n\n    /**\n     * Cluster all nodes in the network that have only X edges\n     *\n     * @param {number} edgeCount\n     * @param {object} options\n     * @param {boolean} [refreshData=true]\n     */\n  }, {\n    key: \"clusterByEdgeCount\",\n    value: function clusterByEdgeCount(edgeCount, options) {\n      var _this3 = this;\n      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      options = this._checkOptions(options);\n      var clusters = [];\n      var usedNodes = {};\n      var edge, edges, relevantEdgeCount;\n      // collect the nodes that will be in the cluster\n      var _loop = function _loop() {\n        var childNodesObj = {};\n        var childEdgesObj = {};\n        var nodeId = _this3.body.nodeIndices[i];\n        var node = _this3.body.nodes[nodeId];\n\n        // if this node is already used in another cluster this session, we do not have to re-evaluate it.\n        if (usedNodes[nodeId] === undefined) {\n          relevantEdgeCount = 0;\n          edges = [];\n          for (var j = 0; j < node.edges.length; j++) {\n            edge = node.edges[j];\n            if (_this3.clusteredEdges[edge.id] === undefined) {\n              if (edge.toId !== edge.fromId) {\n                relevantEdgeCount++;\n              }\n              edges.push(edge);\n            }\n          }\n\n          // this node qualifies, we collect its neighbours to start the clustering process.\n          if (relevantEdgeCount === edgeCount) {\n            var checkJoinCondition = function checkJoinCondition(node) {\n              if (options.joinCondition === undefined || options.joinCondition === null) {\n                return true;\n              }\n              var clonedOptions = NetworkUtil.cloneOptions(node);\n              return options.joinCondition(clonedOptions);\n            };\n            var gatheringSuccessful = true;\n            for (var _j = 0; _j < edges.length; _j++) {\n              edge = edges[_j];\n              var childNodeId = _this3._getConnectedId(edge, nodeId);\n              // add the nodes to the list by the join condition.\n              if (checkJoinCondition(node)) {\n                childEdgesObj[edge.id] = edge;\n                childNodesObj[nodeId] = node;\n                childNodesObj[childNodeId] = _this3.body.nodes[childNodeId];\n                usedNodes[nodeId] = true;\n              } else {\n                // this node does not qualify after all.\n                gatheringSuccessful = false;\n                break;\n              }\n            }\n\n            // add to the cluster queue\n            if (_Object$keys(childNodesObj).length > 0 && _Object$keys(childEdgesObj).length > 0 && gatheringSuccessful === true) {\n              /**\n               * Search for cluster data that contains any of the node id's\n               *\n               * @returns {boolean} true if no joinCondition, otherwise return value of joinCondition\n               */\n              var findClusterData = function findClusterData() {\n                for (var n = 0; n < clusters.length; ++n) {\n                  // Search for a cluster containing any of the node id's\n                  for (var m in childNodesObj) {\n                    if (clusters[n].nodes[m] !== undefined) {\n                      return clusters[n];\n                    }\n                  }\n                }\n                return undefined;\n              };\n\n              // If any of the found nodes is part of a cluster found in this method,\n              // add the current values to that cluster\n              var foundCluster = findClusterData();\n              if (foundCluster !== undefined) {\n                // Add nodes to found cluster if not present\n                for (var m in childNodesObj) {\n                  if (foundCluster.nodes[m] === undefined) {\n                    foundCluster.nodes[m] = childNodesObj[m];\n                  }\n                }\n\n                // Add edges to found cluster, if not present\n                for (var _m in childEdgesObj) {\n                  if (foundCluster.edges[_m] === undefined) {\n                    foundCluster.edges[_m] = childEdgesObj[_m];\n                  }\n                }\n              } else {\n                // Create a new cluster group\n                clusters.push({\n                  nodes: childNodesObj,\n                  edges: childEdgesObj\n                });\n              }\n            }\n          }\n        }\n      };\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        _loop();\n      }\n      for (var _i2 = 0; _i2 < clusters.length; _i2++) {\n        this._cluster(clusters[_i2].nodes, clusters[_i2].edges, options, false);\n      }\n      if (refreshData === true) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n\n    /**\n     * Cluster all nodes in the network that have only 1 edge\n     *\n     * @param {object} options\n     * @param {boolean} [refreshData=true]\n     */\n  }, {\n    key: \"clusterOutliers\",\n    value: function clusterOutliers(options) {\n      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      this.clusterByEdgeCount(1, options, refreshData);\n    }\n\n    /**\n     * Cluster all nodes in the network that have only 2 edge\n     *\n     * @param {object} options\n     * @param {boolean} [refreshData=true]\n     */\n  }, {\n    key: \"clusterBridges\",\n    value: function clusterBridges(options) {\n      var refreshData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      this.clusterByEdgeCount(2, options, refreshData);\n    }\n\n    /**\n     * suck all connected nodes of a node into the node.\n     *\n     * @param {Node.id} nodeId\n     * @param {object} options\n     * @param {boolean} [refreshData=true]\n     */\n  }, {\n    key: \"clusterByConnection\",\n    value: function clusterByConnection(nodeId, options) {\n      var _context;\n      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      // kill conditions\n      if (nodeId === undefined) {\n        throw new Error(\"No nodeId supplied to clusterByConnection!\");\n      }\n      if (this.body.nodes[nodeId] === undefined) {\n        throw new Error(\"The nodeId given to clusterByConnection does not exist!\");\n      }\n      var node = this.body.nodes[nodeId];\n      options = this._checkOptions(options, node);\n      if (options.clusterNodeProperties.x === undefined) {\n        options.clusterNodeProperties.x = node.x;\n      }\n      if (options.clusterNodeProperties.y === undefined) {\n        options.clusterNodeProperties.y = node.y;\n      }\n      if (options.clusterNodeProperties.fixed === undefined) {\n        options.clusterNodeProperties.fixed = {};\n        options.clusterNodeProperties.fixed.x = node.options.fixed.x;\n        options.clusterNodeProperties.fixed.y = node.options.fixed.y;\n      }\n      var childNodesObj = {};\n      var childEdgesObj = {};\n      var parentNodeId = node.id;\n      var parentClonedOptions = NetworkUtil.cloneOptions(node);\n      childNodesObj[parentNodeId] = node;\n\n      // collect the nodes that will be in the cluster\n      for (var i = 0; i < node.edges.length; i++) {\n        var edge = node.edges[i];\n        if (this.clusteredEdges[edge.id] === undefined) {\n          var childNodeId = this._getConnectedId(edge, parentNodeId);\n\n          // if the child node is not in a cluster\n          if (this.clusteredNodes[childNodeId] === undefined) {\n            if (childNodeId !== parentNodeId) {\n              if (options.joinCondition === undefined) {\n                childEdgesObj[edge.id] = edge;\n                childNodesObj[childNodeId] = this.body.nodes[childNodeId];\n              } else {\n                // clone the options and insert some additional parameters that could be interesting.\n                var childClonedOptions = NetworkUtil.cloneOptions(this.body.nodes[childNodeId]);\n                if (options.joinCondition(parentClonedOptions, childClonedOptions) === true) {\n                  childEdgesObj[edge.id] = edge;\n                  childNodesObj[childNodeId] = this.body.nodes[childNodeId];\n                }\n              }\n            } else {\n              // swallow the edge if it is self-referencing.\n              childEdgesObj[edge.id] = edge;\n            }\n          }\n        }\n      }\n      var childNodeIDs = _mapInstanceProperty(_context = _Object$keys(childNodesObj)).call(_context, function (childNode) {\n        return childNodesObj[childNode].id;\n      });\n      for (var childNodeKey in childNodesObj) {\n        if (!Object.prototype.hasOwnProperty.call(childNodesObj, childNodeKey)) continue;\n        var childNode = childNodesObj[childNodeKey];\n        for (var y = 0; y < childNode.edges.length; y++) {\n          var childEdge = childNode.edges[y];\n          if (_indexOfInstanceProperty(childNodeIDs).call(childNodeIDs, this._getConnectedId(childEdge, childNode.id)) > -1) {\n            childEdgesObj[childEdge.id] = childEdge;\n          }\n        }\n      }\n      this._cluster(childNodesObj, childEdgesObj, options, refreshData);\n    }\n\n    /**\n     * This function creates the edges that will be attached to the cluster\n     * It looks for edges that are connected to the nodes from the \"outside' of the cluster.\n     *\n     * @param {{Node.id: vis.Node}} childNodesObj\n     * @param {{vis.Edge.id: vis.Edge}} childEdgesObj\n     * @param {object} clusterNodeProperties\n     * @param {object} clusterEdgeProperties\n     * @private\n     */\n  }, {\n    key: \"_createClusterEdges\",\n    value: function _createClusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, clusterEdgeProperties) {\n      var edge, childNodeId, childNode, toId, fromId, otherNodeId;\n\n      // loop over all child nodes and their edges to find edges going out of the cluster\n      // these edges will be replaced by clusterEdges.\n      var childKeys = _Object$keys(childNodesObj);\n      var createEdges = [];\n      for (var i = 0; i < childKeys.length; i++) {\n        childNodeId = childKeys[i];\n        childNode = childNodesObj[childNodeId];\n\n        // construct new edges from the cluster to others\n        for (var j = 0; j < childNode.edges.length; j++) {\n          edge = childNode.edges[j];\n          // we only handle edges that are visible to the system, not the disabled ones from the clustering process.\n          if (this.clusteredEdges[edge.id] === undefined) {\n            // self-referencing edges will be added to the \"hidden\" list\n            if (edge.toId == edge.fromId) {\n              childEdgesObj[edge.id] = edge;\n            } else {\n              // set up the from and to.\n              if (edge.toId == childNodeId) {\n                // this is a double equals because ints and strings can be interchanged here.\n                toId = clusterNodeProperties.id;\n                fromId = edge.fromId;\n                otherNodeId = fromId;\n              } else {\n                toId = edge.toId;\n                fromId = clusterNodeProperties.id;\n                otherNodeId = toId;\n              }\n            }\n\n            // Only edges from the cluster outwards are being replaced.\n            if (childNodesObj[otherNodeId] === undefined) {\n              createEdges.push({\n                edge: edge,\n                fromId: fromId,\n                toId: toId\n              });\n            }\n          }\n        }\n      }\n\n      //\n      // Here we actually create the replacement edges.\n      //\n      // We could not do this in the loop above as the creation process\n      // would add an edge to the edges array we are iterating over.\n      //\n      // NOTE: a clustered edge can have multiple base edges!\n      //\n      var newEdges = [];\n\n      /**\n       * Find a cluster edge which matches the given created edge.\n       *\n       * @param {vis.Edge} createdEdge\n       * @returns {vis.Edge}\n       */\n      var getNewEdge = function getNewEdge(createdEdge) {\n        for (var _j2 = 0; _j2 < newEdges.length; _j2++) {\n          var newEdge = newEdges[_j2];\n\n          // We replace both to and from edges with a single cluster edge\n          var matchToDirection = createdEdge.fromId === newEdge.fromId && createdEdge.toId === newEdge.toId;\n          var matchFromDirection = createdEdge.fromId === newEdge.toId && createdEdge.toId === newEdge.fromId;\n          if (matchToDirection || matchFromDirection) {\n            return newEdge;\n          }\n        }\n        return null;\n      };\n      for (var _j3 = 0; _j3 < createEdges.length; _j3++) {\n        var createdEdge = createEdges[_j3];\n        var _edge = createdEdge.edge;\n        var newEdge = getNewEdge(createdEdge);\n        if (newEdge === null) {\n          // Create a clustered edge for this connection\n          newEdge = this._createClusteredEdge(createdEdge.fromId, createdEdge.toId, _edge, clusterEdgeProperties);\n          newEdges.push(newEdge);\n        } else {\n          newEdge.clusteringEdgeReplacingIds.push(_edge.id);\n        }\n\n        // also reference the new edge in the old edge\n        this.body.edges[_edge.id].edgeReplacedById = newEdge.id;\n\n        // hide the replaced edge\n        this._backupEdgeOptions(_edge);\n        _edge.setOptions({\n          physics: false\n        });\n      }\n    }\n\n    /**\n     * This function checks the options that can be supplied to the different cluster functions\n     * for certain fields and inserts defaults if needed\n     *\n     * @param {object} options\n     * @returns {*}\n     * @private\n     */\n  }, {\n    key: \"_checkOptions\",\n    value: function _checkOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (options.clusterEdgeProperties === undefined) {\n        options.clusterEdgeProperties = {};\n      }\n      if (options.clusterNodeProperties === undefined) {\n        options.clusterNodeProperties = {};\n      }\n      return options;\n    }\n\n    /**\n     *\n     * @param {object}    childNodesObj         | object with node objects, id as keys, same as childNodes except it also contains a source node\n     * @param {object}    childEdgesObj         | object with edge objects, id as keys\n     * @param {Array}     options               | object with {clusterNodeProperties, clusterEdgeProperties, processProperties}\n     * @param {boolean}   refreshData | when true, do not wrap up\n     * @private\n     */\n  }, {\n    key: \"_cluster\",\n    value: function _cluster(childNodesObj, childEdgesObj, options) {\n      var refreshData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      // Remove nodes which are already clustered\n      var tmpNodesToRemove = [];\n      for (var nodeId in childNodesObj) {\n        if (Object.prototype.hasOwnProperty.call(childNodesObj, nodeId)) {\n          if (this.clusteredNodes[nodeId] !== undefined) {\n            tmpNodesToRemove.push(nodeId);\n          }\n        }\n      }\n      for (var n = 0; n < tmpNodesToRemove.length; ++n) {\n        delete childNodesObj[tmpNodesToRemove[n]];\n      }\n\n      // kill condition: no nodes don't bother\n      if (_Object$keys(childNodesObj).length == 0) {\n        return;\n      }\n\n      // allow clusters of 1 if options allow\n      if (_Object$keys(childNodesObj).length == 1 && options.clusterNodeProperties.allowSingleNodeCluster != true) {\n        return;\n      }\n      var clusterNodeProperties = deepExtend({}, options.clusterNodeProperties);\n\n      // construct the clusterNodeProperties\n      if (options.processProperties !== undefined) {\n        // get the childNode options\n        var childNodesOptions = [];\n        for (var _nodeId in childNodesObj) {\n          if (Object.prototype.hasOwnProperty.call(childNodesObj, _nodeId)) {\n            var clonedOptions = NetworkUtil.cloneOptions(childNodesObj[_nodeId]);\n            childNodesOptions.push(clonedOptions);\n          }\n        }\n\n        // get cluster properties based on childNodes\n        var childEdgesOptions = [];\n        for (var edgeId in childEdgesObj) {\n          if (Object.prototype.hasOwnProperty.call(childEdgesObj, edgeId)) {\n            // these cluster edges will be removed on creation of the cluster.\n            if (edgeId.substr(0, 12) !== \"clusterEdge:\") {\n              var _clonedOptions = NetworkUtil.cloneOptions(childEdgesObj[edgeId], \"edge\");\n              childEdgesOptions.push(_clonedOptions);\n            }\n          }\n        }\n        clusterNodeProperties = options.processProperties(clusterNodeProperties, childNodesOptions, childEdgesOptions);\n        if (!clusterNodeProperties) {\n          throw new Error(\"The processProperties function does not return properties!\");\n        }\n      }\n\n      // check if we have an unique id;\n      if (clusterNodeProperties.id === undefined) {\n        clusterNodeProperties.id = \"cluster:\" + v4();\n      }\n      var clusterId = clusterNodeProperties.id;\n      if (clusterNodeProperties.label === undefined) {\n        clusterNodeProperties.label = \"cluster\";\n      }\n\n      // give the clusterNode a position if it does not have one.\n      var pos = undefined;\n      if (clusterNodeProperties.x === undefined) {\n        pos = this._getClusterPosition(childNodesObj);\n        clusterNodeProperties.x = pos.x;\n      }\n      if (clusterNodeProperties.y === undefined) {\n        if (pos === undefined) {\n          pos = this._getClusterPosition(childNodesObj);\n        }\n        clusterNodeProperties.y = pos.y;\n      }\n\n      // force the ID to remain the same\n      clusterNodeProperties.id = clusterId;\n\n      // create the cluster Node\n      // Note that allowSingleNodeCluster, if present, is stored in the options as well\n      var clusterNode = this.body.functions.createNode(clusterNodeProperties, Cluster);\n      clusterNode.containedNodes = childNodesObj;\n      clusterNode.containedEdges = childEdgesObj;\n      // cache a copy from the cluster edge properties if we have to reconnect others later on\n      clusterNode.clusterEdgeProperties = options.clusterEdgeProperties;\n\n      // finally put the cluster node into global\n      this.body.nodes[clusterNodeProperties.id] = clusterNode;\n      this._clusterEdges(childNodesObj, childEdgesObj, clusterNodeProperties, options.clusterEdgeProperties);\n\n      // set ID to undefined so no duplicates arise\n      clusterNodeProperties.id = undefined;\n\n      // wrap up\n      if (refreshData === true) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n\n    /**\n     *\n     * @param {Edge} edge\n     * @private\n     */\n  }, {\n    key: \"_backupEdgeOptions\",\n    value: function _backupEdgeOptions(edge) {\n      if (this.clusteredEdges[edge.id] === undefined) {\n        this.clusteredEdges[edge.id] = {\n          physics: edge.options.physics\n        };\n      }\n    }\n\n    /**\n     *\n     * @param {Edge} edge\n     * @private\n     */\n  }, {\n    key: \"_restoreEdge\",\n    value: function _restoreEdge(edge) {\n      var originalOptions = this.clusteredEdges[edge.id];\n      if (originalOptions !== undefined) {\n        edge.setOptions({\n          physics: originalOptions.physics\n        });\n        delete this.clusteredEdges[edge.id];\n      }\n    }\n\n    /**\n     * Check if a node is a cluster.\n     *\n     * @param {Node.id} nodeId\n     * @returns {*}\n     */\n  }, {\n    key: \"isCluster\",\n    value: function isCluster(nodeId) {\n      if (this.body.nodes[nodeId] !== undefined) {\n        return this.body.nodes[nodeId].isCluster === true;\n      } else {\n        console.error(\"Node does not exist.\");\n        return false;\n      }\n    }\n\n    /**\n     * get the position of the cluster node based on what's inside\n     *\n     * @param {object} childNodesObj    | object with node objects, id as keys\n     * @returns {{x: number, y: number}}\n     * @private\n     */\n  }, {\n    key: \"_getClusterPosition\",\n    value: function _getClusterPosition(childNodesObj) {\n      var childKeys = _Object$keys(childNodesObj);\n      var minX = childNodesObj[childKeys[0]].x;\n      var maxX = childNodesObj[childKeys[0]].x;\n      var minY = childNodesObj[childKeys[0]].y;\n      var maxY = childNodesObj[childKeys[0]].y;\n      var node;\n      for (var i = 1; i < childKeys.length; i++) {\n        node = childNodesObj[childKeys[i]];\n        minX = node.x < minX ? node.x : minX;\n        maxX = node.x > maxX ? node.x : maxX;\n        minY = node.y < minY ? node.y : minY;\n        maxY = node.y > maxY ? node.y : maxY;\n      }\n      return {\n        x: 0.5 * (minX + maxX),\n        y: 0.5 * (minY + maxY)\n      };\n    }\n\n    /**\n     * Open a cluster by calling this function.\n     *\n     * @param {vis.Edge.id}  clusterNodeId | the ID of the cluster node\n     * @param {object} options\n     * @param {boolean} refreshData | wrap up afterwards if not true\n     */\n  }, {\n    key: \"openCluster\",\n    value: function openCluster(clusterNodeId, options) {\n      var refreshData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      // kill conditions\n      if (clusterNodeId === undefined) {\n        throw new Error(\"No clusterNodeId supplied to openCluster.\");\n      }\n      var clusterNode = this.body.nodes[clusterNodeId];\n      if (clusterNode === undefined) {\n        throw new Error(\"The clusterNodeId supplied to openCluster does not exist.\");\n      }\n      if (clusterNode.isCluster !== true || clusterNode.containedNodes === undefined || clusterNode.containedEdges === undefined) {\n        throw new Error(\"The node:\" + clusterNodeId + \" is not a valid cluster.\");\n      }\n\n      // Check if current cluster is clustered itself\n      var stack = this.findNode(clusterNodeId);\n      var parentIndex = _indexOfInstanceProperty(stack).call(stack, clusterNodeId) - 1;\n      if (parentIndex >= 0) {\n        // Current cluster is clustered; transfer contained nodes and edges to parent\n        var parentClusterNodeId = stack[parentIndex];\n        var parentClusterNode = this.body.nodes[parentClusterNodeId];\n\n        // clustering.clusteredNodes and clustering.clusteredEdges remain unchanged\n        parentClusterNode._openChildCluster(clusterNodeId);\n\n        // All components of child cluster node have been transferred. It can die now.\n        delete this.body.nodes[clusterNodeId];\n        if (refreshData === true) {\n          this.body.emitter.emit(\"_dataChanged\");\n        }\n        return;\n      }\n\n      // main body\n      var containedNodes = clusterNode.containedNodes;\n      var containedEdges = clusterNode.containedEdges;\n\n      // allow the user to position the nodes after release.\n      if (options !== undefined && options.releaseFunction !== undefined && typeof options.releaseFunction === \"function\") {\n        var positions = {};\n        var clusterPosition = {\n          x: clusterNode.x,\n          y: clusterNode.y\n        };\n        for (var nodeId in containedNodes) {\n          if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {\n            var containedNode = this.body.nodes[nodeId];\n            positions[nodeId] = {\n              x: containedNode.x,\n              y: containedNode.y\n            };\n          }\n        }\n        var newPositions = options.releaseFunction(clusterPosition, positions);\n        for (var _nodeId2 in containedNodes) {\n          if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId2)) {\n            var _containedNode = this.body.nodes[_nodeId2];\n            if (newPositions[_nodeId2] !== undefined) {\n              _containedNode.x = newPositions[_nodeId2].x === undefined ? clusterNode.x : newPositions[_nodeId2].x;\n              _containedNode.y = newPositions[_nodeId2].y === undefined ? clusterNode.y : newPositions[_nodeId2].y;\n            }\n          }\n        }\n      } else {\n        // copy the position from the cluster\n        forEach$1(containedNodes, function (containedNode) {\n          // inherit position\n          if (containedNode.options.fixed.x === false) {\n            containedNode.x = clusterNode.x;\n          }\n          if (containedNode.options.fixed.y === false) {\n            containedNode.y = clusterNode.y;\n          }\n        });\n      }\n\n      // release nodes\n      for (var _nodeId3 in containedNodes) {\n        if (Object.prototype.hasOwnProperty.call(containedNodes, _nodeId3)) {\n          var _containedNode2 = this.body.nodes[_nodeId3];\n\n          // inherit speed\n          _containedNode2.vx = clusterNode.vx;\n          _containedNode2.vy = clusterNode.vy;\n          _containedNode2.setOptions({\n            physics: true\n          });\n          delete this.clusteredNodes[_nodeId3];\n        }\n      }\n\n      // copy the clusterNode edges because we cannot iterate over an object that we add or remove from.\n      var edgesToBeDeleted = [];\n      for (var i = 0; i < clusterNode.edges.length; i++) {\n        edgesToBeDeleted.push(clusterNode.edges[i]);\n      }\n\n      // actually handling the deleting.\n      for (var _i3 = 0; _i3 < edgesToBeDeleted.length; _i3++) {\n        var edge = edgesToBeDeleted[_i3];\n        var otherNodeId = this._getConnectedId(edge, clusterNodeId);\n        var otherNode = this.clusteredNodes[otherNodeId];\n        for (var j = 0; j < edge.clusteringEdgeReplacingIds.length; j++) {\n          var transferId = edge.clusteringEdgeReplacingIds[j];\n          var transferEdge = this.body.edges[transferId];\n          if (transferEdge === undefined) continue;\n\n          // if the other node is in another cluster, we transfer ownership of this edge to the other cluster\n          if (otherNode !== undefined) {\n            // transfer ownership:\n            var otherCluster = this.body.nodes[otherNode.clusterId];\n            otherCluster.containedEdges[transferEdge.id] = transferEdge;\n\n            // delete local reference\n            delete containedEdges[transferEdge.id];\n\n            // get to and from\n            var fromId = transferEdge.fromId;\n            var toId = transferEdge.toId;\n            if (transferEdge.toId == otherNodeId) {\n              toId = otherNode.clusterId;\n            } else {\n              fromId = otherNode.clusterId;\n            }\n\n            // create new cluster edge from the otherCluster\n            this._createClusteredEdge(fromId, toId, transferEdge, otherCluster.clusterEdgeProperties, {\n              hidden: false,\n              physics: true\n            });\n          } else {\n            this._restoreEdge(transferEdge);\n          }\n        }\n        edge.remove();\n      }\n\n      // handle the releasing of the edges\n      for (var edgeId in containedEdges) {\n        if (Object.prototype.hasOwnProperty.call(containedEdges, edgeId)) {\n          this._restoreEdge(containedEdges[edgeId]);\n        }\n      }\n\n      // remove clusterNode\n      delete this.body.nodes[clusterNodeId];\n      if (refreshData === true) {\n        this.body.emitter.emit(\"_dataChanged\");\n      }\n    }\n\n    /**\n     *\n     * @param {Cluster.id} clusterId\n     * @returns {Array.<Node.id>}\n     */\n  }, {\n    key: \"getNodesInCluster\",\n    value: function getNodesInCluster(clusterId) {\n      var nodesArray = [];\n      if (this.isCluster(clusterId) === true) {\n        var containedNodes = this.body.nodes[clusterId].containedNodes;\n        for (var nodeId in containedNodes) {\n          if (Object.prototype.hasOwnProperty.call(containedNodes, nodeId)) {\n            nodesArray.push(this.body.nodes[nodeId].id);\n          }\n        }\n      }\n      return nodesArray;\n    }\n\n    /**\n     * Get the stack clusterId's that a certain node resides in. cluster A -> cluster B -> cluster C -> node\n     *\n     * If a node can't be found in the chain, return an empty array.\n     *\n     * @param {string|number} nodeId\n     * @returns {Array}\n     */\n  }, {\n    key: \"findNode\",\n    value: function findNode(nodeId) {\n      var stack = [];\n      var max = 100;\n      var counter = 0;\n      var node;\n      while (this.clusteredNodes[nodeId] !== undefined && counter < max) {\n        node = this.body.nodes[nodeId];\n        if (node === undefined) return [];\n        stack.push(node.id);\n        nodeId = this.clusteredNodes[nodeId].clusterId;\n        counter++;\n      }\n      node = this.body.nodes[nodeId];\n      if (node === undefined) return [];\n      stack.push(node.id);\n      _reverseInstanceProperty(stack).call(stack);\n      return stack;\n    }\n\n    /**\n     * Using a clustered nodeId, update with the new options\n     *\n     * @param {Node.id} clusteredNodeId\n     * @param {object} newOptions\n     */\n  }, {\n    key: \"updateClusteredNode\",\n    value: function updateClusteredNode(clusteredNodeId, newOptions) {\n      if (clusteredNodeId === undefined) {\n        throw new Error(\"No clusteredNodeId supplied to updateClusteredNode.\");\n      }\n      if (newOptions === undefined) {\n        throw new Error(\"No newOptions supplied to updateClusteredNode.\");\n      }\n      if (this.body.nodes[clusteredNodeId] === undefined) {\n        throw new Error(\"The clusteredNodeId supplied to updateClusteredNode does not exist.\");\n      }\n      this.body.nodes[clusteredNodeId].setOptions(newOptions);\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n\n    /**\n     * Using a base edgeId, update all related clustered edges with the new options\n     *\n     * @param {vis.Edge.id} startEdgeId\n     * @param {object} newOptions\n     */\n  }, {\n    key: \"updateEdge\",\n    value: function updateEdge(startEdgeId, newOptions) {\n      if (startEdgeId === undefined) {\n        throw new Error(\"No startEdgeId supplied to updateEdge.\");\n      }\n      if (newOptions === undefined) {\n        throw new Error(\"No newOptions supplied to updateEdge.\");\n      }\n      if (this.body.edges[startEdgeId] === undefined) {\n        throw new Error(\"The startEdgeId supplied to updateEdge does not exist.\");\n      }\n      var allEdgeIds = this.getClusteredEdges(startEdgeId);\n      for (var i = 0; i < allEdgeIds.length; i++) {\n        var edge = this.body.edges[allEdgeIds[i]];\n        edge.setOptions(newOptions);\n      }\n      this.body.emitter.emit(\"_dataChanged\");\n    }\n\n    /**\n     * Get a stack of clusterEdgeId's (+base edgeid) that a base edge is the same as. cluster edge C -> cluster edge B -> cluster edge A -> base edge(edgeId)\n     *\n     * @param {vis.Edge.id} edgeId\n     * @returns {Array.<vis.Edge.id>}\n     */\n  }, {\n    key: \"getClusteredEdges\",\n    value: function getClusteredEdges(edgeId) {\n      var stack = [];\n      var max = 100;\n      var counter = 0;\n      while (edgeId !== undefined && this.body.edges[edgeId] !== undefined && counter < max) {\n        stack.push(this.body.edges[edgeId].id);\n        edgeId = this.body.edges[edgeId].edgeReplacedById;\n        counter++;\n      }\n      _reverseInstanceProperty(stack).call(stack);\n      return stack;\n    }\n\n    /**\n     * Get the base edge id of clusterEdgeId. cluster edge (clusteredEdgeId) -> cluster edge B -> cluster edge C -> base edge\n     *\n     * @param {vis.Edge.id} clusteredEdgeId\n     * @returns {vis.Edge.id} baseEdgeId\n     *\n     * TODO: deprecate in 5.0.0. Method getBaseEdges() is the correct one to use.\n     */\n  }, {\n    key: \"getBaseEdge\",\n    value: function getBaseEdge(clusteredEdgeId) {\n      // Just kludge this by returning the first base edge id found\n      return this.getBaseEdges(clusteredEdgeId)[0];\n    }\n\n    /**\n     * Get all regular edges for this clustered edge id.\n     *\n     * @param {vis.Edge.id} clusteredEdgeId\n     * @returns {Array.<vis.Edge.id>} all baseEdgeId's under this clustered edge\n     */\n  }, {\n    key: \"getBaseEdges\",\n    value: function getBaseEdges(clusteredEdgeId) {\n      var IdsToHandle = [clusteredEdgeId];\n      var doneIds = [];\n      var foundIds = [];\n      var max = 100;\n      var counter = 0;\n      while (IdsToHandle.length > 0 && counter < max) {\n        var nextId = IdsToHandle.pop();\n        if (nextId === undefined) continue; // Paranoia here and onwards\n        var nextEdge = this.body.edges[nextId];\n        if (nextEdge === undefined) continue;\n        counter++;\n        var replacingIds = nextEdge.clusteringEdgeReplacingIds;\n        if (replacingIds === undefined) {\n          // nextId is a base id\n          foundIds.push(nextId);\n        } else {\n          // Another cluster edge, unravel this one as well\n          for (var i = 0; i < replacingIds.length; ++i) {\n            var replacingId = replacingIds[i];\n\n            // Don't add if already handled\n            // TODO: never triggers; find a test-case which does\n            if (_indexOfInstanceProperty(IdsToHandle).call(IdsToHandle, replacingIds) !== -1 || _indexOfInstanceProperty(doneIds).call(doneIds, replacingIds) !== -1) {\n              continue;\n            }\n            IdsToHandle.push(replacingId);\n          }\n        }\n        doneIds.push(nextId);\n      }\n      return foundIds;\n    }\n\n    /**\n     * Get the Id the node is connected to\n     *\n     * @param {vis.Edge} edge\n     * @param {Node.id} nodeId\n     * @returns {*}\n     * @private\n     */\n  }, {\n    key: \"_getConnectedId\",\n    value: function _getConnectedId(edge, nodeId) {\n      if (edge.toId != nodeId) {\n        return edge.toId;\n      } else if (edge.fromId != nodeId) {\n        return edge.fromId;\n      } else {\n        return edge.fromId;\n      }\n    }\n\n    /**\n     * We determine how many connections denote an important hub.\n     * We take the mean + 2*std as the important hub size. (Assuming a normal distribution of data, ~2.2%)\n     *\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_getHubSize\",\n    value: function _getHubSize() {\n      var average = 0;\n      var averageSquared = 0;\n      var hubCounter = 0;\n      var largestHub = 0;\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var node = this.body.nodes[this.body.nodeIndices[i]];\n        if (node.edges.length > largestHub) {\n          largestHub = node.edges.length;\n        }\n        average += node.edges.length;\n        averageSquared += Math.pow(node.edges.length, 2);\n        hubCounter += 1;\n      }\n      average = average / hubCounter;\n      averageSquared = averageSquared / hubCounter;\n      var variance = averageSquared - Math.pow(average, 2);\n      var standardDeviation = Math.sqrt(variance);\n      var hubThreshold = Math.floor(average + 2 * standardDeviation);\n\n      // always have at least one to cluster\n      if (hubThreshold > largestHub) {\n        hubThreshold = largestHub;\n      }\n      return hubThreshold;\n    }\n\n    /**\n     * Create an edge for the cluster representation.\n     *\n     * @param {Node.id} fromId\n     * @param {Node.id} toId\n     * @param {vis.Edge} baseEdge\n     * @param {object} clusterEdgeProperties\n     * @param {object} extraOptions\n     * @returns {Edge} newly created clustered edge\n     * @private\n     */\n  }, {\n    key: \"_createClusteredEdge\",\n    value: function _createClusteredEdge(fromId, toId, baseEdge, clusterEdgeProperties, extraOptions) {\n      // copy the options of the edge we will replace\n      var clonedOptions = NetworkUtil.cloneOptions(baseEdge, \"edge\");\n      // make sure the properties of clusterEdges are superimposed on it\n      deepExtend(clonedOptions, clusterEdgeProperties);\n\n      // set up the edge\n      clonedOptions.from = fromId;\n      clonedOptions.to = toId;\n      clonedOptions.id = \"clusterEdge:\" + v4();\n\n      // apply the edge specific options to it if specified\n      if (extraOptions !== undefined) {\n        deepExtend(clonedOptions, extraOptions);\n      }\n      var newEdge = this.body.functions.createEdge(clonedOptions);\n      newEdge.clusteringEdgeReplacingIds = [baseEdge.id];\n      newEdge.connect();\n\n      // Register the new edge\n      this.body.edges[newEdge.id] = newEdge;\n      return newEdge;\n    }\n\n    /**\n     * Add the passed child nodes and edges to the given cluster node.\n     *\n     * @param {object | Node} childNodes  hash of nodes or single node to add in cluster\n     * @param {object | Edge} childEdges  hash of edges or single edge to take into account when clustering\n     * @param {Node} clusterNode  cluster node to add nodes and edges to\n     * @param {object} [clusterEdgeProperties]\n     * @private\n     */\n  }, {\n    key: \"_clusterEdges\",\n    value: function _clusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties) {\n      if (childEdges instanceof Edge) {\n        var edge = childEdges;\n        var obj = {};\n        obj[edge.id] = edge;\n        childEdges = obj;\n      }\n      if (childNodes instanceof Node) {\n        var node = childNodes;\n        var _obj = {};\n        _obj[node.id] = node;\n        childNodes = _obj;\n      }\n      if (clusterNode === undefined || clusterNode === null) {\n        throw new Error(\"_clusterEdges: parameter clusterNode required\");\n      }\n      if (clusterEdgeProperties === undefined) {\n        // Take the required properties from the cluster node\n        clusterEdgeProperties = clusterNode.clusterEdgeProperties;\n      }\n\n      // create the new edges that will connect to the cluster.\n      // All self-referencing edges will be added to childEdges here.\n      this._createClusterEdges(childNodes, childEdges, clusterNode, clusterEdgeProperties);\n\n      // disable the childEdges\n      for (var edgeId in childEdges) {\n        if (Object.prototype.hasOwnProperty.call(childEdges, edgeId)) {\n          if (this.body.edges[edgeId] !== undefined) {\n            var _edge2 = this.body.edges[edgeId];\n            // cache the options before changing\n            this._backupEdgeOptions(_edge2);\n            // disable physics and hide the edge\n            _edge2.setOptions({\n              physics: false\n            });\n          }\n        }\n      }\n\n      // disable the childNodes\n      for (var nodeId in childNodes) {\n        if (Object.prototype.hasOwnProperty.call(childNodes, nodeId)) {\n          this.clusteredNodes[nodeId] = {\n            clusterId: clusterNode.id,\n            node: this.body.nodes[nodeId]\n          };\n          this.body.nodes[nodeId].setOptions({\n            physics: false\n          });\n        }\n      }\n    }\n\n    /**\n     * Determine in which cluster given nodeId resides.\n     *\n     * If not in cluster, return undefined.\n     *\n     * NOTE: If you know a cleaner way to do this, please enlighten me (wimrijnders).\n     *\n     * @param {Node.id} nodeId\n     * @returns {Node|undefined} Node instance for cluster, if present\n     * @private\n     */\n  }, {\n    key: \"_getClusterNodeForNode\",\n    value: function _getClusterNodeForNode(nodeId) {\n      if (nodeId === undefined) return undefined;\n      var clusteredNode = this.clusteredNodes[nodeId];\n\n      // NOTE: If no cluster info found, it should actually be an error\n      if (clusteredNode === undefined) return undefined;\n      var clusterId = clusteredNode.clusterId;\n      if (clusterId === undefined) return undefined;\n      return this.body.nodes[clusterId];\n    }\n\n    /**\n     * Internal helper function for conditionally removing items in array\n     *\n     * Done like this because Array.filter() is not fully supported by all IE's.\n     *\n     * @param {Array} arr\n     * @param {Function} callback\n     * @returns {Array}\n     * @private\n     */\n  }, {\n    key: \"_filter\",\n    value: function _filter(arr, callback) {\n      var ret = [];\n      forEach$1(arr, function (item) {\n        if (callback(item)) {\n          ret.push(item);\n        }\n      });\n      return ret;\n    }\n\n    /**\n     * Scan all edges for changes in clustering and adjust this if necessary.\n     *\n     * Call this (internally) after there has been a change in node or edge data.\n     *\n     * Pre: States of this.body.nodes and this.body.edges consistent\n     * Pre: this.clusteredNodes and this.clusteredEdge consistent with containedNodes and containedEdges\n     *      of cluster nodes.\n     */\n  }, {\n    key: \"_updateState\",\n    value: function _updateState() {\n      var _this4 = this;\n      var nodeId;\n      var deletedNodeIds = [];\n      var deletedEdgeIds = {};\n\n      /**\n       * Utility function to iterate over clustering nodes only\n       *\n       * @param {Function} callback  function to call for each cluster node\n       */\n      var eachClusterNode = function eachClusterNode(callback) {\n        forEach$1(_this4.body.nodes, function (node) {\n          if (node.isCluster === true) {\n            callback(node);\n          }\n        });\n      };\n\n      //\n      // Remove deleted regular nodes from clustering\n      //\n\n      // Determine the deleted nodes\n      for (nodeId in this.clusteredNodes) {\n        if (!Object.prototype.hasOwnProperty.call(this.clusteredNodes, nodeId)) continue;\n        var node = this.body.nodes[nodeId];\n        if (node === undefined) {\n          deletedNodeIds.push(nodeId);\n        }\n      }\n\n      // Remove nodes from cluster nodes\n      eachClusterNode(function (clusterNode) {\n        for (var n = 0; n < deletedNodeIds.length; n++) {\n          delete clusterNode.containedNodes[deletedNodeIds[n]];\n        }\n      });\n\n      // Remove nodes from cluster list\n      for (var n = 0; n < deletedNodeIds.length; n++) {\n        delete this.clusteredNodes[deletedNodeIds[n]];\n      }\n\n      //\n      // Remove deleted edges from clustering\n      //\n\n      // Add the deleted clustered edges to the list\n      forEach$1(this.clusteredEdges, function (edgeId) {\n        var edge = _this4.body.edges[edgeId];\n        if (edge === undefined || !edge.endPointsValid()) {\n          deletedEdgeIds[edgeId] = edgeId;\n        }\n      });\n\n      // Cluster nodes can also contain edges which are not clustered,\n      // i.e. nodes 1-2 within cluster with an edge in between.\n      // So the cluster nodes also need to be scanned for invalid edges\n      eachClusterNode(function (clusterNode) {\n        forEach$1(clusterNode.containedEdges, function (edge, edgeId) {\n          if (!edge.endPointsValid() && !deletedEdgeIds[edgeId]) {\n            deletedEdgeIds[edgeId] = edgeId;\n          }\n        });\n      });\n\n      // Also scan for cluster edges which need to be removed in the active list.\n      // Regular edges have been removed beforehand, so this only picks up the cluster edges.\n      forEach$1(this.body.edges, function (edge, edgeId) {\n        // Explicitly scan the contained edges for validity\n        var isValid = true;\n        var replacedIds = edge.clusteringEdgeReplacingIds;\n        if (replacedIds !== undefined) {\n          var numValid = 0;\n          forEach$1(replacedIds, function (containedEdgeId) {\n            var containedEdge = _this4.body.edges[containedEdgeId];\n            if (containedEdge !== undefined && containedEdge.endPointsValid()) {\n              numValid += 1;\n            }\n          });\n          isValid = numValid > 0;\n        }\n        if (!edge.endPointsValid() || !isValid) {\n          deletedEdgeIds[edgeId] = edgeId;\n        }\n      });\n\n      // Remove edges from cluster nodes\n      eachClusterNode(function (clusterNode) {\n        forEach$1(deletedEdgeIds, function (deletedEdgeId) {\n          delete clusterNode.containedEdges[deletedEdgeId];\n          forEach$1(clusterNode.edges, function (edge, m) {\n            if (edge.id === deletedEdgeId) {\n              clusterNode.edges[m] = null; // Don't want to directly delete here, because in the loop\n              return;\n            }\n            edge.clusteringEdgeReplacingIds = _this4._filter(edge.clusteringEdgeReplacingIds, function (id) {\n              return !deletedEdgeIds[id];\n            });\n          });\n\n          // Clean up the nulls\n          clusterNode.edges = _this4._filter(clusterNode.edges, function (item) {\n            return item !== null;\n          });\n        });\n      });\n\n      // Remove from cluster list\n      forEach$1(deletedEdgeIds, function (edgeId) {\n        delete _this4.clusteredEdges[edgeId];\n      });\n\n      // Remove cluster edges from active list (this.body.edges).\n      // deletedEdgeIds still contains id of regular edges, but these should all\n      // be gone when you reach here.\n      forEach$1(deletedEdgeIds, function (edgeId) {\n        delete _this4.body.edges[edgeId];\n      });\n\n      //\n      // Check changed cluster state of edges\n      //\n\n      // Iterating over keys here, because edges may be removed in the loop\n      var ids = _Object$keys(this.body.edges);\n      forEach$1(ids, function (edgeId) {\n        var edge = _this4.body.edges[edgeId];\n        var shouldBeClustered = _this4._isClusteredNode(edge.fromId) || _this4._isClusteredNode(edge.toId);\n        if (shouldBeClustered === _this4._isClusteredEdge(edge.id)) {\n          return; // all is well\n        }\n\n        if (shouldBeClustered) {\n          // add edge to clustering\n          var clusterFrom = _this4._getClusterNodeForNode(edge.fromId);\n          if (clusterFrom !== undefined) {\n            _this4._clusterEdges(_this4.body.nodes[edge.fromId], edge, clusterFrom);\n          }\n          var clusterTo = _this4._getClusterNodeForNode(edge.toId);\n          if (clusterTo !== undefined) {\n            _this4._clusterEdges(_this4.body.nodes[edge.toId], edge, clusterTo);\n          }\n\n          // TODO: check that it works for both edges clustered\n          //       (This might be paranoia)\n        } else {\n          delete _this4._clusterEdges[edgeId];\n          _this4._restoreEdge(edge);\n          // This should not be happening, the state should\n          // be properly updated at this point.\n          //\n          // If it *is* reached during normal operation, then we have to implement\n          // undo clustering for this edge here.\n          // throw new Error('remove edge from clustering not implemented!')\n        }\n      });\n\n      // Clusters may be nested to any level. Keep on opening until nothing to open\n      var changed = false;\n      var continueLoop = true;\n      var _loop2 = function _loop2() {\n        var clustersToOpen = [];\n\n        // Determine the id's of clusters that need opening\n        eachClusterNode(function (clusterNode) {\n          var numNodes = _Object$keys(clusterNode.containedNodes).length;\n          var allowSingle = clusterNode.options.allowSingleNodeCluster === true;\n          if (allowSingle && numNodes < 1 || !allowSingle && numNodes < 2) {\n            clustersToOpen.push(clusterNode.id);\n          }\n        });\n\n        // Open them\n        for (var _n = 0; _n < clustersToOpen.length; ++_n) {\n          _this4.openCluster(clustersToOpen[_n], {}, false /* Don't refresh, we're in an refresh/update already */);\n        }\n\n        continueLoop = clustersToOpen.length > 0;\n        changed = changed || continueLoop;\n      };\n      while (continueLoop) {\n        _loop2();\n      }\n      if (changed) {\n        this._updateState(); // Redo this method (recursion possible! should be safe)\n      }\n    }\n\n    /**\n     * Determine if node with given id is part of a cluster.\n     *\n     * @param {Node.id} nodeId\n     * @returns {boolean} true if part of a cluster.\n     */\n  }, {\n    key: \"_isClusteredNode\",\n    value: function _isClusteredNode(nodeId) {\n      return this.clusteredNodes[nodeId] !== undefined;\n    }\n\n    /**\n     * Determine if edge with given id is not visible due to clustering.\n     *\n     * An edge is considered clustered if:\n     * - it is directly replaced by a clustering edge\n     * - any of its connecting nodes is in a cluster\n     *\n     * @param {vis.Edge.id} edgeId\n     * @returns {boolean} true if part of a cluster.\n     */\n  }, {\n    key: \"_isClusteredEdge\",\n    value: function _isClusteredEdge(edgeId) {\n      return this.clusteredEdges[edgeId] !== undefined;\n    }\n  }]);\n  return ClusterEngine;\n}();\n\n/**\n * Initializes window.requestAnimationFrame() to a usable form.\n *\n * Specifically, set up this method for the case of running on node.js with jsdom enabled.\n *\n * NOTES:\n *\n * On node.js, when calling this directly outside of this class, `window` is not defined.\n *   This happens even if jsdom is used.\n * For node.js + jsdom, `window` is available at the moment the constructor is called.\n *   For this reason, the called is placed within the constructor.\n * Even then, `window.requestAnimationFrame()` is not defined, so it still needs to be added.\n * During unit testing, it happens that the window object is reset during execution, causing\n *   a runtime error due to missing `requestAnimationFrame()`. This needs to be compensated for,\n *   see `_requestNextFrame()`.\n * Since this is a global object, it may affect other modules besides `Network`. With normal\n *   usage, this does not cause any problems. During unit testing, errors may occur. These have\n *   been compensated for, see comment block in _requestNextFrame().\n *\n * @private\n */\nfunction _initRequestAnimationFrame() {\n  var func;\n  if (window !== undefined) {\n    func = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;\n  }\n  if (func === undefined) {\n    // window or method not present, setting mock requestAnimationFrame\n    window.requestAnimationFrame = function (callback) {\n      //console.log(\"Called mock requestAnimationFrame\");\n      callback();\n    };\n  } else {\n    window.requestAnimationFrame = func;\n  }\n}\n\n/**\n * The canvas renderer\n */\nvar CanvasRenderer = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   */\n  function CanvasRenderer(body, canvas) {\n    _classCallCheck(this, CanvasRenderer);\n    _initRequestAnimationFrame();\n    this.body = body;\n    this.canvas = canvas;\n    this.redrawRequested = false;\n    this.renderTimer = undefined;\n    this.requiresTimeout = true;\n    this.renderingActive = false;\n    this.renderRequests = 0;\n    this.allowRedraw = true;\n    this.dragging = false;\n    this.zooming = false;\n    this.options = {};\n    this.defaultOptions = {\n      hideEdgesOnDrag: false,\n      hideEdgesOnZoom: false,\n      hideNodesOnDrag: false\n    };\n    _Object$assign(this.options, this.defaultOptions);\n    this._determineBrowserMethod();\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n  _createClass(CanvasRenderer, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this = this,\n        _context2;\n      this.body.emitter.on(\"dragStart\", function () {\n        _this.dragging = true;\n      });\n      this.body.emitter.on(\"dragEnd\", function () {\n        _this.dragging = false;\n      });\n      this.body.emitter.on(\"zoom\", function () {\n        _this.zooming = true;\n        window.clearTimeout(_this.zoomTimeoutId);\n        _this.zoomTimeoutId = _setTimeout(function () {\n          var _context;\n          _this.zooming = false;\n          _bindInstanceProperty$1(_context = _this._requestRedraw).call(_context, _this)();\n        }, 250);\n      });\n      this.body.emitter.on(\"_resizeNodes\", function () {\n        _this._resizeNodes();\n      });\n      this.body.emitter.on(\"_redraw\", function () {\n        if (_this.renderingActive === false) {\n          _this._redraw();\n        }\n      });\n      this.body.emitter.on(\"_blockRedraw\", function () {\n        _this.allowRedraw = false;\n      });\n      this.body.emitter.on(\"_allowRedraw\", function () {\n        _this.allowRedraw = true;\n        _this.redrawRequested = false;\n      });\n      this.body.emitter.on(\"_requestRedraw\", _bindInstanceProperty$1(_context2 = this._requestRedraw).call(_context2, this));\n      this.body.emitter.on(\"_startRendering\", function () {\n        _this.renderRequests += 1;\n        _this.renderingActive = true;\n        _this._startRendering();\n      });\n      this.body.emitter.on(\"_stopRendering\", function () {\n        _this.renderRequests -= 1;\n        _this.renderingActive = _this.renderRequests > 0;\n        _this.renderTimer = undefined;\n      });\n      this.body.emitter.on(\"destroy\", function () {\n        _this.renderRequests = 0;\n        _this.allowRedraw = false;\n        _this.renderingActive = false;\n        if (_this.requiresTimeout === true) {\n          clearTimeout(_this.renderTimer);\n        } else {\n          window.cancelAnimationFrame(_this.renderTimer);\n        }\n        _this.body.emitter.off();\n      });\n    }\n\n    /**\n     *\n     * @param {object} options\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        var fields = [\"hideEdgesOnDrag\", \"hideEdgesOnZoom\", \"hideNodesOnDrag\"];\n        selectiveDeepExtend(fields, this.options, options);\n      }\n    }\n\n    /**\n     * Prepare the drawing of the next frame.\n     *\n     * Calls the callback when the next frame can or will be drawn.\n     *\n     * @param {Function} callback\n     * @param {number} delay - timeout case only, wait this number of milliseconds\n     * @returns {Function | undefined}\n     * @private\n     */\n  }, {\n    key: \"_requestNextFrame\",\n    value: function _requestNextFrame(callback, delay) {\n      // During unit testing, it happens that the mock window object is reset while\n      // the next frame is still pending. Then, either 'window' is not present, or\n      // 'requestAnimationFrame()' is not present because it is not defined on the\n      // mock window object.\n      //\n      // As a consequence, unrelated unit tests may appear to fail, even if the problem\n      // described happens in the current unit test.\n      //\n      // This is not something that will happen in normal operation, but we still need\n      // to take it into account.\n      //\n      if (typeof window === \"undefined\") return; // Doing `if (window === undefined)` does not work here!\n\n      var timer;\n      var myWindow = window; // Grab a reference to reduce the possibility that 'window' is reset\n      // while running this method.\n\n      if (this.requiresTimeout === true) {\n        // wait given number of milliseconds and perform the animation step function\n        timer = _setTimeout(callback, delay);\n      } else {\n        if (myWindow.requestAnimationFrame) {\n          timer = myWindow.requestAnimationFrame(callback);\n        }\n      }\n      return timer;\n    }\n\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_startRendering\",\n    value: function _startRendering() {\n      if (this.renderingActive === true) {\n        if (this.renderTimer === undefined) {\n          var _context3;\n          this.renderTimer = this._requestNextFrame(_bindInstanceProperty$1(_context3 = this._renderStep).call(_context3, this), this.simulationInterval);\n        }\n      }\n    }\n\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_renderStep\",\n    value: function _renderStep() {\n      if (this.renderingActive === true) {\n        // reset the renderTimer so a new scheduled animation step can be set\n        this.renderTimer = undefined;\n        if (this.requiresTimeout === true) {\n          // this schedules a new simulation step\n          this._startRendering();\n        }\n        this._redraw();\n        if (this.requiresTimeout === false) {\n          // this schedules a new simulation step\n          this._startRendering();\n        }\n      }\n    }\n\n    /**\n     * Redraw the network with the current data\n     * chart will be resized too.\n     */\n  }, {\n    key: \"redraw\",\n    value: function redraw() {\n      this.body.emitter.emit(\"setSize\");\n      this._redraw();\n    }\n\n    /**\n     * Redraw the network with the current data\n     *\n     * @private\n     */\n  }, {\n    key: \"_requestRedraw\",\n    value: function _requestRedraw() {\n      var _this2 = this;\n      if (this.redrawRequested !== true && this.renderingActive === false && this.allowRedraw === true) {\n        this.redrawRequested = true;\n        this._requestNextFrame(function () {\n          _this2._redraw(false);\n        }, 0);\n      }\n    }\n\n    /**\n     * Redraw the network with the current data\n     *\n     * @param {boolean} [hidden=false] | Used to get the first estimate of the node sizes.\n     *                                   Only the nodes are drawn after which they are quickly drawn over.\n     * @private\n     */\n  }, {\n    key: \"_redraw\",\n    value: function _redraw() {\n      var hidden = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (this.allowRedraw === true) {\n        this.body.emitter.emit(\"initRedraw\");\n        this.redrawRequested = false;\n        var drawLater = {\n          drawExternalLabels: null\n        };\n\n        // when the container div was hidden, this fixes it back up!\n        if (this.canvas.frame.canvas.width === 0 || this.canvas.frame.canvas.height === 0) {\n          this.canvas.setSize();\n        }\n        this.canvas.setTransform();\n        var ctx = this.canvas.getContext();\n\n        // clear the canvas\n        var w = this.canvas.frame.canvas.clientWidth;\n        var h = this.canvas.frame.canvas.clientHeight;\n        ctx.clearRect(0, 0, w, h);\n\n        // if the div is hidden, we stop the redraw here for performance.\n        if (this.canvas.frame.clientWidth === 0) {\n          return;\n        }\n\n        // set scaling and translation\n        ctx.save();\n        ctx.translate(this.body.view.translation.x, this.body.view.translation.y);\n        ctx.scale(this.body.view.scale, this.body.view.scale);\n        ctx.beginPath();\n        this.body.emitter.emit(\"beforeDrawing\", ctx);\n        ctx.closePath();\n        if (hidden === false) {\n          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {\n            this._drawEdges(ctx);\n          }\n        }\n        if (this.dragging === false || this.dragging === true && this.options.hideNodesOnDrag === false) {\n          var _this$_drawNodes = this._drawNodes(ctx, hidden),\n            drawExternalLabels = _this$_drawNodes.drawExternalLabels;\n          drawLater.drawExternalLabels = drawExternalLabels;\n        }\n\n        // draw the arrows last so they will be at the top\n        if (hidden === false) {\n          if ((this.dragging === false || this.dragging === true && this.options.hideEdgesOnDrag === false) && (this.zooming === false || this.zooming === true && this.options.hideEdgesOnZoom === false)) {\n            this._drawArrows(ctx);\n          }\n        }\n        if (drawLater.drawExternalLabels != null) {\n          drawLater.drawExternalLabels();\n        }\n        if (hidden === false) {\n          this._drawSelectionBox(ctx);\n        }\n        ctx.beginPath();\n        this.body.emitter.emit(\"afterDrawing\", ctx);\n        ctx.closePath();\n\n        // restore original scaling and translation\n        ctx.restore();\n        if (hidden === true) {\n          ctx.clearRect(0, 0, w, h);\n        }\n      }\n    }\n\n    /**\n     * Redraw all nodes\n     *\n     * @param {CanvasRenderingContext2D}   ctx\n     * @param {boolean} [alwaysShow]\n     * @private\n     */\n  }, {\n    key: \"_resizeNodes\",\n    value: function _resizeNodes() {\n      this.canvas.setTransform();\n      var ctx = this.canvas.getContext();\n      ctx.save();\n      ctx.translate(this.body.view.translation.x, this.body.view.translation.y);\n      ctx.scale(this.body.view.scale, this.body.view.scale);\n      var nodes = this.body.nodes;\n      var node;\n\n      // resize all nodes\n      for (var nodeId in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n          node = nodes[nodeId];\n          node.resize(ctx);\n          node.updateBoundingBox(ctx, node.selected);\n        }\n      }\n\n      // restore original scaling and translation\n      ctx.restore();\n    }\n\n    /**\n     * Redraw all nodes\n     *\n     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas\n     * @param {boolean} [alwaysShow]\n     * @private\n     * @returns {object} Callbacks to draw later on higher layers.\n     */\n  }, {\n    key: \"_drawNodes\",\n    value: function _drawNodes(ctx) {\n      var alwaysShow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var nodes = this.body.nodes;\n      var nodeIndices = this.body.nodeIndices;\n      var node;\n      var selected = [];\n      var hovered = [];\n      var margin = 20;\n      var topLeft = this.canvas.DOMtoCanvas({\n        x: -margin,\n        y: -margin\n      });\n      var bottomRight = this.canvas.DOMtoCanvas({\n        x: this.canvas.frame.canvas.clientWidth + margin,\n        y: this.canvas.frame.canvas.clientHeight + margin\n      });\n      var viewableArea = {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x\n      };\n      var _drawExternalLabels = [];\n\n      // draw unselected nodes;\n      for (var _i = 0; _i < nodeIndices.length; _i++) {\n        node = nodes[nodeIndices[_i]];\n        // set selected and hovered nodes aside\n        if (node.hover) {\n          hovered.push(nodeIndices[_i]);\n        } else if (node.isSelected()) {\n          selected.push(nodeIndices[_i]);\n        } else {\n          if (alwaysShow === true) {\n            var drawLater = node.draw(ctx);\n            if (drawLater.drawExternalLabel != null) {\n              _drawExternalLabels.push(drawLater.drawExternalLabel);\n            }\n          } else if (node.isBoundingBoxOverlappingWith(viewableArea) === true) {\n            var _drawLater = node.draw(ctx);\n            if (_drawLater.drawExternalLabel != null) {\n              _drawExternalLabels.push(_drawLater.drawExternalLabel);\n            }\n          } else {\n            node.updateBoundingBox(ctx, node.selected);\n          }\n        }\n      }\n      var i;\n      var selectedLength = selected.length;\n      var hoveredLength = hovered.length;\n\n      // draw the selected nodes on top\n      for (i = 0; i < selectedLength; i++) {\n        node = nodes[selected[i]];\n        var _drawLater2 = node.draw(ctx);\n        if (_drawLater2.drawExternalLabel != null) {\n          _drawExternalLabels.push(_drawLater2.drawExternalLabel);\n        }\n      }\n\n      // draw hovered nodes above everything else: fixes https://github.com/visjs/vis-network/issues/226\n      for (i = 0; i < hoveredLength; i++) {\n        node = nodes[hovered[i]];\n        var _drawLater3 = node.draw(ctx);\n        if (_drawLater3.drawExternalLabel != null) {\n          _drawExternalLabels.push(_drawLater3.drawExternalLabel);\n        }\n      }\n      return {\n        drawExternalLabels: function drawExternalLabels() {\n          for (var _i2 = 0, _drawExternalLabels2 = _drawExternalLabels; _i2 < _drawExternalLabels2.length; _i2++) {\n            var draw = _drawExternalLabels2[_i2];\n            draw();\n          }\n        }\n      };\n    }\n\n    /**\n     * Redraw all edges\n     *\n     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas\n     * @private\n     */\n  }, {\n    key: \"_drawEdges\",\n    value: function _drawEdges(ctx) {\n      var edges = this.body.edges;\n      var edgeIndices = this.body.edgeIndices;\n      for (var i = 0; i < edgeIndices.length; i++) {\n        var edge = edges[edgeIndices[i]];\n        if (edge.connected === true) {\n          edge.draw(ctx);\n        }\n      }\n    }\n\n    /**\n     * Redraw all arrows\n     *\n     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas\n     * @private\n     */\n  }, {\n    key: \"_drawArrows\",\n    value: function _drawArrows(ctx) {\n      var edges = this.body.edges;\n      var edgeIndices = this.body.edgeIndices;\n      for (var i = 0; i < edgeIndices.length; i++) {\n        var edge = edges[edgeIndices[i]];\n        if (edge.connected === true) {\n          edge.drawArrows(ctx);\n        }\n      }\n    }\n\n    /**\n     * Determine if the browser requires a setTimeout or a requestAnimationFrame. This was required because\n     * some implementations (safari and IE9) did not support requestAnimationFrame\n     *\n     * @private\n     */\n  }, {\n    key: \"_determineBrowserMethod\",\n    value: function _determineBrowserMethod() {\n      if (typeof window !== \"undefined\") {\n        var browserType = navigator.userAgent.toLowerCase();\n        this.requiresTimeout = false;\n        if (_indexOfInstanceProperty(browserType).call(browserType, \"msie 9.0\") != -1) {\n          // IE 9\n          this.requiresTimeout = true;\n        } else if (_indexOfInstanceProperty(browserType).call(browserType, \"safari\") != -1) {\n          // safari\n          if (_indexOfInstanceProperty(browserType).call(browserType, \"chrome\") <= -1) {\n            this.requiresTimeout = true;\n          }\n        }\n      } else {\n        this.requiresTimeout = true;\n      }\n    }\n\n    /**\n     * Redraw selection box\n     *\n     * @param {CanvasRenderingContext2D} ctx  2D context of a HTML canvas\n     * @private\n     */\n  }, {\n    key: \"_drawSelectionBox\",\n    value: function _drawSelectionBox(ctx) {\n      if (this.body.selectionBox.show) {\n        ctx.beginPath();\n        var width = this.body.selectionBox.position.end.x - this.body.selectionBox.position.start.x;\n        var height = this.body.selectionBox.position.end.y - this.body.selectionBox.position.start.y;\n        ctx.rect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);\n        ctx.fillStyle = \"rgba(151, 194, 252, 0.2)\";\n        ctx.fillRect(this.body.selectionBox.position.start.x, this.body.selectionBox.position.start.y, width, height);\n        ctx.strokeStyle = \"rgba(151, 194, 252, 1)\";\n        ctx.stroke();\n      } else {\n        ctx.closePath();\n      }\n    }\n  }]);\n  return CanvasRenderer;\n}();\n\nvar path$2 = path$w;\n\nvar setInterval$1 = path$2.setInterval;\n\nvar setInterval = setInterval$1;\n\nvar _setInterval = /*@__PURE__*/getDefaultExportFromCjs(setInterval);\n\n/**\n * Register a touch event, taking place before a gesture\n *\n * @param {Hammer} hammer       A hammer instance\n * @param {Function} callback   Callback, called as callback(event)\n */\nfunction onTouch(hammer, callback) {\n  callback.inputHandler = function (event) {\n    if (event.isFirst) {\n      callback(event);\n    }\n  };\n  hammer.on(\"hammer.input\", callback.inputHandler);\n}\n\n/**\n * Register a release event, taking place after a gesture\n *\n * @param {Hammer} hammer       A hammer instance\n * @param {Function} callback   Callback, called as callback(event)\n * @returns {*}\n */\nfunction onRelease(hammer, callback) {\n  callback.inputHandler = function (event) {\n    if (event.isFinal) {\n      callback(event);\n    }\n  };\n  return hammer.on(\"hammer.input\", callback.inputHandler);\n}\n\n/**\n * Create the main frame for the Network.\n * This function is executed once when a Network object is created. The frame\n * contains a canvas, and this canvas contains all objects like the axis and\n * nodes.\n */\nvar Canvas = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   */\n  function Canvas(body) {\n    _classCallCheck(this, Canvas);\n    this.body = body;\n    this.pixelRatio = 1;\n    this.cameraState = {};\n    this.initialized = false;\n    this.canvasViewCenter = {};\n    this._cleanupCallbacks = [];\n    this.options = {};\n    this.defaultOptions = {\n      autoResize: true,\n      height: \"100%\",\n      width: \"100%\"\n    };\n    _Object$assign(this.options, this.defaultOptions);\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n  _createClass(Canvas, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this = this,\n        _context;\n      // bind the events\n      this.body.emitter.once(\"resize\", function (obj) {\n        if (obj.width !== 0) {\n          _this.body.view.translation.x = obj.width * 0.5;\n        }\n        if (obj.height !== 0) {\n          _this.body.view.translation.y = obj.height * 0.5;\n        }\n      });\n      this.body.emitter.on(\"setSize\", _bindInstanceProperty$1(_context = this.setSize).call(_context, this));\n      this.body.emitter.on(\"destroy\", function () {\n        _this.hammerFrame.destroy();\n        _this.hammer.destroy();\n        _this._cleanUp();\n      });\n    }\n\n    /**\n     * @param {object} options\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var _this2 = this;\n      if (options !== undefined) {\n        var fields = [\"width\", \"height\", \"autoResize\"];\n        selectiveDeepExtend(fields, this.options, options);\n      }\n\n      // Automatically adapt to changing size of the container element.\n      this._cleanUp();\n      if (this.options.autoResize === true) {\n        var _context2;\n        if (window.ResizeObserver) {\n          // decent browsers, immediate reactions\n          var observer = new ResizeObserver(function () {\n            var changed = _this2.setSize();\n            if (changed === true) {\n              _this2.body.emitter.emit(\"_requestRedraw\");\n            }\n          });\n          var frame = this.frame;\n          observer.observe(frame);\n          this._cleanupCallbacks.push(function () {\n            observer.unobserve(frame);\n          });\n        } else {\n          // IE11, continous polling\n          var resizeTimer = _setInterval(function () {\n            var changed = _this2.setSize();\n            if (changed === true) {\n              _this2.body.emitter.emit(\"_requestRedraw\");\n            }\n          }, 1000);\n          this._cleanupCallbacks.push(function () {\n            clearInterval(resizeTimer);\n          });\n        }\n\n        // Automatically adapt to changing size of the browser.\n        var resizeFunction = _bindInstanceProperty$1(_context2 = this._onResize).call(_context2, this);\n        window.addEventListener(\"resize\", resizeFunction);\n        this._cleanupCallbacks.push(function () {\n          window.removeEventListener(\"resize\", resizeFunction);\n        });\n      }\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: \"_cleanUp\",\n    value: function _cleanUp() {\n      var _context3, _context4, _context5;\n      _forEachInstanceProperty(_context3 = _reverseInstanceProperty(_context4 = _spliceInstanceProperty(_context5 = this._cleanupCallbacks).call(_context5, 0)).call(_context4)).call(_context3, function (callback) {\n        try {\n          callback();\n        } catch (error) {\n          console.error(error);\n        }\n      });\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: \"_onResize\",\n    value: function _onResize() {\n      this.setSize();\n      this.body.emitter.emit(\"_redraw\");\n    }\n\n    /**\n     * Get and store the cameraState\n     *\n     * @param {number} [pixelRatio=this.pixelRatio]\n     * @private\n     */\n  }, {\n    key: \"_getCameraState\",\n    value: function _getCameraState() {\n      var pixelRatio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.pixelRatio;\n      if (this.initialized === true) {\n        this.cameraState.previousWidth = this.frame.canvas.width / pixelRatio;\n        this.cameraState.previousHeight = this.frame.canvas.height / pixelRatio;\n        this.cameraState.scale = this.body.view.scale;\n        this.cameraState.position = this.DOMtoCanvas({\n          x: 0.5 * this.frame.canvas.width / pixelRatio,\n          y: 0.5 * this.frame.canvas.height / pixelRatio\n        });\n      }\n    }\n\n    /**\n     * Set the cameraState\n     *\n     * @private\n     */\n  }, {\n    key: \"_setCameraState\",\n    value: function _setCameraState() {\n      if (this.cameraState.scale !== undefined && this.frame.canvas.clientWidth !== 0 && this.frame.canvas.clientHeight !== 0 && this.pixelRatio !== 0 && this.cameraState.previousWidth > 0 && this.cameraState.previousHeight > 0) {\n        var widthRatio = this.frame.canvas.width / this.pixelRatio / this.cameraState.previousWidth;\n        var heightRatio = this.frame.canvas.height / this.pixelRatio / this.cameraState.previousHeight;\n        var newScale = this.cameraState.scale;\n        if (widthRatio != 1 && heightRatio != 1) {\n          newScale = this.cameraState.scale * 0.5 * (widthRatio + heightRatio);\n        } else if (widthRatio != 1) {\n          newScale = this.cameraState.scale * widthRatio;\n        } else if (heightRatio != 1) {\n          newScale = this.cameraState.scale * heightRatio;\n        }\n        this.body.view.scale = newScale;\n        // this comes from the view module.\n        var currentViewCenter = this.DOMtoCanvas({\n          x: 0.5 * this.frame.canvas.clientWidth,\n          y: 0.5 * this.frame.canvas.clientHeight\n        });\n        var distanceFromCenter = {\n          // offset from view, distance view has to change by these x and y to center the node\n          x: currentViewCenter.x - this.cameraState.position.x,\n          y: currentViewCenter.y - this.cameraState.position.y\n        };\n        this.body.view.translation.x += distanceFromCenter.x * this.body.view.scale;\n        this.body.view.translation.y += distanceFromCenter.y * this.body.view.scale;\n      }\n    }\n\n    /**\n     *\n     * @param {number|string} value\n     * @returns {string}\n     * @private\n     */\n  }, {\n    key: \"_prepareValue\",\n    value: function _prepareValue(value) {\n      if (typeof value === \"number\") {\n        return value + \"px\";\n      } else if (typeof value === \"string\") {\n        if (_indexOfInstanceProperty(value).call(value, \"%\") !== -1 || _indexOfInstanceProperty(value).call(value, \"px\") !== -1) {\n          return value;\n        } else if (_indexOfInstanceProperty(value).call(value, \"%\") === -1) {\n          return value + \"px\";\n        }\n      }\n      throw new Error(\"Could not use the value supplied for width or height:\" + value);\n    }\n\n    /**\n     * Create the HTML\n     */\n  }, {\n    key: \"_create\",\n    value: function _create() {\n      // remove all elements from the container element.\n      while (this.body.container.hasChildNodes()) {\n        this.body.container.removeChild(this.body.container.firstChild);\n      }\n      this.frame = document.createElement(\"div\");\n      this.frame.className = \"vis-network\";\n      this.frame.style.position = \"relative\";\n      this.frame.style.overflow = \"hidden\";\n      this.frame.tabIndex = 0; // tab index is required for keycharm to bind keystrokes to the div instead of the window\n\n      //////////////////////////////////////////////////////////////////\n\n      this.frame.canvas = document.createElement(\"canvas\");\n      this.frame.canvas.style.position = \"relative\";\n      this.frame.appendChild(this.frame.canvas);\n      if (!this.frame.canvas.getContext) {\n        var noCanvas = document.createElement(\"DIV\");\n        noCanvas.style.color = \"red\";\n        noCanvas.style.fontWeight = \"bold\";\n        noCanvas.style.padding = \"10px\";\n        noCanvas.innerText = \"Error: your browser does not support HTML canvas\";\n        this.frame.canvas.appendChild(noCanvas);\n      } else {\n        this._setPixelRatio();\n        this.setTransform();\n      }\n\n      // add the frame to the container element\n      this.body.container.appendChild(this.frame);\n      this.body.view.scale = 1;\n      this.body.view.translation = {\n        x: 0.5 * this.frame.canvas.clientWidth,\n        y: 0.5 * this.frame.canvas.clientHeight\n      };\n      this._bindHammer();\n    }\n\n    /**\n     * This function binds hammer, it can be repeated over and over due to the uniqueness check.\n     *\n     * @private\n     */\n  }, {\n    key: \"_bindHammer\",\n    value: function _bindHammer() {\n      var _this3 = this;\n      if (this.hammer !== undefined) {\n        this.hammer.destroy();\n      }\n      this.drag = {};\n      this.pinch = {};\n\n      // init hammer\n      this.hammer = new Hammer(this.frame.canvas);\n      this.hammer.get(\"pinch\").set({\n        enable: true\n      });\n      // enable to get better response, todo: test on mobile.\n      this.hammer.get(\"pan\").set({\n        threshold: 5,\n        direction: Hammer.DIRECTION_ALL\n      });\n      onTouch(this.hammer, function (event) {\n        _this3.body.eventListeners.onTouch(event);\n      });\n      this.hammer.on(\"tap\", function (event) {\n        _this3.body.eventListeners.onTap(event);\n      });\n      this.hammer.on(\"doubletap\", function (event) {\n        _this3.body.eventListeners.onDoubleTap(event);\n      });\n      this.hammer.on(\"press\", function (event) {\n        _this3.body.eventListeners.onHold(event);\n      });\n      this.hammer.on(\"panstart\", function (event) {\n        _this3.body.eventListeners.onDragStart(event);\n      });\n      this.hammer.on(\"panmove\", function (event) {\n        _this3.body.eventListeners.onDrag(event);\n      });\n      this.hammer.on(\"panend\", function (event) {\n        _this3.body.eventListeners.onDragEnd(event);\n      });\n      this.hammer.on(\"pinch\", function (event) {\n        _this3.body.eventListeners.onPinch(event);\n      });\n\n      // TODO: neatly cleanup these handlers when re-creating the Canvas, IF these are done with hammer, event.stopPropagation will not work?\n      this.frame.canvas.addEventListener(\"wheel\", function (event) {\n        _this3.body.eventListeners.onMouseWheel(event);\n      });\n      this.frame.canvas.addEventListener(\"mousemove\", function (event) {\n        _this3.body.eventListeners.onMouseMove(event);\n      });\n      this.frame.canvas.addEventListener(\"contextmenu\", function (event) {\n        _this3.body.eventListeners.onContext(event);\n      });\n      this.hammerFrame = new Hammer(this.frame);\n      onRelease(this.hammerFrame, function (event) {\n        _this3.body.eventListeners.onRelease(event);\n      });\n    }\n\n    /**\n     * Set a new size for the network\n     *\n     * @param {string} width   Width in pixels or percentage (for example '800px'\n     *                         or '50%')\n     * @param {string} height  Height in pixels or percentage  (for example '400px'\n     *                         or '30%')\n     * @returns {boolean}\n     */\n  }, {\n    key: \"setSize\",\n    value: function setSize() {\n      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.width;\n      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.height;\n      width = this._prepareValue(width);\n      height = this._prepareValue(height);\n      var emitEvent = false;\n      var oldWidth = this.frame.canvas.width;\n      var oldHeight = this.frame.canvas.height;\n\n      // update the pixel ratio\n      //\n      // NOTE: Comment in following is rather inconsistent; this is the ONLY place in the code\n      //       where it is assumed that the pixel ratio could change at runtime.\n      //       The only way I can think of this happening is a rotating screen or tablet; but then\n      //       there should be a mechanism for reloading the data (TODO: check if this is present).\n      //\n      //       If the assumption is true (i.e. pixel ratio can change at runtime), then *all* usage\n      //       of pixel ratio must be overhauled for this.\n      //\n      //       For the time being, I will humor the assumption here, and in the rest of the code assume it is\n      //       constant.\n      var previousRatio = this.pixelRatio; // we cache this because the camera state storage needs the old value\n      this._setPixelRatio();\n      if (width != this.options.width || height != this.options.height || this.frame.style.width != width || this.frame.style.height != height) {\n        this._getCameraState(previousRatio);\n        this.frame.style.width = width;\n        this.frame.style.height = height;\n        this.frame.canvas.style.width = \"100%\";\n        this.frame.canvas.style.height = \"100%\";\n        this.frame.canvas.width = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);\n        this.frame.canvas.height = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);\n        this.options.width = width;\n        this.options.height = height;\n        this.canvasViewCenter = {\n          x: 0.5 * this.frame.clientWidth,\n          y: 0.5 * this.frame.clientHeight\n        };\n        emitEvent = true;\n      } else {\n        // this would adapt the width of the canvas to the width from 100% if and only if\n        // there is a change.\n\n        var newWidth = Math.round(this.frame.canvas.clientWidth * this.pixelRatio);\n        var newHeight = Math.round(this.frame.canvas.clientHeight * this.pixelRatio);\n\n        // store the camera if there is a change in size.\n        if (this.frame.canvas.width !== newWidth || this.frame.canvas.height !== newHeight) {\n          this._getCameraState(previousRatio);\n        }\n        if (this.frame.canvas.width !== newWidth) {\n          this.frame.canvas.width = newWidth;\n          emitEvent = true;\n        }\n        if (this.frame.canvas.height !== newHeight) {\n          this.frame.canvas.height = newHeight;\n          emitEvent = true;\n        }\n      }\n      if (emitEvent === true) {\n        this.body.emitter.emit(\"resize\", {\n          width: Math.round(this.frame.canvas.width / this.pixelRatio),\n          height: Math.round(this.frame.canvas.height / this.pixelRatio),\n          oldWidth: Math.round(oldWidth / this.pixelRatio),\n          oldHeight: Math.round(oldHeight / this.pixelRatio)\n        });\n\n        // restore the camera on change.\n        this._setCameraState();\n      }\n\n      // set initialized so the get and set camera will work from now on.\n      this.initialized = true;\n      return emitEvent;\n    }\n\n    /**\n     *\n     * @returns {CanvasRenderingContext2D}\n     */\n  }, {\n    key: \"getContext\",\n    value: function getContext() {\n      return this.frame.canvas.getContext(\"2d\");\n    }\n\n    /**\n     * Determine the pixel ratio for various browsers.\n     *\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_determinePixelRatio\",\n    value: function _determinePixelRatio() {\n      var ctx = this.getContext();\n      if (ctx === undefined) {\n        throw new Error(\"Could not get canvax context\");\n      }\n      var numerator = 1;\n      if (typeof window !== \"undefined\") {\n        // (window !== undefined) doesn't work here!\n        // Protection during unit tests, where 'window' can be missing\n        numerator = window.devicePixelRatio || 1;\n      }\n      var denominator = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\n      return numerator / denominator;\n    }\n\n    /**\n     * Lazy determination of pixel ratio.\n     *\n     * @private\n     */\n  }, {\n    key: \"_setPixelRatio\",\n    value: function _setPixelRatio() {\n      this.pixelRatio = this._determinePixelRatio();\n    }\n\n    /**\n     * Set the transform in the contained context, based on its pixelRatio\n     */\n  }, {\n    key: \"setTransform\",\n    value: function setTransform() {\n      var ctx = this.getContext();\n      if (ctx === undefined) {\n        throw new Error(\"Could not get canvax context\");\n      }\n      ctx.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n    }\n\n    /**\n     * Convert the X coordinate in DOM-space (coordinate point in browser relative to the container div) to\n     * the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon)\n     *\n     * @param {number} x\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_XconvertDOMtoCanvas\",\n    value: function _XconvertDOMtoCanvas(x) {\n      return (x - this.body.view.translation.x) / this.body.view.scale;\n    }\n\n    /**\n     * Convert the X coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to\n     * the X coordinate in DOM-space (coordinate point in browser relative to the container div)\n     *\n     * @param {number} x\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_XconvertCanvasToDOM\",\n    value: function _XconvertCanvasToDOM(x) {\n      return x * this.body.view.scale + this.body.view.translation.x;\n    }\n\n    /**\n     * Convert the Y coordinate in DOM-space (coordinate point in browser relative to the container div) to\n     * the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon)\n     *\n     * @param {number} y\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_YconvertDOMtoCanvas\",\n    value: function _YconvertDOMtoCanvas(y) {\n      return (y - this.body.view.translation.y) / this.body.view.scale;\n    }\n\n    /**\n     * Convert the Y coordinate in canvas-space (the simulation sandbox, which the camera looks upon) to\n     * the Y coordinate in DOM-space (coordinate point in browser relative to the container div)\n     *\n     * @param {number} y\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_YconvertCanvasToDOM\",\n    value: function _YconvertCanvasToDOM(y) {\n      return y * this.body.view.scale + this.body.view.translation.y;\n    }\n\n    /**\n     * @param {point} pos\n     * @returns {point}\n     */\n  }, {\n    key: \"canvasToDOM\",\n    value: function canvasToDOM(pos) {\n      return {\n        x: this._XconvertCanvasToDOM(pos.x),\n        y: this._YconvertCanvasToDOM(pos.y)\n      };\n    }\n\n    /**\n     *\n     * @param {point} pos\n     * @returns {point}\n     */\n  }, {\n    key: \"DOMtoCanvas\",\n    value: function DOMtoCanvas(pos) {\n      return {\n        x: this._XconvertDOMtoCanvas(pos.x),\n        y: this._YconvertDOMtoCanvas(pos.y)\n      };\n    }\n  }]);\n  return Canvas;\n}();\n\n/**\r\n * Validate the fit options, replace missing optional values by defaults etc.\r\n *\r\n * @param rawOptions - The raw options.\r\n * @param allNodeIds - All node ids that will be used if nodes are omitted in\r\n * the raw options.\r\n * @returns Options with everything filled in and validated.\r\n */\nfunction normalizeFitOptions(rawOptions, allNodeIds) {\n  var options = _Object$assign({\n    nodes: allNodeIds,\n    minZoomLevel: Number.MIN_VALUE,\n    maxZoomLevel: 1\n  }, rawOptions !== null && rawOptions !== void 0 ? rawOptions : {});\n  if (!_Array$isArray(options.nodes)) {\n    throw new TypeError(\"Nodes has to be an array of ids.\");\n  }\n  if (options.nodes.length === 0) {\n    options.nodes = allNodeIds;\n  }\n  if (!(typeof options.minZoomLevel === \"number\" && options.minZoomLevel > 0)) {\n    throw new TypeError(\"Min zoom level has to be a number higher than zero.\");\n  }\n  if (!(typeof options.maxZoomLevel === \"number\" && options.minZoomLevel <= options.maxZoomLevel)) {\n    throw new TypeError(\"Max zoom level has to be a number higher than min zoom level.\");\n  }\n  return options;\n}\n\n/**\n * The view\n */\nvar View = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   */\n  function View(body, canvas) {\n    var _context,\n      _this = this,\n      _context2;\n    _classCallCheck(this, View);\n    this.body = body;\n    this.canvas = canvas;\n    this.animationSpeed = 1 / this.renderRefreshRate;\n    this.animationEasingFunction = \"easeInOutQuint\";\n    this.easingTime = 0;\n    this.sourceScale = 0;\n    this.targetScale = 0;\n    this.sourceTranslation = 0;\n    this.targetTranslation = 0;\n    this.lockedOnNodeId = undefined;\n    this.lockedOnNodeOffset = undefined;\n    this.touchTime = 0;\n    this.viewFunction = undefined;\n    this.body.emitter.on(\"fit\", _bindInstanceProperty$1(_context = this.fit).call(_context, this));\n    this.body.emitter.on(\"animationFinished\", function () {\n      _this.body.emitter.emit(\"_stopRendering\");\n    });\n    this.body.emitter.on(\"unlockNode\", _bindInstanceProperty$1(_context2 = this.releaseNode).call(_context2, this));\n  }\n\n  /**\n   *\n   * @param {object} [options={}]\n   */\n  _createClass(View, [{\n    key: \"setOptions\",\n    value: function setOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.options = options;\n    }\n\n    /**\n     * This function zooms out to fit all data on screen based on amount of nodes\n     *\n     * @param {object} [options={{nodes=Array}}]\n     * @param options\n     * @param {boolean} [initialZoom=false]  | zoom based on fitted formula or range, true = fitted, default = false;\n     */\n  }, {\n    key: \"fit\",\n    value: function fit(options) {\n      var initialZoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      options = normalizeFitOptions(options, this.body.nodeIndices);\n      var canvasWidth = this.canvas.frame.canvas.clientWidth;\n      var canvasHeight = this.canvas.frame.canvas.clientHeight;\n      var range;\n      var zoomLevel;\n      if (canvasWidth === 0 || canvasHeight === 0) {\n        // There's no point in trying to fit into zero sized canvas. This could\n        // potentially even result in invalid values being computed. For example\n        // for network without nodes and zero sized canvas the zoom level would\n        // end up being computed as 0/0 which results in NaN. In any other case\n        // this would be 0/something which is again pointless to compute.\n        zoomLevel = 1;\n        range = NetworkUtil.getRange(this.body.nodes, options.nodes);\n      } else if (initialZoom === true) {\n        // check if more than half of the nodes have a predefined position. If so, we use the range, not the approximation.\n        var positionDefined = 0;\n        for (var nodeId in this.body.nodes) {\n          if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {\n            var node = this.body.nodes[nodeId];\n            if (node.predefinedPosition === true) {\n              positionDefined += 1;\n            }\n          }\n        }\n        if (positionDefined > 0.5 * this.body.nodeIndices.length) {\n          this.fit(options, false);\n          return;\n        }\n        range = NetworkUtil.getRange(this.body.nodes, options.nodes);\n        var numberOfNodes = this.body.nodeIndices.length;\n        zoomLevel = 12.662 / (numberOfNodes + 7.4147) + 0.0964822; // this is obtained from fitting a dataset from 5 points with scale levels that looked good.\n\n        // correct for larger canvasses.\n        var factor = Math.min(canvasWidth / 600, canvasHeight / 600);\n        zoomLevel *= factor;\n      } else {\n        this.body.emitter.emit(\"_resizeNodes\");\n        range = NetworkUtil.getRange(this.body.nodes, options.nodes);\n        var xDistance = Math.abs(range.maxX - range.minX) * 1.1;\n        var yDistance = Math.abs(range.maxY - range.minY) * 1.1;\n        var xZoomLevel = canvasWidth / xDistance;\n        var yZoomLevel = canvasHeight / yDistance;\n        zoomLevel = xZoomLevel <= yZoomLevel ? xZoomLevel : yZoomLevel;\n      }\n      if (zoomLevel > options.maxZoomLevel) {\n        zoomLevel = options.maxZoomLevel;\n      } else if (zoomLevel < options.minZoomLevel) {\n        zoomLevel = options.minZoomLevel;\n      }\n      var center = NetworkUtil.findCenter(range);\n      var animationOptions = {\n        position: center,\n        scale: zoomLevel,\n        animation: options.animation\n      };\n      this.moveTo(animationOptions);\n    }\n\n    // animation\n\n    /**\n     * Center a node in view.\n     *\n     * @param {number} nodeId\n     * @param {number} [options]\n     */\n  }, {\n    key: \"focus\",\n    value: function focus(nodeId) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this.body.nodes[nodeId] !== undefined) {\n        var nodePosition = {\n          x: this.body.nodes[nodeId].x,\n          y: this.body.nodes[nodeId].y\n        };\n        options.position = nodePosition;\n        options.lockedOnNode = nodeId;\n        this.moveTo(options);\n      } else {\n        console.error(\"Node: \" + nodeId + \" cannot be found.\");\n      }\n    }\n\n    /**\n     *\n     * @param {object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels\n     *                          |  options.scale    = number                 // scale to move to\n     *                          |  options.position = {x:number, y:number}   // position to move to\n     *                          |  options.animation = {duration:number, easingFunction:String} || Boolean   // position to move to\n     */\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(options) {\n      if (options === undefined) {\n        options = {};\n        return;\n      }\n      if (options.offset != null) {\n        if (options.offset.x != null) {\n          // Coerce and verify that x is valid.\n          options.offset.x = +options.offset.x;\n          if (!_Number$isFinite(options.offset.x)) {\n            throw new TypeError('The option \"offset.x\" has to be a finite number.');\n          }\n        } else {\n          options.offset.x = 0;\n        }\n        if (options.offset.y != null) {\n          // Coerce and verify that y is valid.\n          options.offset.y = +options.offset.y;\n          if (!_Number$isFinite(options.offset.y)) {\n            throw new TypeError('The option \"offset.y\" has to be a finite number.');\n          }\n        } else {\n          options.offset.x = 0;\n        }\n      } else {\n        options.offset = {\n          x: 0,\n          y: 0\n        };\n      }\n      if (options.position != null) {\n        if (options.position.x != null) {\n          // Coerce and verify that x is valid.\n          options.position.x = +options.position.x;\n          if (!_Number$isFinite(options.position.x)) {\n            throw new TypeError('The option \"position.x\" has to be a finite number.');\n          }\n        } else {\n          options.position.x = 0;\n        }\n        if (options.position.y != null) {\n          // Coerce and verify that y is valid.\n          options.position.y = +options.position.y;\n          if (!_Number$isFinite(options.position.y)) {\n            throw new TypeError('The option \"position.y\" has to be a finite number.');\n          }\n        } else {\n          options.position.x = 0;\n        }\n      } else {\n        options.position = this.getViewPosition();\n      }\n      if (options.scale != null) {\n        // Coerce and verify that the scale is valid.\n        options.scale = +options.scale;\n        if (!(options.scale > 0)) {\n          throw new TypeError('The option \"scale\" has to be a number greater than zero.');\n        }\n      } else {\n        options.scale = this.body.view.scale;\n      }\n      if (options.animation === undefined) {\n        options.animation = {\n          duration: 0\n        };\n      }\n      if (options.animation === false) {\n        options.animation = {\n          duration: 0\n        };\n      }\n      if (options.animation === true) {\n        options.animation = {};\n      }\n      if (options.animation.duration === undefined) {\n        options.animation.duration = 1000;\n      } // default duration\n      if (options.animation.easingFunction === undefined) {\n        options.animation.easingFunction = \"easeInOutQuad\";\n      } // default easing function\n\n      this.animateView(options);\n    }\n\n    /**\n     *\n     * @param {object} options  |  options.offset   = {x:number, y:number}   // offset from the center in DOM pixels\n     *                          |  options.time     = number                 // animation time in milliseconds\n     *                          |  options.scale    = number                 // scale to animate to\n     *                          |  options.position = {x:number, y:number}   // position to animate to\n     *                          |  options.easingFunction = String           // linear, easeInQuad, easeOutQuad, easeInOutQuad,\n     *                                                                       // easeInCubic, easeOutCubic, easeInOutCubic,\n     *                                                                       // easeInQuart, easeOutQuart, easeInOutQuart,\n     *                                                                       // easeInQuint, easeOutQuint, easeInOutQuint\n     */\n  }, {\n    key: \"animateView\",\n    value: function animateView(options) {\n      if (options === undefined) {\n        return;\n      }\n      this.animationEasingFunction = options.animation.easingFunction;\n      // release if something focussed on the node\n      this.releaseNode();\n      if (options.locked === true) {\n        this.lockedOnNodeId = options.lockedOnNode;\n        this.lockedOnNodeOffset = options.offset;\n      }\n\n      // forcefully complete the old animation if it was still running\n      if (this.easingTime != 0) {\n        this._transitionRedraw(true); // by setting easingtime to 1, we finish the animation.\n      }\n\n      this.sourceScale = this.body.view.scale;\n      this.sourceTranslation = this.body.view.translation;\n      this.targetScale = options.scale;\n\n      // set the scale so the viewCenter is based on the correct zoom level. This is overridden in the transitionRedraw\n      // but at least then we'll have the target transition\n      this.body.view.scale = this.targetScale;\n      var viewCenter = this.canvas.DOMtoCanvas({\n        x: 0.5 * this.canvas.frame.canvas.clientWidth,\n        y: 0.5 * this.canvas.frame.canvas.clientHeight\n      });\n      var distanceFromCenter = {\n        // offset from view, distance view has to change by these x and y to center the node\n        x: viewCenter.x - options.position.x,\n        y: viewCenter.y - options.position.y\n      };\n      this.targetTranslation = {\n        x: this.sourceTranslation.x + distanceFromCenter.x * this.targetScale + options.offset.x,\n        y: this.sourceTranslation.y + distanceFromCenter.y * this.targetScale + options.offset.y\n      };\n\n      // if the time is set to 0, don't do an animation\n      if (options.animation.duration === 0) {\n        if (this.lockedOnNodeId != undefined) {\n          var _context3;\n          this.viewFunction = _bindInstanceProperty$1(_context3 = this._lockedRedraw).call(_context3, this);\n          this.body.emitter.on(\"initRedraw\", this.viewFunction);\n        } else {\n          this.body.view.scale = this.targetScale;\n          this.body.view.translation = this.targetTranslation;\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n      } else {\n        var _context4;\n        this.animationSpeed = 1 / (60 * options.animation.duration * 0.001) || 1 / 60; // 60 for 60 seconds, 0.001 for milli's\n        this.animationEasingFunction = options.animation.easingFunction;\n        this.viewFunction = _bindInstanceProperty$1(_context4 = this._transitionRedraw).call(_context4, this);\n        this.body.emitter.on(\"initRedraw\", this.viewFunction);\n        this.body.emitter.emit(\"_startRendering\");\n      }\n    }\n\n    /**\n     * used to animate smoothly by hijacking the redraw function.\n     *\n     * @private\n     */\n  }, {\n    key: \"_lockedRedraw\",\n    value: function _lockedRedraw() {\n      var nodePosition = {\n        x: this.body.nodes[this.lockedOnNodeId].x,\n        y: this.body.nodes[this.lockedOnNodeId].y\n      };\n      var viewCenter = this.canvas.DOMtoCanvas({\n        x: 0.5 * this.canvas.frame.canvas.clientWidth,\n        y: 0.5 * this.canvas.frame.canvas.clientHeight\n      });\n      var distanceFromCenter = {\n        // offset from view, distance view has to change by these x and y to center the node\n        x: viewCenter.x - nodePosition.x,\n        y: viewCenter.y - nodePosition.y\n      };\n      var sourceTranslation = this.body.view.translation;\n      var targetTranslation = {\n        x: sourceTranslation.x + distanceFromCenter.x * this.body.view.scale + this.lockedOnNodeOffset.x,\n        y: sourceTranslation.y + distanceFromCenter.y * this.body.view.scale + this.lockedOnNodeOffset.y\n      };\n      this.body.view.translation = targetTranslation;\n    }\n\n    /**\n     * Resets state of a locked on Node\n     */\n  }, {\n    key: \"releaseNode\",\n    value: function releaseNode() {\n      if (this.lockedOnNodeId !== undefined && this.viewFunction !== undefined) {\n        this.body.emitter.off(\"initRedraw\", this.viewFunction);\n        this.lockedOnNodeId = undefined;\n        this.lockedOnNodeOffset = undefined;\n      }\n    }\n\n    /**\n     * @param {boolean} [finished=false]\n     * @private\n     */\n  }, {\n    key: \"_transitionRedraw\",\n    value: function _transitionRedraw() {\n      var finished = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.easingTime += this.animationSpeed;\n      this.easingTime = finished === true ? 1.0 : this.easingTime;\n      var progress = easingFunctions[this.animationEasingFunction](this.easingTime);\n      this.body.view.scale = this.sourceScale + (this.targetScale - this.sourceScale) * progress;\n      this.body.view.translation = {\n        x: this.sourceTranslation.x + (this.targetTranslation.x - this.sourceTranslation.x) * progress,\n        y: this.sourceTranslation.y + (this.targetTranslation.y - this.sourceTranslation.y) * progress\n      };\n\n      // cleanup\n      if (this.easingTime >= 1.0) {\n        this.body.emitter.off(\"initRedraw\", this.viewFunction);\n        this.easingTime = 0;\n        if (this.lockedOnNodeId != undefined) {\n          var _context5;\n          this.viewFunction = _bindInstanceProperty$1(_context5 = this._lockedRedraw).call(_context5, this);\n          this.body.emitter.on(\"initRedraw\", this.viewFunction);\n        }\n        this.body.emitter.emit(\"animationFinished\");\n      }\n    }\n\n    /**\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getScale\",\n    value: function getScale() {\n      return this.body.view.scale;\n    }\n\n    /**\n     *\n     * @returns {{x: number, y: number}}\n     */\n  }, {\n    key: \"getViewPosition\",\n    value: function getViewPosition() {\n      return this.canvas.DOMtoCanvas({\n        x: 0.5 * this.canvas.frame.canvas.clientWidth,\n        y: 0.5 * this.canvas.frame.canvas.clientHeight\n      });\n    }\n  }]);\n  return View;\n}();\n\n/**\r\n * Created by Alex on 11/6/2014.\r\n */\r\nfunction keycharm(options) {\r\n  var preventDefault = options && options.preventDefault || false;\r\n\r\n  var container = options && options.container || window;\r\n\r\n  var _exportFunctions = {};\r\n  var _bound = {keydown:{}, keyup:{}};\r\n  var _keys = {};\r\n  var i;\r\n\r\n  // a - z\r\n  for (i = 97; i <= 122; i++) {_keys[String.fromCharCode(i)] = {code:65 + (i - 97), shift: false};}\r\n  // A - Z\r\n  for (i = 65; i <= 90; i++) {_keys[String.fromCharCode(i)] = {code:i, shift: true};}\r\n  // 0 - 9\r\n  for (i = 0;  i <= 9;   i++) {_keys['' + i] = {code:48 + i, shift: false};}\r\n  // F1 - F12\r\n  for (i = 1;  i <= 12;   i++) {_keys['F' + i] = {code:111 + i, shift: false};}\r\n  // num0 - num9\r\n  for (i = 0;  i <= 9;   i++) {_keys['num' + i] = {code:96 + i, shift: false};}\r\n\r\n  // numpad misc\r\n  _keys['num*'] = {code:106, shift: false};\r\n  _keys['num+'] = {code:107, shift: false};\r\n  _keys['num-'] = {code:109, shift: false};\r\n  _keys['num/'] = {code:111, shift: false};\r\n  _keys['num.'] = {code:110, shift: false};\r\n  // arrows\r\n  _keys['left']  = {code:37, shift: false};\r\n  _keys['up']    = {code:38, shift: false};\r\n  _keys['right'] = {code:39, shift: false};\r\n  _keys['down']  = {code:40, shift: false};\r\n  // extra keys\r\n  _keys['space'] = {code:32, shift: false};\r\n  _keys['enter'] = {code:13, shift: false};\r\n  _keys['shift'] = {code:16, shift: undefined};\r\n  _keys['esc']   = {code:27, shift: false};\r\n  _keys['backspace'] = {code:8, shift: false};\r\n  _keys['tab']       = {code:9, shift: false};\r\n  _keys['ctrl']      = {code:17, shift: false};\r\n  _keys['alt']       = {code:18, shift: false};\r\n  _keys['delete']    = {code:46, shift: false};\r\n  _keys['pageup']    = {code:33, shift: false};\r\n  _keys['pagedown']  = {code:34, shift: false};\r\n  // symbols\r\n  _keys['=']     = {code:187, shift: false};\r\n  _keys['-']     = {code:189, shift: false};\r\n  _keys[']']     = {code:221, shift: false};\r\n  _keys['[']     = {code:219, shift: false};\r\n\r\n\r\n\r\n  var down = function(event) {handleEvent(event,'keydown');};\r\n  var up = function(event) {handleEvent(event,'keyup');};\r\n\r\n  // handle the actualy bound key with the event\r\n  var handleEvent = function(event,type) {\r\n    if (_bound[type][event.keyCode] !== undefined) {\r\n      var bound = _bound[type][event.keyCode];\r\n      for (var i = 0; i < bound.length; i++) {\r\n        if (bound[i].shift === undefined) {\r\n          bound[i].fn(event);\r\n        }\r\n        else if (bound[i].shift == true && event.shiftKey == true) {\r\n          bound[i].fn(event);\r\n        }\r\n        else if (bound[i].shift == false && event.shiftKey == false) {\r\n          bound[i].fn(event);\r\n        }\r\n      }\r\n\r\n      if (preventDefault == true) {\r\n        event.preventDefault();\r\n      }\r\n    }\r\n  };\r\n\r\n  // bind a key to a callback\r\n  _exportFunctions.bind = function(key, callback, type) {\r\n    if (type === undefined) {\r\n      type = 'keydown';\r\n    }\r\n    if (_keys[key] === undefined) {\r\n      throw new Error(\"unsupported key: \" + key);\r\n    }\r\n    if (_bound[type][_keys[key].code] === undefined) {\r\n      _bound[type][_keys[key].code] = [];\r\n    }\r\n    _bound[type][_keys[key].code].push({fn:callback, shift:_keys[key].shift});\r\n  };\r\n\r\n\r\n  // bind all keys to a call back (demo purposes)\r\n  _exportFunctions.bindAll = function(callback, type) {\r\n    if (type === undefined) {\r\n      type = 'keydown';\r\n    }\r\n    for (var key in _keys) {\r\n      if (_keys.hasOwnProperty(key)) {\r\n        _exportFunctions.bind(key,callback,type);\r\n      }\r\n    }\r\n  };\r\n\r\n  // get the key label from an event\r\n  _exportFunctions.getKey = function(event) {\r\n    for (var key in _keys) {\r\n      if (_keys.hasOwnProperty(key)) {\r\n        if (event.shiftKey == true && _keys[key].shift == true && event.keyCode == _keys[key].code) {\r\n          return key;\r\n        }\r\n        else if (event.shiftKey == false && _keys[key].shift == false && event.keyCode == _keys[key].code) {\r\n          return key;\r\n        }\r\n        else if (event.keyCode == _keys[key].code && key == 'shift') {\r\n          return key;\r\n        }\r\n      }\r\n    }\r\n    return \"unknown key, currently not supported\";\r\n  };\r\n\r\n  // unbind either a specific callback from a key or all of them (by leaving callback undefined)\r\n  _exportFunctions.unbind = function(key, callback, type) {\r\n    if (type === undefined) {\r\n      type = 'keydown';\r\n    }\r\n    if (_keys[key] === undefined) {\r\n      throw new Error(\"unsupported key: \" + key);\r\n    }\r\n    if (callback !== undefined) {\r\n      var newBindings = [];\r\n      var bound = _bound[type][_keys[key].code];\r\n      if (bound !== undefined) {\r\n        for (var i = 0; i < bound.length; i++) {\r\n          if (!(bound[i].fn == callback && bound[i].shift == _keys[key].shift)) {\r\n            newBindings.push(_bound[type][_keys[key].code][i]);\r\n          }\r\n        }\r\n      }\r\n      _bound[type][_keys[key].code] = newBindings;\r\n    }\r\n    else {\r\n      _bound[type][_keys[key].code] = [];\r\n    }\r\n  };\r\n\r\n  // reset all bound variables.\r\n  _exportFunctions.reset = function() {\r\n    _bound = {keydown:{}, keyup:{}};\r\n  };\r\n\r\n  // unbind all listeners and reset all variables.\r\n  _exportFunctions.destroy = function() {\r\n    _bound = {keydown:{}, keyup:{}};\r\n    container.removeEventListener('keydown', down, true);\r\n    container.removeEventListener('keyup', up, true);\r\n  };\r\n\r\n  // create listeners.\r\n  container.addEventListener('keydown',down,true);\r\n  container.addEventListener('keyup',up,true);\r\n\r\n  // return the public functions.\r\n  return _exportFunctions;\r\n}\n\n/**\n * Navigation Handler\n */\nvar NavigationHandler = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   */\n  function NavigationHandler(body, canvas) {\n    var _this = this;\n    _classCallCheck(this, NavigationHandler);\n    this.body = body;\n    this.canvas = canvas;\n    this.iconsCreated = false;\n    this.navigationHammers = [];\n    this.boundFunctions = {};\n    this.touchTime = 0;\n    this.activated = false;\n    this.body.emitter.on(\"activate\", function () {\n      _this.activated = true;\n      _this.configureKeyboardBindings();\n    });\n    this.body.emitter.on(\"deactivate\", function () {\n      _this.activated = false;\n      _this.configureKeyboardBindings();\n    });\n    this.body.emitter.on(\"destroy\", function () {\n      if (_this.keycharm !== undefined) {\n        _this.keycharm.destroy();\n      }\n    });\n    this.options = {};\n  }\n\n  /**\n   *\n   * @param {object} options\n   */\n  _createClass(NavigationHandler, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        this.options = options;\n        this.create();\n      }\n    }\n\n    /**\n     * Creates or refreshes navigation and sets key bindings\n     */\n  }, {\n    key: \"create\",\n    value: function create() {\n      if (this.options.navigationButtons === true) {\n        if (this.iconsCreated === false) {\n          this.loadNavigationElements();\n        }\n      } else if (this.iconsCreated === true) {\n        this.cleanNavigation();\n      }\n      this.configureKeyboardBindings();\n    }\n\n    /**\n     * Cleans up previous navigation items\n     */\n  }, {\n    key: \"cleanNavigation\",\n    value: function cleanNavigation() {\n      // clean hammer bindings\n      if (this.navigationHammers.length != 0) {\n        for (var i = 0; i < this.navigationHammers.length; i++) {\n          this.navigationHammers[i].destroy();\n        }\n        this.navigationHammers = [];\n      }\n\n      // clean up previous navigation items\n      if (this.navigationDOM && this.navigationDOM[\"wrapper\"] && this.navigationDOM[\"wrapper\"].parentNode) {\n        this.navigationDOM[\"wrapper\"].parentNode.removeChild(this.navigationDOM[\"wrapper\"]);\n      }\n      this.iconsCreated = false;\n    }\n\n    /**\n     * Creation of the navigation controls nodes. They are drawn over the rest of the nodes and are not affected by scale and translation\n     * they have a triggerFunction which is called on click. If the position of the navigation controls is dependent\n     * on this.frame.canvas.clientWidth or this.frame.canvas.clientHeight, we flag horizontalAlignLeft and verticalAlignTop false.\n     * This means that the location will be corrected by the _relocateNavigation function on a size change of the canvas.\n     *\n     * @private\n     */\n  }, {\n    key: \"loadNavigationElements\",\n    value: function loadNavigationElements() {\n      var _this2 = this;\n      this.cleanNavigation();\n      this.navigationDOM = {};\n      var navigationDivs = [\"up\", \"down\", \"left\", \"right\", \"zoomIn\", \"zoomOut\", \"zoomExtends\"];\n      var navigationDivActions = [\"_moveUp\", \"_moveDown\", \"_moveLeft\", \"_moveRight\", \"_zoomIn\", \"_zoomOut\", \"_fit\"];\n      this.navigationDOM[\"wrapper\"] = document.createElement(\"div\");\n      this.navigationDOM[\"wrapper\"].className = \"vis-navigation\";\n      this.canvas.frame.appendChild(this.navigationDOM[\"wrapper\"]);\n      for (var i = 0; i < navigationDivs.length; i++) {\n        this.navigationDOM[navigationDivs[i]] = document.createElement(\"div\");\n        this.navigationDOM[navigationDivs[i]].className = \"vis-button vis-\" + navigationDivs[i];\n        this.navigationDOM[\"wrapper\"].appendChild(this.navigationDOM[navigationDivs[i]]);\n        var hammer = new Hammer(this.navigationDOM[navigationDivs[i]]);\n        if (navigationDivActions[i] === \"_fit\") {\n          var _context;\n          onTouch(hammer, _bindInstanceProperty$1(_context = this._fit).call(_context, this));\n        } else {\n          var _context2;\n          onTouch(hammer, _bindInstanceProperty$1(_context2 = this.bindToRedraw).call(_context2, this, navigationDivActions[i]));\n        }\n        this.navigationHammers.push(hammer);\n      }\n\n      // use a hammer for the release so we do not require the one used in the rest of the network\n      // the one the rest uses can be overloaded by the manipulation system.\n      var hammerFrame = new Hammer(this.canvas.frame);\n      onRelease(hammerFrame, function () {\n        _this2._stopMovement();\n      });\n      this.navigationHammers.push(hammerFrame);\n      this.iconsCreated = true;\n    }\n\n    /**\n     *\n     * @param {string} action\n     */\n  }, {\n    key: \"bindToRedraw\",\n    value: function bindToRedraw(action) {\n      if (this.boundFunctions[action] === undefined) {\n        var _context3;\n        this.boundFunctions[action] = _bindInstanceProperty$1(_context3 = this[action]).call(_context3, this);\n        this.body.emitter.on(\"initRedraw\", this.boundFunctions[action]);\n        this.body.emitter.emit(\"_startRendering\");\n      }\n    }\n\n    /**\n     *\n     * @param {string} action\n     */\n  }, {\n    key: \"unbindFromRedraw\",\n    value: function unbindFromRedraw(action) {\n      if (this.boundFunctions[action] !== undefined) {\n        this.body.emitter.off(\"initRedraw\", this.boundFunctions[action]);\n        this.body.emitter.emit(\"_stopRendering\");\n        delete this.boundFunctions[action];\n      }\n    }\n\n    /**\n     * this stops all movement induced by the navigation buttons\n     *\n     * @private\n     */\n  }, {\n    key: \"_fit\",\n    value: function _fit() {\n      if (new Date().valueOf() - this.touchTime > 700) {\n        // TODO: fix ugly hack to avoid hammer's double fireing of event (because we use release?)\n        this.body.emitter.emit(\"fit\", {\n          duration: 700\n        });\n        this.touchTime = new Date().valueOf();\n      }\n    }\n\n    /**\n     * this stops all movement induced by the navigation buttons\n     *\n     * @private\n     */\n  }, {\n    key: \"_stopMovement\",\n    value: function _stopMovement() {\n      for (var boundAction in this.boundFunctions) {\n        if (Object.prototype.hasOwnProperty.call(this.boundFunctions, boundAction)) {\n          this.body.emitter.off(\"initRedraw\", this.boundFunctions[boundAction]);\n          this.body.emitter.emit(\"_stopRendering\");\n        }\n      }\n      this.boundFunctions = {};\n    }\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_moveUp\",\n    value: function _moveUp() {\n      this.body.view.translation.y += this.options.keyboard.speed.y;\n    }\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_moveDown\",\n    value: function _moveDown() {\n      this.body.view.translation.y -= this.options.keyboard.speed.y;\n    }\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_moveLeft\",\n    value: function _moveLeft() {\n      this.body.view.translation.x += this.options.keyboard.speed.x;\n    }\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_moveRight\",\n    value: function _moveRight() {\n      this.body.view.translation.x -= this.options.keyboard.speed.x;\n    }\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_zoomIn\",\n    value: function _zoomIn() {\n      var scaleOld = this.body.view.scale;\n      var scale = this.body.view.scale * (1 + this.options.keyboard.speed.zoom);\n      var translation = this.body.view.translation;\n      var scaleFrac = scale / scaleOld;\n      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;\n      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;\n      this.body.view.scale = scale;\n      this.body.view.translation = {\n        x: tx,\n        y: ty\n      };\n      this.body.emitter.emit(\"zoom\", {\n        direction: \"+\",\n        scale: this.body.view.scale,\n        pointer: null\n      });\n    }\n\n    /**\n     *\n     * @private\n     */\n  }, {\n    key: \"_zoomOut\",\n    value: function _zoomOut() {\n      var scaleOld = this.body.view.scale;\n      var scale = this.body.view.scale / (1 + this.options.keyboard.speed.zoom);\n      var translation = this.body.view.translation;\n      var scaleFrac = scale / scaleOld;\n      var tx = (1 - scaleFrac) * this.canvas.canvasViewCenter.x + translation.x * scaleFrac;\n      var ty = (1 - scaleFrac) * this.canvas.canvasViewCenter.y + translation.y * scaleFrac;\n      this.body.view.scale = scale;\n      this.body.view.translation = {\n        x: tx,\n        y: ty\n      };\n      this.body.emitter.emit(\"zoom\", {\n        direction: \"-\",\n        scale: this.body.view.scale,\n        pointer: null\n      });\n    }\n\n    /**\n     * bind all keys using keycharm.\n     */\n  }, {\n    key: \"configureKeyboardBindings\",\n    value: function configureKeyboardBindings() {\n      var _this3 = this;\n      if (this.keycharm !== undefined) {\n        this.keycharm.destroy();\n      }\n      if (this.options.keyboard.enabled === true) {\n        if (this.options.keyboard.bindToWindow === true) {\n          this.keycharm = keycharm({\n            container: window,\n            preventDefault: true\n          });\n        } else {\n          this.keycharm = keycharm({\n            container: this.canvas.frame,\n            preventDefault: true\n          });\n        }\n        this.keycharm.reset();\n        if (this.activated === true) {\n          var _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13, _context14, _context15, _context16, _context17, _context18, _context19, _context20, _context21, _context22, _context23, _context24, _context25, _context26, _context27;\n          _bindInstanceProperty$1(_context4 = this.keycharm).call(_context4, \"up\", function () {\n            _this3.bindToRedraw(\"_moveUp\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context5 = this.keycharm).call(_context5, \"down\", function () {\n            _this3.bindToRedraw(\"_moveDown\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context6 = this.keycharm).call(_context6, \"left\", function () {\n            _this3.bindToRedraw(\"_moveLeft\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context7 = this.keycharm).call(_context7, \"right\", function () {\n            _this3.bindToRedraw(\"_moveRight\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context8 = this.keycharm).call(_context8, \"=\", function () {\n            _this3.bindToRedraw(\"_zoomIn\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context9 = this.keycharm).call(_context9, \"num+\", function () {\n            _this3.bindToRedraw(\"_zoomIn\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context10 = this.keycharm).call(_context10, \"num-\", function () {\n            _this3.bindToRedraw(\"_zoomOut\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context11 = this.keycharm).call(_context11, \"-\", function () {\n            _this3.bindToRedraw(\"_zoomOut\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context12 = this.keycharm).call(_context12, \"[\", function () {\n            _this3.bindToRedraw(\"_zoomOut\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context13 = this.keycharm).call(_context13, \"]\", function () {\n            _this3.bindToRedraw(\"_zoomIn\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context14 = this.keycharm).call(_context14, \"pageup\", function () {\n            _this3.bindToRedraw(\"_zoomIn\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context15 = this.keycharm).call(_context15, \"pagedown\", function () {\n            _this3.bindToRedraw(\"_zoomOut\");\n          }, \"keydown\");\n          _bindInstanceProperty$1(_context16 = this.keycharm).call(_context16, \"up\", function () {\n            _this3.unbindFromRedraw(\"_moveUp\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context17 = this.keycharm).call(_context17, \"down\", function () {\n            _this3.unbindFromRedraw(\"_moveDown\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context18 = this.keycharm).call(_context18, \"left\", function () {\n            _this3.unbindFromRedraw(\"_moveLeft\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context19 = this.keycharm).call(_context19, \"right\", function () {\n            _this3.unbindFromRedraw(\"_moveRight\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context20 = this.keycharm).call(_context20, \"=\", function () {\n            _this3.unbindFromRedraw(\"_zoomIn\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context21 = this.keycharm).call(_context21, \"num+\", function () {\n            _this3.unbindFromRedraw(\"_zoomIn\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context22 = this.keycharm).call(_context22, \"num-\", function () {\n            _this3.unbindFromRedraw(\"_zoomOut\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context23 = this.keycharm).call(_context23, \"-\", function () {\n            _this3.unbindFromRedraw(\"_zoomOut\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context24 = this.keycharm).call(_context24, \"[\", function () {\n            _this3.unbindFromRedraw(\"_zoomOut\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context25 = this.keycharm).call(_context25, \"]\", function () {\n            _this3.unbindFromRedraw(\"_zoomIn\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context26 = this.keycharm).call(_context26, \"pageup\", function () {\n            _this3.unbindFromRedraw(\"_zoomIn\");\n          }, \"keyup\");\n          _bindInstanceProperty$1(_context27 = this.keycharm).call(_context27, \"pagedown\", function () {\n            _this3.unbindFromRedraw(\"_zoomOut\");\n          }, \"keyup\");\n        }\n      }\n    }\n  }]);\n  return NavigationHandler;\n}();\n\nfunction _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$4(o, minLen) { var _context15; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$4(o, minLen); var n = _sliceInstanceProperty(_context15 = Object.prototype.toString.call(o)).call(_context15, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return _Array$from$1(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }\nfunction _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n/**\n * Handler for interactions\n */\nvar InteractionHandler = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   * @param {SelectionHandler} selectionHandler\n   */\n  function InteractionHandler(body, canvas, selectionHandler) {\n    var _context, _context2, _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13;\n    _classCallCheck(this, InteractionHandler);\n    this.body = body;\n    this.canvas = canvas;\n    this.selectionHandler = selectionHandler;\n    this.navigationHandler = new NavigationHandler(body, canvas);\n\n    // bind the events from hammer to functions in this object\n    this.body.eventListeners.onTap = _bindInstanceProperty$1(_context = this.onTap).call(_context, this);\n    this.body.eventListeners.onTouch = _bindInstanceProperty$1(_context2 = this.onTouch).call(_context2, this);\n    this.body.eventListeners.onDoubleTap = _bindInstanceProperty$1(_context3 = this.onDoubleTap).call(_context3, this);\n    this.body.eventListeners.onHold = _bindInstanceProperty$1(_context4 = this.onHold).call(_context4, this);\n    this.body.eventListeners.onDragStart = _bindInstanceProperty$1(_context5 = this.onDragStart).call(_context5, this);\n    this.body.eventListeners.onDrag = _bindInstanceProperty$1(_context6 = this.onDrag).call(_context6, this);\n    this.body.eventListeners.onDragEnd = _bindInstanceProperty$1(_context7 = this.onDragEnd).call(_context7, this);\n    this.body.eventListeners.onMouseWheel = _bindInstanceProperty$1(_context8 = this.onMouseWheel).call(_context8, this);\n    this.body.eventListeners.onPinch = _bindInstanceProperty$1(_context9 = this.onPinch).call(_context9, this);\n    this.body.eventListeners.onMouseMove = _bindInstanceProperty$1(_context10 = this.onMouseMove).call(_context10, this);\n    this.body.eventListeners.onRelease = _bindInstanceProperty$1(_context11 = this.onRelease).call(_context11, this);\n    this.body.eventListeners.onContext = _bindInstanceProperty$1(_context12 = this.onContext).call(_context12, this);\n    this.touchTime = 0;\n    this.drag = {};\n    this.pinch = {};\n    this.popup = undefined;\n    this.popupObj = undefined;\n    this.popupTimer = undefined;\n    this.body.functions.getPointer = _bindInstanceProperty$1(_context13 = this.getPointer).call(_context13, this);\n    this.options = {};\n    this.defaultOptions = {\n      dragNodes: true,\n      dragView: true,\n      hover: false,\n      keyboard: {\n        enabled: false,\n        speed: {\n          x: 10,\n          y: 10,\n          zoom: 0.02\n        },\n        bindToWindow: true,\n        autoFocus: true\n      },\n      navigationButtons: false,\n      tooltipDelay: 300,\n      zoomView: true,\n      zoomSpeed: 1\n    };\n    _Object$assign(this.options, this.defaultOptions);\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n  _createClass(InteractionHandler, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this = this;\n      this.body.emitter.on(\"destroy\", function () {\n        clearTimeout(_this.popupTimer);\n        delete _this.body.functions.getPointer;\n      });\n    }\n\n    /**\n     *\n     * @param {object} options\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        // extend all but the values in fields\n        var fields = [\"hideEdgesOnDrag\", \"hideEdgesOnZoom\", \"hideNodesOnDrag\", \"keyboard\", \"multiselect\", \"selectable\", \"selectConnectedEdges\"];\n        selectiveNotDeepExtend(fields, this.options, options);\n\n        // merge the keyboard options in.\n        mergeOptions(this.options, options, \"keyboard\");\n        if (options.tooltip) {\n          _Object$assign(this.options.tooltip, options.tooltip);\n          if (options.tooltip.color) {\n            this.options.tooltip.color = parseColor(options.tooltip.color);\n          }\n        }\n      }\n      this.navigationHandler.setOptions(this.options);\n    }\n\n    /**\n     * Get the pointer location from a touch location\n     *\n     * @param {{x: number, y: number}} touch\n     * @returns {{x: number, y: number}} pointer\n     * @private\n     */\n  }, {\n    key: \"getPointer\",\n    value: function getPointer(touch) {\n      return {\n        x: touch.x - getAbsoluteLeft(this.canvas.frame.canvas),\n        y: touch.y - getAbsoluteTop(this.canvas.frame.canvas)\n      };\n    }\n\n    /**\n     * On start of a touch gesture, store the pointer\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n  }, {\n    key: \"onTouch\",\n    value: function onTouch(event) {\n      if (new Date().valueOf() - this.touchTime > 50) {\n        this.drag.pointer = this.getPointer(event.center);\n        this.drag.pinched = false;\n        this.pinch.scale = this.body.view.scale;\n        // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)\n        this.touchTime = new Date().valueOf();\n      }\n    }\n\n    /**\n     * handle tap/click event: select/unselect a node\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"onTap\",\n    value: function onTap(event) {\n      var pointer = this.getPointer(event.center);\n      var multiselect = this.selectionHandler.options.multiselect && (event.changedPointers[0].ctrlKey || event.changedPointers[0].metaKey);\n      this.checkSelectionChanges(pointer, multiselect);\n      this.selectionHandler.commitAndEmit(pointer, event);\n      this.selectionHandler.generateClickEvent(\"click\", event, pointer);\n    }\n\n    /**\n     * handle doubletap event\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"onDoubleTap\",\n    value: function onDoubleTap(event) {\n      var pointer = this.getPointer(event.center);\n      this.selectionHandler.generateClickEvent(\"doubleClick\", event, pointer);\n    }\n\n    /**\n     * handle long tap event: multi select nodes\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"onHold\",\n    value: function onHold(event) {\n      var pointer = this.getPointer(event.center);\n      var multiselect = this.selectionHandler.options.multiselect;\n      this.checkSelectionChanges(pointer, multiselect);\n      this.selectionHandler.commitAndEmit(pointer, event);\n      this.selectionHandler.generateClickEvent(\"click\", event, pointer);\n      this.selectionHandler.generateClickEvent(\"hold\", event, pointer);\n    }\n\n    /**\n     * handle the release of the screen\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"onRelease\",\n    value: function onRelease(event) {\n      if (new Date().valueOf() - this.touchTime > 10) {\n        var pointer = this.getPointer(event.center);\n        this.selectionHandler.generateClickEvent(\"release\", event, pointer);\n        // to avoid double fireing of this event because we have two hammer instances. (on canvas and on frame)\n        this.touchTime = new Date().valueOf();\n      }\n    }\n\n    /**\n     *\n     * @param {Event} event\n     */\n  }, {\n    key: \"onContext\",\n    value: function onContext(event) {\n      var pointer = this.getPointer({\n        x: event.clientX,\n        y: event.clientY\n      });\n      this.selectionHandler.generateClickEvent(\"oncontext\", event, pointer);\n    }\n\n    /**\n     * Select and deselect nodes depending current selection change.\n     *\n     * @param {{x: number, y: number}} pointer\n     * @param {boolean} [add=false]\n     */\n  }, {\n    key: \"checkSelectionChanges\",\n    value: function checkSelectionChanges(pointer) {\n      var add = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (add === true) {\n        this.selectionHandler.selectAdditionalOnPoint(pointer);\n      } else {\n        this.selectionHandler.selectOnPoint(pointer);\n      }\n    }\n\n    /**\n     * Remove all node and edge id's from the first set that are present in the second one.\n     *\n     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} firstSet\n     * @param {{nodes: Array.<Node>, edges: Array.<vis.Edge>}} secondSet\n     * @returns {{nodes: Array.<Node>, edges: Array.<vis.Edge>}}\n     * @private\n     */\n  }, {\n    key: \"_determineDifference\",\n    value: function _determineDifference(firstSet, secondSet) {\n      var arrayDiff = function arrayDiff(firstArr, secondArr) {\n        var result = [];\n        for (var i = 0; i < firstArr.length; i++) {\n          var value = firstArr[i];\n          if (_indexOfInstanceProperty(secondArr).call(secondArr, value) === -1) {\n            result.push(value);\n          }\n        }\n        return result;\n      };\n      return {\n        nodes: arrayDiff(firstSet.nodes, secondSet.nodes),\n        edges: arrayDiff(firstSet.edges, secondSet.edges)\n      };\n    }\n\n    /**\n     * This function is called by onDragStart.\n     * It is separated out because we can then overload it for the datamanipulation system.\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"onDragStart\",\n    value: function onDragStart(event) {\n      // if already dragging, do not start\n      // this can happen on touch screens with multiple fingers\n      if (this.drag.dragging) {\n        return;\n      }\n\n      //in case the touch event was triggered on an external div, do the initial touch now.\n      if (this.drag.pointer === undefined) {\n        this.onTouch(event);\n      }\n\n      // note: drag.pointer is set in onTouch to get the initial touch location\n      var node = this.selectionHandler.getNodeAt(this.drag.pointer);\n      this.drag.dragging = true;\n      this.drag.selection = [];\n      this.drag.translation = _Object$assign({}, this.body.view.translation); // copy the object\n      this.drag.nodeId = undefined;\n      if (event.srcEvent.shiftKey) {\n        this.body.selectionBox.show = true;\n        var pointer = this.getPointer(event.center);\n        this.body.selectionBox.position.start = {\n          x: this.canvas._XconvertDOMtoCanvas(pointer.x),\n          y: this.canvas._YconvertDOMtoCanvas(pointer.y)\n        };\n        this.body.selectionBox.position.end = {\n          x: this.canvas._XconvertDOMtoCanvas(pointer.x),\n          y: this.canvas._YconvertDOMtoCanvas(pointer.y)\n        };\n      } else if (node !== undefined && this.options.dragNodes === true) {\n        this.drag.nodeId = node.id;\n        // select the clicked node if not yet selected\n        if (node.isSelected() === false) {\n          this.selectionHandler.setSelection({\n            nodes: [node.id]\n          });\n        }\n\n        // after select to contain the node\n        this.selectionHandler.generateClickEvent(\"dragStart\", event, this.drag.pointer);\n\n        // create an array with the selected nodes and their original location and status\n        var _iterator = _createForOfIteratorHelper$4(this.selectionHandler.getSelectedNodes()),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _node = _step.value;\n            var s = {\n              id: _node.id,\n              node: _node,\n              // store original x, y, xFixed and yFixed, make the node temporarily Fixed\n              x: _node.x,\n              y: _node.y,\n              xFixed: _node.options.fixed.x,\n              yFixed: _node.options.fixed.y\n            };\n            _node.options.fixed.x = true;\n            _node.options.fixed.y = true;\n            this.drag.selection.push(s);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        // fallback if no node is selected and thus the view is dragged.\n        this.selectionHandler.generateClickEvent(\"dragStart\", event, this.drag.pointer, undefined, true);\n      }\n    }\n\n    /**\n     * handle drag event\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"onDrag\",\n    value: function onDrag(event) {\n      var _this2 = this;\n      if (this.drag.pinched === true) {\n        return;\n      }\n\n      // remove the focus on node if it is focussed on by the focusOnNode\n      this.body.emitter.emit(\"unlockNode\");\n      var pointer = this.getPointer(event.center);\n      var selection = this.drag.selection;\n      if (selection && selection.length && this.options.dragNodes === true) {\n        this.selectionHandler.generateClickEvent(\"dragging\", event, pointer);\n\n        // calculate delta's and new location\n        var deltaX = pointer.x - this.drag.pointer.x;\n        var deltaY = pointer.y - this.drag.pointer.y;\n\n        // update position of all selected nodes\n        _forEachInstanceProperty(selection).call(selection, function (selection) {\n          var node = selection.node;\n          // only move the node if it was not fixed initially\n          if (selection.xFixed === false) {\n            node.x = _this2.canvas._XconvertDOMtoCanvas(_this2.canvas._XconvertCanvasToDOM(selection.x) + deltaX);\n          }\n          // only move the node if it was not fixed initially\n          if (selection.yFixed === false) {\n            node.y = _this2.canvas._YconvertDOMtoCanvas(_this2.canvas._YconvertCanvasToDOM(selection.y) + deltaY);\n          }\n        });\n\n        // start the simulation of the physics\n        this.body.emitter.emit(\"startSimulation\");\n      } else {\n        // create selection box\n        if (event.srcEvent.shiftKey) {\n          this.selectionHandler.generateClickEvent(\"dragging\", event, pointer, undefined, true);\n\n          // if the drag was not started properly because the click started outside the network div, start it now.\n          if (this.drag.pointer === undefined) {\n            this.onDragStart(event);\n            return;\n          }\n          this.body.selectionBox.position.end = {\n            x: this.canvas._XconvertDOMtoCanvas(pointer.x),\n            y: this.canvas._YconvertDOMtoCanvas(pointer.y)\n          };\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n\n        // move the network\n        if (this.options.dragView === true && !event.srcEvent.shiftKey) {\n          this.selectionHandler.generateClickEvent(\"dragging\", event, pointer, undefined, true);\n\n          // if the drag was not started properly because the click started outside the network div, start it now.\n          if (this.drag.pointer === undefined) {\n            this.onDragStart(event);\n            return;\n          }\n          var diffX = pointer.x - this.drag.pointer.x;\n          var diffY = pointer.y - this.drag.pointer.y;\n          this.body.view.translation = {\n            x: this.drag.translation.x + diffX,\n            y: this.drag.translation.y + diffY\n          };\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n      }\n    }\n\n    /**\n     * handle drag start event\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"onDragEnd\",\n    value: function onDragEnd(event) {\n      var _this3 = this;\n      this.drag.dragging = false;\n      if (this.body.selectionBox.show) {\n        var _context14;\n        this.body.selectionBox.show = false;\n        var selectionBoxPosition = this.body.selectionBox.position;\n        var selectionBoxPositionMinMax = {\n          minX: Math.min(selectionBoxPosition.start.x, selectionBoxPosition.end.x),\n          minY: Math.min(selectionBoxPosition.start.y, selectionBoxPosition.end.y),\n          maxX: Math.max(selectionBoxPosition.start.x, selectionBoxPosition.end.x),\n          maxY: Math.max(selectionBoxPosition.start.y, selectionBoxPosition.end.y)\n        };\n        var toBeSelectedNodes = _filterInstanceProperty(_context14 = this.body.nodeIndices).call(_context14, function (nodeId) {\n          var node = _this3.body.nodes[nodeId];\n          return node.x >= selectionBoxPositionMinMax.minX && node.x <= selectionBoxPositionMinMax.maxX && node.y >= selectionBoxPositionMinMax.minY && node.y <= selectionBoxPositionMinMax.maxY;\n        });\n        _forEachInstanceProperty(toBeSelectedNodes).call(toBeSelectedNodes, function (nodeId) {\n          return _this3.selectionHandler.selectObject(_this3.body.nodes[nodeId]);\n        });\n        var pointer = this.getPointer(event.center);\n        this.selectionHandler.commitAndEmit(pointer, event);\n        this.selectionHandler.generateClickEvent(\"dragEnd\", event, this.getPointer(event.center), undefined, true);\n        this.body.emitter.emit(\"_requestRedraw\");\n      } else {\n        var selection = this.drag.selection;\n        if (selection && selection.length) {\n          _forEachInstanceProperty(selection).call(selection, function (s) {\n            // restore original xFixed and yFixed\n            s.node.options.fixed.x = s.xFixed;\n            s.node.options.fixed.y = s.yFixed;\n          });\n          this.selectionHandler.generateClickEvent(\"dragEnd\", event, this.getPointer(event.center));\n          this.body.emitter.emit(\"startSimulation\");\n        } else {\n          this.selectionHandler.generateClickEvent(\"dragEnd\", event, this.getPointer(event.center), undefined, true);\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n      }\n    }\n\n    /**\n     * Handle pinch event\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n  }, {\n    key: \"onPinch\",\n    value: function onPinch(event) {\n      var pointer = this.getPointer(event.center);\n      this.drag.pinched = true;\n      if (this.pinch[\"scale\"] === undefined) {\n        this.pinch.scale = 1;\n      }\n\n      // TODO: enabled moving while pinching?\n      var scale = this.pinch.scale * event.scale;\n      this.zoom(scale, pointer);\n    }\n\n    /**\n     * Zoom the network in or out\n     *\n     * @param {number} scale a number around 1, and between 0.01 and 10\n     * @param {{x: number, y: number}} pointer    Position on screen\n     * @private\n     */\n  }, {\n    key: \"zoom\",\n    value: function zoom(scale, pointer) {\n      if (this.options.zoomView === true) {\n        var scaleOld = this.body.view.scale;\n        if (scale < 0.00001) {\n          scale = 0.00001;\n        }\n        if (scale > 10) {\n          scale = 10;\n        }\n        var preScaleDragPointer = undefined;\n        if (this.drag !== undefined) {\n          if (this.drag.dragging === true) {\n            preScaleDragPointer = this.canvas.DOMtoCanvas(this.drag.pointer);\n          }\n        }\n        // + this.canvas.frame.canvas.clientHeight / 2\n        var translation = this.body.view.translation;\n        var scaleFrac = scale / scaleOld;\n        var tx = (1 - scaleFrac) * pointer.x + translation.x * scaleFrac;\n        var ty = (1 - scaleFrac) * pointer.y + translation.y * scaleFrac;\n        this.body.view.scale = scale;\n        this.body.view.translation = {\n          x: tx,\n          y: ty\n        };\n        if (preScaleDragPointer != undefined) {\n          var postScaleDragPointer = this.canvas.canvasToDOM(preScaleDragPointer);\n          this.drag.pointer.x = postScaleDragPointer.x;\n          this.drag.pointer.y = postScaleDragPointer.y;\n        }\n        this.body.emitter.emit(\"_requestRedraw\");\n        if (scaleOld < scale) {\n          this.body.emitter.emit(\"zoom\", {\n            direction: \"+\",\n            scale: this.body.view.scale,\n            pointer: pointer\n          });\n        } else {\n          this.body.emitter.emit(\"zoom\", {\n            direction: \"-\",\n            scale: this.body.view.scale,\n            pointer: pointer\n          });\n        }\n      }\n    }\n\n    /**\n     * Event handler for mouse wheel event, used to zoom the timeline\n     * See http://adomas.org/javascript-mouse-wheel/\n     *     https://github.com/EightMedia/hammer.js/issues/256\n     *\n     * @param {MouseEvent}  event\n     * @private\n     */\n  }, {\n    key: \"onMouseWheel\",\n    value: function onMouseWheel(event) {\n      if (this.options.zoomView === true) {\n        // If delta is nonzero, handle it.\n        // Basically, delta is now positive if wheel was scrolled up,\n        // and negative, if wheel was scrolled down.\n        if (event.deltaY !== 0) {\n          // calculate the new scale\n          var scale = this.body.view.scale;\n          scale *= 1 + (event.deltaY < 0 ? 1 : -1) * (this.options.zoomSpeed * 0.1);\n\n          // calculate the pointer location\n          var pointer = this.getPointer({\n            x: event.clientX,\n            y: event.clientY\n          });\n\n          // apply the new scale\n          this.zoom(scale, pointer);\n        }\n\n        // Prevent default actions caused by mouse wheel.\n        event.preventDefault();\n      }\n    }\n\n    /**\n     * Mouse move handler for checking whether the title moves over a node with a title.\n     *\n     * @param  {Event} event\n     * @private\n     */\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(event) {\n      var _this4 = this;\n      var pointer = this.getPointer({\n        x: event.clientX,\n        y: event.clientY\n      });\n      var popupVisible = false;\n\n      // check if the previously selected node is still selected\n      if (this.popup !== undefined) {\n        if (this.popup.hidden === false) {\n          this._checkHidePopup(pointer);\n        }\n\n        // if the popup was not hidden above\n        if (this.popup.hidden === false) {\n          popupVisible = true;\n          this.popup.setPosition(pointer.x + 3, pointer.y - 5);\n          this.popup.show();\n        }\n      }\n\n      // if we bind the keyboard to the div, we have to highlight it to use it. This highlights it on mouse over.\n      if (this.options.keyboard.autoFocus && this.options.keyboard.bindToWindow === false && this.options.keyboard.enabled === true) {\n        this.canvas.frame.focus();\n      }\n\n      // start a timeout that will check if the mouse is positioned above an element\n      if (popupVisible === false) {\n        if (this.popupTimer !== undefined) {\n          clearInterval(this.popupTimer); // stop any running calculationTimer\n          this.popupTimer = undefined;\n        }\n        if (!this.drag.dragging) {\n          this.popupTimer = _setTimeout(function () {\n            return _this4._checkShowPopup(pointer);\n          }, this.options.tooltipDelay);\n        }\n      }\n\n      // adding hover highlights\n      if (this.options.hover === true) {\n        this.selectionHandler.hoverObject(event, pointer);\n      }\n    }\n\n    /**\n     * Check if there is an element on the given position in the network\n     * (a node or edge). If so, and if this element has a title,\n     * show a popup window with its title.\n     *\n     * @param {{x:number, y:number}} pointer\n     * @private\n     */\n  }, {\n    key: \"_checkShowPopup\",\n    value: function _checkShowPopup(pointer) {\n      var x = this.canvas._XconvertDOMtoCanvas(pointer.x);\n      var y = this.canvas._YconvertDOMtoCanvas(pointer.y);\n      var pointerObj = {\n        left: x,\n        top: y,\n        right: x,\n        bottom: y\n      };\n      var previousPopupObjId = this.popupObj === undefined ? undefined : this.popupObj.id;\n      var nodeUnderCursor = false;\n      var popupType = \"node\";\n\n      // check if a node is under the cursor.\n      if (this.popupObj === undefined) {\n        // search the nodes for overlap, select the top one in case of multiple nodes\n        var nodeIndices = this.body.nodeIndices;\n        var nodes = this.body.nodes;\n        var node;\n        var overlappingNodes = [];\n        for (var i = 0; i < nodeIndices.length; i++) {\n          node = nodes[nodeIndices[i]];\n          if (node.isOverlappingWith(pointerObj) === true) {\n            nodeUnderCursor = true;\n            if (node.getTitle() !== undefined) {\n              overlappingNodes.push(nodeIndices[i]);\n            }\n          }\n        }\n        if (overlappingNodes.length > 0) {\n          // if there are overlapping nodes, select the last one, this is the one which is drawn on top of the others\n          this.popupObj = nodes[overlappingNodes[overlappingNodes.length - 1]];\n          // if you hover over a node, the title of the edge is not supposed to be shown.\n          nodeUnderCursor = true;\n        }\n      }\n      if (this.popupObj === undefined && nodeUnderCursor === false) {\n        // search the edges for overlap\n        var edgeIndices = this.body.edgeIndices;\n        var edges = this.body.edges;\n        var edge;\n        var overlappingEdges = [];\n        for (var _i = 0; _i < edgeIndices.length; _i++) {\n          edge = edges[edgeIndices[_i]];\n          if (edge.isOverlappingWith(pointerObj) === true) {\n            if (edge.connected === true && edge.getTitle() !== undefined) {\n              overlappingEdges.push(edgeIndices[_i]);\n            }\n          }\n        }\n        if (overlappingEdges.length > 0) {\n          this.popupObj = edges[overlappingEdges[overlappingEdges.length - 1]];\n          popupType = \"edge\";\n        }\n      }\n      if (this.popupObj !== undefined) {\n        // show popup message window\n        if (this.popupObj.id !== previousPopupObjId) {\n          if (this.popup === undefined) {\n            this.popup = new Popup(this.canvas.frame);\n          }\n          this.popup.popupTargetType = popupType;\n          this.popup.popupTargetId = this.popupObj.id;\n\n          // adjust a small offset such that the mouse cursor is located in the\n          // bottom left location of the popup, and you can easily move over the\n          // popup area\n          this.popup.setPosition(pointer.x + 3, pointer.y - 5);\n          this.popup.setText(this.popupObj.getTitle());\n          this.popup.show();\n          this.body.emitter.emit(\"showPopup\", this.popupObj.id);\n        }\n      } else {\n        if (this.popup !== undefined) {\n          this.popup.hide();\n          this.body.emitter.emit(\"hidePopup\");\n        }\n      }\n    }\n\n    /**\n     * Check if the popup must be hidden, which is the case when the mouse is no\n     * longer hovering on the object\n     *\n     * @param {{x:number, y:number}} pointer\n     * @private\n     */\n  }, {\n    key: \"_checkHidePopup\",\n    value: function _checkHidePopup(pointer) {\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n      var stillOnObj = false;\n      if (this.popup.popupTargetType === \"node\") {\n        if (this.body.nodes[this.popup.popupTargetId] !== undefined) {\n          stillOnObj = this.body.nodes[this.popup.popupTargetId].isOverlappingWith(pointerObj);\n\n          // if the mouse is still one the node, we have to check if it is not also on one that is drawn on top of it.\n          // we initially only check stillOnObj because this is much faster.\n          if (stillOnObj === true) {\n            var overNode = this.selectionHandler.getNodeAt(pointer);\n            stillOnObj = overNode === undefined ? false : overNode.id === this.popup.popupTargetId;\n          }\n        }\n      } else {\n        if (this.selectionHandler.getNodeAt(pointer) === undefined) {\n          if (this.body.edges[this.popup.popupTargetId] !== undefined) {\n            stillOnObj = this.body.edges[this.popup.popupTargetId].isOverlappingWith(pointerObj);\n          }\n        }\n      }\n      if (stillOnObj === false) {\n        this.popupObj = undefined;\n        this.popup.hide();\n        this.body.emitter.emit(\"hidePopup\");\n      }\n    }\n  }]);\n  return InteractionHandler;\n}();\n\nvar collection$1 = collection$3;\nvar collectionStrong = collectionStrong$2;\n\n// `Set` constructor\n// https://tc39.es/ecma262/#sec-set-objects\ncollection$1('Set', function (init) {\n  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };\n}, collectionStrong);\n\nvar path$1 = path$w;\n\nvar set$2 = path$1.Set;\n\nvar parent$4 = set$2;\n\n\nvar set$1 = parent$4;\n\nvar set = set$1;\n\nvar _Set = /*@__PURE__*/getDefaultExportFromCjs(set);\n\nvar uncurryThis$2 = functionUncurryThis;\nvar defineBuiltIns$1 = defineBuiltIns$3;\nvar getWeakData = internalMetadataExports.getWeakData;\nvar anInstance = anInstance$3;\nvar anObject = anObject$d;\nvar isNullOrUndefined = isNullOrUndefined$6;\nvar isObject$1 = isObject$j;\nvar iterate = iterate$3;\nvar ArrayIterationModule = arrayIteration;\nvar hasOwn = hasOwnProperty_1;\nvar InternalStateModule = internalState;\n\nvar setInternalState = InternalStateModule.set;\nvar internalStateGetterFor = InternalStateModule.getterFor;\nvar find = ArrayIterationModule.find;\nvar findIndex = ArrayIterationModule.findIndex;\nvar splice = uncurryThis$2([].splice);\nvar id = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function (state) {\n  return state.frozen || (state.frozen = new UncaughtFrozenStore());\n};\n\nvar UncaughtFrozenStore = function () {\n  this.entries = [];\n};\n\nvar findUncaughtFrozen = function (store, key) {\n  return find(store.entries, function (it) {\n    return it[0] === key;\n  });\n};\n\nUncaughtFrozenStore.prototype = {\n  get: function (key) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) return entry[1];\n  },\n  has: function (key) {\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function (key, value) {\n    var entry = findUncaughtFrozen(this, key);\n    if (entry) entry[1] = value;\n    else this.entries.push([key, value]);\n  },\n  'delete': function (key) {\n    var index = findIndex(this.entries, function (it) {\n      return it[0] === key;\n    });\n    if (~index) splice(this.entries, index, 1);\n    return !!~index;\n  }\n};\n\nvar collectionWeak$1 = {\n  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n    var Constructor = wrapper(function (that, iterable) {\n      anInstance(that, Prototype);\n      setInternalState(that, {\n        type: CONSTRUCTOR_NAME,\n        id: id++,\n        frozen: undefined\n      });\n      if (!isNullOrUndefined(iterable)) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });\n    });\n\n    var Prototype = Constructor.prototype;\n\n    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);\n\n    var define = function (that, key, value) {\n      var state = getInternalState(that);\n      var data = getWeakData(anObject(key), true);\n      if (data === true) uncaughtFrozenStore(state).set(key, value);\n      else data[state.id] = value;\n      return that;\n    };\n\n    defineBuiltIns$1(Prototype, {\n      // `{ WeakMap, WeakSet }.prototype.delete(key)` methods\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.delete\n      // https://tc39.es/ecma262/#sec-weakset.prototype.delete\n      'delete': function (key) {\n        var state = getInternalState(this);\n        if (!isObject$1(key)) return false;\n        var data = getWeakData(key);\n        if (data === true) return uncaughtFrozenStore(state)['delete'](key);\n        return data && hasOwn(data, state.id) && delete data[state.id];\n      },\n      // `{ WeakMap, WeakSet }.prototype.has(key)` methods\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.has\n      // https://tc39.es/ecma262/#sec-weakset.prototype.has\n      has: function has(key) {\n        var state = getInternalState(this);\n        if (!isObject$1(key)) return false;\n        var data = getWeakData(key);\n        if (data === true) return uncaughtFrozenStore(state).has(key);\n        return data && hasOwn(data, state.id);\n      }\n    });\n\n    defineBuiltIns$1(Prototype, IS_MAP ? {\n      // `WeakMap.prototype.get(key)` method\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.get\n      get: function get(key) {\n        var state = getInternalState(this);\n        if (isObject$1(key)) {\n          var data = getWeakData(key);\n          if (data === true) return uncaughtFrozenStore(state).get(key);\n          return data ? data[state.id] : undefined;\n        }\n      },\n      // `WeakMap.prototype.set(key, value)` method\n      // https://tc39.es/ecma262/#sec-weakmap.prototype.set\n      set: function set(key, value) {\n        return define(this, key, value);\n      }\n    } : {\n      // `WeakSet.prototype.add(value)` method\n      // https://tc39.es/ecma262/#sec-weakset.prototype.add\n      add: function add(value) {\n        return define(this, value, true);\n      }\n    });\n\n    return Constructor;\n  }\n};\n\nvar FREEZING = freezing;\nvar global$2 = global$n;\nvar uncurryThis$1 = functionUncurryThis;\nvar defineBuiltIns = defineBuiltIns$3;\nvar InternalMetadataModule = internalMetadataExports;\nvar collection = collection$3;\nvar collectionWeak = collectionWeak$1;\nvar isObject = isObject$j;\nvar enforceInternalState = internalState.enforce;\nvar fails$1 = fails$w;\nvar NATIVE_WEAK_MAP = weakMapBasicDetection;\n\nvar $Object = Object;\n// eslint-disable-next-line es/no-array-isarray -- safe\nvar isArray = Array.isArray;\n// eslint-disable-next-line es/no-object-isextensible -- safe\nvar isExtensible = $Object.isExtensible;\n// eslint-disable-next-line es/no-object-isfrozen -- safe\nvar isFrozen = $Object.isFrozen;\n// eslint-disable-next-line es/no-object-issealed -- safe\nvar isSealed = $Object.isSealed;\n// eslint-disable-next-line es/no-object-freeze -- safe\nvar freeze = $Object.freeze;\n// eslint-disable-next-line es/no-object-seal -- safe\nvar seal = $Object.seal;\n\nvar FROZEN = {};\nvar SEALED = {};\nvar IS_IE11 = !global$2.ActiveXObject && 'ActiveXObject' in global$2;\nvar InternalWeakMap;\n\nvar wrapper = function (init) {\n  return function WeakMap() {\n    return init(this, arguments.length ? arguments[0] : undefined);\n  };\n};\n\n// `WeakMap` constructor\n// https://tc39.es/ecma262/#sec-weakmap-constructor\nvar $WeakMap = collection('WeakMap', wrapper, collectionWeak);\nvar WeakMapPrototype = $WeakMap.prototype;\nvar nativeSet = uncurryThis$1(WeakMapPrototype.set);\n\n// Chakra Edge bug: adding frozen arrays to WeakMap unfreeze them\nvar hasMSEdgeFreezingBug = function () {\n  return FREEZING && fails$1(function () {\n    var frozenArray = freeze([]);\n    nativeSet(new $WeakMap(), frozenArray, 1);\n    return !isFrozen(frozenArray);\n  });\n};\n\n// IE11 WeakMap frozen keys fix\n// We can't use feature detection because it crash some old IE builds\n// https://github.com/zloirock/core-js/issues/485\nif (NATIVE_WEAK_MAP) if (IS_IE11) {\n  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);\n  InternalMetadataModule.enable();\n  var nativeDelete = uncurryThis$1(WeakMapPrototype['delete']);\n  var nativeHas = uncurryThis$1(WeakMapPrototype.has);\n  var nativeGet = uncurryThis$1(WeakMapPrototype.get);\n  defineBuiltIns(WeakMapPrototype, {\n    'delete': function (key) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        return nativeDelete(this, key) || state.frozen['delete'](key);\n      } return nativeDelete(this, key);\n    },\n    has: function has(key) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        return nativeHas(this, key) || state.frozen.has(key);\n      } return nativeHas(this, key);\n    },\n    get: function get(key) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        return nativeHas(this, key) ? nativeGet(this, key) : state.frozen.get(key);\n      } return nativeGet(this, key);\n    },\n    set: function set(key, value) {\n      if (isObject(key) && !isExtensible(key)) {\n        var state = enforceInternalState(this);\n        if (!state.frozen) state.frozen = new InternalWeakMap();\n        nativeHas(this, key) ? nativeSet(this, key, value) : state.frozen.set(key, value);\n      } else nativeSet(this, key, value);\n      return this;\n    }\n  });\n// Chakra Edge frozen keys fix\n} else if (hasMSEdgeFreezingBug()) {\n  defineBuiltIns(WeakMapPrototype, {\n    set: function set(key, value) {\n      var arrayIntegrityLevel;\n      if (isArray(key)) {\n        if (isFrozen(key)) arrayIntegrityLevel = FROZEN;\n        else if (isSealed(key)) arrayIntegrityLevel = SEALED;\n      }\n      nativeSet(this, key, value);\n      if (arrayIntegrityLevel === FROZEN) freeze(key);\n      if (arrayIntegrityLevel === SEALED) seal(key);\n      return this;\n    }\n  });\n}\n\nvar path = path$w;\n\nvar weakMap$2 = path.WeakMap;\n\nvar parent$3 = weakMap$2;\n\n\nvar weakMap$1 = parent$3;\n\nvar weakMap = weakMap$1;\n\nvar _WeakMap = /*@__PURE__*/getDefaultExportFromCjs(weakMap);\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nfunction _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$3(o, minLen) { var _context2; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$3(o, minLen); var n = _sliceInstanceProperty(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return _Array$from$1(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }\nfunction _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar _SingleTypeSelectionAccumulator_previousSelection, _SingleTypeSelectionAccumulator_selection, _SelectionAccumulator_nodes, _SelectionAccumulator_edges, _SelectionAccumulator_commitHandler;\n/**\r\n * @param prev\r\n * @param next\r\n */\nfunction diffSets(prev, next) {\n  var diff = new _Set();\n  var _iterator = _createForOfIteratorHelper$3(next),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      if (!prev.has(item)) {\n        diff.add(item);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return diff;\n}\nvar SingleTypeSelectionAccumulator = /*#__PURE__*/function () {\n  function SingleTypeSelectionAccumulator() {\n    _classCallCheck(this, SingleTypeSelectionAccumulator);\n    _SingleTypeSelectionAccumulator_previousSelection.set(this, new _Set());\n    _SingleTypeSelectionAccumulator_selection.set(this, new _Set());\n  }\n  _createClass(SingleTypeSelectionAccumulator, [{\n    key: \"size\",\n    get: function get() {\n      return __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\").size;\n    }\n  }, {\n    key: \"add\",\n    value: function add() {\n      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n        items[_key] = arguments[_key];\n      }\n      for (var _i = 0, _items = items; _i < _items.length; _i++) {\n        var item = _items[_i];\n        __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\").add(item);\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        items[_key2] = arguments[_key2];\n      }\n      for (var _i2 = 0, _items2 = items; _i2 < _items2.length; _i2++) {\n        var item = _items2[_i2];\n        __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\").delete(item);\n      }\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\").clear();\n    }\n  }, {\n    key: \"getSelection\",\n    value: function getSelection() {\n      return _toConsumableArray(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\"));\n    }\n  }, {\n    key: \"getChanges\",\n    value: function getChanges() {\n      return {\n        added: _toConsumableArray(diffSets(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, \"f\"), __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\"))),\n        deleted: _toConsumableArray(diffSets(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\"), __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, \"f\"))),\n        previous: _toConsumableArray(new _Set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, \"f\"))),\n        current: _toConsumableArray(new _Set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\")))\n      };\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      var changes = this.getChanges();\n      __classPrivateFieldSet(this, _SingleTypeSelectionAccumulator_previousSelection, __classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_selection, \"f\"), \"f\");\n      __classPrivateFieldSet(this, _SingleTypeSelectionAccumulator_selection, new _Set(__classPrivateFieldGet(this, _SingleTypeSelectionAccumulator_previousSelection, \"f\")), \"f\");\n      var _iterator2 = _createForOfIteratorHelper$3(changes.added),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          item.select();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var _iterator3 = _createForOfIteratorHelper$3(changes.deleted),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _item = _step3.value;\n          _item.unselect();\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return changes;\n    }\n  }]);\n  return SingleTypeSelectionAccumulator;\n}();\n_SingleTypeSelectionAccumulator_previousSelection = new _WeakMap(), _SingleTypeSelectionAccumulator_selection = new _WeakMap();\nvar SelectionAccumulator = /*#__PURE__*/function () {\n  function SelectionAccumulator() {\n    var commitHandler = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n    _classCallCheck(this, SelectionAccumulator);\n    _SelectionAccumulator_nodes.set(this, new SingleTypeSelectionAccumulator());\n    _SelectionAccumulator_edges.set(this, new SingleTypeSelectionAccumulator());\n    _SelectionAccumulator_commitHandler.set(this, void 0);\n    __classPrivateFieldSet(this, _SelectionAccumulator_commitHandler, commitHandler, \"f\");\n  }\n  _createClass(SelectionAccumulator, [{\n    key: \"sizeNodes\",\n    get: function get() {\n      return __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\").size;\n    }\n  }, {\n    key: \"sizeEdges\",\n    get: function get() {\n      return __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\").size;\n    }\n  }, {\n    key: \"getNodes\",\n    value: function getNodes() {\n      return __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\").getSelection();\n    }\n  }, {\n    key: \"getEdges\",\n    value: function getEdges() {\n      return __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\").getSelection();\n    }\n  }, {\n    key: \"addNodes\",\n    value: function addNodes() {\n      var _classPrivateFieldGe;\n      (_classPrivateFieldGe = __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\")).add.apply(_classPrivateFieldGe, arguments);\n    }\n  }, {\n    key: \"addEdges\",\n    value: function addEdges() {\n      var _classPrivateFieldGe2;\n      (_classPrivateFieldGe2 = __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\")).add.apply(_classPrivateFieldGe2, arguments);\n    }\n  }, {\n    key: \"deleteNodes\",\n    value: function deleteNodes(node) {\n      __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\").delete(node);\n    }\n  }, {\n    key: \"deleteEdges\",\n    value: function deleteEdges(edge) {\n      __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\").delete(edge);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\").clear();\n      __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\").clear();\n    }\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      var _classPrivateFieldGe3, _context;\n      var summary = {\n        nodes: __classPrivateFieldGet(this, _SelectionAccumulator_nodes, \"f\").commit(),\n        edges: __classPrivateFieldGet(this, _SelectionAccumulator_edges, \"f\").commit()\n      };\n      for (var _len3 = arguments.length, rest = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        rest[_key3] = arguments[_key3];\n      }\n      (_classPrivateFieldGe3 = __classPrivateFieldGet(this, _SelectionAccumulator_commitHandler, \"f\")).call.apply(_classPrivateFieldGe3, _concatInstanceProperty(_context = [this, summary]).call(_context, rest));\n      return summary;\n    }\n  }]);\n  return SelectionAccumulator;\n}();\n_SelectionAccumulator_nodes = new _WeakMap(), _SelectionAccumulator_edges = new _WeakMap(), _SelectionAccumulator_commitHandler = new _WeakMap();\n\nfunction _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$2(o, minLen) { var _context3; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$2(o, minLen); var n = _sliceInstanceProperty(_context3 = Object.prototype.toString.call(o)).call(_context3, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return _Array$from$1(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }\nfunction _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n/**\n * The handler for selections\n */\nvar SelectionHandler = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   */\n  function SelectionHandler(body, canvas) {\n    var _this = this;\n    _classCallCheck(this, SelectionHandler);\n    this.body = body;\n    this.canvas = canvas;\n    // TODO: Consider firing an event on any change to the selection, not\n    // only those caused by clicks and taps. It would be easy to implement\n    // now and (at least to me) it seems like something that could be\n    // quite useful.\n    this._selectionAccumulator = new SelectionAccumulator();\n    this.hoverObj = {\n      nodes: {},\n      edges: {}\n    };\n    this.options = {};\n    this.defaultOptions = {\n      multiselect: false,\n      selectable: true,\n      selectConnectedEdges: true,\n      hoverConnectedEdges: true\n    };\n    _Object$assign(this.options, this.defaultOptions);\n    this.body.emitter.on(\"_dataChanged\", function () {\n      _this.updateSelection();\n    });\n  }\n\n  /**\n   *\n   * @param {object} [options]\n   */\n  _createClass(SelectionHandler, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options !== undefined) {\n        var fields = [\"multiselect\", \"hoverConnectedEdges\", \"selectable\", \"selectConnectedEdges\"];\n        selectiveDeepExtend(fields, this.options, options);\n      }\n    }\n\n    /**\n     * handles the selection part of the tap;\n     *\n     * @param {{x: number, y: number}} pointer\n     * @returns {boolean}\n     */\n  }, {\n    key: \"selectOnPoint\",\n    value: function selectOnPoint(pointer) {\n      var selected = false;\n      if (this.options.selectable === true) {\n        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);\n\n        // unselect after getting the objects in order to restore width and height.\n        this.unselectAll();\n        if (obj !== undefined) {\n          selected = this.selectObject(obj);\n        }\n        this.body.emitter.emit(\"_requestRedraw\");\n      }\n      return selected;\n    }\n\n    /**\n     *\n     * @param {{x: number, y: number}} pointer\n     * @returns {boolean}\n     */\n  }, {\n    key: \"selectAdditionalOnPoint\",\n    value: function selectAdditionalOnPoint(pointer) {\n      var selectionChanged = false;\n      if (this.options.selectable === true) {\n        var obj = this.getNodeAt(pointer) || this.getEdgeAt(pointer);\n        if (obj !== undefined) {\n          selectionChanged = true;\n          if (obj.isSelected() === true) {\n            this.deselectObject(obj);\n          } else {\n            this.selectObject(obj);\n          }\n          this.body.emitter.emit(\"_requestRedraw\");\n        }\n      }\n      return selectionChanged;\n    }\n\n    /**\n     * Create an object containing the standard fields for an event.\n     *\n     * @param {Event} event\n     * @param {{x: number, y: number}} pointer Object with the x and y screen coordinates of the mouse\n     * @returns {{}}\n     * @private\n     */\n  }, {\n    key: \"_initBaseEvent\",\n    value: function _initBaseEvent(event, pointer) {\n      var properties = {};\n      properties[\"pointer\"] = {\n        DOM: {\n          x: pointer.x,\n          y: pointer.y\n        },\n        canvas: this.canvas.DOMtoCanvas(pointer)\n      };\n      properties[\"event\"] = event;\n      return properties;\n    }\n\n    /**\n     * Generate an event which the user can catch.\n     *\n     * This adds some extra data to the event with respect to cursor position and\n     * selected nodes and edges.\n     *\n     * @param {string} eventType                          Name of event to send\n     * @param {Event}  event\n     * @param {{x: number, y: number}} pointer            Object with the x and y screen coordinates of the mouse\n     * @param {object | undefined} oldSelection             If present, selection state before event occured\n     * @param {boolean|undefined} [emptySelection=false]  Indicate if selection data should be passed\n     */\n  }, {\n    key: \"generateClickEvent\",\n    value: function generateClickEvent(eventType, event, pointer, oldSelection) {\n      var emptySelection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var properties = this._initBaseEvent(event, pointer);\n      if (emptySelection === true) {\n        properties.nodes = [];\n        properties.edges = [];\n      } else {\n        var tmp = this.getSelection();\n        properties.nodes = tmp.nodes;\n        properties.edges = tmp.edges;\n      }\n      if (oldSelection !== undefined) {\n        properties[\"previousSelection\"] = oldSelection;\n      }\n      if (eventType == \"click\") {\n        // For the time being, restrict this functionality to\n        // just the click event.\n        properties.items = this.getClickedItems(pointer);\n      }\n      if (event.controlEdge !== undefined) {\n        properties.controlEdge = event.controlEdge;\n      }\n      this.body.emitter.emit(eventType, properties);\n    }\n\n    /**\n     *\n     * @param {object} obj\n     * @param {boolean} [highlightEdges=this.options.selectConnectedEdges]\n     * @returns {boolean}\n     */\n  }, {\n    key: \"selectObject\",\n    value: function selectObject(obj) {\n      var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.options.selectConnectedEdges;\n      if (obj !== undefined) {\n        if (obj instanceof Node) {\n          if (highlightEdges === true) {\n            var _this$_selectionAccum;\n            (_this$_selectionAccum = this._selectionAccumulator).addEdges.apply(_this$_selectionAccum, _toConsumableArray(obj.edges));\n          }\n          this._selectionAccumulator.addNodes(obj);\n        } else {\n          this._selectionAccumulator.addEdges(obj);\n        }\n        return true;\n      }\n      return false;\n    }\n\n    /**\n     *\n     * @param {object} obj\n     */\n  }, {\n    key: \"deselectObject\",\n    value: function deselectObject(obj) {\n      if (obj.isSelected() === true) {\n        obj.selected = false;\n        this._removeFromSelection(obj);\n      }\n    }\n\n    /**\n     * retrieve all nodes overlapping with given object\n     *\n     * @param {object} object  An object with parameters left, top, right, bottom\n     * @returns {number[]}   An array with id's of the overlapping nodes\n     * @private\n     */\n  }, {\n    key: \"_getAllNodesOverlappingWith\",\n    value: function _getAllNodesOverlappingWith(object) {\n      var overlappingNodes = [];\n      var nodes = this.body.nodes;\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var nodeId = this.body.nodeIndices[i];\n        if (nodes[nodeId].isOverlappingWith(object)) {\n          overlappingNodes.push(nodeId);\n        }\n      }\n      return overlappingNodes;\n    }\n\n    /**\n     * Return a position object in canvasspace from a single point in screenspace\n     *\n     * @param {{x: number, y: number}} pointer\n     * @returns {{left: number, top: number, right: number, bottom: number}}\n     * @private\n     */\n  }, {\n    key: \"_pointerToPositionObject\",\n    value: function _pointerToPositionObject(pointer) {\n      var canvasPos = this.canvas.DOMtoCanvas(pointer);\n      return {\n        left: canvasPos.x - 1,\n        top: canvasPos.y + 1,\n        right: canvasPos.x + 1,\n        bottom: canvasPos.y - 1\n      };\n    }\n\n    /**\n     * Get the top node at the passed point (like a click)\n     *\n     * @param {{x: number, y: number}} pointer\n     * @param {boolean} [returnNode=true]\n     * @returns {Node | undefined} node\n     */\n  }, {\n    key: \"getNodeAt\",\n    value: function getNodeAt(pointer) {\n      var returnNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      // we first check if this is an navigation controls element\n      var positionObject = this._pointerToPositionObject(pointer);\n      var overlappingNodes = this._getAllNodesOverlappingWith(positionObject);\n      // if there are overlapping nodes, select the last one, this is the\n      // one which is drawn on top of the others\n      if (overlappingNodes.length > 0) {\n        if (returnNode === true) {\n          return this.body.nodes[overlappingNodes[overlappingNodes.length - 1]];\n        } else {\n          return overlappingNodes[overlappingNodes.length - 1];\n        }\n      } else {\n        return undefined;\n      }\n    }\n\n    /**\n     * retrieve all edges overlapping with given object, selector is around center\n     *\n     * @param {object} object  An object with parameters left, top, right, bottom\n     * @param {number[]} overlappingEdges An array with id's of the overlapping nodes\n     * @private\n     */\n  }, {\n    key: \"_getEdgesOverlappingWith\",\n    value: function _getEdgesOverlappingWith(object, overlappingEdges) {\n      var edges = this.body.edges;\n      for (var i = 0; i < this.body.edgeIndices.length; i++) {\n        var edgeId = this.body.edgeIndices[i];\n        if (edges[edgeId].isOverlappingWith(object)) {\n          overlappingEdges.push(edgeId);\n        }\n      }\n    }\n\n    /**\n     * retrieve all nodes overlapping with given object\n     *\n     * @param {object} object  An object with parameters left, top, right, bottom\n     * @returns {number[]}   An array with id's of the overlapping nodes\n     * @private\n     */\n  }, {\n    key: \"_getAllEdgesOverlappingWith\",\n    value: function _getAllEdgesOverlappingWith(object) {\n      var overlappingEdges = [];\n      this._getEdgesOverlappingWith(object, overlappingEdges);\n      return overlappingEdges;\n    }\n\n    /**\n     * Get the edges nearest to the passed point (like a click)\n     *\n     * @param {{x: number, y: number}} pointer\n     * @param {boolean} [returnEdge=true]\n     * @returns {Edge | undefined} node\n     */\n  }, {\n    key: \"getEdgeAt\",\n    value: function getEdgeAt(pointer) {\n      var returnEdge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      // Iterate over edges, pick closest within 10\n      var canvasPos = this.canvas.DOMtoCanvas(pointer);\n      var mindist = 10;\n      var overlappingEdge = null;\n      var edges = this.body.edges;\n      for (var i = 0; i < this.body.edgeIndices.length; i++) {\n        var edgeId = this.body.edgeIndices[i];\n        var edge = edges[edgeId];\n        if (edge.connected) {\n          var xFrom = edge.from.x;\n          var yFrom = edge.from.y;\n          var xTo = edge.to.x;\n          var yTo = edge.to.y;\n          var dist = edge.edgeType.getDistanceToEdge(xFrom, yFrom, xTo, yTo, canvasPos.x, canvasPos.y);\n          if (dist < mindist) {\n            overlappingEdge = edgeId;\n            mindist = dist;\n          }\n        }\n      }\n      if (overlappingEdge !== null) {\n        if (returnEdge === true) {\n          return this.body.edges[overlappingEdge];\n        } else {\n          return overlappingEdge;\n        }\n      } else {\n        return undefined;\n      }\n    }\n\n    /**\n     * Add object to the selection array.\n     *\n     * @param {object} obj\n     * @private\n     */\n  }, {\n    key: \"_addToHover\",\n    value: function _addToHover(obj) {\n      if (obj instanceof Node) {\n        this.hoverObj.nodes[obj.id] = obj;\n      } else {\n        this.hoverObj.edges[obj.id] = obj;\n      }\n    }\n\n    /**\n     * Remove a single option from selection.\n     *\n     * @param {object} obj\n     * @private\n     */\n  }, {\n    key: \"_removeFromSelection\",\n    value: function _removeFromSelection(obj) {\n      if (obj instanceof Node) {\n        var _this$_selectionAccum2;\n        this._selectionAccumulator.deleteNodes(obj);\n        (_this$_selectionAccum2 = this._selectionAccumulator).deleteEdges.apply(_this$_selectionAccum2, _toConsumableArray(obj.edges));\n      } else {\n        this._selectionAccumulator.deleteEdges(obj);\n      }\n    }\n\n    /**\n     * Unselect all nodes and edges.\n     */\n  }, {\n    key: \"unselectAll\",\n    value: function unselectAll() {\n      this._selectionAccumulator.clear();\n    }\n\n    /**\n     * return the number of selected nodes\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getSelectedNodeCount\",\n    value: function getSelectedNodeCount() {\n      return this._selectionAccumulator.sizeNodes;\n    }\n\n    /**\n     * return the number of selected edges\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"getSelectedEdgeCount\",\n    value: function getSelectedEdgeCount() {\n      return this._selectionAccumulator.sizeEdges;\n    }\n\n    /**\n     * select the edges connected to the node that is being selected\n     *\n     * @param {Node} node\n     * @private\n     */\n  }, {\n    key: \"_hoverConnectedEdges\",\n    value: function _hoverConnectedEdges(node) {\n      for (var i = 0; i < node.edges.length; i++) {\n        var edge = node.edges[i];\n        edge.hover = true;\n        this._addToHover(edge);\n      }\n    }\n\n    /**\n     * Remove the highlight from a node or edge, in response to mouse movement\n     *\n     * @param {Event}  event\n     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse\n     * @param {Node|vis.Edge} object\n     * @private\n     */\n  }, {\n    key: \"emitBlurEvent\",\n    value: function emitBlurEvent(event, pointer, object) {\n      var properties = this._initBaseEvent(event, pointer);\n      if (object.hover === true) {\n        object.hover = false;\n        if (object instanceof Node) {\n          properties.node = object.id;\n          this.body.emitter.emit(\"blurNode\", properties);\n        } else {\n          properties.edge = object.id;\n          this.body.emitter.emit(\"blurEdge\", properties);\n        }\n      }\n    }\n\n    /**\n     * Create the highlight for a node or edge, in response to mouse movement\n     *\n     * @param {Event}  event\n     * @param {{x: number, y: number}} pointer object with the x and y screen coordinates of the mouse\n     * @param {Node|vis.Edge} object\n     * @returns {boolean} hoverChanged\n     * @private\n     */\n  }, {\n    key: \"emitHoverEvent\",\n    value: function emitHoverEvent(event, pointer, object) {\n      var properties = this._initBaseEvent(event, pointer);\n      var hoverChanged = false;\n      if (object.hover === false) {\n        object.hover = true;\n        this._addToHover(object);\n        hoverChanged = true;\n        if (object instanceof Node) {\n          properties.node = object.id;\n          this.body.emitter.emit(\"hoverNode\", properties);\n        } else {\n          properties.edge = object.id;\n          this.body.emitter.emit(\"hoverEdge\", properties);\n        }\n      }\n      return hoverChanged;\n    }\n\n    /**\n     * Perform actions in response to a mouse movement.\n     *\n     * @param {Event}  event\n     * @param {{x: number, y: number}} pointer | object with the x and y screen coordinates of the mouse\n     */\n  }, {\n    key: \"hoverObject\",\n    value: function hoverObject(event, pointer) {\n      var object = this.getNodeAt(pointer);\n      if (object === undefined) {\n        object = this.getEdgeAt(pointer);\n      }\n      var hoverChanged = false;\n      // remove all node hover highlights\n      for (var nodeId in this.hoverObj.nodes) {\n        if (Object.prototype.hasOwnProperty.call(this.hoverObj.nodes, nodeId)) {\n          if (object === undefined || object instanceof Node && object.id != nodeId || object instanceof Edge) {\n            this.emitBlurEvent(event, pointer, this.hoverObj.nodes[nodeId]);\n            delete this.hoverObj.nodes[nodeId];\n            hoverChanged = true;\n          }\n        }\n      }\n\n      // removing all edge hover highlights\n      for (var edgeId in this.hoverObj.edges) {\n        if (Object.prototype.hasOwnProperty.call(this.hoverObj.edges, edgeId)) {\n          // if the hover has been changed here it means that the node has been hovered over or off\n          // we then do not use the emitBlurEvent method here.\n          if (hoverChanged === true) {\n            this.hoverObj.edges[edgeId].hover = false;\n            delete this.hoverObj.edges[edgeId];\n          }\n          // if the blur remains the same and the object is undefined (mouse off) or another\n          // edge has been hovered, or another node has been hovered we blur the edge.\n          else if (object === undefined || object instanceof Edge && object.id != edgeId || object instanceof Node && !object.hover) {\n            this.emitBlurEvent(event, pointer, this.hoverObj.edges[edgeId]);\n            delete this.hoverObj.edges[edgeId];\n            hoverChanged = true;\n          }\n        }\n      }\n      if (object !== undefined) {\n        var hoveredEdgesCount = _Object$keys(this.hoverObj.edges).length;\n        var hoveredNodesCount = _Object$keys(this.hoverObj.nodes).length;\n        var newOnlyHoveredEdge = object instanceof Edge && hoveredEdgesCount === 0 && hoveredNodesCount === 0;\n        var newOnlyHoveredNode = object instanceof Node && hoveredEdgesCount === 0 && hoveredNodesCount === 0;\n        if (hoverChanged || newOnlyHoveredEdge || newOnlyHoveredNode) {\n          hoverChanged = this.emitHoverEvent(event, pointer, object);\n        }\n        if (object instanceof Node && this.options.hoverConnectedEdges === true) {\n          this._hoverConnectedEdges(object);\n        }\n      }\n      if (hoverChanged === true) {\n        this.body.emitter.emit(\"_requestRedraw\");\n      }\n    }\n\n    /**\n     * Commit the selection changes but don't emit any events.\n     */\n  }, {\n    key: \"commitWithoutEmitting\",\n    value: function commitWithoutEmitting() {\n      this._selectionAccumulator.commit();\n    }\n\n    /**\n     * Select and deselect nodes depending current selection change.\n     *\n     * For changing nodes, select/deselect events are fired.\n     *\n     * NOTE: For a given edge, if one connecting node is deselected and with the\n     * same click the other node is selected, no events for the edge will fire. It\n     * was selected and it will remain selected.\n     *\n     * @param {{x: number, y: number}} pointer - The x and y coordinates of the\n     * click, tap, dragend… that triggered this.\n     * @param {UIEvent} event - The event that triggered this.\n     */\n  }, {\n    key: \"commitAndEmit\",\n    value: function commitAndEmit(pointer, event) {\n      var selected = false;\n      var selectionChanges = this._selectionAccumulator.commit();\n      var previousSelection = {\n        nodes: selectionChanges.nodes.previous,\n        edges: selectionChanges.edges.previous\n      };\n      if (selectionChanges.edges.deleted.length > 0) {\n        this.generateClickEvent(\"deselectEdge\", event, pointer, previousSelection);\n        selected = true;\n      }\n      if (selectionChanges.nodes.deleted.length > 0) {\n        this.generateClickEvent(\"deselectNode\", event, pointer, previousSelection);\n        selected = true;\n      }\n      if (selectionChanges.nodes.added.length > 0) {\n        this.generateClickEvent(\"selectNode\", event, pointer);\n        selected = true;\n      }\n      if (selectionChanges.edges.added.length > 0) {\n        this.generateClickEvent(\"selectEdge\", event, pointer);\n        selected = true;\n      }\n\n      // fire the select event if anything has been selected or deselected\n      if (selected === true) {\n        // select or unselect\n        this.generateClickEvent(\"select\", event, pointer);\n      }\n    }\n\n    /**\n     * Retrieve the currently selected node and edge ids.\n     *\n     * @returns {{nodes: Array.<string>, edges: Array.<string>}} Arrays with the\n     * ids of the selected nodes and edges.\n     */\n  }, {\n    key: \"getSelection\",\n    value: function getSelection() {\n      return {\n        nodes: this.getSelectedNodeIds(),\n        edges: this.getSelectedEdgeIds()\n      };\n    }\n\n    /**\n     * Retrieve the currently selected nodes.\n     *\n     * @returns {Array} An array with selected nodes.\n     */\n  }, {\n    key: \"getSelectedNodes\",\n    value: function getSelectedNodes() {\n      return this._selectionAccumulator.getNodes();\n    }\n\n    /**\n     * Retrieve the currently selected edges.\n     *\n     * @returns {Array} An array with selected edges.\n     */\n  }, {\n    key: \"getSelectedEdges\",\n    value: function getSelectedEdges() {\n      return this._selectionAccumulator.getEdges();\n    }\n\n    /**\n     * Retrieve the currently selected node ids.\n     *\n     * @returns {Array} An array with the ids of the selected nodes.\n     */\n  }, {\n    key: \"getSelectedNodeIds\",\n    value: function getSelectedNodeIds() {\n      var _context;\n      return _mapInstanceProperty(_context = this._selectionAccumulator.getNodes()).call(_context, function (node) {\n        return node.id;\n      });\n    }\n\n    /**\n     * Retrieve the currently selected edge ids.\n     *\n     * @returns {Array} An array with the ids of the selected edges.\n     */\n  }, {\n    key: \"getSelectedEdgeIds\",\n    value: function getSelectedEdgeIds() {\n      var _context2;\n      return _mapInstanceProperty(_context2 = this._selectionAccumulator.getEdges()).call(_context2, function (edge) {\n        return edge.id;\n      });\n    }\n\n    /**\n     * Updates the current selection\n     *\n     * @param {{nodes: Array.<string>, edges: Array.<string>}} selection\n     * @param {object} options                                 Options\n     */\n  }, {\n    key: \"setSelection\",\n    value: function setSelection(selection) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (!selection || !selection.nodes && !selection.edges) {\n        throw new TypeError(\"Selection must be an object with nodes and/or edges properties\");\n      }\n\n      // first unselect any selected node, if option is true or undefined\n      if (options.unselectAll || options.unselectAll === undefined) {\n        this.unselectAll();\n      }\n      if (selection.nodes) {\n        var _iterator = _createForOfIteratorHelper$2(selection.nodes),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var id = _step.value;\n            var node = this.body.nodes[id];\n            if (!node) {\n              throw new RangeError('Node with id \"' + id + '\" not found');\n            }\n            // don't select edges with it\n            this.selectObject(node, options.highlightEdges);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n      if (selection.edges) {\n        var _iterator2 = _createForOfIteratorHelper$2(selection.edges),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _id = _step2.value;\n            var edge = this.body.edges[_id];\n            if (!edge) {\n              throw new RangeError('Edge with id \"' + _id + '\" not found');\n            }\n            this.selectObject(edge);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n      this.body.emitter.emit(\"_requestRedraw\");\n      this._selectionAccumulator.commit();\n    }\n\n    /**\n     * select zero or more nodes with the option to highlight edges\n     *\n     * @param {number[] | string[]} selection     An array with the ids of the\n     *                                            selected nodes.\n     * @param {boolean} [highlightEdges]\n     */\n  }, {\n    key: \"selectNodes\",\n    value: function selectNodes(selection) {\n      var highlightEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      if (!selection || selection.length === undefined) throw \"Selection must be an array with ids\";\n      this.setSelection({\n        nodes: selection\n      }, {\n        highlightEdges: highlightEdges\n      });\n    }\n\n    /**\n     * select zero or more edges\n     *\n     * @param {number[] | string[]} selection     An array with the ids of the\n     *                                            selected nodes.\n     */\n  }, {\n    key: \"selectEdges\",\n    value: function selectEdges(selection) {\n      if (!selection || selection.length === undefined) throw \"Selection must be an array with ids\";\n      this.setSelection({\n        edges: selection\n      });\n    }\n\n    /**\n     * Validate the selection: remove ids of nodes which no longer exist\n     *\n     * @private\n     */\n  }, {\n    key: \"updateSelection\",\n    value: function updateSelection() {\n      for (var node in this._selectionAccumulator.getNodes()) {\n        if (!Object.prototype.hasOwnProperty.call(this.body.nodes, node.id)) {\n          this._selectionAccumulator.deleteNodes(node);\n        }\n      }\n      for (var edge in this._selectionAccumulator.getEdges()) {\n        if (!Object.prototype.hasOwnProperty.call(this.body.edges, edge.id)) {\n          this._selectionAccumulator.deleteEdges(edge);\n        }\n      }\n    }\n\n    /**\n     * Determine all the visual elements clicked which are on the given point.\n     *\n     * All elements are returned; this includes nodes, edges and their labels.\n     * The order returned is from highest to lowest, i.e. element 0 of the return\n     * value is the topmost item clicked on.\n     *\n     * The return value consists of an array of the following possible elements:\n     *\n     * - `{nodeId:number}`             - node with given id clicked on\n     * - `{nodeId:number, labelId:0}`  - label of node with given id clicked on\n     * - `{edgeId:number}`             - edge with given id clicked on\n     * - `{edge:number, labelId:0}`    - label of edge with given id clicked on\n     *\n     * ## NOTES\n     *\n     * - Currently, there is only one label associated with a node or an edge,\n     *   but this is expected to change somewhere in the future.\n     * - Since there is no z-indexing yet, it is not really possible to set the nodes and\n     *   edges in the correct order. For the time being, nodes come first.\n     *\n     * @param {point} pointer  mouse position in screen coordinates\n     * @returns {Array.<nodeClickItem|nodeLabelClickItem|edgeClickItem|edgeLabelClickItem>}\n     * @private\n     */\n  }, {\n    key: \"getClickedItems\",\n    value: function getClickedItems(pointer) {\n      var point = this.canvas.DOMtoCanvas(pointer);\n      var items = [];\n\n      // Note reverse order; we want the topmost clicked items to be first in the array\n      // Also note that selected nodes are disregarded here; these normally display on top\n      var nodeIndices = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      for (var i = nodeIndices.length - 1; i >= 0; i--) {\n        var node = nodes[nodeIndices[i]];\n        var ret = node.getItemsOnPoint(point);\n        items.push.apply(items, ret); // Append the return value to the running list.\n      }\n\n      var edgeIndices = this.body.edgeIndices;\n      var edges = this.body.edges;\n      for (var _i = edgeIndices.length - 1; _i >= 0; _i--) {\n        var edge = edges[edgeIndices[_i]];\n        var _ret = edge.getItemsOnPoint(point);\n        items.push.apply(items, _ret); // Append the return value to the running list.\n      }\n\n      return items;\n    }\n  }]);\n  return SelectionHandler;\n}();\n\nvar arraySlice = arraySliceSimple;\n\nvar floor = Math.floor;\n\nvar mergeSort = function (array, comparefn) {\n  var length = array.length;\n  var middle = floor(length / 2);\n  return length < 8 ? insertionSort(array, comparefn) : merge(\n    array,\n    mergeSort(arraySlice(array, 0, middle), comparefn),\n    mergeSort(arraySlice(array, middle), comparefn),\n    comparefn\n  );\n};\n\nvar insertionSort = function (array, comparefn) {\n  var length = array.length;\n  var i = 1;\n  var element, j;\n\n  while (i < length) {\n    j = i;\n    element = array[i];\n    while (j && comparefn(array[j - 1], element) > 0) {\n      array[j] = array[--j];\n    }\n    if (j !== i++) array[j] = element;\n  } return array;\n};\n\nvar merge = function (array, left, right, comparefn) {\n  var llength = left.length;\n  var rlength = right.length;\n  var lindex = 0;\n  var rindex = 0;\n\n  while (lindex < llength || rindex < rlength) {\n    array[lindex + rindex] = (lindex < llength && rindex < rlength)\n      ? comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]\n      : lindex < llength ? left[lindex++] : right[rindex++];\n  } return array;\n};\n\nvar arraySort = mergeSort;\n\nvar userAgent$1 = engineUserAgent;\n\nvar firefox = userAgent$1.match(/firefox\\/(\\d+)/i);\n\nvar engineFfVersion = !!firefox && +firefox[1];\n\nvar UA = engineUserAgent;\n\nvar engineIsIeOrEdge = /MSIE|Trident/.test(UA);\n\nvar userAgent = engineUserAgent;\n\nvar webkit = userAgent.match(/AppleWebKit\\/(\\d+)\\./);\n\nvar engineWebkitVersion = !!webkit && +webkit[1];\n\nvar $$2 = _export;\nvar uncurryThis = functionUncurryThis;\nvar aCallable$1 = aCallable$7;\nvar toObject$1 = toObject$e;\nvar lengthOfArrayLike$1 = lengthOfArrayLike$c;\nvar deletePropertyOrThrow = deletePropertyOrThrow$2;\nvar toString = toString$a;\nvar fails = fails$w;\nvar internalSort = arraySort;\nvar arrayMethodIsStrict$2 = arrayMethodIsStrict$6;\nvar FF = engineFfVersion;\nvar IE_OR_EDGE = engineIsIeOrEdge;\nvar V8 = engineV8Version;\nvar WEBKIT = engineWebkitVersion;\n\nvar test = [];\nvar nativeSort = uncurryThis(test.sort);\nvar push = uncurryThis(test.push);\n\n// IE8-\nvar FAILS_ON_UNDEFINED = fails(function () {\n  test.sort(undefined);\n});\n// V8 bug\nvar FAILS_ON_NULL = fails(function () {\n  test.sort(null);\n});\n// Old WebKit\nvar STRICT_METHOD$1 = arrayMethodIsStrict$2('sort');\n\nvar STABLE_SORT = !fails(function () {\n  // feature detection can be too slow, so check engines versions\n  if (V8) return V8 < 70;\n  if (FF && FF > 3) return;\n  if (IE_OR_EDGE) return true;\n  if (WEBKIT) return WEBKIT < 603;\n\n  var result = '';\n  var code, chr, value, index;\n\n  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)\n  for (code = 65; code < 76; code++) {\n    chr = String.fromCharCode(code);\n\n    switch (code) {\n      case 66: case 69: case 70: case 72: value = 3; break;\n      case 68: case 71: value = 4; break;\n      default: value = 2;\n    }\n\n    for (index = 0; index < 47; index++) {\n      test.push({ k: chr + index, v: value });\n    }\n  }\n\n  test.sort(function (a, b) { return b.v - a.v; });\n\n  for (index = 0; index < test.length; index++) {\n    chr = test[index].k.charAt(0);\n    if (result.charAt(result.length - 1) !== chr) result += chr;\n  }\n\n  return result !== 'DGBEFHACIJK';\n});\n\nvar FORCED$1 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$1 || !STABLE_SORT;\n\nvar getSortCompare = function (comparefn) {\n  return function (x, y) {\n    if (y === undefined) return -1;\n    if (x === undefined) return 1;\n    if (comparefn !== undefined) return +comparefn(x, y) || 0;\n    return toString(x) > toString(y) ? 1 : -1;\n  };\n};\n\n// `Array.prototype.sort` method\n// https://tc39.es/ecma262/#sec-array.prototype.sort\n$$2({ target: 'Array', proto: true, forced: FORCED$1 }, {\n  sort: function sort(comparefn) {\n    if (comparefn !== undefined) aCallable$1(comparefn);\n\n    var array = toObject$1(this);\n\n    if (STABLE_SORT) return comparefn === undefined ? nativeSort(array) : nativeSort(array, comparefn);\n\n    var items = [];\n    var arrayLength = lengthOfArrayLike$1(array);\n    var itemsLength, index;\n\n    for (index = 0; index < arrayLength; index++) {\n      if (index in array) push(items, array[index]);\n    }\n\n    internalSort(items, getSortCompare(comparefn));\n\n    itemsLength = lengthOfArrayLike$1(items);\n    index = 0;\n\n    while (index < itemsLength) array[index] = items[index++];\n    while (index < arrayLength) deletePropertyOrThrow(array, index++);\n\n    return array;\n  }\n});\n\nvar entryVirtual$2 = entryVirtual$i;\n\nvar sort$3 = entryVirtual$2('Array').sort;\n\nvar isPrototypeOf$2 = objectIsPrototypeOf;\nvar method$2 = sort$3;\n\nvar ArrayPrototype$2 = Array.prototype;\n\nvar sort$2 = function (it) {\n  var own = it.sort;\n  return it === ArrayPrototype$2 || (isPrototypeOf$2(ArrayPrototype$2, it) && own === ArrayPrototype$2.sort) ? method$2 : own;\n};\n\nvar parent$2 = sort$2;\n\nvar sort$1 = parent$2;\n\nvar sort = sort$1;\n\nvar _sortInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(sort);\n\nvar aCallable = aCallable$7;\nvar toObject = toObject$e;\nvar IndexedObject = indexedObject;\nvar lengthOfArrayLike = lengthOfArrayLike$c;\n\nvar $TypeError = TypeError;\n\n// `Array.prototype.{ reduce, reduceRight }` methods implementation\nvar createMethod = function (IS_RIGHT) {\n  return function (that, callbackfn, argumentsLength, memo) {\n    aCallable(callbackfn);\n    var O = toObject(that);\n    var self = IndexedObject(O);\n    var length = lengthOfArrayLike(O);\n    var index = IS_RIGHT ? length - 1 : 0;\n    var i = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2) while (true) {\n      if (index in self) {\n        memo = self[index];\n        index += i;\n        break;\n      }\n      index += i;\n      if (IS_RIGHT ? index < 0 : length <= index) {\n        throw new $TypeError('Reduce of empty array with no initial value');\n      }\n    }\n    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n      memo = callbackfn(memo, self[index], index, O);\n    }\n    return memo;\n  };\n};\n\nvar arrayReduce = {\n  // `Array.prototype.reduce` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduce\n  left: createMethod(false),\n  // `Array.prototype.reduceRight` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduceright\n  right: createMethod(true)\n};\n\nvar global$1 = global$n;\nvar classof = classofRaw$2;\n\nvar engineIsNode = classof(global$1.process) === 'process';\n\nvar $$1 = _export;\nvar $reduce = arrayReduce.left;\nvar arrayMethodIsStrict$1 = arrayMethodIsStrict$6;\nvar CHROME_VERSION = engineV8Version;\nvar IS_NODE = engineIsNode;\n\n// Chrome 80-82 has a critical bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\nvar CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;\nvar FORCED = CHROME_BUG || !arrayMethodIsStrict$1('reduce');\n\n// `Array.prototype.reduce` method\n// https://tc39.es/ecma262/#sec-array.prototype.reduce\n$$1({ target: 'Array', proto: true, forced: FORCED }, {\n  reduce: function reduce(callbackfn /* , initialValue */) {\n    var length = arguments.length;\n    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar entryVirtual$1 = entryVirtual$i;\n\nvar reduce$3 = entryVirtual$1('Array').reduce;\n\nvar isPrototypeOf$1 = objectIsPrototypeOf;\nvar method$1 = reduce$3;\n\nvar ArrayPrototype$1 = Array.prototype;\n\nvar reduce$2 = function (it) {\n  var own = it.reduce;\n  return it === ArrayPrototype$1 || (isPrototypeOf$1(ArrayPrototype$1, it) && own === ArrayPrototype$1.reduce) ? method$1 : own;\n};\n\nvar parent$1 = reduce$2;\n\nvar reduce$1 = parent$1;\n\nvar reduce = reduce$1;\n\nvar _reduceInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(reduce);\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n/**\n * Helper classes for LayoutEngine.\n *\n * Strategy pattern for usage of direction methods for hierarchical layouts.\n */\n/**\n * Interface definition for direction strategy classes.\n *\n * This class describes the interface for the Strategy\n * pattern classes used to differentiate horizontal and vertical\n * direction of hierarchical results.\n *\n * For a given direction, one coordinate will be 'fixed', meaning that it is\n * determined by level.\n * The other coordinate is 'unfixed', meaning that the nodes on a given level\n * can still move along that coordinate. So:\n *\n * - `vertical` layout: `x` unfixed, `y` fixed per level\n * - `horizontal` layout: `x` fixed per level, `y` unfixed\n *\n * The local methods are stubs and should be regarded as abstract.\n * Derived classes **must** implement all the methods themselves.\n *\n * @private\n */\nvar DirectionInterface = /*#__PURE__*/function () {\n  function DirectionInterface() {\n    _classCallCheck(this, DirectionInterface);\n  }\n  _createClass(DirectionInterface, [{\n    key: \"abstract\",\n    value:\n    /**\n     * @ignore\n     */\n    function abstract() {\n      throw new Error(\"Can't instantiate abstract class!\");\n    }\n\n    /**\n     * This is a dummy call which is used to suppress the jsdoc errors of type:\n     *\n     *   \"'param' is assigned a value but never used\"\n     *\n     * @ignore\n     */\n  }, {\n    key: \"fake_use\",\n    value: function fake_use() {\n      // Do nothing special\n    }\n\n    /**\n     * Type to use to translate dynamic curves to, in the case of hierarchical layout.\n     * Dynamic curves do not work for these.\n     *\n     * The value should be perpendicular to the actual direction of the layout.\n     *\n     * @returns {string} Direction, either 'vertical' or 'horizontal'\n     */\n  }, {\n    key: \"curveType\",\n    value: function curveType() {\n      return this.abstract();\n    }\n\n    /**\n     * Return the value of the coordinate that is not fixed for this direction.\n     *\n     * @param {Node} node The node to read\n     * @returns {number} Value of the unfixed coordinate\n     */\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(node) {\n      this.fake_use(node);\n      return this.abstract();\n    }\n\n    /**\n     * Set the value of the coordinate that is not fixed for this direction.\n     *\n     * @param {Node} node The node to adjust\n     * @param {number} position\n     * @param {number} [level] if specified, the hierarchy level that this node should be fixed to\n     */\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(node, position) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      this.fake_use(node, position, level);\n      this.abstract();\n    }\n\n    /**\n     * Get the width of a tree.\n     *\n     * A `tree` here is a subset of nodes within the network which are not connected to other nodes,\n     * only among themselves. In essence, it is a sub-network.\n     *\n     * @param {number} index The index number of a tree\n     * @returns {number} the width of a tree in the view coordinates\n     */\n  }, {\n    key: \"getTreeSize\",\n    value: function getTreeSize(index) {\n      this.fake_use(index);\n      return this.abstract();\n    }\n\n    /**\n     * Sort array of nodes on the unfixed coordinates.\n     *\n     * Note:** chrome has non-stable sorting implementation, which\n     * has a tendency to change the order of the array items,\n     * even if the custom sort function returns 0.\n     *\n     * For this reason, an external sort implementation is used,\n     * which has the added benefit of being faster than the standard\n     * platforms implementation. This has been verified on `node.js`,\n     * `firefox` and `chrome` (all linux).\n     *\n     * @param {Array.<Node>} nodeArray array of nodes to sort\n     */\n  }, {\n    key: \"sort\",\n    value: function sort(nodeArray) {\n      this.fake_use(nodeArray);\n      this.abstract();\n    }\n\n    /**\n     * Assign the fixed coordinate of the node to the given level\n     *\n     * @param {Node} node The node to adjust\n     * @param {number} level The level to fix to\n     */\n  }, {\n    key: \"fix\",\n    value: function fix(node, level) {\n      this.fake_use(node, level);\n      this.abstract();\n    }\n\n    /**\n     * Add an offset to the unfixed coordinate of the given node.\n     *\n     * @param {NodeId} nodeId Id of the node to adjust\n     * @param {number} diff Offset to add to the unfixed coordinate\n     */\n  }, {\n    key: \"shift\",\n    value: function shift(nodeId, diff) {\n      this.fake_use(nodeId, diff);\n      this.abstract();\n    }\n  }]);\n  return DirectionInterface;\n}();\n/**\n * Vertical Strategy\n *\n * Coordinate `y` is fixed on levels, coordinate `x` is unfixed.\n *\n * @augments DirectionInterface\n * @private\n */\nvar VerticalStrategy = /*#__PURE__*/function (_DirectionInterface) {\n  _inherits(VerticalStrategy, _DirectionInterface);\n  var _super = _createSuper(VerticalStrategy);\n  /**\n   * Constructor\n   *\n   * @param {object} layout reference to the parent LayoutEngine instance.\n   */\n  function VerticalStrategy(layout) {\n    var _this;\n    _classCallCheck(this, VerticalStrategy);\n    _this = _super.call(this);\n    _this.layout = layout;\n    return _this;\n  }\n\n  /** @inheritDoc */\n  _createClass(VerticalStrategy, [{\n    key: \"curveType\",\n    value: function curveType() {\n      return \"horizontal\";\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(node) {\n      return node.x;\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(node, position) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      if (level !== undefined) {\n        this.layout.hierarchical.addToOrdering(node, level);\n      }\n      node.x = position;\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"getTreeSize\",\n    value: function getTreeSize(index) {\n      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);\n      return {\n        min: res.min_x,\n        max: res.max_x\n      };\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"sort\",\n    value: function sort(nodeArray) {\n      _sortInstanceProperty(nodeArray).call(nodeArray, function (a, b) {\n        return a.x - b.x;\n      });\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"fix\",\n    value: function fix(node, level) {\n      node.y = this.layout.options.hierarchical.levelSeparation * level;\n      node.options.fixed.y = true;\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"shift\",\n    value: function shift(nodeId, diff) {\n      this.layout.body.nodes[nodeId].x += diff;\n    }\n  }]);\n  return VerticalStrategy;\n}(DirectionInterface);\n/**\n * Horizontal Strategy\n *\n * Coordinate `x` is fixed on levels, coordinate `y` is unfixed.\n *\n * @augments DirectionInterface\n * @private\n */\nvar HorizontalStrategy = /*#__PURE__*/function (_DirectionInterface2) {\n  _inherits(HorizontalStrategy, _DirectionInterface2);\n  var _super2 = _createSuper(HorizontalStrategy);\n  /**\n   * Constructor\n   *\n   * @param {object} layout reference to the parent LayoutEngine instance.\n   */\n  function HorizontalStrategy(layout) {\n    var _this2;\n    _classCallCheck(this, HorizontalStrategy);\n    _this2 = _super2.call(this);\n    _this2.layout = layout;\n    return _this2;\n  }\n\n  /** @inheritDoc */\n  _createClass(HorizontalStrategy, [{\n    key: \"curveType\",\n    value: function curveType() {\n      return \"vertical\";\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"getPosition\",\n    value: function getPosition(node) {\n      return node.y;\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(node, position) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n      if (level !== undefined) {\n        this.layout.hierarchical.addToOrdering(node, level);\n      }\n      node.y = position;\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"getTreeSize\",\n    value: function getTreeSize(index) {\n      var res = this.layout.hierarchical.getTreeSize(this.layout.body.nodes, index);\n      return {\n        min: res.min_y,\n        max: res.max_y\n      };\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"sort\",\n    value: function sort(nodeArray) {\n      _sortInstanceProperty(nodeArray).call(nodeArray, function (a, b) {\n        return a.y - b.y;\n      });\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"fix\",\n    value: function fix(node, level) {\n      node.x = this.layout.options.hierarchical.levelSeparation * level;\n      node.options.fixed.x = true;\n    }\n\n    /** @inheritDoc */\n  }, {\n    key: \"shift\",\n    value: function shift(nodeId, diff) {\n      this.layout.body.nodes[nodeId].y += diff;\n    }\n  }]);\n  return HorizontalStrategy;\n}(DirectionInterface);\n\nvar $ = _export;\nvar $every = arrayIteration.every;\nvar arrayMethodIsStrict = arrayMethodIsStrict$6;\n\nvar STRICT_METHOD = arrayMethodIsStrict('every');\n\n// `Array.prototype.every` method\n// https://tc39.es/ecma262/#sec-array.prototype.every\n$({ target: 'Array', proto: true, forced: !STRICT_METHOD }, {\n  every: function every(callbackfn /* , thisArg */) {\n    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nvar entryVirtual = entryVirtual$i;\n\nvar every$3 = entryVirtual('Array').every;\n\nvar isPrototypeOf = objectIsPrototypeOf;\nvar method = every$3;\n\nvar ArrayPrototype = Array.prototype;\n\nvar every$2 = function (it) {\n  var own = it.every;\n  return it === ArrayPrototype || (isPrototypeOf(ArrayPrototype, it) && own === ArrayPrototype.every) ? method : own;\n};\n\nvar parent = every$2;\n\nvar every$1 = parent;\n\nvar every = every$1;\n\nvar _everyInstanceProperty = /*@__PURE__*/getDefaultExportFromCjs(every);\n\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$1(o, minLen) { var _context9; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen); var n = _sliceInstanceProperty(_context9 = Object.prototype.toString.call(o)).call(_context9, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return _Array$from$1(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }\nfunction _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\r\n * Try to assign levels to nodes according to their positions in the cyclic “hierarchy”.\r\n *\r\n * @param nodes - Visible nodes of the graph.\r\n * @param levels - If present levels will be added to it, if not a new object will be created.\r\n * @returns Populated node levels.\r\n */\nfunction fillLevelsByDirectionCyclic(nodes, levels) {\n  var edges = new _Set();\n  _forEachInstanceProperty(nodes).call(nodes, function (node) {\n    var _context;\n    _forEachInstanceProperty(_context = node.edges).call(_context, function (edge) {\n      if (edge.connected) {\n        edges.add(edge);\n      }\n    });\n  });\n  _forEachInstanceProperty(edges).call(edges, function (edge) {\n    var fromId = edge.from.id;\n    var toId = edge.to.id;\n    if (levels[fromId] == null) {\n      levels[fromId] = 0;\n    }\n    if (levels[toId] == null || levels[fromId] >= levels[toId]) {\n      levels[toId] = levels[fromId] + 1;\n    }\n  });\n  return levels;\n}\n/**\r\n * Assign levels to nodes according to their positions in the hierarchy. Leaves will be lined up at the bottom and all other nodes as close to their children as possible.\r\n *\r\n * @param nodes - Visible nodes of the graph.\r\n * @returns Populated node levels.\r\n */\nfunction fillLevelsByDirectionLeaves(nodes) {\n  return fillLevelsByDirection(\n  // Pick only leaves (nodes without children).\n  function (node) {\n    var _context2, _context3;\n    return _everyInstanceProperty(_context2 = _filterInstanceProperty(_context3 = node.edges\n    // Take only visible nodes into account.\n    ).call(_context3, function (edge) {\n      return nodes.has(edge.toId);\n    })\n    // Check that all edges lead to this node (leaf).\n    ).call(_context2, function (edge) {\n      return edge.to === node;\n    });\n  },\n  // Use the lowest level.\n  function (newLevel, oldLevel) {\n    return oldLevel > newLevel;\n  },\n  // Go against the direction of the edges.\n  \"from\", nodes);\n}\n/**\r\n * Assign levels to nodes according to their positions in the hierarchy. Roots will be lined up at the top and all nodes as close to their parents as possible.\r\n *\r\n * @param nodes - Visible nodes of the graph.\r\n * @returns Populated node levels.\r\n */\nfunction fillLevelsByDirectionRoots(nodes) {\n  return fillLevelsByDirection(\n  // Pick only roots (nodes without parents).\n  function (node) {\n    var _context4, _context5;\n    return _everyInstanceProperty(_context4 = _filterInstanceProperty(_context5 = node.edges\n    // Take only visible nodes into account.\n    ).call(_context5, function (edge) {\n      return nodes.has(edge.toId);\n    })\n    // Check that all edges lead from this node (root).\n    ).call(_context4, function (edge) {\n      return edge.from === node;\n    });\n  },\n  // Use the highest level.\n  function (newLevel, oldLevel) {\n    return oldLevel < newLevel;\n  },\n  // Go in the direction of the edges.\n  \"to\", nodes);\n}\n/**\r\n * Assign levels to nodes according to their positions in the hierarchy.\r\n *\r\n * @param isEntryNode - Checks and return true if the graph should be traversed from this node.\r\n * @param shouldLevelBeReplaced - Checks and returns true if the level of given node should be updated to the new value.\r\n * @param direction - Wheter the graph should be traversed in the direction of the edges `\"to\"` or in the other way `\"from\"`.\r\n * @param nodes - Visible nodes of the graph.\r\n * @returns Populated node levels.\r\n */\nfunction fillLevelsByDirection(isEntryNode, shouldLevelBeReplaced, direction, nodes) {\n  var _context6;\n  var levels = _Object$create$1(null);\n  // If acyclic, the graph can be walked through with (most likely way) fewer\n  // steps than the number bellow. The exact value isn't too important as long\n  // as it's quick to compute (doesn't impact acyclic graphs too much), is\n  // higher than the number of steps actually needed (doesn't cut off before\n  // acyclic graph is walked through) and prevents infinite loops (cuts off for\n  // cyclic graphs).\n  var limit = _reduceInstanceProperty(_context6 = _toConsumableArray(_valuesInstanceProperty(nodes).call(nodes))).call(_context6, function (acc, node) {\n    return acc + 1 + node.edges.length;\n  }, 0);\n  var edgeIdProp = direction + \"Id\";\n  var newLevelDiff = direction === \"to\" ? 1 : -1;\n  var _iterator = _createForOfIteratorHelper$1(nodes),\n    _step;\n  try {\n    var _loop = function _loop() {\n        var _step$value = _slicedToArray(_step.value, 2),\n          entryNodeId = _step$value[0],\n          entryNode = _step$value[1];\n        if (\n        // Skip if the node is not visible.\n        !nodes.has(entryNodeId) ||\n        // Skip if the node is not an entry node.\n        !isEntryNode(entryNode)) {\n          return 0; // continue\n        }\n        // Line up all the entry nodes on level 0.\n        levels[entryNodeId] = 0;\n        var stack = [entryNode];\n        var done = 0;\n        var node;\n        var _loop2 = function _loop2() {\n            var _context7, _context8;\n            if (!nodes.has(entryNodeId)) {\n              // Skip if the node is not visible.\n              return 0; // continue\n            }\n            var newLevel = levels[node.id] + newLevelDiff;\n            _forEachInstanceProperty(_context7 = _filterInstanceProperty(_context8 = node.edges).call(_context8, function (edge) {\n              return (\n                // Ignore disconnected edges.\n                edge.connected &&\n                // Ignore circular edges.\n                edge.to !== edge.from &&\n                // Ignore edges leading to the node that's currently being processed.\n                edge[direction] !== node &&\n                // Ignore edges connecting to an invisible node.\n                nodes.has(edge.toId) &&\n                // Ignore edges connecting from an invisible node.\n                nodes.has(edge.fromId)\n              );\n            })).call(_context7, function (edge) {\n              var targetNodeId = edge[edgeIdProp];\n              var oldLevel = levels[targetNodeId];\n              if (oldLevel == null || shouldLevelBeReplaced(newLevel, oldLevel)) {\n                levels[targetNodeId] = newLevel;\n                stack.push(edge[direction]);\n              }\n            });\n            if (done > limit) {\n              // This would run forever on a cyclic graph.\n              return {\n                v: {\n                  v: fillLevelsByDirectionCyclic(nodes, levels)\n                }\n              };\n            } else {\n              ++done;\n            }\n          },\n          _ret2;\n        while (node = stack.pop()) {\n          _ret2 = _loop2();\n          if (_ret2 === 0) continue;\n          if (_ret2) return _ret2.v;\n        }\n      },\n      _ret;\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _ret = _loop();\n      if (_ret === 0) continue;\n      if (_ret) return _ret.v;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return levels;\n}\n\n/**\n * There's a mix-up with terms in the code. Following are the formal definitions:\n *\n *   tree   - a strict hierarchical network, i.e. every node has at most one parent\n *   forest - a collection of trees. These distinct trees are thus not connected.\n *\n * So:\n * - in a network that is not a tree, there exist nodes with multiple parents.\n * - a network consisting of unconnected sub-networks, of which at least one\n *   is not a tree, is not a forest.\n *\n * In the code, the definitions are:\n *\n *   tree   - any disconnected sub-network, strict hierarchical or not.\n *   forest - a bunch of these sub-networks\n *\n * The difference between tree and not-tree is important in the code, notably within\n * to the block-shifting algorithm. The algorithm assumes formal trees and fails\n * for not-trees, often in a spectacular manner (search for 'exploding network' in the issues).\n *\n * In order to distinguish the definitions in the following code, the adjective 'formal' is\n * used. If 'formal' is absent, you must assume the non-formal definition.\n *\n * ----------------------------------------------------------------------------------\n * NOTES\n * =====\n *\n * A hierarchical layout is a different thing from a hierarchical network.\n * The layout is a way to arrange the nodes in the view; this can be done\n * on non-hierarchical networks as well. The converse is also possible.\n */\n\n/**\n * Container for derived data on current network, relating to hierarchy.\n *\n * @private\n */\nvar HierarchicalStatus = /*#__PURE__*/function () {\n  /**\n   * @ignore\n   */\n  function HierarchicalStatus() {\n    _classCallCheck(this, HierarchicalStatus);\n    this.childrenReference = {}; // child id's per node id\n    this.parentReference = {}; // parent id's per node id\n    this.trees = {}; // tree id per node id; i.e. to which tree does given node id belong\n\n    this.distributionOrdering = {}; // The nodes per level, in the display order\n    this.levels = {}; // hierarchy level per node id\n    this.distributionIndex = {}; // The position of the node in the level sorting order, per node id.\n\n    this.isTree = false; // True if current network is a formal tree\n    this.treeIndex = -1; // Highest tree id in current network.\n  }\n\n  /**\n   * Add the relation between given nodes to the current state.\n   *\n   * @param {Node.id} parentNodeId\n   * @param {Node.id} childNodeId\n   */\n  _createClass(HierarchicalStatus, [{\n    key: \"addRelation\",\n    value: function addRelation(parentNodeId, childNodeId) {\n      if (this.childrenReference[parentNodeId] === undefined) {\n        this.childrenReference[parentNodeId] = [];\n      }\n      this.childrenReference[parentNodeId].push(childNodeId);\n      if (this.parentReference[childNodeId] === undefined) {\n        this.parentReference[childNodeId] = [];\n      }\n      this.parentReference[childNodeId].push(parentNodeId);\n    }\n\n    /**\n     * Check if the current state is for a formal tree or formal forest.\n     *\n     * This is the case if every node has at most one parent.\n     *\n     * Pre: parentReference init'ed properly for current network\n     */\n  }, {\n    key: \"checkIfTree\",\n    value: function checkIfTree() {\n      for (var i in this.parentReference) {\n        if (this.parentReference[i].length > 1) {\n          this.isTree = false;\n          return;\n        }\n      }\n      this.isTree = true;\n    }\n\n    /**\n     * Return the number of separate trees in the current network.\n     *\n     * @returns {number}\n     */\n  }, {\n    key: \"numTrees\",\n    value: function numTrees() {\n      return this.treeIndex + 1; // This assumes the indexes are assigned consecitively\n    }\n\n    /**\n     * Assign a tree id to a node\n     *\n     * @param {Node} node\n     * @param {string|number} treeId\n     */\n  }, {\n    key: \"setTreeIndex\",\n    value: function setTreeIndex(node, treeId) {\n      if (treeId === undefined) return; // Don't bother\n\n      if (this.trees[node.id] === undefined) {\n        this.trees[node.id] = treeId;\n        this.treeIndex = Math.max(treeId, this.treeIndex);\n      }\n    }\n\n    /**\n     * Ensure level for given id is defined.\n     *\n     * Sets level to zero for given node id if not already present\n     *\n     * @param {Node.id} nodeId\n     */\n  }, {\n    key: \"ensureLevel\",\n    value: function ensureLevel(nodeId) {\n      if (this.levels[nodeId] === undefined) {\n        this.levels[nodeId] = 0;\n      }\n    }\n\n    /**\n     * get the maximum level of a branch.\n     *\n     * TODO: Never entered; find a test case to test this!\n     *\n     * @param {Node.id} nodeId\n     * @returns {number}\n     */\n  }, {\n    key: \"getMaxLevel\",\n    value: function getMaxLevel(nodeId) {\n      var _this = this;\n      var accumulator = {};\n      var _getMaxLevel = function _getMaxLevel(nodeId) {\n        if (accumulator[nodeId] !== undefined) {\n          return accumulator[nodeId];\n        }\n        var level = _this.levels[nodeId];\n        if (_this.childrenReference[nodeId]) {\n          var children = _this.childrenReference[nodeId];\n          if (children.length > 0) {\n            for (var i = 0; i < children.length; i++) {\n              level = Math.max(level, _getMaxLevel(children[i]));\n            }\n          }\n        }\n        accumulator[nodeId] = level;\n        return level;\n      };\n      return _getMaxLevel(nodeId);\n    }\n\n    /**\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     */\n  }, {\n    key: \"levelDownstream\",\n    value: function levelDownstream(nodeA, nodeB) {\n      if (this.levels[nodeB.id] === undefined) {\n        // set initial level\n        if (this.levels[nodeA.id] === undefined) {\n          this.levels[nodeA.id] = 0;\n        }\n        // set level\n        this.levels[nodeB.id] = this.levels[nodeA.id] + 1;\n      }\n    }\n\n    /**\n     * Small util method to set the minimum levels of the nodes to zero.\n     *\n     * @param {Array.<Node>} nodes\n     */\n  }, {\n    key: \"setMinLevelToZero\",\n    value: function setMinLevelToZero(nodes) {\n      var minLevel = 1e9;\n      // get the minimum level\n      for (var nodeId in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n          if (this.levels[nodeId] !== undefined) {\n            minLevel = Math.min(this.levels[nodeId], minLevel);\n          }\n        }\n      }\n\n      // subtract the minimum from the set so we have a range starting from 0\n      for (var _nodeId in nodes) {\n        if (Object.prototype.hasOwnProperty.call(nodes, _nodeId)) {\n          if (this.levels[_nodeId] !== undefined) {\n            this.levels[_nodeId] -= minLevel;\n          }\n        }\n      }\n    }\n\n    /**\n     * Get the min and max xy-coordinates of a given tree\n     *\n     * @param {Array.<Node>} nodes\n     * @param {number} index\n     * @returns {{min_x: number, max_x: number, min_y: number, max_y: number}}\n     */\n  }, {\n    key: \"getTreeSize\",\n    value: function getTreeSize(nodes, index) {\n      var min_x = 1e9;\n      var max_x = -1e9;\n      var min_y = 1e9;\n      var max_y = -1e9;\n      for (var nodeId in this.trees) {\n        if (Object.prototype.hasOwnProperty.call(this.trees, nodeId)) {\n          if (this.trees[nodeId] === index) {\n            var node = nodes[nodeId];\n            min_x = Math.min(node.x, min_x);\n            max_x = Math.max(node.x, max_x);\n            min_y = Math.min(node.y, min_y);\n            max_y = Math.max(node.y, max_y);\n          }\n        }\n      }\n      return {\n        min_x: min_x,\n        max_x: max_x,\n        min_y: min_y,\n        max_y: max_y\n      };\n    }\n\n    /**\n     * Check if two nodes have the same parent(s)\n     *\n     * @param {Node} node1\n     * @param {Node} node2\n     * @returns {boolean} true if the two nodes have a same ancestor node, false otherwise\n     */\n  }, {\n    key: \"hasSameParent\",\n    value: function hasSameParent(node1, node2) {\n      var parents1 = this.parentReference[node1.id];\n      var parents2 = this.parentReference[node2.id];\n      if (parents1 === undefined || parents2 === undefined) {\n        return false;\n      }\n      for (var i = 0; i < parents1.length; i++) {\n        for (var j = 0; j < parents2.length; j++) {\n          if (parents1[i] == parents2[j]) {\n            return true;\n          }\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Check if two nodes are in the same tree.\n     *\n     * @param {Node} node1\n     * @param {Node} node2\n     * @returns {boolean} true if this is so, false otherwise\n     */\n  }, {\n    key: \"inSameSubNetwork\",\n    value: function inSameSubNetwork(node1, node2) {\n      return this.trees[node1.id] === this.trees[node2.id];\n    }\n\n    /**\n     * Get a list of the distinct levels in the current network\n     *\n     * @returns {Array}\n     */\n  }, {\n    key: \"getLevels\",\n    value: function getLevels() {\n      return _Object$keys(this.distributionOrdering);\n    }\n\n    /**\n     * Add a node to the ordering per level\n     *\n     * @param {Node} node\n     * @param {number} level\n     */\n  }, {\n    key: \"addToOrdering\",\n    value: function addToOrdering(node, level) {\n      if (this.distributionOrdering[level] === undefined) {\n        this.distributionOrdering[level] = [];\n      }\n      var isPresent = false;\n      var curLevel = this.distributionOrdering[level];\n      for (var n in curLevel) {\n        //if (curLevel[n].id === node.id) {\n        if (curLevel[n] === node) {\n          isPresent = true;\n          break;\n        }\n      }\n      if (!isPresent) {\n        this.distributionOrdering[level].push(node);\n        this.distributionIndex[node.id] = this.distributionOrdering[level].length - 1;\n      }\n    }\n  }]);\n  return HierarchicalStatus;\n}();\n/**\n * The Layout Engine\n */\nvar LayoutEngine = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   */\n  function LayoutEngine(body) {\n    _classCallCheck(this, LayoutEngine);\n    this.body = body;\n\n    // Make sure there always is some RNG because the setOptions method won't\n    // set it unless there's a seed for it.\n    this._resetRNG(Math.random() + \":\" + _Date$now());\n    this.setPhysics = false;\n    this.options = {};\n    this.optionsBackup = {\n      physics: {}\n    };\n    this.defaultOptions = {\n      randomSeed: undefined,\n      improvedLayout: true,\n      clusterThreshold: 150,\n      hierarchical: {\n        enabled: false,\n        levelSeparation: 150,\n        nodeSpacing: 100,\n        treeSpacing: 200,\n        blockShifting: true,\n        edgeMinimization: true,\n        parentCentralization: true,\n        direction: \"UD\",\n        // UD, DU, LR, RL\n        sortMethod: \"hubsize\" // hubsize, directed\n      }\n    };\n\n    _Object$assign(this.options, this.defaultOptions);\n    this.bindEventListeners();\n  }\n\n  /**\n   * Binds event listeners\n   */\n  _createClass(LayoutEngine, [{\n    key: \"bindEventListeners\",\n    value: function bindEventListeners() {\n      var _this2 = this;\n      this.body.emitter.on(\"_dataChanged\", function () {\n        _this2.setupHierarchicalLayout();\n      });\n      this.body.emitter.on(\"_dataLoaded\", function () {\n        _this2.layoutNetwork();\n      });\n      this.body.emitter.on(\"_resetHierarchicalLayout\", function () {\n        _this2.setupHierarchicalLayout();\n      });\n      this.body.emitter.on(\"_adjustEdgesForHierarchicalLayout\", function () {\n        if (_this2.options.hierarchical.enabled !== true) {\n          return;\n        }\n        // get the type of static smooth curve in case it is required\n        var type = _this2.direction.curveType();\n\n        // force all edges into static smooth curves.\n        _this2.body.emitter.emit(\"_forceDisableDynamicCurves\", type, false);\n      });\n    }\n\n    /**\n     *\n     * @param {object} options\n     * @param {object} allOptions\n     * @returns {object}\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options, allOptions) {\n      if (options !== undefined) {\n        var hierarchical = this.options.hierarchical;\n        var prevHierarchicalState = hierarchical.enabled;\n        selectiveDeepExtend([\"randomSeed\", \"improvedLayout\", \"clusterThreshold\"], this.options, options);\n        mergeOptions(this.options, options, \"hierarchical\");\n        if (options.randomSeed !== undefined) {\n          this._resetRNG(options.randomSeed);\n        }\n        if (hierarchical.enabled === true) {\n          if (prevHierarchicalState === true) {\n            // refresh the overridden options for nodes and edges.\n            this.body.emitter.emit(\"refresh\", true);\n          }\n\n          // make sure the level separation is the right way up\n          if (hierarchical.direction === \"RL\" || hierarchical.direction === \"DU\") {\n            if (hierarchical.levelSeparation > 0) {\n              hierarchical.levelSeparation *= -1;\n            }\n          } else {\n            if (hierarchical.levelSeparation < 0) {\n              hierarchical.levelSeparation *= -1;\n            }\n          }\n          this.setDirectionStrategy();\n          this.body.emitter.emit(\"_resetHierarchicalLayout\");\n          // because the hierarchical system needs it's own physics and smooth curve settings,\n          // we adapt the other options if needed.\n          return this.adaptAllOptionsForHierarchicalLayout(allOptions);\n        } else {\n          if (prevHierarchicalState === true) {\n            // refresh the overridden options for nodes and edges.\n            this.body.emitter.emit(\"refresh\");\n            return deepExtend(allOptions, this.optionsBackup);\n          }\n        }\n      }\n      return allOptions;\n    }\n\n    /**\n     * Reset the random number generator with given seed.\n     *\n     * @param {any} seed - The seed that will be forwarded the the RNG.\n     */\n  }, {\n    key: \"_resetRNG\",\n    value: function _resetRNG(seed) {\n      this.initialRandomSeed = seed;\n      this._rng = Alea(this.initialRandomSeed);\n    }\n\n    /**\n     *\n     * @param {object} allOptions\n     * @returns {object}\n     */\n  }, {\n    key: \"adaptAllOptionsForHierarchicalLayout\",\n    value: function adaptAllOptionsForHierarchicalLayout(allOptions) {\n      if (this.options.hierarchical.enabled === true) {\n        var backupPhysics = this.optionsBackup.physics;\n\n        // set the physics\n        if (allOptions.physics === undefined || allOptions.physics === true) {\n          allOptions.physics = {\n            enabled: backupPhysics.enabled === undefined ? true : backupPhysics.enabled,\n            solver: \"hierarchicalRepulsion\"\n          };\n          backupPhysics.enabled = backupPhysics.enabled === undefined ? true : backupPhysics.enabled;\n          backupPhysics.solver = backupPhysics.solver || \"barnesHut\";\n        } else if (_typeof(allOptions.physics) === \"object\") {\n          backupPhysics.enabled = allOptions.physics.enabled === undefined ? true : allOptions.physics.enabled;\n          backupPhysics.solver = allOptions.physics.solver || \"barnesHut\";\n          allOptions.physics.solver = \"hierarchicalRepulsion\";\n        } else if (allOptions.physics !== false) {\n          backupPhysics.solver = \"barnesHut\";\n          allOptions.physics = {\n            solver: \"hierarchicalRepulsion\"\n          };\n        }\n\n        // get the type of static smooth curve in case it is required\n        var type = this.direction.curveType();\n\n        // disable smooth curves if nothing is defined. If smooth curves have been turned on,\n        // turn them into static smooth curves.\n        if (allOptions.edges === undefined) {\n          this.optionsBackup.edges = {\n            smooth: {\n              enabled: true,\n              type: \"dynamic\"\n            }\n          };\n          allOptions.edges = {\n            smooth: false\n          };\n        } else if (allOptions.edges.smooth === undefined) {\n          this.optionsBackup.edges = {\n            smooth: {\n              enabled: true,\n              type: \"dynamic\"\n            }\n          };\n          allOptions.edges.smooth = false;\n        } else {\n          if (typeof allOptions.edges.smooth === \"boolean\") {\n            this.optionsBackup.edges = {\n              smooth: allOptions.edges.smooth\n            };\n            allOptions.edges.smooth = {\n              enabled: allOptions.edges.smooth,\n              type: type\n            };\n          } else {\n            var smooth = allOptions.edges.smooth;\n\n            // allow custom types except for dynamic\n            if (smooth.type !== undefined && smooth.type !== \"dynamic\") {\n              type = smooth.type;\n            }\n\n            // TODO: this is options merging; see if the standard routines can be used here.\n            this.optionsBackup.edges = {\n              smooth: {\n                enabled: smooth.enabled === undefined ? true : smooth.enabled,\n                type: smooth.type === undefined ? \"dynamic\" : smooth.type,\n                roundness: smooth.roundness === undefined ? 0.5 : smooth.roundness,\n                forceDirection: smooth.forceDirection === undefined ? false : smooth.forceDirection\n              }\n            };\n\n            // NOTE: Copying an object to self; this is basically setting defaults for undefined variables\n            allOptions.edges.smooth = {\n              enabled: smooth.enabled === undefined ? true : smooth.enabled,\n              type: type,\n              roundness: smooth.roundness === undefined ? 0.5 : smooth.roundness,\n              forceDirection: smooth.forceDirection === undefined ? false : smooth.forceDirection\n            };\n          }\n        }\n\n        // Force all edges into static smooth curves.\n        // Only applies to edges that do not use the global options for smooth.\n        this.body.emitter.emit(\"_forceDisableDynamicCurves\", type);\n      }\n      return allOptions;\n    }\n\n    /**\n     *\n     * @param {Array.<Node>} nodesArray\n     */\n  }, {\n    key: \"positionInitially\",\n    value: function positionInitially(nodesArray) {\n      if (this.options.hierarchical.enabled !== true) {\n        this._resetRNG(this.initialRandomSeed);\n        var radius = nodesArray.length + 50;\n        for (var i = 0; i < nodesArray.length; i++) {\n          var node = nodesArray[i];\n          var angle = 2 * Math.PI * this._rng();\n          if (node.x === undefined) {\n            node.x = radius * Math.cos(angle);\n          }\n          if (node.y === undefined) {\n            node.y = radius * Math.sin(angle);\n          }\n        }\n      }\n    }\n\n    /**\n     * Use Kamada Kawai to position nodes. This is quite a heavy algorithm so if there are a lot of nodes we\n     * cluster them first to reduce the amount.\n     */\n  }, {\n    key: \"layoutNetwork\",\n    value: function layoutNetwork() {\n      if (this.options.hierarchical.enabled !== true && this.options.improvedLayout === true) {\n        var indices = this.body.nodeIndices;\n\n        // first check if we should Kamada Kawai to layout. The threshold is if less than half of the visible\n        // nodes have predefined positions we use this.\n        var positionDefined = 0;\n        for (var i = 0; i < indices.length; i++) {\n          var node = this.body.nodes[indices[i]];\n          if (node.predefinedPosition === true) {\n            positionDefined += 1;\n          }\n        }\n\n        // if less than half of the nodes have a predefined position we continue\n        if (positionDefined < 0.5 * indices.length) {\n          var MAX_LEVELS = 10;\n          var level = 0;\n          var clusterThreshold = this.options.clusterThreshold;\n\n          //\n          // Define the options for the hidden cluster nodes\n          // These options don't propagate outside the clustering phase.\n          //\n          // Some options are explicitly disabled, because they may be set in group or default node options.\n          // The clusters are never displayed, so most explicit settings here serve as performance optimizations.\n          //\n          // The explicit setting of 'shape' is to avoid `shape: 'image'`; images are not passed to the hidden\n          // cluster nodes, leading to an exception on creation.\n          //\n          // All settings here are performance related, except when noted otherwise.\n          //\n          var clusterOptions = {\n            clusterNodeProperties: {\n              shape: \"ellipse\",\n              // Bugfix: avoid type 'image', no images supplied\n              label: \"\",\n              // avoid label handling\n              group: \"\",\n              // avoid group handling\n              font: {\n                multi: false\n              } // avoid font propagation\n            },\n\n            clusterEdgeProperties: {\n              label: \"\",\n              // avoid label handling\n              font: {\n                multi: false\n              },\n              // avoid font propagation\n              smooth: {\n                enabled: false // avoid drawing penalty for complex edges\n              }\n            }\n          };\n\n          // if there are a lot of nodes, we cluster before we run the algorithm.\n          // NOTE: this part fails to find clusters for large scale-free networks, which should\n          //       be easily clusterable.\n          // TODO: examine why this is so\n          if (indices.length > clusterThreshold) {\n            var startLength = indices.length;\n            while (indices.length > clusterThreshold && level <= MAX_LEVELS) {\n              //console.time(\"clustering\")\n              level += 1;\n              var before = indices.length;\n              // if there are many nodes we do a hubsize cluster\n              if (level % 3 === 0) {\n                this.body.modules.clustering.clusterBridges(clusterOptions);\n              } else {\n                this.body.modules.clustering.clusterOutliers(clusterOptions);\n              }\n              var after = indices.length;\n              if (before == after && level % 3 !== 0) {\n                this._declusterAll();\n                this.body.emitter.emit(\"_layoutFailed\");\n                console.info(\"This network could not be positioned by this version of the improved layout algorithm.\" + \" Please disable improvedLayout for better performance.\");\n                return;\n              }\n              //console.timeEnd(\"clustering\")\n              //console.log(before,level,after);\n            }\n            // increase the size of the edges\n            this.body.modules.kamadaKawai.setOptions({\n              springLength: Math.max(150, 2 * startLength)\n            });\n          }\n          if (level > MAX_LEVELS) {\n            console.info(\"The clustering didn't succeed within the amount of interations allowed,\" + \" progressing with partial result.\");\n          }\n\n          // position the system for these nodes and edges\n          this.body.modules.kamadaKawai.solve(indices, this.body.edgeIndices, true);\n\n          // shift to center point\n          this._shiftToCenter();\n\n          // perturb the nodes a little bit to force the physics to kick in\n          var offset = 70;\n          for (var _i = 0; _i < indices.length; _i++) {\n            // Only perturb the nodes that aren't fixed\n            var _node = this.body.nodes[indices[_i]];\n            if (_node.predefinedPosition === false) {\n              _node.x += (0.5 - this._rng()) * offset;\n              _node.y += (0.5 - this._rng()) * offset;\n            }\n          }\n\n          // uncluster all clusters\n          this._declusterAll();\n\n          // reposition all bezier nodes.\n          this.body.emitter.emit(\"_repositionBezierNodes\");\n        }\n      }\n    }\n\n    /**\n     * Move all the nodes towards to the center so gravitational pull wil not move the nodes away from view\n     *\n     * @private\n     */\n  }, {\n    key: \"_shiftToCenter\",\n    value: function _shiftToCenter() {\n      var range = NetworkUtil.getRangeCore(this.body.nodes, this.body.nodeIndices);\n      var center = NetworkUtil.findCenter(range);\n      for (var i = 0; i < this.body.nodeIndices.length; i++) {\n        var node = this.body.nodes[this.body.nodeIndices[i]];\n        node.x -= center.x;\n        node.y -= center.y;\n      }\n    }\n\n    /**\n     * Expands all clusters\n     *\n     * @private\n     */\n  }, {\n    key: \"_declusterAll\",\n    value: function _declusterAll() {\n      var clustersPresent = true;\n      while (clustersPresent === true) {\n        clustersPresent = false;\n        for (var i = 0; i < this.body.nodeIndices.length; i++) {\n          if (this.body.nodes[this.body.nodeIndices[i]].isCluster === true) {\n            clustersPresent = true;\n            this.body.modules.clustering.openCluster(this.body.nodeIndices[i], {}, false);\n          }\n        }\n        if (clustersPresent === true) {\n          this.body.emitter.emit(\"_dataChanged\");\n        }\n      }\n    }\n\n    /**\n     *\n     * @returns {number|*}\n     */\n  }, {\n    key: \"getSeed\",\n    value: function getSeed() {\n      return this.initialRandomSeed;\n    }\n\n    /**\n     * This is the main function to layout the nodes in a hierarchical way.\n     * It checks if the node details are supplied correctly\n     *\n     * @private\n     */\n  }, {\n    key: \"setupHierarchicalLayout\",\n    value: function setupHierarchicalLayout() {\n      if (this.options.hierarchical.enabled === true && this.body.nodeIndices.length > 0) {\n        // get the size of the largest hubs and check if the user has defined a level for a node.\n        var node, nodeId;\n        var definedLevel = false;\n        var undefinedLevel = false;\n        this.lastNodeOnLevel = {};\n        this.hierarchical = new HierarchicalStatus();\n        for (nodeId in this.body.nodes) {\n          if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {\n            node = this.body.nodes[nodeId];\n            if (node.options.level !== undefined) {\n              definedLevel = true;\n              this.hierarchical.levels[nodeId] = node.options.level;\n            } else {\n              undefinedLevel = true;\n            }\n          }\n        }\n\n        // if the user defined some levels but not all, alert and run without hierarchical layout\n        if (undefinedLevel === true && definedLevel === true) {\n          throw new Error(\"To use the hierarchical layout, nodes require either no predefined levels\" + \" or levels have to be defined for all nodes.\");\n        } else {\n          // define levels if undefined by the users. Based on hubsize.\n          if (undefinedLevel === true) {\n            var sortMethod = this.options.hierarchical.sortMethod;\n            if (sortMethod === \"hubsize\") {\n              this._determineLevelsByHubsize();\n            } else if (sortMethod === \"directed\") {\n              this._determineLevelsDirected();\n            } else if (sortMethod === \"custom\") {\n              this._determineLevelsCustomCallback();\n            }\n          }\n\n          // fallback for cases where there are nodes but no edges\n          for (var _nodeId2 in this.body.nodes) {\n            if (Object.prototype.hasOwnProperty.call(this.body.nodes, _nodeId2)) {\n              this.hierarchical.ensureLevel(_nodeId2);\n            }\n          }\n          // check the distribution of the nodes per level.\n          var distribution = this._getDistribution();\n\n          // get the parent children relations.\n          this._generateMap();\n\n          // place the nodes on the canvas.\n          this._placeNodesByHierarchy(distribution);\n\n          // condense the whitespace.\n          this._condenseHierarchy();\n\n          // shift to center so gravity does not have to do much\n          this._shiftToCenter();\n        }\n      }\n    }\n\n    /**\n     * @private\n     */\n  }, {\n    key: \"_condenseHierarchy\",\n    value: function _condenseHierarchy() {\n      var _this3 = this;\n      // Global var in this scope to define when the movement has stopped.\n      var stillShifting = false;\n      var branches = {};\n      // first we have some methods to help shifting trees around.\n      // the main method to shift the trees\n      var shiftTrees = function shiftTrees() {\n        var treeSizes = getTreeSizes();\n        var shiftBy = 0;\n        for (var i = 0; i < treeSizes.length - 1; i++) {\n          var diff = treeSizes[i].max - treeSizes[i + 1].min;\n          shiftBy += diff + _this3.options.hierarchical.treeSpacing;\n          shiftTree(i + 1, shiftBy);\n        }\n      };\n\n      // shift a single tree by an offset\n      var shiftTree = function shiftTree(index, offset) {\n        var trees = _this3.hierarchical.trees;\n        for (var nodeId in trees) {\n          if (Object.prototype.hasOwnProperty.call(trees, nodeId)) {\n            if (trees[nodeId] === index) {\n              _this3.direction.shift(nodeId, offset);\n            }\n          }\n        }\n      };\n\n      // get the width of all trees\n      var getTreeSizes = function getTreeSizes() {\n        var treeWidths = [];\n        for (var i = 0; i < _this3.hierarchical.numTrees(); i++) {\n          treeWidths.push(_this3.direction.getTreeSize(i));\n        }\n        return treeWidths;\n      };\n\n      // get a map of all nodes in this branch\n      var getBranchNodes = function getBranchNodes(source, map) {\n        if (map[source.id]) {\n          return;\n        }\n        map[source.id] = true;\n        if (_this3.hierarchical.childrenReference[source.id]) {\n          var children = _this3.hierarchical.childrenReference[source.id];\n          if (children.length > 0) {\n            for (var i = 0; i < children.length; i++) {\n              getBranchNodes(_this3.body.nodes[children[i]], map);\n            }\n          }\n        }\n      };\n\n      // get a min max width as well as the maximum movement space it has on either sides\n      // we use min max terminology because width and height can interchange depending on the direction of the layout\n      var getBranchBoundary = function getBranchBoundary(branchMap) {\n        var maxLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e9;\n        var minSpace = 1e9;\n        var maxSpace = 1e9;\n        var min = 1e9;\n        var max = -1e9;\n        for (var branchNode in branchMap) {\n          if (Object.prototype.hasOwnProperty.call(branchMap, branchNode)) {\n            var node = _this3.body.nodes[branchNode];\n            var level = _this3.hierarchical.levels[node.id];\n            var position = _this3.direction.getPosition(node);\n\n            // get the space around the node.\n            var _this3$_getSpaceAroun = _this3._getSpaceAroundNode(node, branchMap),\n              _this3$_getSpaceAroun2 = _slicedToArray(_this3$_getSpaceAroun, 2),\n              minSpaceNode = _this3$_getSpaceAroun2[0],\n              maxSpaceNode = _this3$_getSpaceAroun2[1];\n            minSpace = Math.min(minSpaceNode, minSpace);\n            maxSpace = Math.min(maxSpaceNode, maxSpace);\n\n            // the width is only relevant for the levels two nodes have in common. This is why we filter on this.\n            if (level <= maxLevel) {\n              min = Math.min(position, min);\n              max = Math.max(position, max);\n            }\n          }\n        }\n        return [min, max, minSpace, maxSpace];\n      };\n\n      // check what the maximum level is these nodes have in common.\n      var getCollisionLevel = function getCollisionLevel(node1, node2) {\n        var maxLevel1 = _this3.hierarchical.getMaxLevel(node1.id);\n        var maxLevel2 = _this3.hierarchical.getMaxLevel(node2.id);\n        return Math.min(maxLevel1, maxLevel2);\n      };\n\n      /**\n       * Condense elements. These can be nodes or branches depending on the callback.\n       *\n       * @param {Function} callback\n       * @param {Array.<number>} levels\n       * @param {*} centerParents\n       */\n      var shiftElementsCloser = function shiftElementsCloser(callback, levels, centerParents) {\n        var hier = _this3.hierarchical;\n        for (var i = 0; i < levels.length; i++) {\n          var level = levels[i];\n          var levelNodes = hier.distributionOrdering[level];\n          if (levelNodes.length > 1) {\n            for (var j = 0; j < levelNodes.length - 1; j++) {\n              var node1 = levelNodes[j];\n              var node2 = levelNodes[j + 1];\n\n              // NOTE: logic maintained as it was; if nodes have same ancestor,\n              //       then of course they are in the same sub-network.\n              if (hier.hasSameParent(node1, node2) && hier.inSameSubNetwork(node1, node2)) {\n                callback(node1, node2, centerParents);\n              }\n            }\n          }\n        }\n      };\n\n      // callback for shifting branches\n      var branchShiftCallback = function branchShiftCallback(node1, node2) {\n        var centerParent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        //window.CALLBACKS.push(() => {\n        var pos1 = _this3.direction.getPosition(node1);\n        var pos2 = _this3.direction.getPosition(node2);\n        var diffAbs = Math.abs(pos2 - pos1);\n        var nodeSpacing = _this3.options.hierarchical.nodeSpacing;\n        //console.log(\"NOW CHECKING:\", node1.id, node2.id, diffAbs);\n        if (diffAbs > nodeSpacing) {\n          var branchNodes1 = {};\n          var branchNodes2 = {};\n          getBranchNodes(node1, branchNodes1);\n          getBranchNodes(node2, branchNodes2);\n\n          // check the largest distance between the branches\n          var maxLevel = getCollisionLevel(node1, node2);\n          var branchNodeBoundary1 = getBranchBoundary(branchNodes1, maxLevel);\n          var branchNodeBoundary2 = getBranchBoundary(branchNodes2, maxLevel);\n          var max1 = branchNodeBoundary1[1];\n          var min2 = branchNodeBoundary2[0];\n          var minSpace2 = branchNodeBoundary2[2];\n\n          //console.log(node1.id, getBranchBoundary(branchNodes1, maxLevel), node2.id,\n          //            getBranchBoundary(branchNodes2, maxLevel), maxLevel);\n          var diffBranch = Math.abs(max1 - min2);\n          if (diffBranch > nodeSpacing) {\n            var offset = max1 - min2 + nodeSpacing;\n            if (offset < -minSpace2 + nodeSpacing) {\n              offset = -minSpace2 + nodeSpacing;\n              //console.log(\"RESETTING OFFSET\", max1 - min2 + this.options.hierarchical.nodeSpacing, -minSpace2, offset);\n            }\n\n            if (offset < 0) {\n              //console.log(\"SHIFTING\", node2.id, offset);\n              _this3._shiftBlock(node2.id, offset);\n              stillShifting = true;\n              if (centerParent === true) _this3._centerParent(node2);\n            }\n          }\n        }\n        //this.body.emitter.emit(\"_redraw\");})\n      };\n\n      var minimizeEdgeLength = function minimizeEdgeLength(iterations, node) {\n        //window.CALLBACKS.push(() => {\n        //  console.log(\"ts\",node.id);\n        var nodeId = node.id;\n        var allEdges = node.edges;\n        var nodeLevel = _this3.hierarchical.levels[node.id];\n\n        // gather constants\n        var C2 = _this3.options.hierarchical.levelSeparation * _this3.options.hierarchical.levelSeparation;\n        var referenceNodes = {};\n        var aboveEdges = [];\n        for (var i = 0; i < allEdges.length; i++) {\n          var edge = allEdges[i];\n          if (edge.toId != edge.fromId) {\n            var otherNode = edge.toId == nodeId ? edge.from : edge.to;\n            referenceNodes[allEdges[i].id] = otherNode;\n            if (_this3.hierarchical.levels[otherNode.id] < nodeLevel) {\n              aboveEdges.push(edge);\n            }\n          }\n        }\n\n        // differentiated sum of lengths based on only moving one node over one axis\n        var getFx = function getFx(point, edges) {\n          var sum = 0;\n          for (var _i2 = 0; _i2 < edges.length; _i2++) {\n            if (referenceNodes[edges[_i2].id] !== undefined) {\n              var a = _this3.direction.getPosition(referenceNodes[edges[_i2].id]) - point;\n              sum += a / Math.sqrt(a * a + C2);\n            }\n          }\n          return sum;\n        };\n\n        // doubly differentiated sum of lengths based on only moving one node over one axis\n        var getDFx = function getDFx(point, edges) {\n          var sum = 0;\n          for (var _i3 = 0; _i3 < edges.length; _i3++) {\n            if (referenceNodes[edges[_i3].id] !== undefined) {\n              var a = _this3.direction.getPosition(referenceNodes[edges[_i3].id]) - point;\n              sum -= C2 * Math.pow(a * a + C2, -1.5);\n            }\n          }\n          return sum;\n        };\n        var getGuess = function getGuess(iterations, edges) {\n          var guess = _this3.direction.getPosition(node);\n          // Newton's method for optimization\n          var guessMap = {};\n          for (var _i4 = 0; _i4 < iterations; _i4++) {\n            var fx = getFx(guess, edges);\n            var dfx = getDFx(guess, edges);\n\n            // we limit the movement to avoid instability.\n            var limit = 40;\n            var ratio = Math.max(-limit, Math.min(limit, Math.round(fx / dfx)));\n            guess = guess - ratio;\n            // reduce duplicates\n            if (guessMap[guess] !== undefined) {\n              break;\n            }\n            guessMap[guess] = _i4;\n          }\n          return guess;\n        };\n        var moveBranch = function moveBranch(guess) {\n          // position node if there is space\n          var nodePosition = _this3.direction.getPosition(node);\n\n          // check movable area of the branch\n          if (branches[node.id] === undefined) {\n            var branchNodes = {};\n            getBranchNodes(node, branchNodes);\n            branches[node.id] = branchNodes;\n          }\n          var branchBoundary = getBranchBoundary(branches[node.id]);\n          var minSpaceBranch = branchBoundary[2];\n          var maxSpaceBranch = branchBoundary[3];\n          var diff = guess - nodePosition;\n\n          // check if we are allowed to move the node:\n          var branchOffset = 0;\n          if (diff > 0) {\n            branchOffset = Math.min(diff, maxSpaceBranch - _this3.options.hierarchical.nodeSpacing);\n          } else if (diff < 0) {\n            branchOffset = -Math.min(-diff, minSpaceBranch - _this3.options.hierarchical.nodeSpacing);\n          }\n          if (branchOffset != 0) {\n            //console.log(\"moving branch:\",branchOffset, maxSpaceBranch, minSpaceBranch)\n            _this3._shiftBlock(node.id, branchOffset);\n            //this.body.emitter.emit(\"_redraw\");\n            stillShifting = true;\n          }\n        };\n        var moveNode = function moveNode(guess) {\n          var nodePosition = _this3.direction.getPosition(node);\n\n          // position node if there is space\n          var _this3$_getSpaceAroun3 = _this3._getSpaceAroundNode(node),\n            _this3$_getSpaceAroun4 = _slicedToArray(_this3$_getSpaceAroun3, 2),\n            minSpace = _this3$_getSpaceAroun4[0],\n            maxSpace = _this3$_getSpaceAroun4[1];\n          var diff = guess - nodePosition;\n          // check if we are allowed to move the node:\n          var newPosition = nodePosition;\n          if (diff > 0) {\n            newPosition = Math.min(nodePosition + (maxSpace - _this3.options.hierarchical.nodeSpacing), guess);\n          } else if (diff < 0) {\n            newPosition = Math.max(nodePosition - (minSpace - _this3.options.hierarchical.nodeSpacing), guess);\n          }\n          if (newPosition !== nodePosition) {\n            //console.log(\"moving Node:\",diff, minSpace, maxSpace);\n            _this3.direction.setPosition(node, newPosition);\n            //this.body.emitter.emit(\"_redraw\");\n            stillShifting = true;\n          }\n        };\n        var guess = getGuess(iterations, aboveEdges);\n        moveBranch(guess);\n        guess = getGuess(iterations, allEdges);\n        moveNode(guess);\n        //})\n      };\n\n      // method to remove whitespace between branches. Because we do bottom up, we can center the parents.\n      var minimizeEdgeLengthBottomUp = function minimizeEdgeLengthBottomUp(iterations) {\n        var levels = _this3.hierarchical.getLevels();\n        levels = _reverseInstanceProperty(levels).call(levels);\n        for (var i = 0; i < iterations; i++) {\n          stillShifting = false;\n          for (var j = 0; j < levels.length; j++) {\n            var level = levels[j];\n            var levelNodes = _this3.hierarchical.distributionOrdering[level];\n            for (var k = 0; k < levelNodes.length; k++) {\n              minimizeEdgeLength(1000, levelNodes[k]);\n            }\n          }\n          if (stillShifting !== true) {\n            //console.log(\"FINISHED minimizeEdgeLengthBottomUp IN \" + i);\n            break;\n          }\n        }\n      };\n\n      // method to remove whitespace between branches. Because we do bottom up, we can center the parents.\n      var shiftBranchesCloserBottomUp = function shiftBranchesCloserBottomUp(iterations) {\n        var levels = _this3.hierarchical.getLevels();\n        levels = _reverseInstanceProperty(levels).call(levels);\n        for (var i = 0; i < iterations; i++) {\n          stillShifting = false;\n          shiftElementsCloser(branchShiftCallback, levels, true);\n          if (stillShifting !== true) {\n            //console.log(\"FINISHED shiftBranchesCloserBottomUp IN \" + (i+1));\n            break;\n          }\n        }\n      };\n\n      // center all parents\n      var centerAllParents = function centerAllParents() {\n        for (var nodeId in _this3.body.nodes) {\n          if (Object.prototype.hasOwnProperty.call(_this3.body.nodes, nodeId)) _this3._centerParent(_this3.body.nodes[nodeId]);\n        }\n      };\n\n      // center all parents\n      var centerAllParentsBottomUp = function centerAllParentsBottomUp() {\n        var levels = _this3.hierarchical.getLevels();\n        levels = _reverseInstanceProperty(levels).call(levels);\n        for (var i = 0; i < levels.length; i++) {\n          var level = levels[i];\n          var levelNodes = _this3.hierarchical.distributionOrdering[level];\n          for (var j = 0; j < levelNodes.length; j++) {\n            _this3._centerParent(levelNodes[j]);\n          }\n        }\n      };\n\n      // the actual work is done here.\n      if (this.options.hierarchical.blockShifting === true) {\n        shiftBranchesCloserBottomUp(5);\n        centerAllParents();\n      }\n\n      // minimize edge length\n      if (this.options.hierarchical.edgeMinimization === true) {\n        minimizeEdgeLengthBottomUp(20);\n      }\n      if (this.options.hierarchical.parentCentralization === true) {\n        centerAllParentsBottomUp();\n      }\n      shiftTrees();\n    }\n\n    /**\n     * This gives the space around the node. IF a map is supplied, it will only check against nodes NOT in the map.\n     * This is used to only get the distances to nodes outside of a branch.\n     *\n     * @param {Node} node\n     * @param {{Node.id: vis.Node}} map\n     * @returns {number[]}\n     * @private\n     */\n  }, {\n    key: \"_getSpaceAroundNode\",\n    value: function _getSpaceAroundNode(node, map) {\n      var useMap = true;\n      if (map === undefined) {\n        useMap = false;\n      }\n      var level = this.hierarchical.levels[node.id];\n      if (level !== undefined) {\n        var index = this.hierarchical.distributionIndex[node.id];\n        var position = this.direction.getPosition(node);\n        var ordering = this.hierarchical.distributionOrdering[level];\n        var minSpace = 1e9;\n        var maxSpace = 1e9;\n        if (index !== 0) {\n          var prevNode = ordering[index - 1];\n          if (useMap === true && map[prevNode.id] === undefined || useMap === false) {\n            var prevPos = this.direction.getPosition(prevNode);\n            minSpace = position - prevPos;\n          }\n        }\n        if (index != ordering.length - 1) {\n          var nextNode = ordering[index + 1];\n          if (useMap === true && map[nextNode.id] === undefined || useMap === false) {\n            var nextPos = this.direction.getPosition(nextNode);\n            maxSpace = Math.min(maxSpace, nextPos - position);\n          }\n        }\n        return [minSpace, maxSpace];\n      } else {\n        return [0, 0];\n      }\n    }\n\n    /**\n     * We use this method to center a parent node and check if it does not cross other nodes when it does.\n     *\n     * @param {Node} node\n     * @private\n     */\n  }, {\n    key: \"_centerParent\",\n    value: function _centerParent(node) {\n      if (this.hierarchical.parentReference[node.id]) {\n        var parents = this.hierarchical.parentReference[node.id];\n        for (var i = 0; i < parents.length; i++) {\n          var parentId = parents[i];\n          var parentNode = this.body.nodes[parentId];\n          var children = this.hierarchical.childrenReference[parentId];\n          if (children !== undefined) {\n            // get the range of the children\n            var newPosition = this._getCenterPosition(children);\n            var position = this.direction.getPosition(parentNode);\n            var _this$_getSpaceAround = this._getSpaceAroundNode(parentNode),\n              _this$_getSpaceAround2 = _slicedToArray(_this$_getSpaceAround, 2),\n              minSpace = _this$_getSpaceAround2[0],\n              maxSpace = _this$_getSpaceAround2[1];\n            var diff = position - newPosition;\n            if (diff < 0 && Math.abs(diff) < maxSpace - this.options.hierarchical.nodeSpacing || diff > 0 && Math.abs(diff) < minSpace - this.options.hierarchical.nodeSpacing) {\n              this.direction.setPosition(parentNode, newPosition);\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * This function places the nodes on the canvas based on the hierarchial distribution.\n     *\n     * @param {object} distribution | obtained by the function this._getDistribution()\n     * @private\n     */\n  }, {\n    key: \"_placeNodesByHierarchy\",\n    value: function _placeNodesByHierarchy(distribution) {\n      this.positionedNodes = {};\n      // start placing all the level 0 nodes first. Then recursively position their branches.\n      for (var level in distribution) {\n        if (Object.prototype.hasOwnProperty.call(distribution, level)) {\n          var _context;\n          // sort nodes in level by position:\n          var nodeArray = _Object$keys(distribution[level]);\n          nodeArray = this._indexArrayToNodes(nodeArray);\n          _sortInstanceProperty(_context = this.direction).call(_context, nodeArray);\n          var handledNodeCount = 0;\n          for (var i = 0; i < nodeArray.length; i++) {\n            var node = nodeArray[i];\n            if (this.positionedNodes[node.id] === undefined) {\n              var spacing = this.options.hierarchical.nodeSpacing;\n              var pos = spacing * handledNodeCount;\n              // We get the X or Y values we need and store them in pos and previousPos.\n              // The get and set make sure we get X or Y\n              if (handledNodeCount > 0) {\n                pos = this.direction.getPosition(nodeArray[i - 1]) + spacing;\n              }\n              this.direction.setPosition(node, pos, level);\n              this._validatePositionAndContinue(node, level, pos);\n              handledNodeCount++;\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     * This is a recursively called function to enumerate the branches from the largest hubs and place the nodes\n     * on a X position that ensures there will be no overlap.\n     *\n     * @param {Node.id} parentId\n     * @param {number} parentLevel\n     * @private\n     */\n  }, {\n    key: \"_placeBranchNodes\",\n    value: function _placeBranchNodes(parentId, parentLevel) {\n      var _context2;\n      var childRef = this.hierarchical.childrenReference[parentId];\n\n      // if this is not a parent, cancel the placing. This can happen with multiple parents to one child.\n      if (childRef === undefined) {\n        return;\n      }\n\n      // get a list of childNodes\n      var childNodes = [];\n      for (var i = 0; i < childRef.length; i++) {\n        childNodes.push(this.body.nodes[childRef[i]]);\n      }\n\n      // use the positions to order the nodes.\n      _sortInstanceProperty(_context2 = this.direction).call(_context2, childNodes);\n\n      // position the childNodes\n      for (var _i5 = 0; _i5 < childNodes.length; _i5++) {\n        var childNode = childNodes[_i5];\n        var childNodeLevel = this.hierarchical.levels[childNode.id];\n        // check if the child node is below the parent node and if it has already been positioned.\n        if (childNodeLevel > parentLevel && this.positionedNodes[childNode.id] === undefined) {\n          // get the amount of space required for this node. If parent the width is based on the amount of children.\n          var spacing = this.options.hierarchical.nodeSpacing;\n          var pos = void 0;\n\n          // we get the X or Y values we need and store them in pos and previousPos.\n          // The get and set make sure we get X or Y\n          if (_i5 === 0) {\n            pos = this.direction.getPosition(this.body.nodes[parentId]);\n          } else {\n            pos = this.direction.getPosition(childNodes[_i5 - 1]) + spacing;\n          }\n          this.direction.setPosition(childNode, pos, childNodeLevel);\n          this._validatePositionAndContinue(childNode, childNodeLevel, pos);\n        } else {\n          return;\n        }\n      }\n\n      // center the parent nodes.\n      var center = this._getCenterPosition(childNodes);\n      this.direction.setPosition(this.body.nodes[parentId], center, parentLevel);\n    }\n\n    /**\n     * This method checks for overlap and if required shifts the branch. It also keeps records of positioned nodes.\n     * Finally it will call _placeBranchNodes to place the branch nodes.\n     *\n     * @param {Node} node\n     * @param {number} level\n     * @param {number} pos\n     * @private\n     */\n  }, {\n    key: \"_validatePositionAndContinue\",\n    value: function _validatePositionAndContinue(node, level, pos) {\n      // This method only works for formal trees and formal forests\n      // Early exit if this is not the case\n      if (!this.hierarchical.isTree) return;\n\n      // if overlap has been detected, we shift the branch\n      if (this.lastNodeOnLevel[level] !== undefined) {\n        var previousPos = this.direction.getPosition(this.body.nodes[this.lastNodeOnLevel[level]]);\n        if (pos - previousPos < this.options.hierarchical.nodeSpacing) {\n          var diff = previousPos + this.options.hierarchical.nodeSpacing - pos;\n          var sharedParent = this._findCommonParent(this.lastNodeOnLevel[level], node.id);\n          this._shiftBlock(sharedParent.withChild, diff);\n        }\n      }\n      this.lastNodeOnLevel[level] = node.id; // store change in position.\n      this.positionedNodes[node.id] = true;\n      this._placeBranchNodes(node.id, level);\n    }\n\n    /**\n     * Receives an array with node indices and returns an array with the actual node references.\n     * Used for sorting based on node properties.\n     *\n     * @param {Array.<Node.id>} idArray\n     * @returns {Array.<Node>}\n     */\n  }, {\n    key: \"_indexArrayToNodes\",\n    value: function _indexArrayToNodes(idArray) {\n      var array = [];\n      for (var i = 0; i < idArray.length; i++) {\n        array.push(this.body.nodes[idArray[i]]);\n      }\n      return array;\n    }\n\n    /**\n     * This function get the distribution of levels based on hubsize\n     *\n     * @returns {object}\n     * @private\n     */\n  }, {\n    key: \"_getDistribution\",\n    value: function _getDistribution() {\n      var distribution = {};\n      var nodeId, node;\n\n      // we fix Y because the hierarchy is vertical,\n      // we fix X so we do not give a node an x position for a second time.\n      // the fix of X is removed after the x value has been set.\n      for (nodeId in this.body.nodes) {\n        if (Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) {\n          node = this.body.nodes[nodeId];\n          var level = this.hierarchical.levels[nodeId] === undefined ? 0 : this.hierarchical.levels[nodeId];\n          this.direction.fix(node, level);\n          if (distribution[level] === undefined) {\n            distribution[level] = {};\n          }\n          distribution[level][nodeId] = node;\n        }\n      }\n      return distribution;\n    }\n\n    /**\n     * Return the active (i.e. visible) edges for this node\n     *\n     * @param {Node} node\n     * @returns {Array.<vis.Edge>} Array of edge instances\n     * @private\n     */\n  }, {\n    key: \"_getActiveEdges\",\n    value: function _getActiveEdges(node) {\n      var _this4 = this;\n      var result = [];\n      forEach$1(node.edges, function (edge) {\n        var _context3;\n        if (_indexOfInstanceProperty(_context3 = _this4.body.edgeIndices).call(_context3, edge.id) !== -1) {\n          result.push(edge);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * Get the hubsizes for all active nodes.\n     *\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_getHubSizes\",\n    value: function _getHubSizes() {\n      var _this5 = this;\n      var hubSizes = {};\n      var nodeIds = this.body.nodeIndices;\n      forEach$1(nodeIds, function (nodeId) {\n        var node = _this5.body.nodes[nodeId];\n        var hubSize = _this5._getActiveEdges(node).length;\n        hubSizes[hubSize] = true;\n      });\n\n      // Make an array of the size sorted descending\n      var result = [];\n      forEach$1(hubSizes, function (size) {\n        result.push(Number(size));\n      });\n      _sortInstanceProperty(result).call(result, function (a, b) {\n        return b - a;\n      });\n      return result;\n    }\n\n    /**\n     * this function allocates nodes in levels based on the recursive branching from the largest hubs.\n     *\n     * @private\n     */\n  }, {\n    key: \"_determineLevelsByHubsize\",\n    value: function _determineLevelsByHubsize() {\n      var _this6 = this;\n      var levelDownstream = function levelDownstream(nodeA, nodeB) {\n        _this6.hierarchical.levelDownstream(nodeA, nodeB);\n      };\n      var hubSizes = this._getHubSizes();\n      var _loop = function _loop() {\n        var hubSize = hubSizes[i];\n        if (hubSize === 0) return 1; // break\n        forEach$1(_this6.body.nodeIndices, function (nodeId) {\n          var node = _this6.body.nodes[nodeId];\n          if (hubSize === _this6._getActiveEdges(node).length) {\n            _this6._crawlNetwork(levelDownstream, nodeId);\n          }\n        });\n      };\n      for (var i = 0; i < hubSizes.length; ++i) {\n        if (_loop()) break;\n      }\n    }\n\n    /**\n     * TODO: release feature\n     * TODO: Determine if this feature is needed at all\n     *\n     * @private\n     */\n  }, {\n    key: \"_determineLevelsCustomCallback\",\n    value: function _determineLevelsCustomCallback() {\n      var _this7 = this;\n      var minLevel = 100000;\n\n      // TODO: this should come from options.\n      // eslint-disable-next-line no-unused-vars -- This should eventually be implemented with these parameters used.\n      var customCallback = function customCallback(nodeA, nodeB, edge) {};\n\n      // TODO: perhaps move to HierarchicalStatus.\n      //       But I currently don't see the point, this method is not used.\n      var levelByDirection = function levelByDirection(nodeA, nodeB, edge) {\n        var levelA = _this7.hierarchical.levels[nodeA.id];\n        // set initial level\n        if (levelA === undefined) {\n          levelA = _this7.hierarchical.levels[nodeA.id] = minLevel;\n        }\n        var diff = customCallback(NetworkUtil.cloneOptions(nodeA, \"node\"), NetworkUtil.cloneOptions(nodeB, \"node\"), NetworkUtil.cloneOptions(edge, \"edge\"));\n        _this7.hierarchical.levels[nodeB.id] = levelA + diff;\n      };\n      this._crawlNetwork(levelByDirection);\n      this.hierarchical.setMinLevelToZero(this.body.nodes);\n    }\n\n    /**\n     * Allocate nodes in levels based on the direction of the edges.\n     *\n     * @private\n     */\n  }, {\n    key: \"_determineLevelsDirected\",\n    value: function _determineLevelsDirected() {\n      var _context4,\n        _this8 = this;\n      var nodes = _reduceInstanceProperty(_context4 = this.body.nodeIndices).call(_context4, function (acc, id) {\n        acc.set(id, _this8.body.nodes[id]);\n        return acc;\n      }, new _Map());\n      if (this.options.hierarchical.shakeTowards === \"roots\") {\n        this.hierarchical.levels = fillLevelsByDirectionRoots(nodes);\n      } else {\n        this.hierarchical.levels = fillLevelsByDirectionLeaves(nodes);\n      }\n      this.hierarchical.setMinLevelToZero(this.body.nodes);\n    }\n\n    /**\n     * Update the bookkeeping of parent and child.\n     *\n     * @private\n     */\n  }, {\n    key: \"_generateMap\",\n    value: function _generateMap() {\n      var _this9 = this;\n      var fillInRelations = function fillInRelations(parentNode, childNode) {\n        if (_this9.hierarchical.levels[childNode.id] > _this9.hierarchical.levels[parentNode.id]) {\n          _this9.hierarchical.addRelation(parentNode.id, childNode.id);\n        }\n      };\n      this._crawlNetwork(fillInRelations);\n      this.hierarchical.checkIfTree();\n    }\n\n    /**\n     * Crawl over the entire network and use a callback on each node couple that is connected to each other.\n     *\n     * @param {Function} [callback=function(){}]          | will receive nodeA, nodeB and the connecting edge. A and B are distinct.\n     * @param {Node.id} startingNodeId\n     * @private\n     */\n  }, {\n    key: \"_crawlNetwork\",\n    value: function _crawlNetwork() {\n      var _this10 = this;\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n      var startingNodeId = arguments.length > 1 ? arguments[1] : undefined;\n      var progress = {};\n      var crawler = function crawler(node, tree) {\n        if (progress[node.id] === undefined) {\n          _this10.hierarchical.setTreeIndex(node, tree);\n          progress[node.id] = true;\n          var childNode;\n          var edges = _this10._getActiveEdges(node);\n          for (var i = 0; i < edges.length; i++) {\n            var edge = edges[i];\n            if (edge.connected === true) {\n              if (edge.toId == node.id) {\n                // Not '===' because id's can be string and numeric\n                childNode = edge.from;\n              } else {\n                childNode = edge.to;\n              }\n              if (node.id != childNode.id) {\n                // Not '!==' because id's can be string and numeric\n                callback(node, childNode, edge);\n                crawler(childNode, tree);\n              }\n            }\n          }\n        }\n      };\n      if (startingNodeId === undefined) {\n        // Crawl over all nodes\n        var treeIndex = 0; // Serves to pass a unique id for the current distinct tree\n\n        for (var i = 0; i < this.body.nodeIndices.length; i++) {\n          var nodeId = this.body.nodeIndices[i];\n          if (progress[nodeId] === undefined) {\n            var node = this.body.nodes[nodeId];\n            crawler(node, treeIndex);\n            treeIndex += 1;\n          }\n        }\n      } else {\n        // Crawl from the given starting node\n        var _node2 = this.body.nodes[startingNodeId];\n        if (_node2 === undefined) {\n          console.error(\"Node not found:\", startingNodeId);\n          return;\n        }\n        crawler(_node2);\n      }\n    }\n\n    /**\n     * Shift a branch a certain distance\n     *\n     * @param {Node.id} parentId\n     * @param {number} diff\n     * @private\n     */\n  }, {\n    key: \"_shiftBlock\",\n    value: function _shiftBlock(parentId, diff) {\n      var _this11 = this;\n      var progress = {};\n      var shifter = function shifter(parentId) {\n        if (progress[parentId]) {\n          return;\n        }\n        progress[parentId] = true;\n        _this11.direction.shift(parentId, diff);\n        var childRef = _this11.hierarchical.childrenReference[parentId];\n        if (childRef !== undefined) {\n          for (var i = 0; i < childRef.length; i++) {\n            shifter(childRef[i]);\n          }\n        }\n      };\n      shifter(parentId);\n    }\n\n    /**\n     * Find a common parent between branches.\n     *\n     * @param {Node.id} childA\n     * @param {Node.id} childB\n     * @returns {{foundParent, withChild}}\n     * @private\n     */\n  }, {\n    key: \"_findCommonParent\",\n    value: function _findCommonParent(childA, childB) {\n      var _this12 = this;\n      var parents = {};\n      var iterateParents = function iterateParents(parents, child) {\n        var parentRef = _this12.hierarchical.parentReference[child];\n        if (parentRef !== undefined) {\n          for (var i = 0; i < parentRef.length; i++) {\n            var parent = parentRef[i];\n            parents[parent] = true;\n            iterateParents(parents, parent);\n          }\n        }\n      };\n      var findParent = function findParent(parents, child) {\n        var parentRef = _this12.hierarchical.parentReference[child];\n        if (parentRef !== undefined) {\n          for (var i = 0; i < parentRef.length; i++) {\n            var parent = parentRef[i];\n            if (parents[parent] !== undefined) {\n              return {\n                foundParent: parent,\n                withChild: child\n              };\n            }\n            var branch = findParent(parents, parent);\n            if (branch.foundParent !== null) {\n              return branch;\n            }\n          }\n        }\n        return {\n          foundParent: null,\n          withChild: child\n        };\n      };\n      iterateParents(parents, childA);\n      return findParent(parents, childB);\n    }\n\n    /**\n     * Set the strategy pattern for handling the coordinates given the current direction.\n     *\n     * The individual instances contain all the operations and data specific to a layout direction.\n     *\n     * @param {Node} node\n     * @param {{x: number, y: number}} position\n     * @param {number} level\n     * @param {boolean} [doNotUpdate=false]\n     * @private\n     */\n  }, {\n    key: \"setDirectionStrategy\",\n    value: function setDirectionStrategy() {\n      var isVertical = this.options.hierarchical.direction === \"UD\" || this.options.hierarchical.direction === \"DU\";\n      if (isVertical) {\n        this.direction = new VerticalStrategy(this);\n      } else {\n        this.direction = new HorizontalStrategy(this);\n      }\n    }\n\n    /**\n     * Determine the center position of a branch from the passed list of child nodes\n     *\n     * This takes into account the positions of all the child nodes.\n     *\n     * @param {Array.<Node|vis.Node.id>} childNodes  Array of either child nodes or node id's\n     * @returns {number}\n     * @private\n     */\n  }, {\n    key: \"_getCenterPosition\",\n    value: function _getCenterPosition(childNodes) {\n      var minPos = 1e9;\n      var maxPos = -1e9;\n      for (var i = 0; i < childNodes.length; i++) {\n        var childNode = void 0;\n        if (childNodes[i].id !== undefined) {\n          childNode = childNodes[i];\n        } else {\n          var childNodeId = childNodes[i];\n          childNode = this.body.nodes[childNodeId];\n        }\n        var position = this.direction.getPosition(childNode);\n        minPos = Math.min(minPos, position);\n        maxPos = Math.max(maxPos, position);\n      }\n      return 0.5 * (minPos + maxPos);\n    }\n  }]);\n  return LayoutEngine;\n}();\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof _Symbol !== \"undefined\" && _getIteratorMethod(o) || o[\"@@iterator\"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { var _context32; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = _sliceInstanceProperty(_context32 = Object.prototype.toString.call(o)).call(_context32, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return _Array$from$1(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n/**\n * Clears the toolbar div element of children\n *\n * @private\n */\nvar ManipulationSystem = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {Canvas} canvas\n   * @param {SelectionHandler} selectionHandler\n   * @param {InteractionHandler} interactionHandler\n   */\n  function ManipulationSystem(body, canvas, selectionHandler, interactionHandler) {\n    var _this = this,\n      _context,\n      _context2;\n    _classCallCheck(this, ManipulationSystem);\n    this.body = body;\n    this.canvas = canvas;\n    this.selectionHandler = selectionHandler;\n    this.interactionHandler = interactionHandler;\n    this.editMode = false;\n    this.manipulationDiv = undefined;\n    this.editModeDiv = undefined;\n    this.closeDiv = undefined;\n    this._domEventListenerCleanupQueue = [];\n    this.temporaryUIFunctions = {};\n    this.temporaryEventFunctions = [];\n    this.touchTime = 0;\n    this.temporaryIds = {\n      nodes: [],\n      edges: []\n    };\n    this.guiEnabled = false;\n    this.inMode = false;\n    this.selectedControlNode = undefined;\n    this.options = {};\n    this.defaultOptions = {\n      enabled: false,\n      initiallyActive: false,\n      addNode: true,\n      addEdge: true,\n      editNode: undefined,\n      editEdge: true,\n      deleteNode: true,\n      deleteEdge: true,\n      controlNodeStyle: {\n        shape: \"dot\",\n        size: 6,\n        color: {\n          background: \"#ff0000\",\n          border: \"#3c3c3c\",\n          highlight: {\n            background: \"#07f968\",\n            border: \"#3c3c3c\"\n          }\n        },\n        borderWidth: 2,\n        borderWidthSelected: 2\n      }\n    };\n    _Object$assign(this.options, this.defaultOptions);\n    this.body.emitter.on(\"destroy\", function () {\n      _this._clean();\n    });\n    this.body.emitter.on(\"_dataChanged\", _bindInstanceProperty$1(_context = this._restore).call(_context, this));\n    this.body.emitter.on(\"_resetData\", _bindInstanceProperty$1(_context2 = this._restore).call(_context2, this));\n  }\n\n  /**\n   * If something changes in the data during editing, switch back to the initial datamanipulation state and close all edit modes.\n   *\n   * @private\n   */\n  _createClass(ManipulationSystem, [{\n    key: \"_restore\",\n    value: function _restore() {\n      if (this.inMode !== false) {\n        if (this.options.initiallyActive === true) {\n          this.enableEditMode();\n        } else {\n          this.disableEditMode();\n        }\n      }\n    }\n\n    /**\n     * Set the Options\n     *\n     * @param {object} options\n     * @param {object} allOptions\n     * @param {object} globalOptions\n     */\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options, allOptions, globalOptions) {\n      if (allOptions !== undefined) {\n        if (allOptions.locale !== undefined) {\n          this.options.locale = allOptions.locale;\n        } else {\n          this.options.locale = globalOptions.locale;\n        }\n        if (allOptions.locales !== undefined) {\n          this.options.locales = allOptions.locales;\n        } else {\n          this.options.locales = globalOptions.locales;\n        }\n      }\n      if (options !== undefined) {\n        if (typeof options === \"boolean\") {\n          this.options.enabled = options;\n        } else {\n          this.options.enabled = true;\n          deepExtend(this.options, options);\n        }\n        if (this.options.initiallyActive === true) {\n          this.editMode = true;\n        }\n        this._setup();\n      }\n    }\n\n    /**\n     * Enable or disable edit-mode. Draws the DOM required and cleans up after itself.\n     *\n     * @private\n     */\n  }, {\n    key: \"toggleEditMode\",\n    value: function toggleEditMode() {\n      if (this.editMode === true) {\n        this.disableEditMode();\n      } else {\n        this.enableEditMode();\n      }\n    }\n\n    /**\n     * Enables Edit Mode\n     */\n  }, {\n    key: \"enableEditMode\",\n    value: function enableEditMode() {\n      this.editMode = true;\n      this._clean();\n      if (this.guiEnabled === true) {\n        this.manipulationDiv.style.display = \"block\";\n        this.closeDiv.style.display = \"block\";\n        this.editModeDiv.style.display = \"none\";\n        this.showManipulatorToolbar();\n      }\n    }\n\n    /**\n     * Disables Edit Mode\n     */\n  }, {\n    key: \"disableEditMode\",\n    value: function disableEditMode() {\n      this.editMode = false;\n      this._clean();\n      if (this.guiEnabled === true) {\n        this.manipulationDiv.style.display = \"none\";\n        this.closeDiv.style.display = \"none\";\n        this.editModeDiv.style.display = \"block\";\n        this._createEditButton();\n      }\n    }\n\n    /**\n     * Creates the main toolbar. Removes functions bound to the select event. Binds all the buttons of the toolbar.\n     *\n     * @private\n     */\n  }, {\n    key: \"showManipulatorToolbar\",\n    value: function showManipulatorToolbar() {\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n\n      // reset global variables\n      this.manipulationDOM = {};\n\n      // if the gui is enabled, draw all elements.\n      if (this.guiEnabled === true) {\n        var _context3, _context4;\n        // a _restore will hide these menus\n        this.editMode = true;\n        this.manipulationDiv.style.display = \"block\";\n        this.closeDiv.style.display = \"block\";\n        var selectedNodeCount = this.selectionHandler.getSelectedNodeCount();\n        var selectedEdgeCount = this.selectionHandler.getSelectedEdgeCount();\n        var selectedTotalCount = selectedNodeCount + selectedEdgeCount;\n        var locale = this.options.locales[this.options.locale];\n        var needSeperator = false;\n        if (this.options.addNode !== false) {\n          this._createAddNodeButton(locale);\n          needSeperator = true;\n        }\n        if (this.options.addEdge !== false) {\n          if (needSeperator === true) {\n            this._createSeperator(1);\n          } else {\n            needSeperator = true;\n          }\n          this._createAddEdgeButton(locale);\n        }\n        if (selectedNodeCount === 1 && typeof this.options.editNode === \"function\") {\n          if (needSeperator === true) {\n            this._createSeperator(2);\n          } else {\n            needSeperator = true;\n          }\n          this._createEditNodeButton(locale);\n        } else if (selectedEdgeCount === 1 && selectedNodeCount === 0 && this.options.editEdge !== false) {\n          if (needSeperator === true) {\n            this._createSeperator(3);\n          } else {\n            needSeperator = true;\n          }\n          this._createEditEdgeButton(locale);\n        }\n\n        // remove buttons\n        if (selectedTotalCount !== 0) {\n          if (selectedNodeCount > 0 && this.options.deleteNode !== false) {\n            if (needSeperator === true) {\n              this._createSeperator(4);\n            }\n            this._createDeleteButton(locale);\n          } else if (selectedNodeCount === 0 && this.options.deleteEdge !== false) {\n            if (needSeperator === true) {\n              this._createSeperator(4);\n            }\n            this._createDeleteButton(locale);\n          }\n        }\n\n        // bind the close button\n        this._bindElementEvents(this.closeDiv, _bindInstanceProperty$1(_context3 = this.toggleEditMode).call(_context3, this));\n\n        // refresh this bar based on what has been selected\n        this._temporaryBindEvent(\"select\", _bindInstanceProperty$1(_context4 = this.showManipulatorToolbar).call(_context4, this));\n      }\n\n      // redraw to show any possible changes\n      this.body.emitter.emit(\"_redraw\");\n    }\n\n    /**\n     * Create the toolbar for adding Nodes\n     */\n  }, {\n    key: \"addNodeMode\",\n    value: function addNodeMode() {\n      var _context6;\n      // when using the gui, enable edit mode if it wasnt already.\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n      this.inMode = \"addNode\";\n      if (this.guiEnabled === true) {\n        var _context5;\n        var locale = this.options.locales[this.options.locale];\n        this.manipulationDOM = {};\n        this._createBackButton(locale);\n        this._createSeperator();\n        this._createDescription(locale[\"addDescription\"] || this.options.locales[\"en\"][\"addDescription\"]);\n\n        // bind the close button\n        this._bindElementEvents(this.closeDiv, _bindInstanceProperty$1(_context5 = this.toggleEditMode).call(_context5, this));\n      }\n      this._temporaryBindEvent(\"click\", _bindInstanceProperty$1(_context6 = this._performAddNode).call(_context6, this));\n    }\n\n    /**\n     * call the bound function to handle the editing of the node. The node has to be selected.\n     */\n  }, {\n    key: \"editNode\",\n    value: function editNode() {\n      var _this2 = this;\n      // when using the gui, enable edit mode if it wasnt already.\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n      var node = this.selectionHandler.getSelectedNodes()[0];\n      if (node !== undefined) {\n        this.inMode = \"editNode\";\n        if (typeof this.options.editNode === \"function\") {\n          if (node.isCluster !== true) {\n            var data = deepExtend({}, node.options, false);\n            data.x = node.x;\n            data.y = node.y;\n            if (this.options.editNode.length === 2) {\n              this.options.editNode(data, function (finalizedData) {\n                if (finalizedData !== null && finalizedData !== undefined && _this2.inMode === \"editNode\") {\n                  // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {\n                  _this2.body.data.nodes.getDataSet().update(finalizedData);\n                }\n                _this2.showManipulatorToolbar();\n              });\n            } else {\n              throw new Error(\"The function for edit does not support two arguments (data, callback)\");\n            }\n          } else {\n            alert(this.options.locales[this.options.locale][\"editClusterError\"] || this.options.locales[\"en\"][\"editClusterError\"]);\n          }\n        } else {\n          throw new Error(\"No function has been configured to handle the editing of nodes.\");\n        }\n      } else {\n        this.showManipulatorToolbar();\n      }\n    }\n\n    /**\n     * create the toolbar to connect nodes\n     */\n  }, {\n    key: \"addEdgeMode\",\n    value: function addEdgeMode() {\n      var _context8, _context9, _context10, _context11, _context12;\n      // when using the gui, enable edit mode if it wasnt already.\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n      this.inMode = \"addEdge\";\n      if (this.guiEnabled === true) {\n        var _context7;\n        var locale = this.options.locales[this.options.locale];\n        this.manipulationDOM = {};\n        this._createBackButton(locale);\n        this._createSeperator();\n        this._createDescription(locale[\"edgeDescription\"] || this.options.locales[\"en\"][\"edgeDescription\"]);\n\n        // bind the close button\n        this._bindElementEvents(this.closeDiv, _bindInstanceProperty$1(_context7 = this.toggleEditMode).call(_context7, this));\n      }\n\n      // temporarily overload functions\n      this._temporaryBindUI(\"onTouch\", _bindInstanceProperty$1(_context8 = this._handleConnect).call(_context8, this));\n      this._temporaryBindUI(\"onDragEnd\", _bindInstanceProperty$1(_context9 = this._finishConnect).call(_context9, this));\n      this._temporaryBindUI(\"onDrag\", _bindInstanceProperty$1(_context10 = this._dragControlNode).call(_context10, this));\n      this._temporaryBindUI(\"onRelease\", _bindInstanceProperty$1(_context11 = this._finishConnect).call(_context11, this));\n      this._temporaryBindUI(\"onDragStart\", _bindInstanceProperty$1(_context12 = this._dragStartEdge).call(_context12, this));\n      this._temporaryBindUI(\"onHold\", function () {});\n    }\n\n    /**\n     * create the toolbar to edit edges\n     */\n  }, {\n    key: \"editEdgeMode\",\n    value: function editEdgeMode() {\n      // when using the gui, enable edit mode if it wasn't already.\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n      this.inMode = \"editEdge\";\n      if (_typeof(this.options.editEdge) === \"object\" && typeof this.options.editEdge.editWithoutDrag === \"function\") {\n        this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0];\n        if (this.edgeBeingEditedId !== undefined) {\n          var edge = this.body.edges[this.edgeBeingEditedId];\n          this._performEditEdge(edge.from.id, edge.to.id);\n          return;\n        }\n      }\n      if (this.guiEnabled === true) {\n        var _context13;\n        var locale = this.options.locales[this.options.locale];\n        this.manipulationDOM = {};\n        this._createBackButton(locale);\n        this._createSeperator();\n        this._createDescription(locale[\"editEdgeDescription\"] || this.options.locales[\"en\"][\"editEdgeDescription\"]);\n\n        // bind the close button\n        this._bindElementEvents(this.closeDiv, _bindInstanceProperty$1(_context13 = this.toggleEditMode).call(_context13, this));\n      }\n      this.edgeBeingEditedId = this.selectionHandler.getSelectedEdgeIds()[0];\n      if (this.edgeBeingEditedId !== undefined) {\n        var _context14, _context15, _context16, _context17;\n        var _edge = this.body.edges[this.edgeBeingEditedId];\n\n        // create control nodes\n        var controlNodeFrom = this._getNewTargetNode(_edge.from.x, _edge.from.y);\n        var controlNodeTo = this._getNewTargetNode(_edge.to.x, _edge.to.y);\n        this.temporaryIds.nodes.push(controlNodeFrom.id);\n        this.temporaryIds.nodes.push(controlNodeTo.id);\n        this.body.nodes[controlNodeFrom.id] = controlNodeFrom;\n        this.body.nodeIndices.push(controlNodeFrom.id);\n        this.body.nodes[controlNodeTo.id] = controlNodeTo;\n        this.body.nodeIndices.push(controlNodeTo.id);\n\n        // temporarily overload UI functions, cleaned up automatically because of _temporaryBindUI\n        this._temporaryBindUI(\"onTouch\", _bindInstanceProperty$1(_context14 = this._controlNodeTouch).call(_context14, this)); // used to get the position\n        this._temporaryBindUI(\"onTap\", function () {}); // disabled\n        this._temporaryBindUI(\"onHold\", function () {}); // disabled\n        this._temporaryBindUI(\"onDragStart\", _bindInstanceProperty$1(_context15 = this._controlNodeDragStart).call(_context15, this)); // used to select control node\n        this._temporaryBindUI(\"onDrag\", _bindInstanceProperty$1(_context16 = this._controlNodeDrag).call(_context16, this)); // used to drag control node\n        this._temporaryBindUI(\"onDragEnd\", _bindInstanceProperty$1(_context17 = this._controlNodeDragEnd).call(_context17, this)); // used to connect or revert control nodes\n        this._temporaryBindUI(\"onMouseMove\", function () {}); // disabled\n\n        // create function to position control nodes correctly on movement\n        // automatically cleaned up because we use the temporary bind\n        this._temporaryBindEvent(\"beforeDrawing\", function (ctx) {\n          var positions = _edge.edgeType.findBorderPositions(ctx);\n          if (controlNodeFrom.selected === false) {\n            controlNodeFrom.x = positions.from.x;\n            controlNodeFrom.y = positions.from.y;\n          }\n          if (controlNodeTo.selected === false) {\n            controlNodeTo.x = positions.to.x;\n            controlNodeTo.y = positions.to.y;\n          }\n        });\n        this.body.emitter.emit(\"_redraw\");\n      } else {\n        this.showManipulatorToolbar();\n      }\n    }\n\n    /**\n     * delete everything in the selection\n     */\n  }, {\n    key: \"deleteSelected\",\n    value: function deleteSelected() {\n      var _this3 = this;\n      // when using the gui, enable edit mode if it wasnt already.\n      if (this.editMode !== true) {\n        this.enableEditMode();\n      }\n\n      // restore the state of any bound functions or events, remove control nodes, restore physics\n      this._clean();\n      this.inMode = \"delete\";\n      var selectedNodes = this.selectionHandler.getSelectedNodeIds();\n      var selectedEdges = this.selectionHandler.getSelectedEdgeIds();\n      var deleteFunction = undefined;\n      if (selectedNodes.length > 0) {\n        for (var i = 0; i < selectedNodes.length; i++) {\n          if (this.body.nodes[selectedNodes[i]].isCluster === true) {\n            alert(this.options.locales[this.options.locale][\"deleteClusterError\"] || this.options.locales[\"en\"][\"deleteClusterError\"]);\n            return;\n          }\n        }\n        if (typeof this.options.deleteNode === \"function\") {\n          deleteFunction = this.options.deleteNode;\n        }\n      } else if (selectedEdges.length > 0) {\n        if (typeof this.options.deleteEdge === \"function\") {\n          deleteFunction = this.options.deleteEdge;\n        }\n      }\n      if (typeof deleteFunction === \"function\") {\n        var data = {\n          nodes: selectedNodes,\n          edges: selectedEdges\n        };\n        if (deleteFunction.length === 2) {\n          deleteFunction(data, function (finalizedData) {\n            if (finalizedData !== null && finalizedData !== undefined && _this3.inMode === \"delete\") {\n              // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {\n              _this3.body.data.edges.getDataSet().remove(finalizedData.edges);\n              _this3.body.data.nodes.getDataSet().remove(finalizedData.nodes);\n              _this3.body.emitter.emit(\"startSimulation\");\n              _this3.showManipulatorToolbar();\n            } else {\n              _this3.body.emitter.emit(\"startSimulation\");\n              _this3.showManipulatorToolbar();\n            }\n          });\n        } else {\n          throw new Error(\"The function for delete does not support two arguments (data, callback)\");\n        }\n      } else {\n        this.body.data.edges.getDataSet().remove(selectedEdges);\n        this.body.data.nodes.getDataSet().remove(selectedNodes);\n        this.body.emitter.emit(\"startSimulation\");\n        this.showManipulatorToolbar();\n      }\n    }\n\n    //********************************************** PRIVATE ***************************************//\n\n    /**\n     * draw or remove the DOM\n     *\n     * @private\n     */\n  }, {\n    key: \"_setup\",\n    value: function _setup() {\n      if (this.options.enabled === true) {\n        // Enable the GUI\n        this.guiEnabled = true;\n        this._createWrappers();\n        if (this.editMode === false) {\n          this._createEditButton();\n        } else {\n          this.showManipulatorToolbar();\n        }\n      } else {\n        this._removeManipulationDOM();\n\n        // disable the gui\n        this.guiEnabled = false;\n      }\n    }\n\n    /**\n     * create the div overlays that contain the DOM\n     *\n     * @private\n     */\n  }, {\n    key: \"_createWrappers\",\n    value: function _createWrappers() {\n      // load the manipulator HTML elements. All styling done in css.\n      if (this.manipulationDiv === undefined) {\n        this.manipulationDiv = document.createElement(\"div\");\n        this.manipulationDiv.className = \"vis-manipulation\";\n        if (this.editMode === true) {\n          this.manipulationDiv.style.display = \"block\";\n        } else {\n          this.manipulationDiv.style.display = \"none\";\n        }\n        this.canvas.frame.appendChild(this.manipulationDiv);\n      }\n\n      // container for the edit button.\n      if (this.editModeDiv === undefined) {\n        this.editModeDiv = document.createElement(\"div\");\n        this.editModeDiv.className = \"vis-edit-mode\";\n        if (this.editMode === true) {\n          this.editModeDiv.style.display = \"none\";\n        } else {\n          this.editModeDiv.style.display = \"block\";\n        }\n        this.canvas.frame.appendChild(this.editModeDiv);\n      }\n\n      // container for the close div button\n      if (this.closeDiv === undefined) {\n        var _this$options$locales, _this$options$locales2;\n        this.closeDiv = document.createElement(\"button\");\n        this.closeDiv.className = \"vis-close\";\n        this.closeDiv.setAttribute(\"aria-label\", (_this$options$locales = (_this$options$locales2 = this.options.locales[this.options.locale]) === null || _this$options$locales2 === void 0 ? void 0 : _this$options$locales2[\"close\"]) !== null && _this$options$locales !== void 0 ? _this$options$locales : this.options.locales[\"en\"][\"close\"]);\n        this.closeDiv.style.display = this.manipulationDiv.style.display;\n        this.canvas.frame.appendChild(this.closeDiv);\n      }\n    }\n\n    /**\n     * generate a new target node. Used for creating new edges and editing edges\n     *\n     * @param {number} x\n     * @param {number} y\n     * @returns {Node}\n     * @private\n     */\n  }, {\n    key: \"_getNewTargetNode\",\n    value: function _getNewTargetNode(x, y) {\n      var controlNodeStyle = deepExtend({}, this.options.controlNodeStyle);\n      controlNodeStyle.id = \"targetNode\" + v4();\n      controlNodeStyle.hidden = false;\n      controlNodeStyle.physics = false;\n      controlNodeStyle.x = x;\n      controlNodeStyle.y = y;\n\n      // we have to define the bounding box in order for the nodes to be drawn immediately\n      var node = this.body.functions.createNode(controlNodeStyle);\n      node.shape.boundingBox = {\n        left: x,\n        right: x,\n        top: y,\n        bottom: y\n      };\n      return node;\n    }\n\n    /**\n     * Create the edit button\n     */\n  }, {\n    key: \"_createEditButton\",\n    value: function _createEditButton() {\n      var _context18;\n      // restore everything to it's original state (if applicable)\n      this._clean();\n\n      // reset the manipulationDOM\n      this.manipulationDOM = {};\n\n      // empty the editModeDiv\n      recursiveDOMDelete(this.editModeDiv);\n\n      // create the contents for the editMode button\n      var locale = this.options.locales[this.options.locale];\n      var button = this._createButton(\"editMode\", \"vis-edit vis-edit-mode\", locale[\"edit\"] || this.options.locales[\"en\"][\"edit\"]);\n      this.editModeDiv.appendChild(button);\n\n      // bind a hammer listener to the button, calling the function toggleEditMode.\n      this._bindElementEvents(button, _bindInstanceProperty$1(_context18 = this.toggleEditMode).call(_context18, this));\n    }\n\n    /**\n     * this function cleans up after everything this module does. Temporary elements, functions and events are removed, physics restored, hammers removed.\n     *\n     * @private\n     */\n  }, {\n    key: \"_clean\",\n    value: function _clean() {\n      // not in mode\n      this.inMode = false;\n\n      // _clean the divs\n      if (this.guiEnabled === true) {\n        recursiveDOMDelete(this.editModeDiv);\n        recursiveDOMDelete(this.manipulationDiv);\n\n        // removes all the bindings and overloads\n        this._cleanupDOMEventListeners();\n      }\n\n      // remove temporary nodes and edges\n      this._cleanupTemporaryNodesAndEdges();\n\n      // restore overloaded UI functions\n      this._unbindTemporaryUIs();\n\n      // remove the temporaryEventFunctions\n      this._unbindTemporaryEvents();\n\n      // restore the physics if required\n      this.body.emitter.emit(\"restorePhysics\");\n    }\n\n    /**\n     * Each dom element has it's own hammer. They are stored in this.manipulationHammers. This cleans them up.\n     *\n     * @private\n     */\n  }, {\n    key: \"_cleanupDOMEventListeners\",\n    value: function _cleanupDOMEventListeners() {\n      var _context19;\n      // _clean DOM event listener bindings\n      var _iterator = _createForOfIteratorHelper(_spliceInstanceProperty(_context19 = this._domEventListenerCleanupQueue).call(_context19, 0)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var callback = _step.value;\n          callback();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    /**\n     * Remove all DOM elements created by this module.\n     *\n     * @private\n     */\n  }, {\n    key: \"_removeManipulationDOM\",\n    value: function _removeManipulationDOM() {\n      // removes all the bindings and overloads\n      this._clean();\n\n      // empty the manipulation divs\n      recursiveDOMDelete(this.manipulationDiv);\n      recursiveDOMDelete(this.editModeDiv);\n      recursiveDOMDelete(this.closeDiv);\n\n      // remove the manipulation divs\n      if (this.manipulationDiv) {\n        this.canvas.frame.removeChild(this.manipulationDiv);\n      }\n      if (this.editModeDiv) {\n        this.canvas.frame.removeChild(this.editModeDiv);\n      }\n      if (this.closeDiv) {\n        this.canvas.frame.removeChild(this.closeDiv);\n      }\n\n      // set the references to undefined\n      this.manipulationDiv = undefined;\n      this.editModeDiv = undefined;\n      this.closeDiv = undefined;\n    }\n\n    /**\n     * create a seperator line. the index is to differentiate in the manipulation dom\n     *\n     * @param {number} [index=1]\n     * @private\n     */\n  }, {\n    key: \"_createSeperator\",\n    value: function _createSeperator() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      this.manipulationDOM[\"seperatorLineDiv\" + index] = document.createElement(\"div\");\n      this.manipulationDOM[\"seperatorLineDiv\" + index].className = \"vis-separator-line\";\n      this.manipulationDiv.appendChild(this.manipulationDOM[\"seperatorLineDiv\" + index]);\n    }\n\n    // ----------------------    DOM functions for buttons    --------------------------//\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n  }, {\n    key: \"_createAddNodeButton\",\n    value: function _createAddNodeButton(locale) {\n      var _context20;\n      var button = this._createButton(\"addNode\", \"vis-add\", locale[\"addNode\"] || this.options.locales[\"en\"][\"addNode\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, _bindInstanceProperty$1(_context20 = this.addNodeMode).call(_context20, this));\n    }\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n  }, {\n    key: \"_createAddEdgeButton\",\n    value: function _createAddEdgeButton(locale) {\n      var _context21;\n      var button = this._createButton(\"addEdge\", \"vis-connect\", locale[\"addEdge\"] || this.options.locales[\"en\"][\"addEdge\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, _bindInstanceProperty$1(_context21 = this.addEdgeMode).call(_context21, this));\n    }\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n  }, {\n    key: \"_createEditNodeButton\",\n    value: function _createEditNodeButton(locale) {\n      var _context22;\n      var button = this._createButton(\"editNode\", \"vis-edit\", locale[\"editNode\"] || this.options.locales[\"en\"][\"editNode\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, _bindInstanceProperty$1(_context22 = this.editNode).call(_context22, this));\n    }\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n  }, {\n    key: \"_createEditEdgeButton\",\n    value: function _createEditEdgeButton(locale) {\n      var _context23;\n      var button = this._createButton(\"editEdge\", \"vis-edit\", locale[\"editEdge\"] || this.options.locales[\"en\"][\"editEdge\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, _bindInstanceProperty$1(_context23 = this.editEdgeMode).call(_context23, this));\n    }\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n  }, {\n    key: \"_createDeleteButton\",\n    value: function _createDeleteButton(locale) {\n      var _context24;\n      var deleteBtnClass;\n      if (this.options.rtl) {\n        deleteBtnClass = \"vis-delete-rtl\";\n      } else {\n        deleteBtnClass = \"vis-delete\";\n      }\n      var button = this._createButton(\"delete\", deleteBtnClass, locale[\"del\"] || this.options.locales[\"en\"][\"del\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, _bindInstanceProperty$1(_context24 = this.deleteSelected).call(_context24, this));\n    }\n\n    /**\n     *\n     * @param {Locale} locale\n     * @private\n     */\n  }, {\n    key: \"_createBackButton\",\n    value: function _createBackButton(locale) {\n      var _context25;\n      var button = this._createButton(\"back\", \"vis-back\", locale[\"back\"] || this.options.locales[\"en\"][\"back\"]);\n      this.manipulationDiv.appendChild(button);\n      this._bindElementEvents(button, _bindInstanceProperty$1(_context25 = this.showManipulatorToolbar).call(_context25, this));\n    }\n\n    /**\n     *\n     * @param {number|string} id\n     * @param {string} className\n     * @param {label} label\n     * @param {string} labelClassName\n     * @returns {HTMLElement}\n     * @private\n     */\n  }, {\n    key: \"_createButton\",\n    value: function _createButton(id, className, label) {\n      var labelClassName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"vis-label\";\n      this.manipulationDOM[id + \"Div\"] = document.createElement(\"button\");\n      this.manipulationDOM[id + \"Div\"].className = \"vis-button \" + className;\n      this.manipulationDOM[id + \"Label\"] = document.createElement(\"div\");\n      this.manipulationDOM[id + \"Label\"].className = labelClassName;\n      this.manipulationDOM[id + \"Label\"].innerText = label;\n      this.manipulationDOM[id + \"Div\"].appendChild(this.manipulationDOM[id + \"Label\"]);\n      return this.manipulationDOM[id + \"Div\"];\n    }\n\n    /**\n     *\n     * @param {Label} label\n     * @private\n     */\n  }, {\n    key: \"_createDescription\",\n    value: function _createDescription(label) {\n      this.manipulationDOM[\"descriptionLabel\"] = document.createElement(\"div\");\n      this.manipulationDOM[\"descriptionLabel\"].className = \"vis-none\";\n      this.manipulationDOM[\"descriptionLabel\"].innerText = label;\n      this.manipulationDiv.appendChild(this.manipulationDOM[\"descriptionLabel\"]);\n    }\n\n    // -------------------------- End of DOM functions for buttons ------------------------------//\n\n    /**\n     * this binds an event until cleanup by the clean functions.\n     *\n     * @param {Event}  event   The event\n     * @param {Function} newFunction\n     * @private\n     */\n  }, {\n    key: \"_temporaryBindEvent\",\n    value: function _temporaryBindEvent(event, newFunction) {\n      this.temporaryEventFunctions.push({\n        event: event,\n        boundFunction: newFunction\n      });\n      this.body.emitter.on(event, newFunction);\n    }\n\n    /**\n     * this overrides an UI function until cleanup by the clean function\n     *\n     * @param {string} UIfunctionName\n     * @param {Function} newFunction\n     * @private\n     */\n  }, {\n    key: \"_temporaryBindUI\",\n    value: function _temporaryBindUI(UIfunctionName, newFunction) {\n      if (this.body.eventListeners[UIfunctionName] !== undefined) {\n        this.temporaryUIFunctions[UIfunctionName] = this.body.eventListeners[UIfunctionName];\n        this.body.eventListeners[UIfunctionName] = newFunction;\n      } else {\n        throw new Error(\"This UI function does not exist. Typo? You tried: \" + UIfunctionName + \" possible are: \" + _JSON$stringify(_Object$keys(this.body.eventListeners)));\n      }\n    }\n\n    /**\n     * Restore the overridden UI functions to their original state.\n     *\n     * @private\n     */\n  }, {\n    key: \"_unbindTemporaryUIs\",\n    value: function _unbindTemporaryUIs() {\n      for (var functionName in this.temporaryUIFunctions) {\n        if (Object.prototype.hasOwnProperty.call(this.temporaryUIFunctions, functionName)) {\n          this.body.eventListeners[functionName] = this.temporaryUIFunctions[functionName];\n          delete this.temporaryUIFunctions[functionName];\n        }\n      }\n      this.temporaryUIFunctions = {};\n    }\n\n    /**\n     * Unbind the events created by _temporaryBindEvent\n     *\n     * @private\n     */\n  }, {\n    key: \"_unbindTemporaryEvents\",\n    value: function _unbindTemporaryEvents() {\n      for (var i = 0; i < this.temporaryEventFunctions.length; i++) {\n        var eventName = this.temporaryEventFunctions[i].event;\n        var boundFunction = this.temporaryEventFunctions[i].boundFunction;\n        this.body.emitter.off(eventName, boundFunction);\n      }\n      this.temporaryEventFunctions = [];\n    }\n\n    /**\n     * Bind an hammer instance to a DOM element.\n     *\n     * @param {Element} domElement\n     * @param {Function} boundFunction\n     */\n  }, {\n    key: \"_bindElementEvents\",\n    value: function _bindElementEvents(domElement, boundFunction) {\n      // Bind touch events.\n      var hammer = new Hammer(domElement, {});\n      onTouch(hammer, boundFunction);\n      this._domEventListenerCleanupQueue.push(function () {\n        hammer.destroy();\n      });\n\n      // Bind keyboard events.\n      var keyupListener = function keyupListener(_ref) {\n        var keyCode = _ref.keyCode,\n          key = _ref.key;\n        if (key === \"Enter\" || key === \" \" || keyCode === 13 || keyCode === 32) {\n          boundFunction();\n        }\n      };\n      domElement.addEventListener(\"keyup\", keyupListener, false);\n      this._domEventListenerCleanupQueue.push(function () {\n        domElement.removeEventListener(\"keyup\", keyupListener, false);\n      });\n    }\n\n    /**\n     * Neatly clean up temporary edges and nodes\n     *\n     * @private\n     */\n  }, {\n    key: \"_cleanupTemporaryNodesAndEdges\",\n    value: function _cleanupTemporaryNodesAndEdges() {\n      // _clean temporary edges\n      for (var i = 0; i < this.temporaryIds.edges.length; i++) {\n        var _context26;\n        this.body.edges[this.temporaryIds.edges[i]].disconnect();\n        delete this.body.edges[this.temporaryIds.edges[i]];\n        var indexTempEdge = _indexOfInstanceProperty(_context26 = this.body.edgeIndices).call(_context26, this.temporaryIds.edges[i]);\n        if (indexTempEdge !== -1) {\n          var _context27;\n          _spliceInstanceProperty(_context27 = this.body.edgeIndices).call(_context27, indexTempEdge, 1);\n        }\n      }\n\n      // _clean temporary nodes\n      for (var _i = 0; _i < this.temporaryIds.nodes.length; _i++) {\n        var _context28;\n        delete this.body.nodes[this.temporaryIds.nodes[_i]];\n        var indexTempNode = _indexOfInstanceProperty(_context28 = this.body.nodeIndices).call(_context28, this.temporaryIds.nodes[_i]);\n        if (indexTempNode !== -1) {\n          var _context29;\n          _spliceInstanceProperty(_context29 = this.body.nodeIndices).call(_context29, indexTempNode, 1);\n        }\n      }\n      this.temporaryIds = {\n        nodes: [],\n        edges: []\n      };\n    }\n\n    // ------------------------------------------ EDIT EDGE FUNCTIONS -----------------------------------------//\n\n    /**\n     * the touch is used to get the position of the initial click\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n  }, {\n    key: \"_controlNodeTouch\",\n    value: function _controlNodeTouch(event) {\n      this.selectionHandler.unselectAll();\n      this.lastTouch = this.body.functions.getPointer(event.center);\n      this.lastTouch.translation = _Object$assign({}, this.body.view.translation); // copy the object\n    }\n\n    /**\n     * the drag start is used to mark one of the control nodes as selected.\n     *\n     * @private\n     */\n  }, {\n    key: \"_controlNodeDragStart\",\n    value: function _controlNodeDragStart() {\n      var pointer = this.lastTouch;\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n      var from = this.body.nodes[this.temporaryIds.nodes[0]];\n      var to = this.body.nodes[this.temporaryIds.nodes[1]];\n      var edge = this.body.edges[this.edgeBeingEditedId];\n      this.selectedControlNode = undefined;\n      var fromSelect = from.isOverlappingWith(pointerObj);\n      var toSelect = to.isOverlappingWith(pointerObj);\n      if (fromSelect === true) {\n        this.selectedControlNode = from;\n        edge.edgeType.from = from;\n      } else if (toSelect === true) {\n        this.selectedControlNode = to;\n        edge.edgeType.to = to;\n      }\n\n      // we use the selection to find the node that is being dragged. We explicitly select it here.\n      if (this.selectedControlNode !== undefined) {\n        this.selectionHandler.selectObject(this.selectedControlNode);\n      }\n      this.body.emitter.emit(\"_redraw\");\n    }\n\n    /**\n     * dragging the control nodes or the canvas\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n  }, {\n    key: \"_controlNodeDrag\",\n    value: function _controlNodeDrag(event) {\n      this.body.emitter.emit(\"disablePhysics\");\n      var pointer = this.body.functions.getPointer(event.center);\n      var pos = this.canvas.DOMtoCanvas(pointer);\n      if (this.selectedControlNode !== undefined) {\n        this.selectedControlNode.x = pos.x;\n        this.selectedControlNode.y = pos.y;\n      } else {\n        this.interactionHandler.onDrag(event);\n      }\n      this.body.emitter.emit(\"_redraw\");\n    }\n\n    /**\n     * connecting or restoring the control nodes.\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n  }, {\n    key: \"_controlNodeDragEnd\",\n    value: function _controlNodeDragEnd(event) {\n      var pointer = this.body.functions.getPointer(event.center);\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n      var edge = this.body.edges[this.edgeBeingEditedId];\n      // if the node that was dragged is not a control node, return\n      if (this.selectedControlNode === undefined) {\n        return;\n      }\n\n      // we use the selection to find the node that is being dragged. We explicitly DEselect the control node here.\n      this.selectionHandler.unselectAll();\n      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);\n      var node = undefined;\n      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {\n        if (overlappingNodeIds[i] !== this.selectedControlNode.id) {\n          node = this.body.nodes[overlappingNodeIds[i]];\n          break;\n        }\n      }\n      // perform the connection\n      if (node !== undefined && this.selectedControlNode !== undefined) {\n        if (node.isCluster === true) {\n          alert(this.options.locales[this.options.locale][\"createEdgeError\"] || this.options.locales[\"en\"][\"createEdgeError\"]);\n        } else {\n          var from = this.body.nodes[this.temporaryIds.nodes[0]];\n          if (this.selectedControlNode.id === from.id) {\n            this._performEditEdge(node.id, edge.to.id);\n          } else {\n            this._performEditEdge(edge.from.id, node.id);\n          }\n        }\n      } else {\n        edge.updateEdgeType();\n        this.body.emitter.emit(\"restorePhysics\");\n      }\n      this.body.emitter.emit(\"_redraw\");\n    }\n\n    // ------------------------------------ END OF EDIT EDGE FUNCTIONS -----------------------------------------//\n\n    // ------------------------------------------- ADD EDGE FUNCTIONS -----------------------------------------//\n    /**\n     * the function bound to the selection event. It checks if you want to connect a cluster and changes the description\n     * to walk the user through the process.\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"_handleConnect\",\n    value: function _handleConnect(event) {\n      // check to avoid double fireing of this function.\n      if (new Date().valueOf() - this.touchTime > 100) {\n        this.lastTouch = this.body.functions.getPointer(event.center);\n        this.lastTouch.translation = _Object$assign({}, this.body.view.translation); // copy the object\n\n        this.interactionHandler.drag.pointer = this.lastTouch; // Drag pointer is not updated when adding edges\n        this.interactionHandler.drag.translation = this.lastTouch.translation;\n        var pointer = this.lastTouch;\n        var node = this.selectionHandler.getNodeAt(pointer);\n        if (node !== undefined) {\n          if (node.isCluster === true) {\n            alert(this.options.locales[this.options.locale][\"createEdgeError\"] || this.options.locales[\"en\"][\"createEdgeError\"]);\n          } else {\n            // create a node the temporary line can look at\n            var targetNode = this._getNewTargetNode(node.x, node.y);\n            this.body.nodes[targetNode.id] = targetNode;\n            this.body.nodeIndices.push(targetNode.id);\n\n            // create a temporary edge\n            var connectionEdge = this.body.functions.createEdge({\n              id: \"connectionEdge\" + v4(),\n              from: node.id,\n              to: targetNode.id,\n              physics: false,\n              smooth: {\n                enabled: true,\n                type: \"continuous\",\n                roundness: 0.5\n              }\n            });\n            this.body.edges[connectionEdge.id] = connectionEdge;\n            this.body.edgeIndices.push(connectionEdge.id);\n            this.temporaryIds.nodes.push(targetNode.id);\n            this.temporaryIds.edges.push(connectionEdge.id);\n          }\n        }\n        this.touchTime = new Date().valueOf();\n      }\n    }\n\n    /**\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"_dragControlNode\",\n    value: function _dragControlNode(event) {\n      var pointer = this.body.functions.getPointer(event.center);\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n      // remember the edge id\n      var connectFromId = undefined;\n      if (this.temporaryIds.edges[0] !== undefined) {\n        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;\n      }\n\n      // get the overlapping node but NOT the temporary node;\n      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);\n      var node = undefined;\n      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {\n        var _context30;\n        // if the node id is NOT a temporary node, accept the node.\n        if (_indexOfInstanceProperty(_context30 = this.temporaryIds.nodes).call(_context30, overlappingNodeIds[i]) === -1) {\n          node = this.body.nodes[overlappingNodeIds[i]];\n          break;\n        }\n      }\n      event.controlEdge = {\n        from: connectFromId,\n        to: node ? node.id : undefined\n      };\n      this.selectionHandler.generateClickEvent(\"controlNodeDragging\", event, pointer);\n      if (this.temporaryIds.nodes[0] !== undefined) {\n        var targetNode = this.body.nodes[this.temporaryIds.nodes[0]]; // there is only one temp node in the add edge mode.\n        targetNode.x = this.canvas._XconvertDOMtoCanvas(pointer.x);\n        targetNode.y = this.canvas._YconvertDOMtoCanvas(pointer.y);\n        this.body.emitter.emit(\"_redraw\");\n      } else {\n        this.interactionHandler.onDrag(event);\n      }\n    }\n\n    /**\n     * Connect the new edge to the target if one exists, otherwise remove temp line\n     *\n     * @param {Event}  event   The event\n     * @private\n     */\n  }, {\n    key: \"_finishConnect\",\n    value: function _finishConnect(event) {\n      var pointer = this.body.functions.getPointer(event.center);\n      var pointerObj = this.selectionHandler._pointerToPositionObject(pointer);\n\n      // remember the edge id\n      var connectFromId = undefined;\n      if (this.temporaryIds.edges[0] !== undefined) {\n        connectFromId = this.body.edges[this.temporaryIds.edges[0]].fromId;\n      }\n\n      // get the overlapping node but NOT the temporary node;\n      var overlappingNodeIds = this.selectionHandler._getAllNodesOverlappingWith(pointerObj);\n      var node = undefined;\n      for (var i = overlappingNodeIds.length - 1; i >= 0; i--) {\n        var _context31;\n        // if the node id is NOT a temporary node, accept the node.\n        if (_indexOfInstanceProperty(_context31 = this.temporaryIds.nodes).call(_context31, overlappingNodeIds[i]) === -1) {\n          node = this.body.nodes[overlappingNodeIds[i]];\n          break;\n        }\n      }\n\n      // clean temporary nodes and edges.\n      this._cleanupTemporaryNodesAndEdges();\n\n      // perform the connection\n      if (node !== undefined) {\n        if (node.isCluster === true) {\n          alert(this.options.locales[this.options.locale][\"createEdgeError\"] || this.options.locales[\"en\"][\"createEdgeError\"]);\n        } else {\n          if (this.body.nodes[connectFromId] !== undefined && this.body.nodes[node.id] !== undefined) {\n            this._performAddEdge(connectFromId, node.id);\n          }\n        }\n      }\n      event.controlEdge = {\n        from: connectFromId,\n        to: node ? node.id : undefined\n      };\n      this.selectionHandler.generateClickEvent(\"controlNodeDragEnd\", event, pointer);\n\n      // No need to do _generateclickevent('dragEnd') here, the regular dragEnd event fires.\n      this.body.emitter.emit(\"_redraw\");\n    }\n\n    /**\n     *\n     * @param {Event} event\n     * @private\n     */\n  }, {\n    key: \"_dragStartEdge\",\n    value: function _dragStartEdge(event) {\n      var pointer = this.lastTouch;\n      this.selectionHandler.generateClickEvent(\"dragStart\", event, pointer, undefined, true);\n    }\n\n    // --------------------------------------- END OF ADD EDGE FUNCTIONS -------------------------------------//\n\n    // ------------------------------ Performing all the actual data manipulation ------------------------//\n\n    /**\n     * Adds a node on the specified location\n     *\n     * @param {object} clickData\n     * @private\n     */\n  }, {\n    key: \"_performAddNode\",\n    value: function _performAddNode(clickData) {\n      var _this4 = this;\n      var defaultData = {\n        id: v4(),\n        x: clickData.pointer.canvas.x,\n        y: clickData.pointer.canvas.y,\n        label: \"new\"\n      };\n      if (typeof this.options.addNode === \"function\") {\n        if (this.options.addNode.length === 2) {\n          this.options.addNode(defaultData, function (finalizedData) {\n            if (finalizedData !== null && finalizedData !== undefined && _this4.inMode === \"addNode\") {\n              // if for whatever reason the mode has changes (due to dataset change) disregard the callback\n              _this4.body.data.nodes.getDataSet().add(finalizedData);\n            }\n            _this4.showManipulatorToolbar();\n          });\n        } else {\n          this.showManipulatorToolbar();\n          throw new Error(\"The function for add does not support two arguments (data,callback)\");\n        }\n      } else {\n        this.body.data.nodes.getDataSet().add(defaultData);\n        this.showManipulatorToolbar();\n      }\n    }\n\n    /**\n     * connect two nodes with a new edge.\n     *\n     * @param {Node.id} sourceNodeId\n     * @param {Node.id} targetNodeId\n     * @private\n     */\n  }, {\n    key: \"_performAddEdge\",\n    value: function _performAddEdge(sourceNodeId, targetNodeId) {\n      var _this5 = this;\n      var defaultData = {\n        from: sourceNodeId,\n        to: targetNodeId\n      };\n      if (typeof this.options.addEdge === \"function\") {\n        if (this.options.addEdge.length === 2) {\n          this.options.addEdge(defaultData, function (finalizedData) {\n            if (finalizedData !== null && finalizedData !== undefined && _this5.inMode === \"addEdge\") {\n              // if for whatever reason the mode has changes (due to dataset change) disregard the callback\n              _this5.body.data.edges.getDataSet().add(finalizedData);\n              _this5.selectionHandler.unselectAll();\n              _this5.showManipulatorToolbar();\n            }\n          });\n        } else {\n          throw new Error(\"The function for connect does not support two arguments (data,callback)\");\n        }\n      } else {\n        this.body.data.edges.getDataSet().add(defaultData);\n        this.selectionHandler.unselectAll();\n        this.showManipulatorToolbar();\n      }\n    }\n\n    /**\n     * connect two nodes with a new edge.\n     *\n     * @param {Node.id} sourceNodeId\n     * @param {Node.id} targetNodeId\n     * @private\n     */\n  }, {\n    key: \"_performEditEdge\",\n    value: function _performEditEdge(sourceNodeId, targetNodeId) {\n      var _this6 = this;\n      var defaultData = {\n        id: this.edgeBeingEditedId,\n        from: sourceNodeId,\n        to: targetNodeId,\n        label: this.body.data.edges.get(this.edgeBeingEditedId).label\n      };\n      var eeFunct = this.options.editEdge;\n      if (_typeof(eeFunct) === \"object\") {\n        eeFunct = eeFunct.editWithoutDrag;\n      }\n      if (typeof eeFunct === \"function\") {\n        if (eeFunct.length === 2) {\n          eeFunct(defaultData, function (finalizedData) {\n            if (finalizedData === null || finalizedData === undefined || _this6.inMode !== \"editEdge\") {\n              // if for whatever reason the mode has changes (due to dataset change) disregard the callback) {\n              _this6.body.edges[defaultData.id].updateEdgeType();\n              _this6.body.emitter.emit(\"_redraw\");\n              _this6.showManipulatorToolbar();\n            } else {\n              _this6.body.data.edges.getDataSet().update(finalizedData);\n              _this6.selectionHandler.unselectAll();\n              _this6.showManipulatorToolbar();\n            }\n          });\n        } else {\n          throw new Error(\"The function for edit does not support two arguments (data, callback)\");\n        }\n      } else {\n        this.body.data.edges.getDataSet().update(defaultData);\n        this.selectionHandler.unselectAll();\n        this.showManipulatorToolbar();\n      }\n    }\n  }]);\n  return ManipulationSystem;\n}();\n\n/**\r\n * This object contains all possible options. It will check if the types are correct, if required if the option is one\r\n * of the allowed values.\r\n *\r\n * __any__ means that the name of the property does not matter.\r\n * __type__ is a required field for all objects and contains the allowed types of all objects\r\n */\nvar string = \"string\";\nvar bool = \"boolean\";\nvar number = \"number\";\nvar array = \"array\";\nvar object = \"object\"; // should only be in a __type__ property\nvar dom = \"dom\";\nvar any = \"any\";\n// List of endpoints\nvar endPoints = [\"arrow\", \"bar\", \"box\", \"circle\", \"crow\", \"curve\", \"diamond\", \"image\", \"inv_curve\", \"inv_triangle\", \"triangle\", \"vee\"];\n/* eslint-disable @typescript-eslint/naming-convention -- The __*__ format is used to prevent collisions with actual option names. */\nvar nodeOptions = {\n  borderWidth: {\n    number: number\n  },\n  borderWidthSelected: {\n    number: number,\n    undefined: \"undefined\"\n  },\n  brokenImage: {\n    string: string,\n    undefined: \"undefined\"\n  },\n  chosen: {\n    label: {\n      boolean: bool,\n      function: \"function\"\n    },\n    node: {\n      boolean: bool,\n      function: \"function\"\n    },\n    __type__: {\n      object: object,\n      boolean: bool\n    }\n  },\n  color: {\n    border: {\n      string: string\n    },\n    background: {\n      string: string\n    },\n    highlight: {\n      border: {\n        string: string\n      },\n      background: {\n        string: string\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    hover: {\n      border: {\n        string: string\n      },\n      background: {\n        string: string\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    __type__: {\n      object: object,\n      string: string\n    }\n  },\n  opacity: {\n    number: number,\n    undefined: \"undefined\"\n  },\n  fixed: {\n    x: {\n      boolean: bool\n    },\n    y: {\n      boolean: bool\n    },\n    __type__: {\n      object: object,\n      boolean: bool\n    }\n  },\n  font: {\n    align: {\n      string: string\n    },\n    color: {\n      string: string\n    },\n    size: {\n      number: number\n    },\n    face: {\n      string: string\n    },\n    background: {\n      string: string\n    },\n    strokeWidth: {\n      number: number\n    },\n    strokeColor: {\n      string: string\n    },\n    vadjust: {\n      number: number\n    },\n    multi: {\n      boolean: bool,\n      string: string\n    },\n    bold: {\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      face: {\n        string: string\n      },\n      mod: {\n        string: string\n      },\n      vadjust: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    boldital: {\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      face: {\n        string: string\n      },\n      mod: {\n        string: string\n      },\n      vadjust: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    ital: {\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      face: {\n        string: string\n      },\n      mod: {\n        string: string\n      },\n      vadjust: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    mono: {\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      face: {\n        string: string\n      },\n      mod: {\n        string: string\n      },\n      vadjust: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    __type__: {\n      object: object,\n      string: string\n    }\n  },\n  group: {\n    string: string,\n    number: number,\n    undefined: \"undefined\"\n  },\n  heightConstraint: {\n    minimum: {\n      number: number\n    },\n    valign: {\n      string: string\n    },\n    __type__: {\n      object: object,\n      boolean: bool,\n      number: number\n    }\n  },\n  hidden: {\n    boolean: bool\n  },\n  icon: {\n    face: {\n      string: string\n    },\n    code: {\n      string: string\n    },\n    size: {\n      number: number\n    },\n    color: {\n      string: string\n    },\n    weight: {\n      string: string,\n      number: number\n    },\n    __type__: {\n      object: object\n    }\n  },\n  id: {\n    string: string,\n    number: number\n  },\n  image: {\n    selected: {\n      string: string,\n      undefined: \"undefined\"\n    },\n    unselected: {\n      string: string,\n      undefined: \"undefined\"\n    },\n    __type__: {\n      object: object,\n      string: string\n    }\n  },\n  imagePadding: {\n    top: {\n      number: number\n    },\n    right: {\n      number: number\n    },\n    bottom: {\n      number: number\n    },\n    left: {\n      number: number\n    },\n    __type__: {\n      object: object,\n      number: number\n    }\n  },\n  label: {\n    string: string,\n    undefined: \"undefined\"\n  },\n  labelHighlightBold: {\n    boolean: bool\n  },\n  level: {\n    number: number,\n    undefined: \"undefined\"\n  },\n  margin: {\n    top: {\n      number: number\n    },\n    right: {\n      number: number\n    },\n    bottom: {\n      number: number\n    },\n    left: {\n      number: number\n    },\n    __type__: {\n      object: object,\n      number: number\n    }\n  },\n  mass: {\n    number: number\n  },\n  physics: {\n    boolean: bool\n  },\n  scaling: {\n    min: {\n      number: number\n    },\n    max: {\n      number: number\n    },\n    label: {\n      enabled: {\n        boolean: bool\n      },\n      min: {\n        number: number\n      },\n      max: {\n        number: number\n      },\n      maxVisible: {\n        number: number\n      },\n      drawThreshold: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    customScalingFunction: {\n      function: \"function\"\n    },\n    __type__: {\n      object: object\n    }\n  },\n  shadow: {\n    enabled: {\n      boolean: bool\n    },\n    color: {\n      string: string\n    },\n    size: {\n      number: number\n    },\n    x: {\n      number: number\n    },\n    y: {\n      number: number\n    },\n    __type__: {\n      object: object,\n      boolean: bool\n    }\n  },\n  shape: {\n    string: [\"custom\", \"ellipse\", \"circle\", \"database\", \"box\", \"text\", \"image\", \"circularImage\", \"diamond\", \"dot\", \"star\", \"triangle\", \"triangleDown\", \"square\", \"icon\", \"hexagon\"]\n  },\n  ctxRenderer: {\n    function: \"function\"\n  },\n  shapeProperties: {\n    borderDashes: {\n      boolean: bool,\n      array: array\n    },\n    borderRadius: {\n      number: number\n    },\n    interpolation: {\n      boolean: bool\n    },\n    useImageSize: {\n      boolean: bool\n    },\n    useBorderWithImage: {\n      boolean: bool\n    },\n    coordinateOrigin: {\n      string: [\"center\", \"top-left\"]\n    },\n    __type__: {\n      object: object\n    }\n  },\n  size: {\n    number: number\n  },\n  title: {\n    string: string,\n    dom: dom,\n    undefined: \"undefined\"\n  },\n  value: {\n    number: number,\n    undefined: \"undefined\"\n  },\n  widthConstraint: {\n    minimum: {\n      number: number\n    },\n    maximum: {\n      number: number\n    },\n    __type__: {\n      object: object,\n      boolean: bool,\n      number: number\n    }\n  },\n  x: {\n    number: number\n  },\n  y: {\n    number: number\n  },\n  __type__: {\n    object: object\n  }\n};\nvar allOptions = {\n  configure: {\n    enabled: {\n      boolean: bool\n    },\n    filter: {\n      boolean: bool,\n      string: string,\n      array: array,\n      function: \"function\"\n    },\n    container: {\n      dom: dom\n    },\n    showButton: {\n      boolean: bool\n    },\n    __type__: {\n      object: object,\n      boolean: bool,\n      string: string,\n      array: array,\n      function: \"function\"\n    }\n  },\n  edges: {\n    arrows: {\n      to: {\n        enabled: {\n          boolean: bool\n        },\n        scaleFactor: {\n          number: number\n        },\n        type: {\n          string: endPoints\n        },\n        imageHeight: {\n          number: number\n        },\n        imageWidth: {\n          number: number\n        },\n        src: {\n          string: string\n        },\n        __type__: {\n          object: object,\n          boolean: bool\n        }\n      },\n      middle: {\n        enabled: {\n          boolean: bool\n        },\n        scaleFactor: {\n          number: number\n        },\n        type: {\n          string: endPoints\n        },\n        imageWidth: {\n          number: number\n        },\n        imageHeight: {\n          number: number\n        },\n        src: {\n          string: string\n        },\n        __type__: {\n          object: object,\n          boolean: bool\n        }\n      },\n      from: {\n        enabled: {\n          boolean: bool\n        },\n        scaleFactor: {\n          number: number\n        },\n        type: {\n          string: endPoints\n        },\n        imageWidth: {\n          number: number\n        },\n        imageHeight: {\n          number: number\n        },\n        src: {\n          string: string\n        },\n        __type__: {\n          object: object,\n          boolean: bool\n        }\n      },\n      __type__: {\n        string: [\"from\", \"to\", \"middle\"],\n        object: object\n      }\n    },\n    endPointOffset: {\n      from: {\n        number: number\n      },\n      to: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        number: number\n      }\n    },\n    arrowStrikethrough: {\n      boolean: bool\n    },\n    background: {\n      enabled: {\n        boolean: bool\n      },\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      dashes: {\n        boolean: bool,\n        array: array\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    chosen: {\n      label: {\n        boolean: bool,\n        function: \"function\"\n      },\n      edge: {\n        boolean: bool,\n        function: \"function\"\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    color: {\n      color: {\n        string: string\n      },\n      highlight: {\n        string: string\n      },\n      hover: {\n        string: string\n      },\n      inherit: {\n        string: [\"from\", \"to\", \"both\"],\n        boolean: bool\n      },\n      opacity: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    dashes: {\n      boolean: bool,\n      array: array\n    },\n    font: {\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      face: {\n        string: string\n      },\n      background: {\n        string: string\n      },\n      strokeWidth: {\n        number: number\n      },\n      strokeColor: {\n        string: string\n      },\n      align: {\n        string: [\"horizontal\", \"top\", \"middle\", \"bottom\"]\n      },\n      vadjust: {\n        number: number\n      },\n      multi: {\n        boolean: bool,\n        string: string\n      },\n      bold: {\n        color: {\n          string: string\n        },\n        size: {\n          number: number\n        },\n        face: {\n          string: string\n        },\n        mod: {\n          string: string\n        },\n        vadjust: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      boldital: {\n        color: {\n          string: string\n        },\n        size: {\n          number: number\n        },\n        face: {\n          string: string\n        },\n        mod: {\n          string: string\n        },\n        vadjust: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      ital: {\n        color: {\n          string: string\n        },\n        size: {\n          number: number\n        },\n        face: {\n          string: string\n        },\n        mod: {\n          string: string\n        },\n        vadjust: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      mono: {\n        color: {\n          string: string\n        },\n        size: {\n          number: number\n        },\n        face: {\n          string: string\n        },\n        mod: {\n          string: string\n        },\n        vadjust: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          string: string\n        }\n      },\n      __type__: {\n        object: object,\n        string: string\n      }\n    },\n    hidden: {\n      boolean: bool\n    },\n    hoverWidth: {\n      function: \"function\",\n      number: number\n    },\n    label: {\n      string: string,\n      undefined: \"undefined\"\n    },\n    labelHighlightBold: {\n      boolean: bool\n    },\n    length: {\n      number: number,\n      undefined: \"undefined\"\n    },\n    physics: {\n      boolean: bool\n    },\n    scaling: {\n      min: {\n        number: number\n      },\n      max: {\n        number: number\n      },\n      label: {\n        enabled: {\n          boolean: bool\n        },\n        min: {\n          number: number\n        },\n        max: {\n          number: number\n        },\n        maxVisible: {\n          number: number\n        },\n        drawThreshold: {\n          number: number\n        },\n        __type__: {\n          object: object,\n          boolean: bool\n        }\n      },\n      customScalingFunction: {\n        function: \"function\"\n      },\n      __type__: {\n        object: object\n      }\n    },\n    selectionWidth: {\n      function: \"function\",\n      number: number\n    },\n    selfReferenceSize: {\n      number: number\n    },\n    selfReference: {\n      size: {\n        number: number\n      },\n      angle: {\n        number: number\n      },\n      renderBehindTheNode: {\n        boolean: bool\n      },\n      __type__: {\n        object: object\n      }\n    },\n    shadow: {\n      enabled: {\n        boolean: bool\n      },\n      color: {\n        string: string\n      },\n      size: {\n        number: number\n      },\n      x: {\n        number: number\n      },\n      y: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    smooth: {\n      enabled: {\n        boolean: bool\n      },\n      type: {\n        string: [\"dynamic\", \"continuous\", \"discrete\", \"diagonalCross\", \"straightCross\", \"horizontal\", \"vertical\", \"curvedCW\", \"curvedCCW\", \"cubicBezier\"]\n      },\n      roundness: {\n        number: number\n      },\n      forceDirection: {\n        string: [\"horizontal\", \"vertical\", \"none\"],\n        boolean: bool\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    title: {\n      string: string,\n      undefined: \"undefined\"\n    },\n    width: {\n      number: number\n    },\n    widthConstraint: {\n      maximum: {\n        number: number\n      },\n      __type__: {\n        object: object,\n        boolean: bool,\n        number: number\n      }\n    },\n    value: {\n      number: number,\n      undefined: \"undefined\"\n    },\n    __type__: {\n      object: object\n    }\n  },\n  groups: {\n    useDefaultGroups: {\n      boolean: bool\n    },\n    __any__: nodeOptions,\n    __type__: {\n      object: object\n    }\n  },\n  interaction: {\n    dragNodes: {\n      boolean: bool\n    },\n    dragView: {\n      boolean: bool\n    },\n    hideEdgesOnDrag: {\n      boolean: bool\n    },\n    hideEdgesOnZoom: {\n      boolean: bool\n    },\n    hideNodesOnDrag: {\n      boolean: bool\n    },\n    hover: {\n      boolean: bool\n    },\n    keyboard: {\n      enabled: {\n        boolean: bool\n      },\n      speed: {\n        x: {\n          number: number\n        },\n        y: {\n          number: number\n        },\n        zoom: {\n          number: number\n        },\n        __type__: {\n          object: object\n        }\n      },\n      bindToWindow: {\n        boolean: bool\n      },\n      autoFocus: {\n        boolean: bool\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    multiselect: {\n      boolean: bool\n    },\n    navigationButtons: {\n      boolean: bool\n    },\n    selectable: {\n      boolean: bool\n    },\n    selectConnectedEdges: {\n      boolean: bool\n    },\n    hoverConnectedEdges: {\n      boolean: bool\n    },\n    tooltipDelay: {\n      number: number\n    },\n    zoomView: {\n      boolean: bool\n    },\n    zoomSpeed: {\n      number: number\n    },\n    __type__: {\n      object: object\n    }\n  },\n  layout: {\n    randomSeed: {\n      undefined: \"undefined\",\n      number: number,\n      string: string\n    },\n    improvedLayout: {\n      boolean: bool\n    },\n    clusterThreshold: {\n      number: number\n    },\n    hierarchical: {\n      enabled: {\n        boolean: bool\n      },\n      levelSeparation: {\n        number: number\n      },\n      nodeSpacing: {\n        number: number\n      },\n      treeSpacing: {\n        number: number\n      },\n      blockShifting: {\n        boolean: bool\n      },\n      edgeMinimization: {\n        boolean: bool\n      },\n      parentCentralization: {\n        boolean: bool\n      },\n      direction: {\n        string: [\"UD\", \"DU\", \"LR\", \"RL\"]\n      },\n      sortMethod: {\n        string: [\"hubsize\", \"directed\"]\n      },\n      shakeTowards: {\n        string: [\"leaves\", \"roots\"]\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    __type__: {\n      object: object\n    }\n  },\n  manipulation: {\n    enabled: {\n      boolean: bool\n    },\n    initiallyActive: {\n      boolean: bool\n    },\n    addNode: {\n      boolean: bool,\n      function: \"function\"\n    },\n    addEdge: {\n      boolean: bool,\n      function: \"function\"\n    },\n    editNode: {\n      function: \"function\"\n    },\n    editEdge: {\n      editWithoutDrag: {\n        function: \"function\"\n      },\n      __type__: {\n        object: object,\n        boolean: bool,\n        function: \"function\"\n      }\n    },\n    deleteNode: {\n      boolean: bool,\n      function: \"function\"\n    },\n    deleteEdge: {\n      boolean: bool,\n      function: \"function\"\n    },\n    controlNodeStyle: nodeOptions,\n    __type__: {\n      object: object,\n      boolean: bool\n    }\n  },\n  nodes: nodeOptions,\n  physics: {\n    enabled: {\n      boolean: bool\n    },\n    barnesHut: {\n      theta: {\n        number: number\n      },\n      gravitationalConstant: {\n        number: number\n      },\n      centralGravity: {\n        number: number\n      },\n      springLength: {\n        number: number\n      },\n      springConstant: {\n        number: number\n      },\n      damping: {\n        number: number\n      },\n      avoidOverlap: {\n        number: number\n      },\n      __type__: {\n        object: object\n      }\n    },\n    forceAtlas2Based: {\n      theta: {\n        number: number\n      },\n      gravitationalConstant: {\n        number: number\n      },\n      centralGravity: {\n        number: number\n      },\n      springLength: {\n        number: number\n      },\n      springConstant: {\n        number: number\n      },\n      damping: {\n        number: number\n      },\n      avoidOverlap: {\n        number: number\n      },\n      __type__: {\n        object: object\n      }\n    },\n    repulsion: {\n      centralGravity: {\n        number: number\n      },\n      springLength: {\n        number: number\n      },\n      springConstant: {\n        number: number\n      },\n      nodeDistance: {\n        number: number\n      },\n      damping: {\n        number: number\n      },\n      __type__: {\n        object: object\n      }\n    },\n    hierarchicalRepulsion: {\n      centralGravity: {\n        number: number\n      },\n      springLength: {\n        number: number\n      },\n      springConstant: {\n        number: number\n      },\n      nodeDistance: {\n        number: number\n      },\n      damping: {\n        number: number\n      },\n      avoidOverlap: {\n        number: number\n      },\n      __type__: {\n        object: object\n      }\n    },\n    maxVelocity: {\n      number: number\n    },\n    minVelocity: {\n      number: number\n    },\n    solver: {\n      string: [\"barnesHut\", \"repulsion\", \"hierarchicalRepulsion\", \"forceAtlas2Based\"]\n    },\n    stabilization: {\n      enabled: {\n        boolean: bool\n      },\n      iterations: {\n        number: number\n      },\n      updateInterval: {\n        number: number\n      },\n      onlyDynamicEdges: {\n        boolean: bool\n      },\n      fit: {\n        boolean: bool\n      },\n      __type__: {\n        object: object,\n        boolean: bool\n      }\n    },\n    timestep: {\n      number: number\n    },\n    adaptiveTimestep: {\n      boolean: bool\n    },\n    wind: {\n      x: {\n        number: number\n      },\n      y: {\n        number: number\n      },\n      __type__: {\n        object: object\n      }\n    },\n    __type__: {\n      object: object,\n      boolean: bool\n    }\n  },\n  //globals :\n  autoResize: {\n    boolean: bool\n  },\n  clickToUse: {\n    boolean: bool\n  },\n  locale: {\n    string: string\n  },\n  locales: {\n    __any__: {\n      any: any\n    },\n    __type__: {\n      object: object\n    }\n  },\n  height: {\n    string: string\n  },\n  width: {\n    string: string\n  },\n  __type__: {\n    object: object\n  }\n};\n/* eslint-enable @typescript-eslint/naming-convention */\n/**\r\n * This provides ranges, initial values, steps and dropdown menu choices for the\r\n * configuration.\r\n *\r\n * @remarks\r\n * Checkbox: `boolean`\r\n *   The value supllied will be used as the initial value.\r\n *\r\n * Text field: `string`\r\n *   The passed text will be used as the initial value. Any text will be\r\n *   accepted afterwards.\r\n *\r\n * Number range: `[number, number, number, number]`\r\n *   The meanings are `[initial value, min, max, step]`.\r\n *\r\n * Dropdown: `[Exclude<string, \"color\">, ...(string | number | boolean)[]]`\r\n *   Translations for people with poor understanding of TypeScript: the first\r\n *   value always has to be a string but never `\"color\"`, the rest can be any\r\n *   combination of strings, numbers and booleans.\r\n *\r\n * Color picker: `[\"color\", string]`\r\n *   The first value says this will be a color picker not a dropdown menu. The\r\n *   next value is the initial color.\r\n */\nvar configureOptions = {\n  nodes: {\n    borderWidth: [1, 0, 10, 1],\n    borderWidthSelected: [2, 0, 10, 1],\n    color: {\n      border: [\"color\", \"#2B7CE9\"],\n      background: [\"color\", \"#97C2FC\"],\n      highlight: {\n        border: [\"color\", \"#2B7CE9\"],\n        background: [\"color\", \"#D2E5FF\"]\n      },\n      hover: {\n        border: [\"color\", \"#2B7CE9\"],\n        background: [\"color\", \"#D2E5FF\"]\n      }\n    },\n    opacity: [0, 0, 1, 0.1],\n    fixed: {\n      x: false,\n      y: false\n    },\n    font: {\n      color: [\"color\", \"#343434\"],\n      size: [14, 0, 100, 1],\n      face: [\"arial\", \"verdana\", \"tahoma\"],\n      background: [\"color\", \"none\"],\n      strokeWidth: [0, 0, 50, 1],\n      strokeColor: [\"color\", \"#ffffff\"]\n    },\n    //group: 'string',\n    hidden: false,\n    labelHighlightBold: true,\n    //icon: {\n    //  face: 'string',  //'FontAwesome',\n    //  code: 'string',  //'\\uf007',\n    //  size: [50, 0, 200, 1],  //50,\n    //  color: ['color','#2B7CE9']   //'#aa00ff'\n    //},\n    //image: 'string', // --> URL\n    physics: true,\n    scaling: {\n      min: [10, 0, 200, 1],\n      max: [30, 0, 200, 1],\n      label: {\n        enabled: false,\n        min: [14, 0, 200, 1],\n        max: [30, 0, 200, 1],\n        maxVisible: [30, 0, 200, 1],\n        drawThreshold: [5, 0, 20, 1]\n      }\n    },\n    shadow: {\n      enabled: false,\n      color: \"rgba(0,0,0,0.5)\",\n      size: [10, 0, 20, 1],\n      x: [5, -30, 30, 1],\n      y: [5, -30, 30, 1]\n    },\n    shape: [\"ellipse\", \"box\", \"circle\", \"database\", \"diamond\", \"dot\", \"square\", \"star\", \"text\", \"triangle\", \"triangleDown\", \"hexagon\"],\n    shapeProperties: {\n      borderDashes: false,\n      borderRadius: [6, 0, 20, 1],\n      interpolation: true,\n      useImageSize: false\n    },\n    size: [25, 0, 200, 1]\n  },\n  edges: {\n    arrows: {\n      to: {\n        enabled: false,\n        scaleFactor: [1, 0, 3, 0.05],\n        type: \"arrow\"\n      },\n      middle: {\n        enabled: false,\n        scaleFactor: [1, 0, 3, 0.05],\n        type: \"arrow\"\n      },\n      from: {\n        enabled: false,\n        scaleFactor: [1, 0, 3, 0.05],\n        type: \"arrow\"\n      }\n    },\n    endPointOffset: {\n      from: [0, -10, 10, 1],\n      to: [0, -10, 10, 1]\n    },\n    arrowStrikethrough: true,\n    color: {\n      color: [\"color\", \"#848484\"],\n      highlight: [\"color\", \"#848484\"],\n      hover: [\"color\", \"#848484\"],\n      inherit: [\"from\", \"to\", \"both\", true, false],\n      opacity: [1, 0, 1, 0.05]\n    },\n    dashes: false,\n    font: {\n      color: [\"color\", \"#343434\"],\n      size: [14, 0, 100, 1],\n      face: [\"arial\", \"verdana\", \"tahoma\"],\n      background: [\"color\", \"none\"],\n      strokeWidth: [2, 0, 50, 1],\n      strokeColor: [\"color\", \"#ffffff\"],\n      align: [\"horizontal\", \"top\", \"middle\", \"bottom\"]\n    },\n    hidden: false,\n    hoverWidth: [1.5, 0, 5, 0.1],\n    labelHighlightBold: true,\n    physics: true,\n    scaling: {\n      min: [1, 0, 100, 1],\n      max: [15, 0, 100, 1],\n      label: {\n        enabled: true,\n        min: [14, 0, 200, 1],\n        max: [30, 0, 200, 1],\n        maxVisible: [30, 0, 200, 1],\n        drawThreshold: [5, 0, 20, 1]\n      }\n    },\n    selectionWidth: [1.5, 0, 5, 0.1],\n    selfReferenceSize: [20, 0, 200, 1],\n    selfReference: {\n      size: [20, 0, 200, 1],\n      angle: [Math.PI / 2, -6 * Math.PI, 6 * Math.PI, Math.PI / 8],\n      renderBehindTheNode: true\n    },\n    shadow: {\n      enabled: false,\n      color: \"rgba(0,0,0,0.5)\",\n      size: [10, 0, 20, 1],\n      x: [5, -30, 30, 1],\n      y: [5, -30, 30, 1]\n    },\n    smooth: {\n      enabled: true,\n      type: [\"dynamic\", \"continuous\", \"discrete\", \"diagonalCross\", \"straightCross\", \"horizontal\", \"vertical\", \"curvedCW\", \"curvedCCW\", \"cubicBezier\"],\n      forceDirection: [\"horizontal\", \"vertical\", \"none\"],\n      roundness: [0.5, 0, 1, 0.05]\n    },\n    width: [1, 0, 30, 1]\n  },\n  layout: {\n    //randomSeed: [0, 0, 500, 1],\n    //improvedLayout: true,\n    hierarchical: {\n      enabled: false,\n      levelSeparation: [150, 20, 500, 5],\n      nodeSpacing: [100, 20, 500, 5],\n      treeSpacing: [200, 20, 500, 5],\n      blockShifting: true,\n      edgeMinimization: true,\n      parentCentralization: true,\n      direction: [\"UD\", \"DU\", \"LR\", \"RL\"],\n      sortMethod: [\"hubsize\", \"directed\"],\n      shakeTowards: [\"leaves\", \"roots\"] // leaves, roots\n    }\n  },\n\n  interaction: {\n    dragNodes: true,\n    dragView: true,\n    hideEdgesOnDrag: false,\n    hideEdgesOnZoom: false,\n    hideNodesOnDrag: false,\n    hover: false,\n    keyboard: {\n      enabled: false,\n      speed: {\n        x: [10, 0, 40, 1],\n        y: [10, 0, 40, 1],\n        zoom: [0.02, 0, 0.1, 0.005]\n      },\n      bindToWindow: true,\n      autoFocus: true\n    },\n    multiselect: false,\n    navigationButtons: false,\n    selectable: true,\n    selectConnectedEdges: true,\n    hoverConnectedEdges: true,\n    tooltipDelay: [300, 0, 1000, 25],\n    zoomView: true,\n    zoomSpeed: [1, 0.1, 2, 0.1]\n  },\n  manipulation: {\n    enabled: false,\n    initiallyActive: false\n  },\n  physics: {\n    enabled: true,\n    barnesHut: {\n      theta: [0.5, 0.1, 1, 0.05],\n      gravitationalConstant: [-2000, -30000, 0, 50],\n      centralGravity: [0.3, 0, 10, 0.05],\n      springLength: [95, 0, 500, 5],\n      springConstant: [0.04, 0, 1.2, 0.005],\n      damping: [0.09, 0, 1, 0.01],\n      avoidOverlap: [0, 0, 1, 0.01]\n    },\n    forceAtlas2Based: {\n      theta: [0.5, 0.1, 1, 0.05],\n      gravitationalConstant: [-50, -500, 0, 1],\n      centralGravity: [0.01, 0, 1, 0.005],\n      springLength: [95, 0, 500, 5],\n      springConstant: [0.08, 0, 1.2, 0.005],\n      damping: [0.4, 0, 1, 0.01],\n      avoidOverlap: [0, 0, 1, 0.01]\n    },\n    repulsion: {\n      centralGravity: [0.2, 0, 10, 0.05],\n      springLength: [200, 0, 500, 5],\n      springConstant: [0.05, 0, 1.2, 0.005],\n      nodeDistance: [100, 0, 500, 5],\n      damping: [0.09, 0, 1, 0.01]\n    },\n    hierarchicalRepulsion: {\n      centralGravity: [0.2, 0, 10, 0.05],\n      springLength: [100, 0, 500, 5],\n      springConstant: [0.01, 0, 1.2, 0.005],\n      nodeDistance: [120, 0, 500, 5],\n      damping: [0.09, 0, 1, 0.01],\n      avoidOverlap: [0, 0, 1, 0.01]\n    },\n    maxVelocity: [50, 0, 150, 1],\n    minVelocity: [0.1, 0.01, 0.5, 0.01],\n    solver: [\"barnesHut\", \"forceAtlas2Based\", \"repulsion\", \"hierarchicalRepulsion\"],\n    timestep: [0.5, 0.01, 1, 0.01],\n    wind: {\n      x: [0, -10, 10, 0.1],\n      y: [0, -10, 10, 0.1]\n    }\n    //adaptiveTimestep: true\n  }\n};\n\nvar configuratorHideOption = function configuratorHideOption(parentPath, optionName, options) {\n  var _context;\n  if (_includesInstanceProperty(parentPath).call(parentPath, \"physics\") && _includesInstanceProperty(_context = configureOptions.physics.solver).call(_context, optionName) && options.physics.solver !== optionName && optionName !== \"wind\") {\n    return true;\n  }\n  return false;\n};\n\nvar options = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tallOptions: allOptions,\n\tconfiguratorHideOption: configuratorHideOption,\n\tconfigureOptions: configureOptions\n});\n\n/**\n *  The Floyd–Warshall algorithm is an algorithm for finding shortest paths in\n *  a weighted graph with positive or negative edge weights (but with no negative\n *  cycles). - https://en.wikipedia.org/wiki/Floyd–Warshall_algorithm\n */\nvar FloydWarshall = /*#__PURE__*/function () {\n  /**\n   * @ignore\n   */\n  function FloydWarshall() {\n    _classCallCheck(this, FloydWarshall);\n  }\n\n  /**\n   *\n   * @param {object} body\n   * @param {Array.<Node>} nodesArray\n   * @param {Array.<Edge>} edgesArray\n   * @returns {{}}\n   */\n  _createClass(FloydWarshall, [{\n    key: \"getDistances\",\n    value: function getDistances(body, nodesArray, edgesArray) {\n      var D_matrix = {};\n      var edges = body.edges;\n\n      // prepare matrix with large numbers\n      for (var i = 0; i < nodesArray.length; i++) {\n        var node = nodesArray[i];\n        var cell = {};\n        D_matrix[node] = cell;\n        for (var j = 0; j < nodesArray.length; j++) {\n          cell[nodesArray[j]] = i == j ? 0 : 1e9;\n        }\n      }\n\n      // put the weights for the edges in. This assumes unidirectionality.\n      for (var _i = 0; _i < edgesArray.length; _i++) {\n        var edge = edges[edgesArray[_i]];\n        // edge has to be connected if it counts to the distances. If it is connected to inner clusters it will crash so we also check if it is in the D_matrix\n        if (edge.connected === true && D_matrix[edge.fromId] !== undefined && D_matrix[edge.toId] !== undefined) {\n          D_matrix[edge.fromId][edge.toId] = 1;\n          D_matrix[edge.toId][edge.fromId] = 1;\n        }\n      }\n      var nodeCount = nodesArray.length;\n\n      // Adapted FloydWarshall based on unidirectionality to greatly reduce complexity.\n      for (var k = 0; k < nodeCount; k++) {\n        var knode = nodesArray[k];\n        var kcolm = D_matrix[knode];\n        for (var _i2 = 0; _i2 < nodeCount - 1; _i2++) {\n          var inode = nodesArray[_i2];\n          var icolm = D_matrix[inode];\n          for (var _j = _i2 + 1; _j < nodeCount; _j++) {\n            var jnode = nodesArray[_j];\n            var jcolm = D_matrix[jnode];\n            var val = Math.min(icolm[jnode], icolm[knode] + kcolm[jnode]);\n            icolm[jnode] = val;\n            jcolm[inode] = val;\n          }\n        }\n      }\n      return D_matrix;\n    }\n  }]);\n  return FloydWarshall;\n}();\n\n/**\n * KamadaKawai positions the nodes initially based on\n *\n * \"AN ALGORITHM FOR DRAWING GENERAL UNDIRECTED GRAPHS\"\n * -- Tomihisa KAMADA and Satoru KAWAI in 1989\n *\n * Possible optimizations in the distance calculation can be implemented.\n */\nvar KamadaKawai = /*#__PURE__*/function () {\n  /**\n   * @param {object} body\n   * @param {number} edgeLength\n   * @param {number} edgeStrength\n   */\n  function KamadaKawai(body, edgeLength, edgeStrength) {\n    _classCallCheck(this, KamadaKawai);\n    this.body = body;\n    this.springLength = edgeLength;\n    this.springConstant = edgeStrength;\n    this.distanceSolver = new FloydWarshall();\n  }\n\n  /**\n   * Not sure if needed but can be used to update the spring length and spring constant\n   *\n   * @param {object} options\n   */\n  _createClass(KamadaKawai, [{\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      if (options) {\n        if (options.springLength) {\n          this.springLength = options.springLength;\n        }\n        if (options.springConstant) {\n          this.springConstant = options.springConstant;\n        }\n      }\n    }\n\n    /**\n     * Position the system\n     *\n     * @param {Array.<Node>} nodesArray\n     * @param {Array.<vis.Edge>} edgesArray\n     * @param {boolean} [ignoreClusters=false]\n     */\n  }, {\n    key: \"solve\",\n    value: function solve(nodesArray, edgesArray) {\n      var ignoreClusters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      // get distance matrix\n      var D_matrix = this.distanceSolver.getDistances(this.body, nodesArray, edgesArray); // distance matrix\n\n      // get the L Matrix\n      this._createL_matrix(D_matrix);\n\n      // get the K Matrix\n      this._createK_matrix(D_matrix);\n\n      // initial E Matrix\n      this._createE_matrix();\n\n      // calculate positions\n      var threshold = 0.01;\n      var innerThreshold = 1;\n      var iterations = 0;\n      var maxIterations = Math.max(1000, Math.min(10 * this.body.nodeIndices.length, 6000));\n      var maxInnerIterations = 5;\n      var maxEnergy = 1e9;\n      var highE_nodeId = 0,\n        dE_dx = 0,\n        dE_dy = 0,\n        delta_m = 0,\n        subIterations = 0;\n      while (maxEnergy > threshold && iterations < maxIterations) {\n        iterations += 1;\n        var _this$_getHighestEner = this._getHighestEnergyNode(ignoreClusters);\n        var _this$_getHighestEner2 = _slicedToArray(_this$_getHighestEner, 4);\n        highE_nodeId = _this$_getHighestEner2[0];\n        maxEnergy = _this$_getHighestEner2[1];\n        dE_dx = _this$_getHighestEner2[2];\n        dE_dy = _this$_getHighestEner2[3];\n        delta_m = maxEnergy;\n        subIterations = 0;\n        while (delta_m > innerThreshold && subIterations < maxInnerIterations) {\n          subIterations += 1;\n          this._moveNode(highE_nodeId, dE_dx, dE_dy);\n          var _this$_getEnergy = this._getEnergy(highE_nodeId);\n          var _this$_getEnergy2 = _slicedToArray(_this$_getEnergy, 3);\n          delta_m = _this$_getEnergy2[0];\n          dE_dx = _this$_getEnergy2[1];\n          dE_dy = _this$_getEnergy2[2];\n        }\n      }\n    }\n\n    /**\n     * get the node with the highest energy\n     *\n     * @param {boolean} ignoreClusters\n     * @returns {number[]}\n     * @private\n     */\n  }, {\n    key: \"_getHighestEnergyNode\",\n    value: function _getHighestEnergyNode(ignoreClusters) {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      var maxEnergy = 0;\n      var maxEnergyNodeId = nodesArray[0];\n      var dE_dx_max = 0,\n        dE_dy_max = 0;\n      for (var nodeIdx = 0; nodeIdx < nodesArray.length; nodeIdx++) {\n        var m = nodesArray[nodeIdx];\n        // by not evaluating nodes with predefined positions we should only move nodes that have no positions.\n        if (nodes[m].predefinedPosition !== true || nodes[m].isCluster === true && ignoreClusters === true || nodes[m].options.fixed.x !== true || nodes[m].options.fixed.y !== true) {\n          var _this$_getEnergy3 = this._getEnergy(m),\n            _this$_getEnergy4 = _slicedToArray(_this$_getEnergy3, 3),\n            delta_m = _this$_getEnergy4[0],\n            dE_dx = _this$_getEnergy4[1],\n            dE_dy = _this$_getEnergy4[2];\n          if (maxEnergy < delta_m) {\n            maxEnergy = delta_m;\n            maxEnergyNodeId = m;\n            dE_dx_max = dE_dx;\n            dE_dy_max = dE_dy;\n          }\n        }\n      }\n      return [maxEnergyNodeId, maxEnergy, dE_dx_max, dE_dy_max];\n    }\n\n    /**\n     * calculate the energy of a single node\n     *\n     * @param {Node.id} m\n     * @returns {number[]}\n     * @private\n     */\n  }, {\n    key: \"_getEnergy\",\n    value: function _getEnergy(m) {\n      var _this$E_sums$m = _slicedToArray(this.E_sums[m], 2),\n        dE_dx = _this$E_sums$m[0],\n        dE_dy = _this$E_sums$m[1];\n      var delta_m = Math.sqrt(Math.pow(dE_dx, 2) + Math.pow(dE_dy, 2));\n      return [delta_m, dE_dx, dE_dy];\n    }\n\n    /**\n     * move the node based on it's energy\n     * the dx and dy are calculated from the linear system proposed by Kamada and Kawai\n     *\n     * @param {number} m\n     * @param {number} dE_dx\n     * @param {number} dE_dy\n     * @private\n     */\n  }, {\n    key: \"_moveNode\",\n    value: function _moveNode(m, dE_dx, dE_dy) {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      var d2E_dx2 = 0;\n      var d2E_dxdy = 0;\n      var d2E_dy2 = 0;\n      var x_m = nodes[m].x;\n      var y_m = nodes[m].y;\n      var km = this.K_matrix[m];\n      var lm = this.L_matrix[m];\n      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {\n        var i = nodesArray[iIdx];\n        if (i !== m) {\n          var x_i = nodes[i].x;\n          var y_i = nodes[i].y;\n          var kmat = km[i];\n          var lmat = lm[i];\n          var denominator = 1.0 / Math.pow(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2), 1.5);\n          d2E_dx2 += kmat * (1 - lmat * Math.pow(y_m - y_i, 2) * denominator);\n          d2E_dxdy += kmat * (lmat * (x_m - x_i) * (y_m - y_i) * denominator);\n          d2E_dy2 += kmat * (1 - lmat * Math.pow(x_m - x_i, 2) * denominator);\n        }\n      }\n      // make the variable names easier to make the solving of the linear system easier to read\n      var A = d2E_dx2,\n        B = d2E_dxdy,\n        C = dE_dx,\n        D = d2E_dy2,\n        E = dE_dy;\n\n      // solve the linear system for dx and dy\n      var dy = (C / A + E / B) / (B / A - D / B);\n      var dx = -(B * dy + C) / A;\n\n      // move the node\n      nodes[m].x += dx;\n      nodes[m].y += dy;\n\n      // Recalculate E_matrix (should be incremental)\n      this._updateE_matrix(m);\n    }\n\n    /**\n     * Create the L matrix: edge length times shortest path\n     *\n     * @param {object} D_matrix\n     * @private\n     */\n  }, {\n    key: \"_createL_matrix\",\n    value: function _createL_matrix(D_matrix) {\n      var nodesArray = this.body.nodeIndices;\n      var edgeLength = this.springLength;\n      this.L_matrix = [];\n      for (var i = 0; i < nodesArray.length; i++) {\n        this.L_matrix[nodesArray[i]] = {};\n        for (var j = 0; j < nodesArray.length; j++) {\n          this.L_matrix[nodesArray[i]][nodesArray[j]] = edgeLength * D_matrix[nodesArray[i]][nodesArray[j]];\n        }\n      }\n    }\n\n    /**\n     * Create the K matrix: spring constants times shortest path\n     *\n     * @param {object} D_matrix\n     * @private\n     */\n  }, {\n    key: \"_createK_matrix\",\n    value: function _createK_matrix(D_matrix) {\n      var nodesArray = this.body.nodeIndices;\n      var edgeStrength = this.springConstant;\n      this.K_matrix = [];\n      for (var i = 0; i < nodesArray.length; i++) {\n        this.K_matrix[nodesArray[i]] = {};\n        for (var j = 0; j < nodesArray.length; j++) {\n          this.K_matrix[nodesArray[i]][nodesArray[j]] = edgeStrength * Math.pow(D_matrix[nodesArray[i]][nodesArray[j]], -2);\n        }\n      }\n    }\n\n    /**\n     *  Create matrix with all energies between nodes\n     *\n     *  @private\n     */\n  }, {\n    key: \"_createE_matrix\",\n    value: function _createE_matrix() {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      this.E_matrix = {};\n      this.E_sums = {};\n      for (var mIdx = 0; mIdx < nodesArray.length; mIdx++) {\n        this.E_matrix[nodesArray[mIdx]] = [];\n      }\n      for (var _mIdx = 0; _mIdx < nodesArray.length; _mIdx++) {\n        var m = nodesArray[_mIdx];\n        var x_m = nodes[m].x;\n        var y_m = nodes[m].y;\n        var dE_dx = 0;\n        var dE_dy = 0;\n        for (var iIdx = _mIdx; iIdx < nodesArray.length; iIdx++) {\n          var i = nodesArray[iIdx];\n          if (i !== m) {\n            var x_i = nodes[i].x;\n            var y_i = nodes[i].y;\n            var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));\n            this.E_matrix[m][iIdx] = [this.K_matrix[m][i] * (x_m - x_i - this.L_matrix[m][i] * (x_m - x_i) * denominator), this.K_matrix[m][i] * (y_m - y_i - this.L_matrix[m][i] * (y_m - y_i) * denominator)];\n            this.E_matrix[i][_mIdx] = this.E_matrix[m][iIdx];\n            dE_dx += this.E_matrix[m][iIdx][0];\n            dE_dy += this.E_matrix[m][iIdx][1];\n          }\n        }\n        //Store sum\n        this.E_sums[m] = [dE_dx, dE_dy];\n      }\n    }\n\n    /**\n     * Update method, just doing single column (rows are auto-updated) (update all sums)\n     *\n     * @param {number} m\n     * @private\n     */\n  }, {\n    key: \"_updateE_matrix\",\n    value: function _updateE_matrix(m) {\n      var nodesArray = this.body.nodeIndices;\n      var nodes = this.body.nodes;\n      var colm = this.E_matrix[m];\n      var kcolm = this.K_matrix[m];\n      var lcolm = this.L_matrix[m];\n      var x_m = nodes[m].x;\n      var y_m = nodes[m].y;\n      var dE_dx = 0;\n      var dE_dy = 0;\n      for (var iIdx = 0; iIdx < nodesArray.length; iIdx++) {\n        var i = nodesArray[iIdx];\n        if (i !== m) {\n          //Keep old energy value for sum modification below\n          var cell = colm[iIdx];\n          var oldDx = cell[0];\n          var oldDy = cell[1];\n\n          //Calc new energy:\n          var x_i = nodes[i].x;\n          var y_i = nodes[i].y;\n          var denominator = 1.0 / Math.sqrt(Math.pow(x_m - x_i, 2) + Math.pow(y_m - y_i, 2));\n          var dx = kcolm[i] * (x_m - x_i - lcolm[i] * (x_m - x_i) * denominator);\n          var dy = kcolm[i] * (y_m - y_i - lcolm[i] * (y_m - y_i) * denominator);\n          colm[iIdx] = [dx, dy];\n          dE_dx += dx;\n          dE_dy += dy;\n\n          //add new energy to sum of each column\n          var sum = this.E_sums[i];\n          sum[0] += dx - oldDx;\n          sum[1] += dy - oldDy;\n        }\n      }\n      //Store sum at -1 index\n      this.E_sums[m] = [dE_dx, dE_dy];\n    }\n  }]);\n  return KamadaKawai;\n}();\n\n/**\n * Create a network visualization, displaying nodes and edges.\n *\n * @param {Element} container   The DOM element in which the Network will\n *                                  be created. Normally a div element.\n * @param {object} data         An object containing parameters\n *                              {Array} nodes\n *                              {Array} edges\n * @param {object} options      Options\n * @class Network\n */\nfunction Network(container, data, options) {\n  var _context,\n    _context2,\n    _context3,\n    _context4,\n    _this = this;\n  if (!(this instanceof Network)) {\n    throw new SyntaxError(\"Constructor must be called with the new operator\");\n  }\n\n  // set constant values\n  this.options = {};\n  this.defaultOptions = {\n    locale: \"en\",\n    locales: locales,\n    clickToUse: false\n  };\n  _Object$assign(this.options, this.defaultOptions);\n\n  /**\n   * Containers for nodes and edges.\n   *\n   * 'edges' and 'nodes' contain the full definitions of all the network elements.\n   * 'nodeIndices' and 'edgeIndices' contain the id's of the active elements.\n   *\n   * The distinction is important, because a defined node need not be active, i.e.\n   * visible on the canvas. This happens in particular when clusters are defined, in\n   * that case there will be nodes and edges not displayed.\n   * The bottom line is that all code with actions related to visibility, *must* use\n   * 'nodeIndices' and 'edgeIndices', not 'nodes' and 'edges' directly.\n   */\n  this.body = {\n    container: container,\n    // See comment above for following fields\n    nodes: {},\n    nodeIndices: [],\n    edges: {},\n    edgeIndices: [],\n    emitter: {\n      on: _bindInstanceProperty$1(_context = this.on).call(_context, this),\n      off: _bindInstanceProperty$1(_context2 = this.off).call(_context2, this),\n      emit: _bindInstanceProperty$1(_context3 = this.emit).call(_context3, this),\n      once: _bindInstanceProperty$1(_context4 = this.once).call(_context4, this)\n    },\n    eventListeners: {\n      onTap: function onTap() {},\n      onTouch: function onTouch() {},\n      onDoubleTap: function onDoubleTap() {},\n      onHold: function onHold() {},\n      onDragStart: function onDragStart() {},\n      onDrag: function onDrag() {},\n      onDragEnd: function onDragEnd() {},\n      onMouseWheel: function onMouseWheel() {},\n      onPinch: function onPinch() {},\n      onMouseMove: function onMouseMove() {},\n      onRelease: function onRelease() {},\n      onContext: function onContext() {}\n    },\n    data: {\n      nodes: null,\n      // A DataSet or DataView\n      edges: null // A DataSet or DataView\n    },\n\n    functions: {\n      createNode: function createNode() {},\n      createEdge: function createEdge() {},\n      getPointer: function getPointer() {}\n    },\n    modules: {},\n    view: {\n      scale: 1,\n      translation: {\n        x: 0,\n        y: 0\n      }\n    },\n    selectionBox: {\n      show: false,\n      position: {\n        start: {\n          x: 0,\n          y: 0\n        },\n        end: {\n          x: 0,\n          y: 0\n        }\n      }\n    }\n  };\n\n  // bind the event listeners\n  this.bindEventListeners();\n\n  // setting up all modules\n  this.images = new Images(function () {\n    return _this.body.emitter.emit(\"_requestRedraw\");\n  }); // object with images\n  this.groups = new Groups(); // object with groups\n  this.canvas = new Canvas(this.body); // DOM handler\n  this.selectionHandler = new SelectionHandler(this.body, this.canvas); // Selection handler\n  this.interactionHandler = new InteractionHandler(this.body, this.canvas, this.selectionHandler); // Interaction handler handles all the hammer bindings (that are bound by canvas), key\n  this.view = new View(this.body, this.canvas); // camera handler, does animations and zooms\n  this.renderer = new CanvasRenderer(this.body, this.canvas); // renderer, starts renderloop, has events that modules can hook into\n  this.physics = new PhysicsEngine(this.body); // physics engine, does all the simulations\n  this.layoutEngine = new LayoutEngine(this.body); // layout engine for inital layout and hierarchical layout\n  this.clustering = new ClusterEngine(this.body); // clustering api\n  this.manipulation = new ManipulationSystem(this.body, this.canvas, this.selectionHandler, this.interactionHandler); // data manipulation system\n\n  this.nodesHandler = new NodesHandler(this.body, this.images, this.groups, this.layoutEngine); // Handle adding, deleting and updating of nodes as well as global options\n  this.edgesHandler = new EdgesHandler(this.body, this.images, this.groups); // Handle adding, deleting and updating of edges as well as global options\n\n  this.body.modules[\"kamadaKawai\"] = new KamadaKawai(this.body, 150, 0.05); // Layouting algorithm.\n  this.body.modules[\"clustering\"] = this.clustering;\n\n  // create the DOM elements\n  this.canvas._create();\n\n  // apply options\n  this.setOptions(options);\n\n  // load data (the disable start variable will be the same as the enabled clustering)\n  this.setData(data);\n}\n\n// Extend Network with an Emitter mixin\nEmitter(Network.prototype);\n\n/**\n * Set options\n *\n * @param {object} options\n */\nNetwork.prototype.setOptions = function (options) {\n  var _this2 = this;\n  if (options === null) {\n    options = undefined; // This ensures that options handling doesn't crash in the handling\n  }\n\n  if (options !== undefined) {\n    var errorFound = Validator.validate(options, allOptions);\n    if (errorFound === true) {\n      console.error(\"%cErrors have been found in the supplied options object.\", VALIDATOR_PRINT_STYLE);\n    }\n\n    // copy the global fields over\n    var fields = [\"locale\", \"locales\", \"clickToUse\"];\n    selectiveDeepExtend(fields, this.options, options);\n\n    // normalize the locale or use English\n    if (options.locale !== undefined) {\n      options.locale = normalizeLanguageCode(options.locales || this.options.locales, options.locale);\n    }\n\n    // the hierarchical system can adapt the edges and the physics to it's own options because not all combinations work with the hierarichical system.\n    options = this.layoutEngine.setOptions(options.layout, options);\n    this.canvas.setOptions(options); // options for canvas are in globals\n\n    // pass the options to the modules\n    this.groups.setOptions(options.groups);\n    this.nodesHandler.setOptions(options.nodes);\n    this.edgesHandler.setOptions(options.edges);\n    this.physics.setOptions(options.physics);\n    this.manipulation.setOptions(options.manipulation, options, this.options); // manipulation uses the locales in the globals\n\n    this.interactionHandler.setOptions(options.interaction);\n    this.renderer.setOptions(options.interaction); // options for rendering are in interaction\n    this.selectionHandler.setOptions(options.interaction); // options for selection are in interaction\n\n    // reload the settings of the nodes to apply changes in groups that are not referenced by pointer.\n    if (options.groups !== undefined) {\n      this.body.emitter.emit(\"refreshNodes\");\n    }\n    // these two do not have options at the moment, here for completeness\n    //this.view.setOptions(options.view);\n    //this.clustering.setOptions(options.clustering);\n\n    if (\"configure\" in options) {\n      if (!this.configurator) {\n        this.configurator = new Configurator(this, this.body.container, configureOptions, this.canvas.pixelRatio, configuratorHideOption);\n      }\n      this.configurator.setOptions(options.configure);\n    }\n\n    // if the configuration system is enabled, copy all options and put them into the config system\n    if (this.configurator && this.configurator.options.enabled === true) {\n      var networkOptions = {\n        nodes: {},\n        edges: {},\n        layout: {},\n        interaction: {},\n        manipulation: {},\n        physics: {},\n        global: {}\n      };\n      deepExtend(networkOptions.nodes, this.nodesHandler.options);\n      deepExtend(networkOptions.edges, this.edgesHandler.options);\n      deepExtend(networkOptions.layout, this.layoutEngine.options);\n      // load the selectionHandler and render default options in to the interaction group\n      deepExtend(networkOptions.interaction, this.selectionHandler.options);\n      deepExtend(networkOptions.interaction, this.renderer.options);\n      deepExtend(networkOptions.interaction, this.interactionHandler.options);\n      deepExtend(networkOptions.manipulation, this.manipulation.options);\n      deepExtend(networkOptions.physics, this.physics.options);\n\n      // load globals into the global object\n      deepExtend(networkOptions.global, this.canvas.options);\n      deepExtend(networkOptions.global, this.options);\n      this.configurator.setModuleOptions(networkOptions);\n    }\n\n    // handle network global options\n    if (options.clickToUse !== undefined) {\n      if (options.clickToUse === true) {\n        if (this.activator === undefined) {\n          this.activator = new Activator(this.canvas.frame);\n          this.activator.on(\"change\", function () {\n            _this2.body.emitter.emit(\"activate\");\n          });\n        }\n      } else {\n        if (this.activator !== undefined) {\n          this.activator.destroy();\n          delete this.activator;\n        }\n        this.body.emitter.emit(\"activate\");\n      }\n    } else {\n      this.body.emitter.emit(\"activate\");\n    }\n    this.canvas.setSize();\n    // start the physics simulation. Can be safely called multiple times.\n    this.body.emitter.emit(\"startSimulation\");\n  }\n};\n\n/**\n * Update the visible nodes and edges list with the most recent node state.\n *\n * Visible nodes are stored in this.body.nodeIndices.\n * Visible edges are stored in this.body.edgeIndices.\n * A node or edges is visible if it is not hidden or clustered.\n *\n * @private\n */\nNetwork.prototype._updateVisibleIndices = function () {\n  var nodes = this.body.nodes;\n  var edges = this.body.edges;\n  this.body.nodeIndices = [];\n  this.body.edgeIndices = [];\n  for (var nodeId in nodes) {\n    if (Object.prototype.hasOwnProperty.call(nodes, nodeId)) {\n      if (!this.clustering._isClusteredNode(nodeId) && nodes[nodeId].options.hidden === false) {\n        this.body.nodeIndices.push(nodes[nodeId].id);\n      }\n    }\n  }\n  for (var edgeId in edges) {\n    if (Object.prototype.hasOwnProperty.call(edges, edgeId)) {\n      var edge = edges[edgeId];\n\n      // It can happen that this is executed *after* a node edge has been removed,\n      // but *before* the edge itself has been removed. Taking this into account.\n      var fromNode = nodes[edge.fromId];\n      var toNode = nodes[edge.toId];\n      var edgeNodesPresent = fromNode !== undefined && toNode !== undefined;\n      var isVisible = !this.clustering._isClusteredEdge(edgeId) && edge.options.hidden === false && edgeNodesPresent && fromNode.options.hidden === false &&\n      // Also hidden if any of its connecting nodes are hidden\n      toNode.options.hidden === false; // idem\n\n      if (isVisible) {\n        this.body.edgeIndices.push(edge.id);\n      }\n    }\n  }\n};\n\n/**\n * Bind all events\n */\nNetwork.prototype.bindEventListeners = function () {\n  var _this3 = this;\n  // This event will trigger a rebuilding of the cache everything.\n  // Used when nodes or edges have been added or removed.\n  this.body.emitter.on(\"_dataChanged\", function () {\n    _this3.edgesHandler._updateState();\n    _this3.body.emitter.emit(\"_dataUpdated\");\n  });\n\n  // this is called when options of EXISTING nodes or edges have changed.\n  this.body.emitter.on(\"_dataUpdated\", function () {\n    // Order important in following block\n    _this3.clustering._updateState();\n    _this3._updateVisibleIndices();\n    _this3._updateValueRange(_this3.body.nodes);\n    _this3._updateValueRange(_this3.body.edges);\n    // start simulation (can be called safely, even if already running)\n    _this3.body.emitter.emit(\"startSimulation\");\n    _this3.body.emitter.emit(\"_requestRedraw\");\n  });\n};\n\n/**\n * Set nodes and edges, and optionally options as well.\n *\n * @param {object} data              Object containing parameters:\n *                                   {Array | DataSet | DataView} [nodes] Array with nodes\n *                                   {Array | DataSet | DataView} [edges] Array with edges\n *                                   {String} [dot] String containing data in DOT format\n *                                   {String} [gephi] String containing data in gephi JSON format\n *                                   {Options} [options] Object with options\n */\nNetwork.prototype.setData = function (data) {\n  // reset the physics engine.\n  this.body.emitter.emit(\"resetPhysics\");\n  this.body.emitter.emit(\"_resetData\");\n\n  // unselect all to ensure no selections from old data are carried over.\n  this.selectionHandler.unselectAll();\n  if (data && data.dot && (data.nodes || data.edges)) {\n    throw new SyntaxError('Data must contain either parameter \"dot\" or ' + ' parameter pair \"nodes\" and \"edges\", but not both.');\n  }\n\n  // set options\n  this.setOptions(data && data.options);\n  // set all data\n  if (data && data.dot) {\n    console.warn(\"The dot property has been deprecated. Please use the static convertDot method to convert DOT into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertDot(dotString);\");\n    // parse DOT file\n    var dotData = DOTToGraph(data.dot);\n    this.setData(dotData);\n    return;\n  } else if (data && data.gephi) {\n    // parse DOT file\n    console.warn(\"The gephi property has been deprecated. Please use the static convertGephi method to convert gephi into vis.network format and use the normal data format with nodes and edges. This converter is used like this: var data = vis.network.convertGephi(gephiJson);\");\n    var gephiData = parseGephi(data.gephi);\n    this.setData(gephiData);\n    return;\n  } else {\n    this.nodesHandler.setData(data && data.nodes, true);\n    this.edgesHandler.setData(data && data.edges, true);\n  }\n\n  // emit change in data\n  this.body.emitter.emit(\"_dataChanged\");\n\n  // emit data loaded\n  this.body.emitter.emit(\"_dataLoaded\");\n\n  // find a stable position or start animating to a stable position\n  this.body.emitter.emit(\"initPhysics\");\n};\n\n/**\n * Cleans up all bindings of the network, removing it fully from the memory IF the variable is set to null after calling this function.\n * var network = new vis.Network(..);\n * network.destroy();\n * network = null;\n */\nNetwork.prototype.destroy = function () {\n  this.body.emitter.emit(\"destroy\");\n  // clear events\n  this.body.emitter.off();\n  this.off();\n\n  // delete modules\n  delete this.groups;\n  delete this.canvas;\n  delete this.selectionHandler;\n  delete this.interactionHandler;\n  delete this.view;\n  delete this.renderer;\n  delete this.physics;\n  delete this.layoutEngine;\n  delete this.clustering;\n  delete this.manipulation;\n  delete this.nodesHandler;\n  delete this.edgesHandler;\n  delete this.configurator;\n  delete this.images;\n  for (var nodeId in this.body.nodes) {\n    if (!Object.prototype.hasOwnProperty.call(this.body.nodes, nodeId)) continue;\n    delete this.body.nodes[nodeId];\n  }\n  for (var edgeId in this.body.edges) {\n    if (!Object.prototype.hasOwnProperty.call(this.body.edges, edgeId)) continue;\n    delete this.body.edges[edgeId];\n  }\n\n  // remove the container and everything inside it recursively\n  recursiveDOMDelete(this.body.container);\n};\n\n/**\n * Update the values of all object in the given array according to the current\n * value range of the objects in the array.\n *\n * @param {object} obj    An object containing a set of Edges or Nodes\n *                        The objects must have a method getValue() and\n *                        setValueRange(min, max).\n * @private\n */\nNetwork.prototype._updateValueRange = function (obj) {\n  var id;\n\n  // determine the range of the objects\n  var valueMin = undefined;\n  var valueMax = undefined;\n  var valueTotal = 0;\n  for (id in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, id)) {\n      var value = obj[id].getValue();\n      if (value !== undefined) {\n        valueMin = valueMin === undefined ? value : Math.min(value, valueMin);\n        valueMax = valueMax === undefined ? value : Math.max(value, valueMax);\n        valueTotal += value;\n      }\n    }\n  }\n\n  // adjust the range of all objects\n  if (valueMin !== undefined && valueMax !== undefined) {\n    for (id in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, id)) {\n        obj[id].setValueRange(valueMin, valueMax, valueTotal);\n      }\n    }\n  }\n};\n\n/**\n * Returns true when the Network is active.\n *\n * @returns {boolean}\n */\nNetwork.prototype.isActive = function () {\n  return !this.activator || this.activator.active;\n};\nNetwork.prototype.setSize = function () {\n  return this.canvas.setSize.apply(this.canvas, arguments);\n};\nNetwork.prototype.canvasToDOM = function () {\n  return this.canvas.canvasToDOM.apply(this.canvas, arguments);\n};\nNetwork.prototype.DOMtoCanvas = function () {\n  return this.canvas.DOMtoCanvas.apply(this.canvas, arguments);\n};\n\n/**\n * Nodes can be in clusters. Clusters can also be in clusters. This function returns and array of\n * nodeIds showing where the node is.\n *\n * If any nodeId in the chain, especially the first passed in as a parameter, is not present in\n * the current nodes list, an empty array is returned.\n *\n * Example:\n * cluster 'A' contains cluster 'B',\n * cluster 'B' contains cluster 'C',\n * cluster 'C' contains node 'fred'.\n * `jsnetwork.clustering.findNode('fred')` will return `['A','B','C','fred']`.\n *\n * @param {string|number} nodeId\n * @returns {Array}\n */\nNetwork.prototype.findNode = function () {\n  return this.clustering.findNode.apply(this.clustering, arguments);\n};\nNetwork.prototype.isCluster = function () {\n  return this.clustering.isCluster.apply(this.clustering, arguments);\n};\nNetwork.prototype.openCluster = function () {\n  return this.clustering.openCluster.apply(this.clustering, arguments);\n};\nNetwork.prototype.cluster = function () {\n  return this.clustering.cluster.apply(this.clustering, arguments);\n};\nNetwork.prototype.getNodesInCluster = function () {\n  return this.clustering.getNodesInCluster.apply(this.clustering, arguments);\n};\nNetwork.prototype.clusterByConnection = function () {\n  return this.clustering.clusterByConnection.apply(this.clustering, arguments);\n};\nNetwork.prototype.clusterByHubsize = function () {\n  return this.clustering.clusterByHubsize.apply(this.clustering, arguments);\n};\nNetwork.prototype.updateClusteredNode = function () {\n  return this.clustering.updateClusteredNode.apply(this.clustering, arguments);\n};\nNetwork.prototype.getClusteredEdges = function () {\n  return this.clustering.getClusteredEdges.apply(this.clustering, arguments);\n};\nNetwork.prototype.getBaseEdge = function () {\n  return this.clustering.getBaseEdge.apply(this.clustering, arguments);\n};\nNetwork.prototype.getBaseEdges = function () {\n  return this.clustering.getBaseEdges.apply(this.clustering, arguments);\n};\nNetwork.prototype.updateEdge = function () {\n  return this.clustering.updateEdge.apply(this.clustering, arguments);\n};\n\n/**\n * This method will cluster all nodes with 1 edge with their respective connected node.\n * The options object is explained in full <a data-scroll=\"\" data-options=\"{ &quot;easing&quot;: &quot;easeInCubic&quot; }\" href=\"#optionsObject\">below</a>.\n *\n * @param {object} [options]\n * @returns {undefined}\n */\nNetwork.prototype.clusterOutliers = function () {\n  return this.clustering.clusterOutliers.apply(this.clustering, arguments);\n};\nNetwork.prototype.getSeed = function () {\n  return this.layoutEngine.getSeed.apply(this.layoutEngine, arguments);\n};\nNetwork.prototype.enableEditMode = function () {\n  return this.manipulation.enableEditMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.disableEditMode = function () {\n  return this.manipulation.disableEditMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.addNodeMode = function () {\n  return this.manipulation.addNodeMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.editNode = function () {\n  return this.manipulation.editNode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.editNodeMode = function () {\n  console.warn(\"Deprecated: Please use editNode instead of editNodeMode.\");\n  return this.manipulation.editNode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.addEdgeMode = function () {\n  return this.manipulation.addEdgeMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.editEdgeMode = function () {\n  return this.manipulation.editEdgeMode.apply(this.manipulation, arguments);\n};\nNetwork.prototype.deleteSelected = function () {\n  return this.manipulation.deleteSelected.apply(this.manipulation, arguments);\n};\nNetwork.prototype.getPositions = function () {\n  return this.nodesHandler.getPositions.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.getPosition = function () {\n  return this.nodesHandler.getPosition.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.storePositions = function () {\n  return this.nodesHandler.storePositions.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.moveNode = function () {\n  return this.nodesHandler.moveNode.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.getBoundingBox = function () {\n  return this.nodesHandler.getBoundingBox.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.getConnectedNodes = function (objectId) {\n  if (this.body.nodes[objectId] !== undefined) {\n    return this.nodesHandler.getConnectedNodes.apply(this.nodesHandler, arguments);\n  } else {\n    return this.edgesHandler.getConnectedNodes.apply(this.edgesHandler, arguments);\n  }\n};\nNetwork.prototype.getConnectedEdges = function () {\n  return this.nodesHandler.getConnectedEdges.apply(this.nodesHandler, arguments);\n};\nNetwork.prototype.startSimulation = function () {\n  return this.physics.startSimulation.apply(this.physics, arguments);\n};\nNetwork.prototype.stopSimulation = function () {\n  return this.physics.stopSimulation.apply(this.physics, arguments);\n};\nNetwork.prototype.stabilize = function () {\n  return this.physics.stabilize.apply(this.physics, arguments);\n};\nNetwork.prototype.getSelection = function () {\n  return this.selectionHandler.getSelection.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.setSelection = function () {\n  return this.selectionHandler.setSelection.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.getSelectedNodes = function () {\n  return this.selectionHandler.getSelectedNodeIds.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.getSelectedEdges = function () {\n  return this.selectionHandler.getSelectedEdgeIds.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.getNodeAt = function () {\n  var node = this.selectionHandler.getNodeAt.apply(this.selectionHandler, arguments);\n  if (node !== undefined && node.id !== undefined) {\n    return node.id;\n  }\n  return node;\n};\nNetwork.prototype.getEdgeAt = function () {\n  var edge = this.selectionHandler.getEdgeAt.apply(this.selectionHandler, arguments);\n  if (edge !== undefined && edge.id !== undefined) {\n    return edge.id;\n  }\n  return edge;\n};\nNetwork.prototype.selectNodes = function () {\n  return this.selectionHandler.selectNodes.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.selectEdges = function () {\n  return this.selectionHandler.selectEdges.apply(this.selectionHandler, arguments);\n};\nNetwork.prototype.unselectAll = function () {\n  this.selectionHandler.unselectAll.apply(this.selectionHandler, arguments);\n  this.selectionHandler.commitWithoutEmitting.apply(this.selectionHandler);\n  this.redraw();\n};\nNetwork.prototype.redraw = function () {\n  return this.renderer.redraw.apply(this.renderer, arguments);\n};\nNetwork.prototype.getScale = function () {\n  return this.view.getScale.apply(this.view, arguments);\n};\nNetwork.prototype.getViewPosition = function () {\n  return this.view.getViewPosition.apply(this.view, arguments);\n};\nNetwork.prototype.fit = function () {\n  return this.view.fit.apply(this.view, arguments);\n};\nNetwork.prototype.moveTo = function () {\n  return this.view.moveTo.apply(this.view, arguments);\n};\nNetwork.prototype.focus = function () {\n  return this.view.focus.apply(this.view, arguments);\n};\nNetwork.prototype.releaseNode = function () {\n  return this.view.releaseNode.apply(this.view, arguments);\n};\nNetwork.prototype.getOptionsFromConfigurator = function () {\n  var options = {};\n  if (this.configurator) {\n    options = this.configurator.getOptions.apply(this.configurator);\n  }\n  return options;\n};\n\nvar parseDOTNetwork = DOTToGraph;\n// DataSet, utils etc. can't be reexported here because that would cause stack\n// overflow in UMD builds. They all export vis namespace therefore reexporting\n// leads to loading vis to load vis to load vis…\n\n\n//# sourceMappingURL=vis-network.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdmlzLW5ldHdvcmsvcGVlci9lc20vdmlzLW5ldHdvcmsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFd0U7O0FBRXhFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sbUJBQW1CLGFBQWE7QUFDeEUsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQSxnRkFBZ0YsTUFBTTs7QUFFdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDOztBQUUxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7O0FBRWhCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxrREFBa0Q7QUFDeEYsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7O0FBRWpFOztBQUVBOztBQUVBO0FBQ0EseUVBQXlFO0FBQ3pFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsYUFBYTtBQUMxRDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0RkFBNEY7O0FBRTVGLG1HQUFtRztBQUNuRzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxhQUFhO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsZ0NBQWdDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBLGdFQUFnRSwyREFBMkQ7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDLDhDQUE4QztBQUM5QyxnREFBZ0Q7QUFDaEQ7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxXQUFXLG9GQUFvRjtBQUNyRzs7QUFFQTtBQUNBO0FBQ0Esc0VBQXNFLGVBQWU7QUFDckY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxnQkFBZ0I7QUFDMUQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUNBQXVDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pELEVBQUUsZ0JBQWdCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsTUFBTSwwREFBMEQ7QUFDaEU7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHdHQUF3RztBQUM5RztBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBEQUEwRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtB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QkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsWUFBWSw0RkFBNEY7QUFDaEgsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOERBQThEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDhEQUE4RDtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtELGdCQUFnQjs7QUFFbEU7QUFDQTtBQUNBLE1BQU0sNkRBQTZEO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sNEJBQTRCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVztBQUMzRCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sZ0VBQWdFO0FBQ3RFO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtRkFBbUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOERBQThEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJDQUEyQztBQUMvRCxNQUFNO0FBQ04sd0NBQXdDLGlCQUFpQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsTUFBTSx3REFBd0Q7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlCQUFpQjtBQUN2QixJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDBFQUEwRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUFrRCwwQkFBMEI7O0FBRTVFO0FBQ0E7QUFDQSxNQUFNLDhGQUE4RjtBQUNwRztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDREQUE0RDtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsK0NBQStDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsa0NBQWtDOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDhDQUE4QztBQUNwRDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLGdEQUFnRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxvREFBb0Q7QUFDMUQ7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLDBFQUEwRTtBQUNoRjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLHdFQUF3RTtBQUM5RTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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RUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QXFEO0FBQ3JELFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsRUFBRSxlQUFlLEVBQUU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0NBQWdDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QVE7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakMsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZCQUE2QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQkFBc0IsNkJBQTZCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxpQkFBaUI7QUFDaEMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxlQUFlO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtB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QkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FB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QSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVztBQUNwQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVELDJCQUEyQix5QkFBeUIscUNBQXFDLDBDQUEwQyw0REFBNEQsNkRBQTZELDBCQUEwQjtBQUN0Uiw4QkFBOEIsZ0JBQWdCLHNCQUFzQixPQUFPLDBCQUEwQixrREFBa0Qsc0dBQXNHLDhCQUE4QixzTUFBc00seUVBQXlFLEtBQUs7QUFDL2lCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsK0NBQStDLFVBQVU7QUFDekQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRCxtQ0FBbUMsK0RBQStELHlDQUF5Qyw4Q0FB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QUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0QkFBNEI7QUFDM0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNEJBQTRCO0FBQzNDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLE1BQU07QUFDckI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsTUFB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O0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQjtBQUN6QyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVE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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0I7QUFDaEU7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZC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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxl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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsZ0NBQWdDLHNCQUFzQjtBQUM3RTtBQUNBO0FBQ0EsdURBQXVELHNCQUFzQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVLE1BQU0saUNBQWlDO0FBQ2hFO0FBQ0EsZUFBZSxTQUFTLE1BQU0saUNBQWlDO0FBQy9EO0FBQ0EsZUFBZSxVQUFVLE1BQU0saUJBQWlCO0FBQ2hEO0FBQ0EsZUFBZSxXQUFXLE1BQU0sa0JBQWtCO0FBQ2xEO0FBQ0EsZUFBZSxVQUFVLE1BQU0sb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QjtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9DQUFvQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1DQUFtQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsV0FBVztBQUNY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QTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQix1QkFBdUI7QUFDdkM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrSEFBK0g7QUFDL0gscURBQXFELEdBQUc7QUFDeEQsc0RBQXNELEdBQUc7QUFDekQsdUlBQXVJO0FBQ3ZJLDZIQUE2SDtBQUM3SCxtSUFBbUk7QUFDbkksMkRBQTJELEdBQUc7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOEJBQThCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQix5Q0FBeUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFVBQVU7QUFDekI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQ0FBb0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLHFDQUFxQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwrQkFBK0I7QUFDbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCwrQkFBK0I7O0FBRXJGLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsUUFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdB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QSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsc0NBQXNDLDRCQUE0QjtBQUNsRSxzQ0FBc0MsNEJBQTRCO0FBQ2xFLHNDQUFzQyxRQUFRO0FBQzlDLHNDQUFzQyxRQUFRO0FBQzlDLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJRQUEyUTtBQUMzUTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG1SQUFtUjtBQUNuUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkVBQTZFLE1BQU0sWUFBWSxRQUFRLG1CQUFtQjtBQUMxSDtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUUyTDtBQUMzTCIsInNvdXJjZXMiOlsid2VicGFjazovL25lbzRqLW5leHQtYXBwLy4vbm9kZV9tb2R1bGVzL3Zpcy1uZXR3b3JrL3BlZXIvZXNtL3Zpcy1uZXR3b3JrLmpzP2U3ZWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB2aXMtbmV0d29ya1xuICogaHR0cHM6Ly92aXNqcy5naXRodWIuaW8vdmlzLW5ldHdvcmsvXG4gKlxuICogQSBkeW5hbWljLCBicm93c2VyLWJhc2VkIHZpc3VhbGl6YXRpb24gbGlicmFyeS5cbiAqXG4gKiBAdmVyc2lvbiA5LjEuOVxuICogQGRhdGUgICAgMjAyMy0xMS0wM1QwMTo0MjoyNy40MThaXG4gKlxuICogQGNvcHlyaWdodCAoYykgMjAxMS0yMDE3IEFsbWVuZGUgQi5WLCBodHRwOi8vYWxtZW5kZS5jb21cbiAqIEBjb3B5cmlnaHQgKGMpIDIwMTctMjAxOSB2aXNqcyBjb250cmlidXRvcnMsIGh0dHBzOi8vZ2l0aHViLmNvbS92aXNqc1xuICpcbiAqIEBsaWNlbnNlXG4gKiB2aXMuanMgaXMgZHVhbCBsaWNlbnNlZCB1bmRlciBib3RoXG4gKlxuICogICAxLiBUaGUgQXBhY2hlIDIuMCBMaWNlbnNlXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqICAgYW5kXG4gKlxuICogICAyLiBUaGUgTUlUIExpY2Vuc2VcbiAqICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICpcbiAqIHZpcy5qcyBtYXkgYmUgZGlzdHJpYnV0ZWQgdW5kZXIgZWl0aGVyIGxpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgaXNEYXRhVmlld0xpa2UsIERhdGFTZXQgfSBmcm9tICd2aXMtZGF0YS9wZWVyL2VzbS92aXMtZGF0YS5qcyc7XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT09IE1hdGggJiYgaXQ7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCRuID1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWdsb2JhbC10aGlzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIGdsb2JhbFRoaXMgPT0gJ29iamVjdCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgY2hlY2sodHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmKSB8fFxuICBjaGVjayh0eXBlb2YgY29tbW9uanNHbG9iYWwgPT0gJ29iamVjdCcgJiYgY29tbW9uanNHbG9iYWwpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBjb21tb25qc0dsb2JhbCB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgZmFpbHMkdyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG52YXIgZmFpbHMkdiA9IGZhaWxzJHc7XG5cbnZhciBmdW5jdGlvbkJpbmROYXRpdmUgPSAhZmFpbHMkdihmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1mdW5jdGlvbi1wcm90b3R5cGUtYmluZCAtLSBzYWZlXG4gIHZhciB0ZXN0ID0gKGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSkuYmluZCgpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuIHR5cGVvZiB0ZXN0ICE9ICdmdW5jdGlvbicgfHwgdGVzdC5oYXNPd25Qcm9wZXJ0eSgncHJvdG90eXBlJyk7XG59KTtcblxudmFyIE5BVElWRV9CSU5EJDQgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSQ0ID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGFwcGx5JDUgPSBGdW5jdGlvblByb3RvdHlwZSQ0LmFwcGx5O1xudmFyIGNhbGwkZiA9IEZ1bmN0aW9uUHJvdG90eXBlJDQuY2FsbDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLXJlZmxlY3QgLS0gc2FmZVxudmFyIGZ1bmN0aW9uQXBwbHkgPSB0eXBlb2YgUmVmbGVjdCA9PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmFwcGx5IHx8IChOQVRJVkVfQklORCQ0ID8gY2FsbCRmLmJpbmQoYXBwbHkkNSkgOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsJGYuYXBwbHkoYXBwbHkkNSwgYXJndW1lbnRzKTtcbn0pO1xuXG52YXIgTkFUSVZFX0JJTkQkMyA9IGZ1bmN0aW9uQmluZE5hdGl2ZTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlJDMgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgY2FsbCRlID0gRnVuY3Rpb25Qcm90b3R5cGUkMy5jYWxsO1xudmFyIHVuY3VycnlUaGlzV2l0aEJpbmQgPSBOQVRJVkVfQklORCQzICYmIEZ1bmN0aW9uUHJvdG90eXBlJDMuYmluZC5iaW5kKGNhbGwkZSwgY2FsbCRlKTtcblxudmFyIGZ1bmN0aW9uVW5jdXJyeVRoaXMgPSBOQVRJVkVfQklORCQzID8gdW5jdXJyeVRoaXNXaXRoQmluZCA6IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWxsJGUuYXBwbHkoZm4sIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkeCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciB0b1N0cmluZyRjID0gdW5jdXJyeVRoaXMkeCh7fS50b1N0cmluZyk7XG52YXIgc3RyaW5nU2xpY2UkMSA9IHVuY3VycnlUaGlzJHgoJycuc2xpY2UpO1xuXG52YXIgY2xhc3NvZlJhdyQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBzdHJpbmdTbGljZSQxKHRvU3RyaW5nJGMoaXQpLCA4LCAtMSk7XG59O1xuXG52YXIgY2xhc3NvZlJhdyQxID0gY2xhc3NvZlJhdyQyO1xudmFyIHVuY3VycnlUaGlzJHcgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgZnVuY3Rpb25VbmN1cnJ5VGhpc0NsYXVzZSA9IGZ1bmN0aW9uIChmbikge1xuICAvLyBOYXNob3JuIGJ1ZzpcbiAgLy8gICBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTEyOFxuICAvLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xMTMwXG4gIGlmIChjbGFzc29mUmF3JDEoZm4pID09PSAnRnVuY3Rpb24nKSByZXR1cm4gdW5jdXJyeVRoaXMkdyhmbik7XG59O1xuXG52YXIgZG9jdW1lbnRBbGwkMiA9IHR5cGVvZiBkb2N1bWVudCA9PSAnb2JqZWN0JyAmJiBkb2N1bWVudC5hbGw7XG5cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtSXNIVE1MRERBLWludGVybmFsLXNsb3Rcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL25vLXR5cGVvZi11bmRlZmluZWQgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBJU19IVE1MRERBID0gdHlwZW9mIGRvY3VtZW50QWxsJDIgPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnRBbGwkMiAhPT0gdW5kZWZpbmVkO1xuXG52YXIgZG9jdW1lbnRBbGxfMSA9IHtcbiAgYWxsOiBkb2N1bWVudEFsbCQyLFxuICBJU19IVE1MRERBOiBJU19IVE1MRERBXG59O1xuXG52YXIgJGRvY3VtZW50QWxsJDEgPSBkb2N1bWVudEFsbF8xO1xuXG52YXIgZG9jdW1lbnRBbGwkMSA9ICRkb2N1bWVudEFsbCQxLmFsbDtcblxuLy8gYElzQ2FsbGFibGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXG52YXIgaXNDYWxsYWJsZSRpID0gJGRvY3VtZW50QWxsJDEuSVNfSFRNTEREQSA/IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbicgfHwgYXJndW1lbnQgPT09IGRvY3VtZW50QWxsJDE7XG59IDogZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT0gJ2Z1bmN0aW9uJztcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSB7fTtcblxudmFyIGZhaWxzJHUgPSBmYWlscyR3O1xuXG4vLyBEZXRlY3QgSUU4J3MgaW5jb21wbGV0ZSBkZWZpbmVQcm9wZXJ0eSBpbXBsZW1lbnRhdGlvblxudmFyIGRlc2NyaXB0b3JzID0gIWZhaWxzJHUoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9PSA3O1xufSk7XG5cbnZhciBOQVRJVkVfQklORCQyID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgY2FsbCRkID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGw7XG5cbnZhciBmdW5jdGlvbkNhbGwgPSBOQVRJVkVfQklORCQyID8gY2FsbCRkLmJpbmQoY2FsbCRkKSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNhbGwkZC5hcHBseShjYWxsJGQsIGFyZ3VtZW50cyk7XG59O1xuXG52YXIgb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGUgPSB7fTtcblxudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSQxID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBOYXNob3JuIH4gSkRLOCBidWdcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ5ICYmICEkcHJvcGVydHlJc0VudW1lcmFibGUkMS5jYWxsKHsgMTogMiB9LCAxKTtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGVgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5vYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZS5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDkodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZSQxO1xuXG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDUgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcblxudmFyIHVuY3VycnlUaGlzJHYgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJHQgPSBmYWlscyR3O1xudmFyIGNsYXNzb2YkZSA9IGNsYXNzb2ZSYXckMjtcblxudmFyICRPYmplY3QkNSA9IE9iamVjdDtcbnZhciBzcGxpdCA9IHVuY3VycnlUaGlzJHYoJycuc3BsaXQpO1xuXG4vLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGluZGV4ZWRPYmplY3QgPSBmYWlscyR0KGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuICEkT2JqZWN0JDUoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mJGUoaXQpID09PSAnU3RyaW5nJyA/IHNwbGl0KGl0LCAnJykgOiAkT2JqZWN0JDUoaXQpO1xufSA6ICRPYmplY3QkNTtcblxuLy8gd2UgY2FuJ3QgdXNlIGp1c3QgYGl0ID09IG51bGxgIHNpbmNlIG9mIGBkb2N1bWVudC5hbGxgIHNwZWNpYWwgY2FzZVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1Jc0hUTUxEREEtaW50ZXJuYWwtc2xvdC1hZWNcbnZhciBpc051bGxPclVuZGVmaW5lZCQ2ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gbnVsbCB8fCBpdCA9PT0gdW5kZWZpbmVkO1xufTtcblxudmFyIGlzTnVsbE9yVW5kZWZpbmVkJDUgPSBpc051bGxPclVuZGVmaW5lZCQ2O1xuXG52YXIgJFR5cGVFcnJvciRnID0gVHlwZUVycm9yO1xuXG4vLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkJDUoaXQpKSB0aHJvdyBuZXcgJFR5cGVFcnJvciRnKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG5cbi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSW5kZXhlZE9iamVjdCQzID0gaW5kZXhlZE9iamVjdDtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDQgPSByZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDU7XG5cbnZhciB0b0luZGV4ZWRPYmplY3QkYSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdCQzKHJlcXVpcmVPYmplY3RDb2VyY2libGUkNChpdCkpO1xufTtcblxudmFyIGlzQ2FsbGFibGUkaCA9IGlzQ2FsbGFibGUkaTtcbnZhciAkZG9jdW1lbnRBbGwgPSBkb2N1bWVudEFsbF8xO1xuXG52YXIgZG9jdW1lbnRBbGwgPSAkZG9jdW1lbnRBbGwuYWxsO1xuXG52YXIgaXNPYmplY3QkaiA9ICRkb2N1bWVudEFsbC5JU19IVE1MRERBID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IGlzQ2FsbGFibGUkaChpdCkgfHwgaXQgPT09IGRvY3VtZW50QWxsO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlJGgoaXQpO1xufTtcblxudmFyIHBhdGgkdyA9IHt9O1xuXG52YXIgcGF0aCR2ID0gcGF0aCR3O1xudmFyIGdsb2JhbCRtID0gZ2xvYmFsJG47XG52YXIgaXNDYWxsYWJsZSRnID0gaXNDYWxsYWJsZSRpO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gIHJldHVybiBpc0NhbGxhYmxlJGcodmFyaWFibGUpID8gdmFyaWFibGUgOiB1bmRlZmluZWQ7XG59O1xuXG52YXIgZ2V0QnVpbHRJbiRjID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihwYXRoJHZbbmFtZXNwYWNlXSkgfHwgYUZ1bmN0aW9uKGdsb2JhbCRtW25hbWVzcGFjZV0pXG4gICAgOiBwYXRoJHZbbmFtZXNwYWNlXSAmJiBwYXRoJHZbbmFtZXNwYWNlXVttZXRob2RdIHx8IGdsb2JhbCRtW25hbWVzcGFjZV0gJiYgZ2xvYmFsJG1bbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxudmFyIHVuY3VycnlUaGlzJHUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xuXG52YXIgb2JqZWN0SXNQcm90b3R5cGVPZiA9IHVuY3VycnlUaGlzJHUoe30uaXNQcm90b3R5cGVPZik7XG5cbnZhciBlbmdpbmVVc2VyQWdlbnQgPSB0eXBlb2YgbmF2aWdhdG9yICE9ICd1bmRlZmluZWQnICYmIFN0cmluZyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCAnJztcblxudmFyIGdsb2JhbCRsID0gZ2xvYmFsJG47XG52YXIgdXNlckFnZW50JDIgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBwcm9jZXNzID0gZ2xvYmFsJGwucHJvY2VzcztcbnZhciBEZW5vID0gZ2xvYmFsJGwuRGVubztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucyB8fCBEZW5vICYmIERlbm8udmVyc2lvbjtcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICAvLyBpbiBvbGQgQ2hyb21lLCB2ZXJzaW9ucyBvZiBWOCBpc24ndCBWOCA9IENocm9tZSAvIDEwXG4gIC8vIGJ1dCB0aGVpciBjb3JyZWN0IHZlcnNpb25zIGFyZSBub3QgaW50ZXJlc3RpbmcgZm9yIHVzXG4gIHZlcnNpb24gPSBtYXRjaFswXSA+IDAgJiYgbWF0Y2hbMF0gPCA0ID8gMSA6ICsobWF0Y2hbMF0gKyBtYXRjaFsxXSk7XG59XG5cbi8vIEJyb3dzZXJGUyBOb2RlSlMgYHByb2Nlc3NgIHBvbHlmaWxsIGluY29ycmVjdGx5IHNldCBgLnY4YCB0byBgMC4wYFxuLy8gc28gY2hlY2sgYHVzZXJBZ2VudGAgZXZlbiBpZiBgLnY4YCBleGlzdHMsIGJ1dCAwXG5pZiAoIXZlcnNpb24gJiYgdXNlckFnZW50JDIpIHtcbiAgbWF0Y2ggPSB1c2VyQWdlbnQkMi5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQkMi5tYXRjaCgvQ2hyb21lXFwvKFxcZCspLyk7XG4gICAgaWYgKG1hdGNoKSB2ZXJzaW9uID0gK21hdGNoWzFdO1xuICB9XG59XG5cbnZhciBlbmdpbmVWOFZlcnNpb24gPSB2ZXJzaW9uO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbnZhciBWOF9WRVJTSU9OJDIgPSBlbmdpbmVWOFZlcnNpb247XG52YXIgZmFpbHMkcyA9IGZhaWxzJHc7XG52YXIgZ2xvYmFsJGsgPSBnbG9iYWwkbjtcblxudmFyICRTdHJpbmckNSA9IGdsb2JhbCRrLlN0cmluZztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciBzeW1ib2xDb25zdHJ1Y3RvckRldGVjdGlvbiA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMkcyhmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSBTeW1ib2woJ3N5bWJvbCBkZXRlY3Rpb24nKTtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gYGdldC1vd24tcHJvcGVydHktc3ltYm9sc2AgcG9seWZpbGwgc3ltYm9scyBjb252ZXJ0ZWQgdG8gb2JqZWN0IGFyZSBub3QgU3ltYm9sIGluc3RhbmNlc1xuICAvLyBuYjogRG8gbm90IGNhbGwgYFN0cmluZ2AgZGlyZWN0bHkgdG8gYXZvaWQgdGhpcyBiZWluZyBvcHRpbWl6ZWQgb3V0IHRvIGBzeW1ib2wrJydgIHdoaWNoIHdpbGwsXG4gIC8vIG9mIGNvdXJzZSwgZmFpbC5cbiAgcmV0dXJuICEkU3RyaW5nJDUoc3ltYm9sKSB8fCAhKE9iamVjdChzeW1ib2wpIGluc3RhbmNlb2YgU3ltYm9sKSB8fFxuICAgIC8vIENocm9tZSAzOC00MCBzeW1ib2xzIGFyZSBub3QgaW5oZXJpdGVkIGZyb20gRE9NIGNvbGxlY3Rpb25zIHByb3RvdHlwZXMgdG8gaW5zdGFuY2VzXG4gICAgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04kMiAmJiBWOF9WRVJTSU9OJDIgPCA0MTtcbn0pO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmcgKi9cbnZhciBOQVRJVkVfU1lNQk9MJDUgPSBzeW1ib2xDb25zdHJ1Y3RvckRldGVjdGlvbjtcblxudmFyIHVzZVN5bWJvbEFzVWlkID0gTkFUSVZFX1NZTUJPTCQ1XG4gICYmICFTeW1ib2wuc2hhbVxuICAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xuXG52YXIgZ2V0QnVpbHRJbiRiID0gZ2V0QnVpbHRJbiRjO1xudmFyIGlzQ2FsbGFibGUkZiA9IGlzQ2FsbGFibGUkaTtcbnZhciBpc1Byb3RvdHlwZU9mJGsgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEJDEgPSB1c2VTeW1ib2xBc1VpZDtcblxudmFyICRPYmplY3QkNCA9IE9iamVjdDtcblxudmFyIGlzU3ltYm9sJDUgPSBVU0VfU1lNQk9MX0FTX1VJRCQxID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbiRiKCdTeW1ib2wnKTtcbiAgcmV0dXJuIGlzQ2FsbGFibGUkZigkU3ltYm9sKSAmJiBpc1Byb3RvdHlwZU9mJGsoJFN5bWJvbC5wcm90b3R5cGUsICRPYmplY3QkNChpdCkpO1xufTtcblxudmFyICRTdHJpbmckNCA9IFN0cmluZztcblxudmFyIHRyeVRvU3RyaW5nJDYgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gJFN0cmluZyQ0KGFyZ3VtZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cbn07XG5cbnZhciBpc0NhbGxhYmxlJGUgPSBpc0NhbGxhYmxlJGk7XG52YXIgdHJ5VG9TdHJpbmckNSA9IHRyeVRvU3RyaW5nJDY7XG5cbnZhciAkVHlwZUVycm9yJGYgPSBUeXBlRXJyb3I7XG5cbi8vIGBBc3NlcnQ6IElzQ2FsbGFibGUoYXJndW1lbnQpIGlzIHRydWVgXG52YXIgYUNhbGxhYmxlJDcgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzQ2FsbGFibGUkZShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IkZih0cnlUb1N0cmluZyQ1KGFyZ3VtZW50KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbn07XG5cbnZhciBhQ2FsbGFibGUkNiA9IGFDYWxsYWJsZSQ3O1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkJDQgPSBpc051bGxPclVuZGVmaW5lZCQ2O1xuXG4vLyBgR2V0TWV0aG9kYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0bWV0aG9kXG52YXIgZ2V0TWV0aG9kJDMgPSBmdW5jdGlvbiAoViwgUCkge1xuICB2YXIgZnVuYyA9IFZbUF07XG4gIHJldHVybiBpc051bGxPclVuZGVmaW5lZCQ0KGZ1bmMpID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlJDYoZnVuYyk7XG59O1xuXG52YXIgY2FsbCRjID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzQ2FsbGFibGUkZCA9IGlzQ2FsbGFibGUkaTtcbnZhciBpc09iamVjdCRpID0gaXNPYmplY3QkajtcblxudmFyICRUeXBlRXJyb3IkZSA9IFR5cGVFcnJvcjtcblxuLy8gYE9yZGluYXJ5VG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vcmRpbmFyeXRvcHJpbWl0aXZlXG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSQxID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAocHJlZiA9PT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZSRkKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCRpKHZhbCA9IGNhbGwkYyhmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKGlzQ2FsbGFibGUkZChmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCRpKHZhbCA9IGNhbGwkYyhmbiwgaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHByZWYgIT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUkZChmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QkaSh2YWwgPSBjYWxsJGMoZm4sIGlucHV0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IG5ldyAkVHlwZUVycm9yJGUoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG52YXIgc2hhcmVkJDcgPSB7ZXhwb3J0czoge319O1xuXG52YXIgZ2xvYmFsJGogPSBnbG9iYWwkbjtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgZGVmaW5lUHJvcGVydHkkZiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5JDEgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGRlZmluZVByb3BlcnR5JGYoZ2xvYmFsJGosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsJGpba2V5XSA9IHZhbHVlO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBnbG9iYWwkaSA9IGdsb2JhbCRuO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gZGVmaW5lR2xvYmFsUHJvcGVydHkkMTtcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlJDMgPSBnbG9iYWwkaVtTSEFSRURdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5KFNIQVJFRCwge30pO1xuXG52YXIgc2hhcmVkU3RvcmUgPSBzdG9yZSQzO1xuXG52YXIgc3RvcmUkMiA9IHNoYXJlZFN0b3JlO1xuXG4oc2hhcmVkJDcuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZSQyW2tleV0gfHwgKHN0b3JlJDJba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuMzMuMCcsXG4gIG1vZGU6ICdwdXJlJyAsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTQtMjAyMyBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KScsXG4gIGxpY2Vuc2U6ICdodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjMzLjAvTElDRU5TRScsXG4gIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xufSk7XG5cbnZhciBzaGFyZWRFeHBvcnRzID0gc2hhcmVkJDcuZXhwb3J0cztcblxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNTtcblxudmFyICRPYmplY3QkMyA9IE9iamVjdDtcblxuLy8gYFRvT2JqZWN0YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9vYmplY3RcbnZhciB0b09iamVjdCRlID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiAkT2JqZWN0JDMocmVxdWlyZU9iamVjdENvZXJjaWJsZSQzKGFyZ3VtZW50KSk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkdCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9PYmplY3QkZCA9IHRvT2JqZWN0JGU7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHVuY3VycnlUaGlzJHQoe30uaGFzT3duUHJvcGVydHkpO1xuXG4vLyBgSGFzT3duUHJvcGVydHlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1oYXNvd25wcm9wZXJ0eVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1oYXNvd24gLS0gc2FmZVxudmFyIGhhc093blByb3BlcnR5XzEgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eSh0b09iamVjdCRkKGl0KSwga2V5KTtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIGlkJDIgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xudmFyIHRvU3RyaW5nJGIgPSB1bmN1cnJ5VGhpcyRzKDEuMC50b1N0cmluZyk7XG5cbnZhciB1aWQkNCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIChrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyB0b1N0cmluZyRiKCsraWQkMiArIHBvc3RmaXgsIDM2KTtcbn07XG5cbnZhciBnbG9iYWwkaCA9IGdsb2JhbCRuO1xudmFyIHNoYXJlZCQ2ID0gc2hhcmVkRXhwb3J0cztcbnZhciBoYXNPd24kaCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdWlkJDMgPSB1aWQkNDtcbnZhciBOQVRJVkVfU1lNQk9MJDQgPSBzeW1ib2xDb25zdHJ1Y3RvckRldGVjdGlvbjtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IHVzZVN5bWJvbEFzVWlkO1xuXG52YXIgU3ltYm9sJDUgPSBnbG9iYWwkaC5TeW1ib2w7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlJDIgPSBzaGFyZWQkNignd2tzJyk7XG52YXIgY3JlYXRlV2VsbEtub3duU3ltYm9sID0gVVNFX1NZTUJPTF9BU19VSUQgPyBTeW1ib2wkNVsnZm9yJ10gfHwgU3ltYm9sJDUgOiBTeW1ib2wkNSAmJiBTeW1ib2wkNS53aXRob3V0U2V0dGVyIHx8IHVpZCQzO1xuXG52YXIgd2VsbEtub3duU3ltYm9sJG0gPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIWhhc093biRoKFdlbGxLbm93blN5bWJvbHNTdG9yZSQyLCBuYW1lKSkge1xuICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZSQyW25hbWVdID0gTkFUSVZFX1NZTUJPTCQ0ICYmIGhhc093biRoKFN5bWJvbCQ1LCBuYW1lKVxuICAgICAgPyBTeW1ib2wkNVtuYW1lXVxuICAgICAgOiBjcmVhdGVXZWxsS25vd25TeW1ib2woJ1N5bWJvbC4nICsgbmFtZSk7XG4gIH0gcmV0dXJuIFdlbGxLbm93blN5bWJvbHNTdG9yZSQyW25hbWVdO1xufTtcblxudmFyIGNhbGwkYiA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBpc09iamVjdCRoID0gaXNPYmplY3QkajtcbnZhciBpc1N5bWJvbCQ0ID0gaXNTeW1ib2wkNTtcbnZhciBnZXRNZXRob2QkMiA9IGdldE1ldGhvZCQzO1xudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSBvcmRpbmFyeVRvUHJpbWl0aXZlJDE7XG52YXIgd2VsbEtub3duU3ltYm9sJGwgPSB3ZWxsS25vd25TeW1ib2wkbTtcblxudmFyICRUeXBlRXJyb3IkZCA9IFR5cGVFcnJvcjtcbnZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2wkbCgndG9QcmltaXRpdmUnKTtcblxuLy8gYFRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcmltaXRpdmVcbnZhciB0b1ByaW1pdGl2ZSQ2ID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIGlmICghaXNPYmplY3QkaChpbnB1dCkgfHwgaXNTeW1ib2wkNChpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGV4b3RpY1RvUHJpbSA9IGdldE1ldGhvZCQyKGlucHV0LCBUT19QUklNSVRJVkUpO1xuICB2YXIgcmVzdWx0O1xuICBpZiAoZXhvdGljVG9QcmltKSB7XG4gICAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdkZWZhdWx0JztcbiAgICByZXN1bHQgPSBjYWxsJGIoZXhvdGljVG9QcmltLCBpbnB1dCwgcHJlZik7XG4gICAgaWYgKCFpc09iamVjdCRoKHJlc3VsdCkgfHwgaXNTeW1ib2wkNChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHRocm93IG5ldyAkVHlwZUVycm9yJGQoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gIH1cbiAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdudW1iZXInO1xuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XG59O1xuXG52YXIgdG9QcmltaXRpdmUkNSA9IHRvUHJpbWl0aXZlJDY7XG52YXIgaXNTeW1ib2wkMyA9IGlzU3ltYm9sJDU7XG5cbi8vIGBUb1Byb3BlcnR5S2V5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9wcm9wZXJ0eWtleVxudmFyIHRvUHJvcGVydHlLZXkkNCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUkNShhcmd1bWVudCwgJ3N0cmluZycpO1xuICByZXR1cm4gaXNTeW1ib2wkMyhrZXkpID8ga2V5IDoga2V5ICsgJyc7XG59O1xuXG52YXIgZ2xvYmFsJGcgPSBnbG9iYWwkbjtcbnZhciBpc09iamVjdCRnID0gaXNPYmplY3QkajtcblxudmFyIGRvY3VtZW50JDEgPSBnbG9iYWwkZy5kb2N1bWVudDtcbi8vIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50IGlzICdvYmplY3QnIGluIG9sZCBJRVxudmFyIEVYSVNUUyQxID0gaXNPYmplY3QkZyhkb2N1bWVudCQxKSAmJiBpc09iamVjdCRnKGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCk7XG5cbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTJDEgPyBkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkaCA9IGRlc2NyaXB0b3JzO1xudmFyIGZhaWxzJHIgPSBmYWlscyR3O1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMTtcblxuLy8gVGhhbmtzIHRvIElFOCBmb3IgaXRzIGZ1bm55IGRlZmluZVByb3BlcnR5XG52YXIgaWU4RG9tRGVmaW5lID0gIURFU0NSSVBUT1JTJGggJiYgIWZhaWxzJHIoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9PSA3O1xufSk7XG5cbnZhciBERVNDUklQVE9SUyRnID0gZGVzY3JpcHRvcnM7XG52YXIgY2FsbCRhID0gZnVuY3Rpb25DYWxsO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDIgPSBvYmplY3RQcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNCA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xudmFyIHRvSW5kZXhlZE9iamVjdCQ5ID0gdG9JbmRleGVkT2JqZWN0JGE7XG52YXIgdG9Qcm9wZXJ0eUtleSQzID0gdG9Qcm9wZXJ0eUtleSQ0O1xudmFyIGhhc093biRnID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBJRThfRE9NX0RFRklORSQxID0gaWU4RG9tRGVmaW5lO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5vYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuZiA9IERFU0NSSVBUT1JTJGcgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0JDkoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5JDMoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSQxKSB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDIoTywgUCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKGhhc093biRnKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yJDQoIWNhbGwkYShwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQyLmYsIE8sIFApLCBPW1BdKTtcbn07XG5cbnZhciBmYWlscyRxID0gZmFpbHMkdztcbnZhciBpc0NhbGxhYmxlJGMgPSBpc0NhbGxhYmxlJGk7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCQxID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gIHJldHVybiB2YWx1ZSA9PT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IGlzQ2FsbGFibGUkYyhkZXRlY3Rpb24pID8gZmFpbHMkcShkZXRlY3Rpb24pXG4gICAgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZCQxLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQkMS5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQkMS5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZCQxLlBPTFlGSUxMID0gJ1AnO1xuXG52YXIgaXNGb3JjZWRfMSA9IGlzRm9yY2VkJDE7XG5cbnZhciB1bmN1cnJ5VGhpcyRyID0gZnVuY3Rpb25VbmN1cnJ5VGhpc0NsYXVzZTtcbnZhciBhQ2FsbGFibGUkNSA9IGFDYWxsYWJsZSQ3O1xudmFyIE5BVElWRV9CSU5EJDEgPSBmdW5jdGlvbkJpbmROYXRpdmU7XG5cbnZhciBiaW5kJGUgPSB1bmN1cnJ5VGhpcyRyKHVuY3VycnlUaGlzJHIuYmluZCk7XG5cbi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGZ1bmN0aW9uQmluZENvbnRleHQgPSBmdW5jdGlvbiAoZm4sIHRoYXQpIHtcbiAgYUNhbGxhYmxlJDUoZm4pO1xuICByZXR1cm4gdGhhdCA9PT0gdW5kZWZpbmVkID8gZm4gOiBOQVRJVkVfQklORCQxID8gYmluZCRlKGZuLCB0aGF0KSA6IGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydHkgPSB7fTtcblxudmFyIERFU0NSSVBUT1JTJGYgPSBkZXNjcmlwdG9ycztcbnZhciBmYWlscyRwID0gZmFpbHMkdztcblxuLy8gVjggfiBDaHJvbWUgMzYtXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMzM0XG52YXIgdjhQcm90b3R5cGVEZWZpbmVCdWcgPSBERVNDUklQVE9SUyRmICYmIGZhaWxzJHAoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCAncHJvdG90eXBlJywge1xuICAgIHZhbHVlOiA0MixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSkucHJvdG90eXBlICE9PSA0Mjtcbn0pO1xuXG52YXIgaXNPYmplY3QkZiA9IGlzT2JqZWN0JGo7XG5cbnZhciAkU3RyaW5nJDMgPSBTdHJpbmc7XG52YXIgJFR5cGVFcnJvciRjID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBUeXBlKGFyZ3VtZW50KSBpcyBPYmplY3RgXG52YXIgYW5PYmplY3QkZCA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNPYmplY3QkZihhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IkYygkU3RyaW5nJDMoYXJndW1lbnQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkZSA9IGRlc2NyaXB0b3JzO1xudmFyIElFOF9ET01fREVGSU5FID0gaWU4RG9tRGVmaW5lO1xudmFyIFY4X1BST1RPVFlQRV9ERUZJTkVfQlVHJDEgPSB2OFByb3RvdHlwZURlZmluZUJ1ZztcbnZhciBhbk9iamVjdCRjID0gYW5PYmplY3QkZDtcbnZhciB0b1Byb3BlcnR5S2V5JDIgPSB0b1Byb3BlcnR5S2V5JDQ7XG5cbnZhciAkVHlwZUVycm9yJGIgPSBUeXBlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIEVOVU1FUkFCTEUgPSAnZW51bWVyYWJsZSc7XG52YXIgQ09ORklHVVJBQkxFJDEgPSAnY29uZmlndXJhYmxlJztcbnZhciBXUklUQUJMRSA9ICd3cml0YWJsZSc7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbm9iamVjdERlZmluZVByb3BlcnR5LmYgPSBERVNDUklQVE9SUyRlID8gVjhfUFJPVE9UWVBFX0RFRklORV9CVUckMSA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QkYyhPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMihQKTtcbiAgYW5PYmplY3QkYyhBdHRyaWJ1dGVzKTtcbiAgaWYgKHR5cGVvZiBPID09PSAnZnVuY3Rpb24nICYmIFAgPT09ICdwcm90b3R5cGUnICYmICd2YWx1ZScgaW4gQXR0cmlidXRlcyAmJiBXUklUQUJMRSBpbiBBdHRyaWJ1dGVzICYmICFBdHRyaWJ1dGVzW1dSSVRBQkxFXSkge1xuICAgIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKE8sIFApO1xuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnRbV1JJVEFCTEVdKSB7XG4gICAgICBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgICAgIEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogQ09ORklHVVJBQkxFJDEgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbQ09ORklHVVJBQkxFJDFdIDogY3VycmVudFtDT05GSUdVUkFCTEUkMV0sXG4gICAgICAgIGVudW1lcmFibGU6IEVOVU1FUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbRU5VTUVSQUJMRV0gOiBjdXJyZW50W0VOVU1FUkFCTEVdLFxuICAgICAgICB3cml0YWJsZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICB9IHJldHVybiAkZGVmaW5lUHJvcGVydHkkMShPLCBQLCBBdHRyaWJ1dGVzKTtcbn0gOiAkZGVmaW5lUHJvcGVydHkkMSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QkYyhPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkkMihQKTtcbiAgYW5PYmplY3QkYyhBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkkMShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBuZXcgJFR5cGVFcnJvciRiKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgREVTQ1JJUFRPUlMkZCA9IGRlc2NyaXB0b3JzO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDMgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMyA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xuXG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDYgPSBERVNDUklQVE9SUyRkID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUkMy5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbnZhciBnbG9iYWwkZiA9IGdsb2JhbCRuO1xudmFyIGFwcGx5JDQgPSBmdW5jdGlvbkFwcGx5O1xudmFyIHVuY3VycnlUaGlzJHEgPSBmdW5jdGlvblVuY3VycnlUaGlzQ2xhdXNlO1xudmFyIGlzQ2FsbGFibGUkYiA9IGlzQ2FsbGFibGUkaTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkOCA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mO1xudmFyIGlzRm9yY2VkID0gaXNGb3JjZWRfMTtcbnZhciBwYXRoJHUgPSBwYXRoJHc7XG52YXIgYmluZCRkID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNSA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2O1xudmFyIGhhc093biRmID0gaGFzT3duUHJvcGVydHlfMTtcblxudmFyIHdyYXBDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChOYXRpdmVDb25zdHJ1Y3Rvcikge1xuICB2YXIgV3JhcHBlciA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBXcmFwcGVyKSB7XG4gICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCk7XG4gICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcihhKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGEsIGIpO1xuICAgICAgfSByZXR1cm4gbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGEsIGIsIGMpO1xuICAgIH0gcmV0dXJuIGFwcGx5JDQoTmF0aXZlQ29uc3RydWN0b3IsIHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIFdyYXBwZXIucHJvdG90eXBlID0gTmF0aXZlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICByZXR1cm4gV3JhcHBlcjtcbn07XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAgICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMuZG9udENhbGxHZXRTZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4gIG9wdGlvbnMubmFtZSAgICAgICAgICAgLSB0aGUgLm5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlmIGl0IGRvZXMgbm90IG1hdGNoIHRoZSBrZXlcbiovXG52YXIgX2V4cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcbiAgdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuICB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gIHZhciBTVEFUSUMgPSBvcHRpb25zLnN0YXQ7XG4gIHZhciBQUk9UTyA9IG9wdGlvbnMucHJvdG87XG5cbiAgdmFyIG5hdGl2ZVNvdXJjZSA9IEdMT0JBTCA/IGdsb2JhbCRmIDogU1RBVElDID8gZ2xvYmFsJGZbVEFSR0VUXSA6IChnbG9iYWwkZltUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG5cbiAgdmFyIHRhcmdldCA9IEdMT0JBTCA/IHBhdGgkdSA6IHBhdGgkdVtUQVJHRVRdIHx8IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KHBhdGgkdSwgVEFSR0VULCB7fSlbVEFSR0VUXTtcbiAgdmFyIHRhcmdldFByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG5cbiAgdmFyIEZPUkNFRCwgVVNFX05BVElWRSwgVklSVFVBTF9QUk9UT1RZUEU7XG4gIHZhciBrZXksIHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSwgbmF0aXZlUHJvcGVydHksIHJlc3VsdFByb3BlcnR5LCBkZXNjcmlwdG9yO1xuXG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgVVNFX05BVElWRSA9ICFGT1JDRUQgJiYgbmF0aXZlU291cmNlICYmIGhhc093biRmKG5hdGl2ZVNvdXJjZSwga2V5KTtcblxuICAgIHRhcmdldFByb3BlcnR5ID0gdGFyZ2V0W2tleV07XG5cbiAgICBpZiAoVVNFX05BVElWRSkgaWYgKG9wdGlvbnMuZG9udENhbGxHZXRTZXQpIHtcbiAgICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkOChuYXRpdmVTb3VyY2UsIGtleSk7XG4gICAgICBuYXRpdmVQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgbmF0aXZlUHJvcGVydHkgPSBuYXRpdmVTb3VyY2Vba2V5XTtcblxuICAgIC8vIGV4cG9ydCBuYXRpdmUgb3IgaW1wbGVtZW50YXRpb25cbiAgICBzb3VyY2VQcm9wZXJ0eSA9IChVU0VfTkFUSVZFICYmIG5hdGl2ZVByb3BlcnR5KSA/IG5hdGl2ZVByb3BlcnR5IDogc291cmNlW2tleV07XG5cbiAgICBpZiAoVVNFX05BVElWRSAmJiB0eXBlb2YgdGFyZ2V0UHJvcGVydHkgPT0gdHlwZW9mIHNvdXJjZVByb3BlcnR5KSBjb250aW51ZTtcblxuICAgIC8vIGJpbmQgbWV0aG9kcyB0byBnbG9iYWwgZm9yIGNhbGxpbmcgZnJvbSBleHBvcnQgY29udGV4dFxuICAgIGlmIChvcHRpb25zLmJpbmQgJiYgVVNFX05BVElWRSkgcmVzdWx0UHJvcGVydHkgPSBiaW5kJGQoc291cmNlUHJvcGVydHksIGdsb2JhbCRmKTtcbiAgICAvLyB3cmFwIGdsb2JhbCBjb25zdHJ1Y3RvcnMgZm9yIHByZXZlbnQgY2hhbmdlcyBpbiB0aGlzIHZlcnNpb25cbiAgICBlbHNlIGlmIChvcHRpb25zLndyYXAgJiYgVVNFX05BVElWRSkgcmVzdWx0UHJvcGVydHkgPSB3cmFwQ29uc3RydWN0b3Ioc291cmNlUHJvcGVydHkpO1xuICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kc1xuICAgIGVsc2UgaWYgKFBST1RPICYmIGlzQ2FsbGFibGUkYihzb3VyY2VQcm9wZXJ0eSkpIHJlc3VsdFByb3BlcnR5ID0gdW5jdXJyeVRoaXMkcShzb3VyY2VQcm9wZXJ0eSk7XG4gICAgLy8gZGVmYXVsdCBjYXNlXG4gICAgZWxzZSByZXN1bHRQcm9wZXJ0eSA9IHNvdXJjZVByb3BlcnR5O1xuXG4gICAgLy8gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICAgIGlmIChvcHRpb25zLnNoYW0gfHwgKHNvdXJjZVByb3BlcnR5ICYmIHNvdXJjZVByb3BlcnR5LnNoYW0pIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUocmVzdWx0UHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUodGFyZ2V0LCBrZXksIHJlc3VsdFByb3BlcnR5KTtcblxuICAgIGlmIChQUk9UTykge1xuICAgICAgVklSVFVBTF9QUk9UT1RZUEUgPSBUQVJHRVQgKyAnUHJvdG90eXBlJztcbiAgICAgIGlmICghaGFzT3duJGYocGF0aCR1LCBWSVJUVUFMX1BST1RPVFlQRSkpIHtcbiAgICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDUocGF0aCR1LCBWSVJUVUFMX1BST1RPVFlQRSwge30pO1xuICAgICAgfVxuICAgICAgLy8gZXhwb3J0IHZpcnR1YWwgcHJvdG90eXBlIG1ldGhvZHNcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ1KHBhdGgkdVtWSVJUVUFMX1BST1RPVFlQRV0sIGtleSwgc291cmNlUHJvcGVydHkpO1xuICAgICAgLy8gZXhwb3J0IHJlYWwgcHJvdG90eXBlIG1ldGhvZHNcbiAgICAgIGlmIChvcHRpb25zLnJlYWwgJiYgdGFyZ2V0UHJvdG90eXBlICYmIChGT1JDRUQgfHwgIXRhcmdldFByb3RvdHlwZVtrZXldKSkge1xuICAgICAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNSh0YXJnZXRQcm90b3R5cGUsIGtleSwgc291cmNlUHJvcGVydHkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IkMSA9IE1hdGguZmxvb3I7XG5cbi8vIGBNYXRoLnRydW5jYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWF0aC50cnVuY1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW1hdGgtdHJ1bmMgLS0gc2FmZVxudmFyIG1hdGhUcnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gdHJ1bmMoeCkge1xuICB2YXIgbiA9ICt4O1xuICByZXR1cm4gKG4gPiAwID8gZmxvb3IkMSA6IGNlaWwpKG4pO1xufTtcblxudmFyIHRydW5jID0gbWF0aFRydW5jO1xuXG4vLyBgVG9JbnRlZ2VyT3JJbmZpbml0eWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvaW50ZWdlcm9yaW5maW5pdHlcbnZhciB0b0ludGVnZXJPckluZmluaXR5JDQgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIG51bWJlciA9ICthcmd1bWVudDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgcmV0dXJuIG51bWJlciAhPT0gbnVtYmVyIHx8IG51bWJlciA9PT0gMCA/IDAgOiB0cnVuYyhudW1iZXIpO1xufTtcblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkkMyA9IHRvSW50ZWdlck9ySW5maW5pdHkkNDtcblxudmFyIG1heCQzID0gTWF0aC5tYXg7XG52YXIgbWluJDIgPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxudmFyIHRvQWJzb2x1dGVJbmRleCQ1ID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgdmFyIGludGVnZXIgPSB0b0ludGVnZXJPckluZmluaXR5JDMoaW5kZXgpO1xuICByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgkMyhpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbiQyKGludGVnZXIsIGxlbmd0aCk7XG59O1xuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQyID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ0O1xuXG52YXIgbWluJDEgPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9sZW5ndGhcbnZhciB0b0xlbmd0aCQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4kMSh0b0ludGVnZXJPckluZmluaXR5JDIoYXJndW1lbnQpLCAweDFGRkZGRkZGRkZGRkZGKSA6IDA7IC8vIDIgKiogNTMgLSAxID09IDkwMDcxOTkyNTQ3NDA5OTFcbn07XG5cbnZhciB0b0xlbmd0aCA9IHRvTGVuZ3RoJDE7XG5cbi8vIGBMZW5ndGhPZkFycmF5TGlrZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxlbmd0aG9mYXJyYXlsaWtlXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkYyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHRvTGVuZ3RoKG9iai5sZW5ndGgpO1xufTtcblxudmFyIHRvSW5kZXhlZE9iamVjdCQ4ID0gdG9JbmRleGVkT2JqZWN0JGE7XG52YXIgdG9BYnNvbHV0ZUluZGV4JDQgPSB0b0Fic29sdXRlSW5kZXgkNTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSRiID0gbGVuZ3RoT2ZBcnJheUxpa2UkYztcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QkNCA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QkOCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJGIoTyk7XG4gICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4JDQoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT09IGVsKSB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUgLS0gTmFOIGNoZWNrXG4gICAgICBpZiAodmFsdWUgIT09IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxudmFyIGFycmF5SW5jbHVkZXMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kJDQodHJ1ZSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiAgaW5kZXhPZjogY3JlYXRlTWV0aG9kJDQoZmFsc2UpXG59O1xuXG52YXIgaGlkZGVuS2V5cyQ2ID0ge307XG5cbnZhciB1bmN1cnJ5VGhpcyRwID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBoYXNPd24kZSA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdG9JbmRleGVkT2JqZWN0JDcgPSB0b0luZGV4ZWRPYmplY3QkYTtcbnZhciBpbmRleE9mJDQgPSBhcnJheUluY2x1ZGVzLmluZGV4T2Y7XG52YXIgaGlkZGVuS2V5cyQ1ID0gaGlkZGVuS2V5cyQ2O1xuXG52YXIgcHVzaCRiID0gdW5jdXJyeVRoaXMkcChbXS5wdXNoKTtcblxudmFyIG9iamVjdEtleXNJbnRlcm5hbCA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0JDcob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pICFoYXNPd24kZShoaWRkZW5LZXlzJDUsIGtleSkgJiYgaGFzT3duJGUoTywga2V5KSAmJiBwdXNoJGIocmVzdWx0LCBrZXkpO1xuICAvLyBEb24ndCBlbnVtIGJ1ZyAmIGhpZGRlbiBrZXlzXG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSBpZiAoaGFzT3duJGUoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZiQ0KHJlc3VsdCwga2V5KSB8fCBwdXNoJGIocmVzdWx0LCBrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbnZhciBlbnVtQnVnS2V5cyQzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyQxID0gb2JqZWN0S2V5c0ludGVybmFsO1xudmFyIGVudW1CdWdLZXlzJDIgPSBlbnVtQnVnS2V5cyQzO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1rZXlzIC0tIHNhZmVcbnZhciBvYmplY3RLZXlzJDMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyQxKE8sIGVudW1CdWdLZXlzJDIpO1xufTtcblxudmFyIG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scyA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSBzYWZlXG5vYmplY3RHZXRPd25Qcm9wZXJ0eVN5bWJvbHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbnZhciBERVNDUklQVE9SUyRjID0gZGVzY3JpcHRvcnM7XG52YXIgdW5jdXJyeVRoaXMkbyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgY2FsbCQ5ID0gZnVuY3Rpb25DYWxsO1xudmFyIGZhaWxzJG8gPSBmYWlscyR3O1xudmFyIG9iamVjdEtleXMkMiA9IG9iamVjdEtleXMkMztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMyA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSQxID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgdG9PYmplY3QkYyA9IHRvT2JqZWN0JGU7XG52YXIgSW5kZXhlZE9iamVjdCQyID0gaW5kZXhlZE9iamVjdDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1hc3NpZ24gLS0gc2FmZVxudmFyICRhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIGRlZmluZVByb3BlcnR5JGUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgY29uY2F0JDYgPSB1bmN1cnJ5VGhpcyRvKFtdLmNvbmNhdCk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxudmFyIG9iamVjdEFzc2lnbiA9ICEkYXNzaWduIHx8IGZhaWxzJG8oZnVuY3Rpb24gKCkge1xuICAvLyBzaG91bGQgaGF2ZSBjb3JyZWN0IG9yZGVyIG9mIG9wZXJhdGlvbnMgKEVkZ2UgYnVnKVxuICBpZiAoREVTQ1JJUFRPUlMkYyAmJiAkYXNzaWduKHsgYjogMSB9LCAkYXNzaWduKGRlZmluZVByb3BlcnR5JGUoe30sICdhJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSRlKHRoaXMsICdiJywge1xuICAgICAgICB2YWx1ZTogMyxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSksIHsgYjogMiB9KSkuYiAhPT0gMSkgcmV0dXJuIHRydWU7XG4gIC8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxuICB2YXIgQSA9IHt9O1xuICB2YXIgQiA9IHt9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tc3ltYm9sIC0tIHNhZmVcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgnYXNzaWduIGRldGVjdGlvbicpO1xuICB2YXIgYWxwaGFiZXQgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3QnO1xuICBBW3N5bWJvbF0gPSA3O1xuICBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7IEJbY2hyXSA9IGNocjsgfSk7XG4gIHJldHVybiAkYXNzaWduKHt9LCBBKVtzeW1ib2xdICE9PSA3IHx8IG9iamVjdEtleXMkMigkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT09IGFscGhhYmV0O1xufSkgPyBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2UpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIHZhciBUID0gdG9PYmplY3QkYyh0YXJnZXQpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSQzLmY7XG4gIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlJDEuZjtcbiAgd2hpbGUgKGFyZ3VtZW50c0xlbmd0aCA+IGluZGV4KSB7XG4gICAgdmFyIFMgPSBJbmRleGVkT2JqZWN0JDIoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdCQ2KG9iamVjdEtleXMkMihTKSwgZ2V0T3duUHJvcGVydHlTeW1ib2xzKFMpKSA6IG9iamVjdEtleXMkMihTKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGopIHtcbiAgICAgIGtleSA9IGtleXNbaisrXTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMkYyB8fCBjYWxsJDkocHJvcGVydHlJc0VudW1lcmFibGUsIFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogJGFzc2lnbjtcblxudmFyICQkTyA9IF9leHBvcnQ7XG52YXIgYXNzaWduJDUgPSBvYmplY3RBc3NpZ247XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmFzc2lnblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1hc3NpZ24gLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiQkTyh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGFyaXR5OiAyLCBmb3JjZWQ6IE9iamVjdC5hc3NpZ24gIT09IGFzc2lnbiQ1IH0sIHtcbiAgYXNzaWduOiBhc3NpZ24kNVxufSk7XG5cbnZhciBwYXRoJHQgPSBwYXRoJHc7XG5cbnZhciBhc3NpZ24kNCA9IHBhdGgkdC5PYmplY3QuYXNzaWduO1xuXG52YXIgcGFyZW50JDFiID0gYXNzaWduJDQ7XG5cbnZhciBhc3NpZ24kMyA9IHBhcmVudCQxYjtcblxudmFyIGFzc2lnbiQyID0gYXNzaWduJDM7XG5cbnZhciBfT2JqZWN0JGFzc2lnbiA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhhc3NpZ24kMik7XG5cbnZhciB1bmN1cnJ5VGhpcyRuID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyIGFycmF5U2xpY2UkNSA9IHVuY3VycnlUaGlzJG4oW10uc2xpY2UpO1xuXG52YXIgdW5jdXJyeVRoaXMkbSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgYUNhbGxhYmxlJDQgPSBhQ2FsbGFibGUkNztcbnZhciBpc09iamVjdCRlID0gaXNPYmplY3QkajtcbnZhciBoYXNPd24kZCA9IGhhc093blByb3BlcnR5XzE7XG52YXIgYXJyYXlTbGljZSQ0ID0gYXJyYXlTbGljZSQ1O1xudmFyIE5BVElWRV9CSU5EID0gZnVuY3Rpb25CaW5kTmF0aXZlO1xuXG52YXIgJEZ1bmN0aW9uID0gRnVuY3Rpb247XG52YXIgY29uY2F0JDUgPSB1bmN1cnJ5VGhpcyRtKFtdLmNvbmNhdCk7XG52YXIgam9pbiA9IHVuY3VycnlUaGlzJG0oW10uam9pbik7XG52YXIgZmFjdG9yaWVzID0ge307XG5cbnZhciBjb25zdHJ1Y3QkNCA9IGZ1bmN0aW9uIChDLCBhcmdzTGVuZ3RoLCBhcmdzKSB7XG4gIGlmICghaGFzT3duJGQoZmFjdG9yaWVzLCBhcmdzTGVuZ3RoKSkge1xuICAgIHZhciBsaXN0ID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgYXJnc0xlbmd0aDsgaSsrKSBsaXN0W2ldID0gJ2FbJyArIGkgKyAnXSc7XG4gICAgZmFjdG9yaWVzW2FyZ3NMZW5ndGhdID0gJEZ1bmN0aW9uKCdDLGEnLCAncmV0dXJuIG5ldyBDKCcgKyBqb2luKGxpc3QsICcsJykgKyAnKScpO1xuICB9IHJldHVybiBmYWN0b3JpZXNbYXJnc0xlbmd0aF0oQywgYXJncyk7XG59O1xuXG4vLyBgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWZ1bmN0aW9uLXByb3RvdHlwZS1iaW5kIC0tIGRldGVjdGlvblxudmFyIGZ1bmN0aW9uQmluZCA9IE5BVElWRV9CSU5EID8gJEZ1bmN0aW9uLmJpbmQgOiBmdW5jdGlvbiBiaW5kKHRoYXQgLyogLCAuLi5hcmdzICovKSB7XG4gIHZhciBGID0gYUNhbGxhYmxlJDQodGhpcyk7XG4gIHZhciBQcm90b3R5cGUgPSBGLnByb3RvdHlwZTtcbiAgdmFyIHBhcnRBcmdzID0gYXJyYXlTbGljZSQ0KGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZEZ1bmN0aW9uID0gZnVuY3Rpb24gYm91bmQoLyogYXJncy4uLiAqLykge1xuICAgIHZhciBhcmdzID0gY29uY2F0JDUocGFydEFyZ3MsIGFycmF5U2xpY2UkNChhcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIGJvdW5kRnVuY3Rpb24gPyBjb25zdHJ1Y3QkNChGLCBhcmdzLmxlbmd0aCwgYXJncykgOiBGLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9O1xuICBpZiAoaXNPYmplY3QkZShQcm90b3R5cGUpKSBib3VuZEZ1bmN0aW9uLnByb3RvdHlwZSA9IFByb3RvdHlwZTtcbiAgcmV0dXJuIGJvdW5kRnVuY3Rpb247XG59O1xuXG4vLyBUT0RPOiBSZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxudmFyICQkTiA9IF9leHBvcnQ7XG52YXIgYmluZCRjID0gZnVuY3Rpb25CaW5kO1xuXG4vLyBgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWZ1bmN0aW9uLXByb3RvdHlwZS1iaW5kIC0tIGRldGVjdGlvblxuJCROKHsgdGFyZ2V0OiAnRnVuY3Rpb24nLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGdW5jdGlvbi5iaW5kICE9PSBiaW5kJGMgfSwge1xuICBiaW5kOiBiaW5kJGNcbn0pO1xuXG52YXIgcGF0aCRzID0gcGF0aCR3O1xuXG52YXIgZW50cnlWaXJ0dWFsJGkgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1IpIHtcbiAgcmV0dXJuIHBhdGgkc1tDT05TVFJVQ1RPUiArICdQcm90b3R5cGUnXTtcbn07XG5cbnZhciBlbnRyeVZpcnR1YWwkaCA9IGVudHJ5VmlydHVhbCRpO1xuXG52YXIgYmluZCRiID0gZW50cnlWaXJ0dWFsJGgoJ0Z1bmN0aW9uJykuYmluZDtcblxudmFyIGlzUHJvdG90eXBlT2YkaiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJGYgPSBiaW5kJGI7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSQyID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuXG52YXIgYmluZCRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5iaW5kO1xuICByZXR1cm4gaXQgPT09IEZ1bmN0aW9uUHJvdG90eXBlJDIgfHwgKGlzUHJvdG90eXBlT2YkaihGdW5jdGlvblByb3RvdHlwZSQyLCBpdCkgJiYgb3duID09PSBGdW5jdGlvblByb3RvdHlwZSQyLmJpbmQpID8gbWV0aG9kJGYgOiBvd247XG59O1xuXG52YXIgcGFyZW50JDFhID0gYmluZCRhO1xuXG52YXIgYmluZCQ5ID0gcGFyZW50JDFhO1xuXG52YXIgYmluZCQ4ID0gYmluZCQ5O1xuXG52YXIgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoYmluZCQ4KTtcblxuLyoqXHJcbiAqIERyYXcgYSBjaXJjbGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gciAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZS5cclxuICovXG5mdW5jdGlvbiBkcmF3Q2lyY2xlKGN0eCwgeCwgeSwgcikge1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgciwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuLyoqXHJcbiAqIERyYXcgYSBzcXVhcmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gciAtIEhhbGYgb2YgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHNxdWFyZS5cclxuICovXG5mdW5jdGlvbiBkcmF3U3F1YXJlKGN0eCwgeCwgeSwgcikge1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5yZWN0KHggLSByLCB5IC0gciwgciAqIDIsIHIgKiAyKTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuLyoqXHJcbiAqIERyYXcgYW4gZXF1aWxhdGVyYWwgdHJpYW5nbGUgc3RhbmRpbmcgb24gYSBzaWRlLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHIgLSBIYWxmIG9mIHRoZSBsZW5ndGggb2YgdGhlIHNpZGVzLlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VxdWlsYXRlcmFsX3RyaWFuZ2xlXHJcbiAqL1xuZnVuY3Rpb24gZHJhd1RyaWFuZ2xlKGN0eCwgeCwgeSwgcikge1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIC8vIHRoZSBjaGFuZ2UgaW4gcmFkaXVzIGFuZCB0aGUgb2Zmc2V0IGlzIGhlcmUgdG8gY2VudGVyIHRoZSBzaGFwZVxuICByICo9IDEuMTU7XG4gIHkgKz0gMC4yNzUgKiByO1xuICB2YXIgcyA9IHIgKiAyO1xuICB2YXIgczIgPSBzIC8gMjtcbiAgdmFyIGlyID0gTWF0aC5zcXJ0KDMpIC8gNiAqIHM7IC8vIHJhZGl1cyBvZiBpbm5lciBjaXJjbGVcbiAgdmFyIGggPSBNYXRoLnNxcnQocyAqIHMgLSBzMiAqIHMyKTsgLy8gaGVpZ2h0XG4gIGN0eC5tb3ZlVG8oeCwgeSAtIChoIC0gaXIpKTtcbiAgY3R4LmxpbmVUbyh4ICsgczIsIHkgKyBpcik7XG4gIGN0eC5saW5lVG8oeCAtIHMyLCB5ICsgaXIpO1xuICBjdHgubGluZVRvKHgsIHkgLSAoaCAtIGlyKSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbi8qKlxyXG4gKiBEcmF3IGFuIGVxdWlsYXRlcmFsIHRyaWFuZ2xlIHN0YW5kaW5nIG9uIGEgdmVydGV4LlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHIgLSBIYWxmIG9mIHRoZSBsZW5ndGggb2YgdGhlIHNpZGVzLlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0VxdWlsYXRlcmFsX3RyaWFuZ2xlXHJcbiAqL1xuZnVuY3Rpb24gZHJhd1RyaWFuZ2xlRG93bihjdHgsIHgsIHksIHIpIHtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICAvLyB0aGUgY2hhbmdlIGluIHJhZGl1cyBhbmQgdGhlIG9mZnNldCBpcyBoZXJlIHRvIGNlbnRlciB0aGUgc2hhcGVcbiAgciAqPSAxLjE1O1xuICB5IC09IDAuMjc1ICogcjtcbiAgdmFyIHMgPSByICogMjtcbiAgdmFyIHMyID0gcyAvIDI7XG4gIHZhciBpciA9IE1hdGguc3FydCgzKSAvIDYgKiBzOyAvLyByYWRpdXMgb2YgaW5uZXIgY2lyY2xlXG4gIHZhciBoID0gTWF0aC5zcXJ0KHMgKiBzIC0gczIgKiBzMik7IC8vIGhlaWdodFxuICBjdHgubW92ZVRvKHgsIHkgKyAoaCAtIGlyKSk7XG4gIGN0eC5saW5lVG8oeCArIHMyLCB5IC0gaXIpO1xuICBjdHgubGluZVRvKHggLSBzMiwgeSAtIGlyKTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgKGggLSBpcikpO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhIHN0YXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gciAtIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIHN0YXIuXHJcbiAqL1xuZnVuY3Rpb24gZHJhd1N0YXIoY3R4LCB4LCB5LCByKSB7XG4gIC8vIGh0dHA6Ly93d3cuaHRtbDVjYW52YXN0dXRvcmlhbHMuY29tL2xhYnMvaHRtbDUtY2FudmFzLXN0YXItc3Bpbm5lci9cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICAvLyB0aGUgY2hhbmdlIGluIHJhZGl1cyBhbmQgdGhlIG9mZnNldCBpcyBoZXJlIHRvIGNlbnRlciB0aGUgc2hhcGVcbiAgciAqPSAwLjgyO1xuICB5ICs9IDAuMSAqIHI7XG4gIGZvciAodmFyIG4gPSAwOyBuIDwgMTA7IG4rKykge1xuICAgIHZhciByYWRpdXMgPSBuICUgMiA9PT0gMCA/IHIgKiAxLjMgOiByICogMC41O1xuICAgIGN0eC5saW5lVG8oeCArIHJhZGl1cyAqIE1hdGguc2luKG4gKiAyICogTWF0aC5QSSAvIDEwKSwgeSAtIHJhZGl1cyAqIE1hdGguY29zKG4gKiAyICogTWF0aC5QSSAvIDEwKSk7XG4gIH1cbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuLyoqXHJcbiAqIERyYXcgYSBkaWFtb25kLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHIgLSBIYWxmIG9mIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBkaWFtb25kLlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBodHRwOi8vd3d3Lmh0bWw1Y2FudmFzdHV0b3JpYWxzLmNvbS9sYWJzL2h0bWw1LWNhbnZhcy1zdGFyLXNwaW5uZXIvXHJcbiAqL1xuZnVuY3Rpb24gZHJhd0RpYW1vbmQoY3R4LCB4LCB5LCByKSB7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgcik7XG4gIGN0eC5saW5lVG8oeCArIHIsIHkpO1xuICBjdHgubGluZVRvKHgsIHkgLSByKTtcbiAgY3R4LmxpbmVUbyh4IC0gciwgeSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbi8qKlxyXG4gKiBEcmF3IGEgcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhpcyBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIHRvLlxyXG4gKiBAcGFyYW0geCAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB4IGF4aXMuXHJcbiAqIEBwYXJhbSB5IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHcgLSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZS5cclxuICogQHBhcmFtIGggLSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUuXHJcbiAqIEBwYXJhbSByIC0gVGhlIHJhZGl1cyBvZiB0aGUgY29ybmVycy5cclxuICogQHJlbWFya3NcclxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjU1NTEyL2hvdy10by1kcmF3LWEtcm91bmRlZC1yZWN0YW5nbGUtb24taHRtbC1jYW52YXNcclxuICovXG5mdW5jdGlvbiBkcmF3Um91bmRSZWN0KGN0eCwgeCwgeSwgdywgaCwgcikge1xuICB2YXIgcjJkID0gTWF0aC5QSSAvIDE4MDtcbiAgaWYgKHcgLSAyICogciA8IDApIHtcbiAgICByID0gdyAvIDI7XG4gIH0gLy9lbnN1cmUgdGhhdCB0aGUgcmFkaXVzIGlzbid0IHRvbyBsYXJnZSBmb3IgeFxuICBpZiAoaCAtIDIgKiByIDwgMCkge1xuICAgIHIgPSBoIC8gMjtcbiAgfSAvL2Vuc3VyZSB0aGF0IHRoZSByYWRpdXMgaXNuJ3QgdG9vIGxhcmdlIGZvciB5XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4Lm1vdmVUbyh4ICsgciwgeSk7XG4gIGN0eC5saW5lVG8oeCArIHcgLSByLCB5KTtcbiAgY3R4LmFyYyh4ICsgdyAtIHIsIHkgKyByLCByLCByMmQgKiAyNzAsIHIyZCAqIDM2MCwgZmFsc2UpO1xuICBjdHgubGluZVRvKHggKyB3LCB5ICsgaCAtIHIpO1xuICBjdHguYXJjKHggKyB3IC0gciwgeSArIGggLSByLCByLCAwLCByMmQgKiA5MCwgZmFsc2UpO1xuICBjdHgubGluZVRvKHggKyByLCB5ICsgaCk7XG4gIGN0eC5hcmMoeCArIHIsIHkgKyBoIC0gciwgciwgcjJkICogOTAsIHIyZCAqIDE4MCwgZmFsc2UpO1xuICBjdHgubGluZVRvKHgsIHkgKyByKTtcbiAgY3R4LmFyYyh4ICsgciwgeSArIHIsIHIsIHIyZCAqIDE4MCwgcjJkICogMjcwLCBmYWxzZSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbi8qKlxyXG4gKiBEcmF3IGFuIGVsbGlwc2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gdyAtIFRoZSB3aWR0aCBvZiB0aGUgZWxsaXBzZS5cclxuICogQHBhcmFtIGggLSBUaGUgaGVpZ2h0IG9mIHRoZSBlbGxpcHNlLlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIxNzI3OTgvaG93LXRvLWRyYXctYW4tb3ZhbC1pbi1odG1sNS1jYW52YXNcclxuICpcclxuICogUG9zdGZpeCAnX3ZpcycgYWRkZWQgdG8gZGlzY2VybiBpdCBmcm9tIHN0YW5kYXJkIG1ldGhvZCBlbGxpcHNlKCkuXHJcbiAqL1xuZnVuY3Rpb24gZHJhd0VsbGlwc2UoY3R4LCB4LCB5LCB3LCBoKSB7XG4gIHZhciBrYXBwYSA9IDAuNTUyMjg0OCxcbiAgICBveCA9IHcgLyAyICoga2FwcGEsXG4gICAgLy8gY29udHJvbCBwb2ludCBvZmZzZXQgaG9yaXpvbnRhbFxuICAgIG95ID0gaCAvIDIgKiBrYXBwYSxcbiAgICAvLyBjb250cm9sIHBvaW50IG9mZnNldCB2ZXJ0aWNhbFxuICAgIHhlID0geCArIHcsXG4gICAgLy8geC1lbmRcbiAgICB5ZSA9IHkgKyBoLFxuICAgIC8vIHktZW5kXG4gICAgeG0gPSB4ICsgdyAvIDIsXG4gICAgLy8geC1taWRkbGVcbiAgICB5bSA9IHkgKyBoIC8gMjsgLy8geS1taWRkbGVcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKHgsIHltKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeCwgeW0gLSBveSwgeG0gLSBveCwgeSwgeG0sIHkpO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4bSArIG94LCB5LCB4ZSwgeW0gLSBveSwgeGUsIHltKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeGUsIHltICsgb3ksIHhtICsgb3gsIHllLCB4bSwgeWUpO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgeCwgeW0gKyBveSwgeCwgeW0pO1xuICBjdHguY2xvc2VQYXRoKCk7XG59XG4vKipcclxuICogRHJhdyBhbiBpc29tZXRyaWMgY3lsaW5kZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGlzIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgdG8uXHJcbiAqIEBwYXJhbSB4IC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBjZW50ZXIgb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeSBheGlzLlxyXG4gKiBAcGFyYW0gdyAtIFRoZSB3aWR0aCBvZiB0aGUgZGF0YWJhc2UuXHJcbiAqIEBwYXJhbSBoIC0gVGhlIGhlaWdodCBvZiB0aGUgZGF0YWJhc2UuXHJcbiAqIEByZW1hcmtzXHJcbiAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjE3Mjc5OC9ob3ctdG8tZHJhdy1hbi1vdmFsLWluLWh0bWw1LWNhbnZhc1xyXG4gKi9cbmZ1bmN0aW9uIGRyYXdEYXRhYmFzZShjdHgsIHgsIHksIHcsIGgpIHtcbiAgdmFyIGYgPSAxIC8gMztcbiAgdmFyIHdFbGxpcHNlID0gdztcbiAgdmFyIGhFbGxpcHNlID0gaCAqIGY7XG4gIHZhciBrYXBwYSA9IDAuNTUyMjg0OCxcbiAgICBveCA9IHdFbGxpcHNlIC8gMiAqIGthcHBhLFxuICAgIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IGhvcml6b250YWxcbiAgICBveSA9IGhFbGxpcHNlIC8gMiAqIGthcHBhLFxuICAgIC8vIGNvbnRyb2wgcG9pbnQgb2Zmc2V0IHZlcnRpY2FsXG4gICAgeGUgPSB4ICsgd0VsbGlwc2UsXG4gICAgLy8geC1lbmRcbiAgICB5ZSA9IHkgKyBoRWxsaXBzZSxcbiAgICAvLyB5LWVuZFxuICAgIHhtID0geCArIHdFbGxpcHNlIC8gMixcbiAgICAvLyB4LW1pZGRsZVxuICAgIHltID0geSArIGhFbGxpcHNlIC8gMixcbiAgICAvLyB5LW1pZGRsZVxuICAgIHltYiA9IHkgKyAoaCAtIGhFbGxpcHNlIC8gMiksXG4gICAgLy8geS1taWRsbGUsIGJvdHRvbSBlbGxpcHNlXG4gICAgeWViID0geSArIGg7IC8vIHktZW5kLCBib3R0b20gZWxsaXBzZVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5tb3ZlVG8oeGUsIHltKTtcbiAgY3R4LmJlemllckN1cnZlVG8oeGUsIHltICsgb3ksIHhtICsgb3gsIHllLCB4bSwgeWUpO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4bSAtIG94LCB5ZSwgeCwgeW0gKyBveSwgeCwgeW0pO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5bSAtIG95LCB4bSAtIG94LCB5LCB4bSwgeSk7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHhtICsgb3gsIHksIHhlLCB5bSAtIG95LCB4ZSwgeW0pO1xuICBjdHgubGluZVRvKHhlLCB5bWIpO1xuICBjdHguYmV6aWVyQ3VydmVUbyh4ZSwgeW1iICsgb3ksIHhtICsgb3gsIHllYiwgeG0sIHllYik7XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKHhtIC0gb3gsIHllYiwgeCwgeW1iICsgb3ksIHgsIHltYik7XG4gIGN0eC5saW5lVG8oeCwgeW0pO1xufVxuLyoqXHJcbiAqIERyYXcgYSBkYXNoZWQgbGluZS5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgc3RhcnQgcG9zaXRpb24gb24gdGhlIHggYXhpcy5cclxuICogQHBhcmFtIHkgLSBUaGUgc3RhcnQgcG9zaXRpb24gb24gdGhlIHkgYXhpcy5cclxuICogQHBhcmFtIHgyIC0gVGhlIGVuZCBwb3NpdGlvbiBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geTIgLSBUaGUgZW5kIHBvc2l0aW9uIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSBwYXR0ZXJuIC0gTGlzdCBvZiBsZW5ndGhzIHN0YXJ0aW5nIHdpdGggbGluZSBhbmQgdGhlbiBhbHRlcm5hdGluZyBiZXR3ZWVuIHNwYWNlIGFuZCBsaW5lLlxyXG4gKiBAYXV0aG9yIERhdmlkIEpvcmRhblxyXG4gKiBAcmVtYXJrc1xyXG4gKiBkYXRlIDIwMTItMDgtMDhcclxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80NTc2NzI0L2RvdHRlZC1zdHJva2UtaW4tY2FudmFzXHJcbiAqL1xuZnVuY3Rpb24gZHJhd0Rhc2hlZExpbmUoY3R4LCB4LCB5LCB4MiwgeTIsIHBhdHRlcm4pIHtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgubW92ZVRvKHgsIHkpO1xuICB2YXIgcGF0dGVybkxlbmd0aCA9IHBhdHRlcm4ubGVuZ3RoO1xuICB2YXIgZHggPSB4MiAtIHg7XG4gIHZhciBkeSA9IHkyIC0geTtcbiAgdmFyIHNsb3BlID0gZHkgLyBkeDtcbiAgdmFyIGRpc3RSZW1haW5pbmcgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICB2YXIgcGF0dGVybkluZGV4ID0gMDtcbiAgdmFyIGRyYXcgPSB0cnVlO1xuICB2YXIgeFN0ZXAgPSAwO1xuICB2YXIgZGFzaExlbmd0aCA9ICtwYXR0ZXJuWzBdO1xuICB3aGlsZSAoZGlzdFJlbWFpbmluZyA+PSAwLjEpIHtcbiAgICBkYXNoTGVuZ3RoID0gK3BhdHRlcm5bcGF0dGVybkluZGV4KysgJSBwYXR0ZXJuTGVuZ3RoXTtcbiAgICBpZiAoZGFzaExlbmd0aCA+IGRpc3RSZW1haW5pbmcpIHtcbiAgICAgIGRhc2hMZW5ndGggPSBkaXN0UmVtYWluaW5nO1xuICAgIH1cbiAgICB4U3RlcCA9IE1hdGguc3FydChkYXNoTGVuZ3RoICogZGFzaExlbmd0aCAvICgxICsgc2xvcGUgKiBzbG9wZSkpO1xuICAgIHhTdGVwID0gZHggPCAwID8gLXhTdGVwIDogeFN0ZXA7XG4gICAgeCArPSB4U3RlcDtcbiAgICB5ICs9IHNsb3BlICogeFN0ZXA7XG4gICAgaWYgKGRyYXcgPT09IHRydWUpIHtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgfVxuICAgIGRpc3RSZW1haW5pbmcgLT0gZGFzaExlbmd0aDtcbiAgICBkcmF3ID0gIWRyYXc7XG4gIH1cbn1cbi8qKlxyXG4gKiBEcmF3IGEgaGV4YWdvbi5cclxuICpcclxuICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoaXMgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCB0by5cclxuICogQHBhcmFtIHggLSBUaGUgcG9zaXRpb24gb2YgdGhlIGNlbnRlciBvbiB0aGUgeCBheGlzLlxyXG4gKiBAcGFyYW0geSAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgY2VudGVyIG9uIHRoZSB5IGF4aXMuXHJcbiAqIEBwYXJhbSByIC0gVGhlIHJhZGl1cyBvZiB0aGUgaGV4YWdvbi5cclxuICovXG5mdW5jdGlvbiBkcmF3SGV4YWdvbihjdHgsIHgsIHksIHIpIHtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICB2YXIgc2lkZXMgPSA2O1xuICB2YXIgYSA9IE1hdGguUEkgKiAyIC8gc2lkZXM7XG4gIGN0eC5tb3ZlVG8oeCArIHIsIHkpO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICBjdHgubGluZVRvKHggKyByICogTWF0aC5jb3MoYSAqIGkpLCB5ICsgciAqIE1hdGguc2luKGEgKiBpKSk7XG4gIH1cbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxudmFyIHNoYXBlTWFwID0ge1xuICBjaXJjbGU6IGRyYXdDaXJjbGUsXG4gIGRhc2hlZExpbmU6IGRyYXdEYXNoZWRMaW5lLFxuICBkYXRhYmFzZTogZHJhd0RhdGFiYXNlLFxuICBkaWFtb25kOiBkcmF3RGlhbW9uZCxcbiAgZWxsaXBzZTogZHJhd0VsbGlwc2UsXG4gIGVsbGlwc2VfdmlzOiBkcmF3RWxsaXBzZSxcbiAgaGV4YWdvbjogZHJhd0hleGFnb24sXG4gIHJvdW5kUmVjdDogZHJhd1JvdW5kUmVjdCxcbiAgc3F1YXJlOiBkcmF3U3F1YXJlLFxuICBzdGFyOiBkcmF3U3RhcixcbiAgdHJpYW5nbGU6IGRyYXdUcmlhbmdsZSxcbiAgdHJpYW5nbGVEb3duOiBkcmF3VHJpYW5nbGVEb3duXG59O1xuLyoqXHJcbiAqIFJldHVybnMgZWl0aGVyIGN1c3RvbSBvciBuYXRpdmUgZHJhd2luZyBmdW5jdGlvbiBiYXNlIG9uIHN1cHBsaWVkIG5hbWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLiBFaXRoZXIgdGhlIG5hbWUgb2YgYVxyXG4gKiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgcHJvcGVydHkgb3IgYW4gZXhwb3J0IGZyb20gc2hhcGVzLnRzIHdpdGhvdXQgdGhlXHJcbiAqIGRyYXcgcHJlZml4LlxyXG4gKiBAcmV0dXJucyBUaGUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCBmb3IgcmVuZGVyaW5nLiBJbiBjYXNlIG9mIG5hdGl2ZVxyXG4gKiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgZnVuY3Rpb24gdGhlIEFQSSBpcyBub3JtYWxpemVkIHRvXHJcbiAqIGAoY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQsIC4uLm9yaWdpbmFsQXJncykgPT4gdm9pZGAuXHJcbiAqL1xuZnVuY3Rpb24gZ2V0U2hhcGUobmFtZSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNoYXBlTWFwLCBuYW1lKSkge1xuICAgIHJldHVybiBzaGFwZU1hcFtuYW1lXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGN0eCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGVbbmFtZV0uY2FsbChjdHgsIGFyZ3MpO1xuICAgIH07XG4gIH1cbn1cblxudmFyIGNvbXBvbmVudEVtaXR0ZXIgPSB7ZXhwb3J0czoge319O1xuXG4oZnVuY3Rpb24gKG1vZHVsZSkge1xuXHQvKipcclxuXHQgKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG5cdCAqL1xyXG5cclxuXHR7XHJcblx0ICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuXHQgKlxyXG5cdCAqIEBhcGkgcHVibGljXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcblx0ICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxuXHR9XHJcblx0LyoqXHJcblx0ICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XHJcblx0ICogQGFwaSBwcml2YXRlXHJcblx0ICovXHJcblxyXG5cdGZ1bmN0aW9uIG1peGluKG9iaikge1xyXG5cdCAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcblx0ICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuXHQgIH1cclxuXHQgIHJldHVybiBvYmo7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG5cdCAqIEBhcGkgcHVibGljXHJcblx0ICovXHJcblxyXG5cdEVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuXHRFbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHQgICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuXHQgICAgLnB1c2goZm4pO1xyXG5cdCAgcmV0dXJuIHRoaXM7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcblx0ICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcblx0ICogQHJldHVybiB7RW1pdHRlcn1cclxuXHQgKiBAYXBpIHB1YmxpY1xyXG5cdCAqL1xyXG5cclxuXHRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuXHQgIGZ1bmN0aW9uIG9uKCkge1xyXG5cdCAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG5cdCAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdCAgfVxyXG5cclxuXHQgIG9uLmZuID0gZm47XHJcblx0ICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcblx0ICByZXR1cm4gdGhpcztcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG5cdCAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG5cdCAqIEBhcGkgcHVibGljXHJcblx0ICovXHJcblxyXG5cdEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcblx0RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxyXG5cdEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcblx0RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG5cdCAgLy8gYWxsXHJcblx0ICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0ICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG5cdCAgICByZXR1cm4gdGhpcztcclxuXHQgIH1cclxuXHJcblx0ICAvLyBzcGVjaWZpYyBldmVudFxyXG5cdCAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblx0ICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG5cdCAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG5cdCAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdCAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHQgICAgcmV0dXJuIHRoaXM7XHJcblx0ICB9XHJcblxyXG5cdCAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuXHQgIHZhciBjYjtcclxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcblx0ICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG5cdCAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG5cdCAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcblx0ICAgICAgYnJlYWs7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHJcblx0ICAvLyBSZW1vdmUgZXZlbnQgc3BlY2lmaWMgYXJyYXlzIGZvciBldmVudCB0eXBlcyB0aGF0IG5vXHJcblx0ICAvLyBvbmUgaXMgc3Vic2NyaWJlZCBmb3IgdG8gYXZvaWQgbWVtb3J5IGxlYWsuXHJcblx0ICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xyXG5cdCAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHQgIH1cclxuXHJcblx0ICByZXR1cm4gdGhpcztcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG5cdCAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG5cdCAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcblx0ICovXHJcblxyXG5cdEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG5cdCAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpXHJcblx0ICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcblx0ICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdCAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcclxuXHQgIH1cclxuXHJcblx0ICBpZiAoY2FsbGJhY2tzKSB7XHJcblx0ICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuXHQgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG5cdCAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cclxuXHQgIHJldHVybiB0aGlzO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuXHQgKiBAcmV0dXJuIHtBcnJheX1cclxuXHQgKiBAYXBpIHB1YmxpY1xyXG5cdCAqL1xyXG5cclxuXHRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblx0ICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcblx0ICpcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxyXG5cdCAqIEBhcGkgcHVibGljXHJcblx0ICovXHJcblxyXG5cdEVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuXHQgIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xyXG5cdH07IFxufSAoY29tcG9uZW50RW1pdHRlcikpO1xuXG52YXIgY29tcG9uZW50RW1pdHRlckV4cG9ydHMgPSBjb21wb25lbnRFbWl0dGVyLmV4cG9ydHM7XG52YXIgRW1pdHRlciA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhjb21wb25lbnRFbWl0dGVyRXhwb3J0cyk7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wkayA9IHdlbGxLbm93blN5bWJvbCRtO1xuXG52YXIgVE9fU1RSSU5HX1RBRyQzID0gd2VsbEtub3duU3ltYm9sJGsoJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCQyID0ge307XG5cbnRlc3QkMltUT19TVFJJTkdfVEFHJDNdID0gJ3onO1xuXG52YXIgdG9TdHJpbmdUYWdTdXBwb3J0ID0gU3RyaW5nKHRlc3QkMikgPT09ICdbb2JqZWN0IHpdJztcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCQyID0gdG9TdHJpbmdUYWdTdXBwb3J0O1xudmFyIGlzQ2FsbGFibGUkYSA9IGlzQ2FsbGFibGUkaTtcbnZhciBjbGFzc29mUmF3ID0gY2xhc3NvZlJhdyQyO1xudmFyIHdlbGxLbm93blN5bWJvbCRqID0gd2VsbEtub3duU3ltYm9sJG07XG5cbnZhciBUT19TVFJJTkdfVEFHJDIgPSB3ZWxsS25vd25TeW1ib2wkaigndG9TdHJpbmdUYWcnKTtcbnZhciAkT2JqZWN0JDIgPSBPYmplY3Q7XG5cbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufTtcblxuLy8gZ2V0dGluZyB0YWcgZnJvbSBFUzYrIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYFxudmFyIGNsYXNzb2YkZCA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCQyID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9ICRPYmplY3QkMihpdCksIFRPX1NUUklOR19UQUckMikpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUkYShPLmNhbGxlZSkgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG5cbnZhciBjbGFzc29mJGMgPSBjbGFzc29mJGQ7XG5cbnZhciAkU3RyaW5nJDIgPSBTdHJpbmc7XG5cbnZhciB0b1N0cmluZyRhID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChjbGFzc29mJGMoYXJndW1lbnQpID09PSAnU3ltYm9sJykgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuICRTdHJpbmckMihhcmd1bWVudCk7XG59O1xuXG52YXIgdW5jdXJyeVRoaXMkbCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSQxID0gdG9JbnRlZ2VyT3JJbmZpbml0eSQ0O1xudmFyIHRvU3RyaW5nJDkgPSB0b1N0cmluZyRhO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMiA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNTtcblxudmFyIGNoYXJBdCQzID0gdW5jdXJyeVRoaXMkbCgnJy5jaGFyQXQpO1xudmFyIGNoYXJDb2RlQXQkMSA9IHVuY3VycnlUaGlzJGwoJycuY2hhckNvZGVBdCk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcyRsKCcnLnNsaWNlKTtcblxudmFyIGNyZWF0ZU1ldGhvZCQzID0gZnVuY3Rpb24gKENPTlZFUlRfVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIHBvcykge1xuICAgIHZhciBTID0gdG9TdHJpbmckOShyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDIoJHRoaXMpKTtcbiAgICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXJPckluZmluaXR5JDEocG9zKTtcbiAgICB2YXIgc2l6ZSA9IFMubGVuZ3RoO1xuICAgIHZhciBmaXJzdCwgc2Vjb25kO1xuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSkgcmV0dXJuIENPTlZFUlRfVE9fU1RSSU5HID8gJycgOiB1bmRlZmluZWQ7XG4gICAgZmlyc3QgPSBjaGFyQ29kZUF0JDEoUywgcG9zaXRpb24pO1xuICAgIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemVcbiAgICAgIHx8IChzZWNvbmQgPSBjaGFyQ29kZUF0JDEoUywgcG9zaXRpb24gKyAxKSkgPCAweERDMDAgfHwgc2Vjb25kID4gMHhERkZGXG4gICAgICAgID8gQ09OVkVSVF9UT19TVFJJTkdcbiAgICAgICAgICA/IGNoYXJBdCQzKFMsIHBvc2l0aW9uKVxuICAgICAgICAgIDogZmlyc3RcbiAgICAgICAgOiBDT05WRVJUX1RPX1NUUklOR1xuICAgICAgICAgID8gc3RyaW5nU2xpY2UoUywgcG9zaXRpb24sIHBvc2l0aW9uICsgMilcbiAgICAgICAgICA6IChmaXJzdCAtIDB4RDgwMCA8PCAxMCkgKyAoc2Vjb25kIC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG52YXIgc3RyaW5nTXVsdGlieXRlID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS5jb2RlUG9pbnRBdGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdFxuICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZCQzKGZhbHNlKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUuYXRgIG1ldGhvZFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmF0XG4gIGNoYXJBdDogY3JlYXRlTWV0aG9kJDModHJ1ZSlcbn07XG5cbnZhciBnbG9iYWwkZSA9IGdsb2JhbCRuO1xudmFyIGlzQ2FsbGFibGUkOSA9IGlzQ2FsbGFibGUkaTtcblxudmFyIFdlYWtNYXAkMSA9IGdsb2JhbCRlLldlYWtNYXA7XG5cbnZhciB3ZWFrTWFwQmFzaWNEZXRlY3Rpb24gPSBpc0NhbGxhYmxlJDkoV2Vha01hcCQxKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoU3RyaW5nKFdlYWtNYXAkMSkpO1xuXG52YXIgc2hhcmVkJDUgPSBzaGFyZWRFeHBvcnRzO1xudmFyIHVpZCQyID0gdWlkJDQ7XG5cbnZhciBrZXlzJDMgPSBzaGFyZWQkNSgna2V5cycpO1xuXG52YXIgc2hhcmVkS2V5JDQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzJDNba2V5XSB8fCAoa2V5cyQzW2tleV0gPSB1aWQkMihrZXkpKTtcbn07XG5cbnZhciBOQVRJVkVfV0VBS19NQVAkMSA9IHdlYWtNYXBCYXNpY0RldGVjdGlvbjtcbnZhciBnbG9iYWwkZCA9IGdsb2JhbCRuO1xudmFyIGlzT2JqZWN0JGQgPSBpc09iamVjdCRqO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ0ID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDY7XG52YXIgaGFzT3duJGMgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIHNoYXJlZCQ0ID0gc2hhcmVkU3RvcmU7XG52YXIgc2hhcmVkS2V5JDMgPSBzaGFyZWRLZXkkNDtcbnZhciBoaWRkZW5LZXlzJDQgPSBoaWRkZW5LZXlzJDY7XG5cbnZhciBPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCA9ICdPYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZCc7XG52YXIgVHlwZUVycm9yJDIgPSBnbG9iYWwkZC5UeXBlRXJyb3I7XG52YXIgV2Vha01hcCA9IGdsb2JhbCRkLldlYWtNYXA7XG52YXIgc2V0JDMsIGdldCQ2LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0JDYoaXQpIDogc2V0JDMoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QkZChpdCkgfHwgKHN0YXRlID0gZ2V0JDYoaXQpKS50eXBlICE9PSBUWVBFKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yJDIoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQJDEgfHwgc2hhcmVkJDQuc3RhdGUpIHtcbiAgdmFyIHN0b3JlJDEgPSBzaGFyZWQkNC5zdGF0ZSB8fCAoc2hhcmVkJDQuc3RhdGUgPSBuZXcgV2Vha01hcCgpKTtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tc2VsZi1hc3NpZ24gLS0gcHJvdG90eXBlIG1ldGhvZHMgcHJvdGVjdGlvbiAqL1xuICBzdG9yZSQxLmdldCA9IHN0b3JlJDEuZ2V0O1xuICBzdG9yZSQxLmhhcyA9IHN0b3JlJDEuaGFzO1xuICBzdG9yZSQxLnNldCA9IHN0b3JlJDEuc2V0O1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtYXNzaWduIC0tIHByb3RvdHlwZSBtZXRob2RzIHByb3RlY3Rpb24gKi9cbiAgc2V0JDMgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKHN0b3JlJDEuaGFzKGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvciQyKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICBzdG9yZSQxLnNldChpdCwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0JDYgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gc3RvcmUkMS5nZXQoaXQpIHx8IHt9O1xuICB9O1xuICBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gc3RvcmUkMS5oYXMoaXQpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIFNUQVRFID0gc2hhcmVkS2V5JDMoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXMkNFtTVEFURV0gPSB0cnVlO1xuICBzZXQkMyA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAoaGFzT3duJGMoaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvciQyKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNChpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCQ2ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biRjKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGhhc093biRjKGl0LCBTVEFURSk7XG4gIH07XG59XG5cbnZhciBpbnRlcm5hbFN0YXRlID0ge1xuICBzZXQ6IHNldCQzLFxuICBnZXQ6IGdldCQ2LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cbnZhciBERVNDUklQVE9SUyRiID0gZGVzY3JpcHRvcnM7XG52YXIgaGFzT3duJGIgPSBoYXNPd25Qcm9wZXJ0eV8xO1xuXG52YXIgRnVuY3Rpb25Qcm90b3R5cGUkMSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMkYiAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgRVhJU1RTID0gaGFzT3duJGIoRnVuY3Rpb25Qcm90b3R5cGUkMSwgJ25hbWUnKTtcbi8vIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmcm9tIG1pbmlmaWVkIC8gbWFuZ2xlZCAvIGRyb3BwZWQgZnVuY3Rpb24gbmFtZXNcbnZhciBQUk9QRVIgPSBFWElTVFMgJiYgKGZ1bmN0aW9uIHNvbWV0aGluZygpIHsgLyogZW1wdHkgKi8gfSkubmFtZSA9PT0gJ3NvbWV0aGluZyc7XG52YXIgQ09ORklHVVJBQkxFID0gRVhJU1RTICYmICghREVTQ1JJUFRPUlMkYiB8fCAoREVTQ1JJUFRPUlMkYiAmJiBnZXREZXNjcmlwdG9yKEZ1bmN0aW9uUHJvdG90eXBlJDEsICduYW1lJykuY29uZmlndXJhYmxlKSk7XG5cbnZhciBmdW5jdGlvbk5hbWUgPSB7XG4gIEVYSVNUUzogRVhJU1RTLFxuICBQUk9QRVI6IFBST1BFUixcbiAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbn07XG5cbnZhciBvYmplY3REZWZpbmVQcm9wZXJ0aWVzID0ge307XG5cbnZhciBERVNDUklQVE9SUyRhID0gZGVzY3JpcHRvcnM7XG52YXIgVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPSB2OFByb3RvdHlwZURlZmluZUJ1ZztcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG52YXIgYW5PYmplY3QkYiA9IGFuT2JqZWN0JGQ7XG52YXIgdG9JbmRleGVkT2JqZWN0JDYgPSB0b0luZGV4ZWRPYmplY3QkYTtcbnZhciBvYmplY3RLZXlzJDEgPSBvYmplY3RLZXlzJDM7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnRpZXMgLS0gc2FmZVxub2JqZWN0RGVmaW5lUHJvcGVydGllcy5mID0gREVTQ1JJUFRPUlMkYSAmJiAhVjhfUFJPVE9UWVBFX0RFRklORV9CVUcgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykge1xuICBhbk9iamVjdCRiKE8pO1xuICB2YXIgcHJvcHMgPSB0b0luZGV4ZWRPYmplY3QkNihQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzJDEoUHJvcGVydGllcyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZSQyLmYoTywga2V5ID0ga2V5c1tpbmRleCsrXSwgcHJvcHNba2V5XSk7XG4gIHJldHVybiBPO1xufTtcblxudmFyIGdldEJ1aWx0SW4kYSA9IGdldEJ1aWx0SW4kYztcblxudmFyIGh0bWwkMSA9IGdldEJ1aWx0SW4kYSgnZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG5cbi8qIGdsb2JhbCBBY3RpdmVYT2JqZWN0IC0tIG9sZCBJRSwgV1NIICovXG52YXIgYW5PYmplY3QkYSA9IGFuT2JqZWN0JGQ7XG52YXIgZGVmaW5lUHJvcGVydGllc01vZHVsZSQxID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcztcbnZhciBlbnVtQnVnS2V5cyQxID0gZW51bUJ1Z0tleXMkMztcbnZhciBoaWRkZW5LZXlzJDMgPSBoaWRkZW5LZXlzJDY7XG52YXIgaHRtbCA9IGh0bWwkMTtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQkMTtcbnZhciBzaGFyZWRLZXkkMiA9IHNoYXJlZEtleSQ0O1xuXG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFJDEgPSAncHJvdG90eXBlJztcbnZhciBTQ1JJUFQgPSAnc2NyaXB0JztcbnZhciBJRV9QUk9UTyQxID0gc2hhcmVkS2V5JDIoJ0lFX1BST1RPJyk7XG5cbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuXG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgcmV0dXJuIExUICsgU0NSSVBUICsgR1QgKyBjb250ZW50ICsgTFQgKyAnLycgKyBTQ1JJUFQgKyBHVDtcbn07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBBY3RpdmVYIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWCA9IGZ1bmN0aW9uIChhY3RpdmVYRG9jdW1lbnQpIHtcbiAgYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuICBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiAgdmFyIHRlbXAgPSBhY3RpdmVYRG9jdW1lbnQucGFyZW50V2luZG93Lk9iamVjdDtcbiAgYWN0aXZlWERvY3VtZW50ID0gbnVsbDsgLy8gYXZvaWQgbWVtb3J5IGxlYWtcbiAgcmV0dXJuIHRlbXA7XG59O1xuXG4vLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlXG52YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgdmFyIEpTID0gJ2phdmEnICsgU0NSSVBUICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy80NzVcbiAgaWZyYW1lLnNyYyA9IFN0cmluZyhKUyk7XG4gIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiAgaWZyYW1lRG9jdW1lbnQud3JpdGUoc2NyaXB0VGFnKCdkb2N1bWVudC5GPU9iamVjdCcpKTtcbiAgaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiAgcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59O1xuXG4vLyBDaGVjayBmb3IgZG9jdW1lbnQuZG9tYWluIGFuZCBhY3RpdmUgeCBzdXBwb3J0XG4vLyBObyBuZWVkIHRvIHVzZSBhY3RpdmUgeCBhcHByb2FjaCB3aGVuIGRvY3VtZW50LmRvbWFpbiBpcyBub3Qgc2V0XG4vLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltL2lzc3Vlcy8xNTBcbi8vIHZhcmlhdGlvbiBvZiBodHRwczovL2dpdGh1Yi5jb20va2l0Y2FtYnJpZGdlL2VzNS1zaGltL2NvbW1pdC80ZjczOGFjMDY2MzQ2XG4vLyBhdm9pZCBJRSBHQyBidWdcbnZhciBhY3RpdmVYRG9jdW1lbnQ7XG52YXIgTnVsbFByb3RvT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIGFjdGl2ZVhEb2N1bWVudCA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBpZ25vcmUgKi8gfVxuICBOdWxsUHJvdG9PYmplY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCdcbiAgICA/IGRvY3VtZW50LmRvbWFpbiAmJiBhY3RpdmVYRG9jdW1lbnRcbiAgICAgID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIC8vIG9sZCBJRVxuICAgICAgOiBOdWxsUHJvdG9PYmplY3RWaWFJRnJhbWUoKVxuICAgIDogTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpOyAvLyBXU0hcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzJDEubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFJDFdW2VudW1CdWdLZXlzJDFbbGVuZ3RoXV07XG4gIHJldHVybiBOdWxsUHJvdG9PYmplY3QoKTtcbn07XG5cbmhpZGRlbktleXMkM1tJRV9QUk9UTyQxXSA9IHRydWU7XG5cbi8vIGBPYmplY3QuY3JlYXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1jcmVhdGUgLS0gc2FmZVxudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRSQxXSA9IGFuT2JqZWN0JGEoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5Q29uc3RydWN0b3IoKTtcbiAgICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRSQxXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UTyQxXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcbiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRlZmluZVByb3BlcnRpZXNNb2R1bGUkMS5mKHJlc3VsdCwgUHJvcGVydGllcyk7XG59O1xuXG52YXIgZmFpbHMkbiA9IGZhaWxzJHc7XG5cbnZhciBjb3JyZWN0UHJvdG90eXBlR2V0dGVyID0gIWZhaWxzJG4oZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGKCkgeyAvKiBlbXB0eSAqLyB9XG4gIEYucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gbnVsbDtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuXG52YXIgaGFzT3duJGEgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzQ2FsbGFibGUkOCA9IGlzQ2FsbGFibGUkaTtcbnZhciB0b09iamVjdCRiID0gdG9PYmplY3QkZTtcbnZhciBzaGFyZWRLZXkkMSA9IHNoYXJlZEtleSQ0O1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiQxID0gY29ycmVjdFByb3RvdHlwZUdldHRlcjtcblxudmFyIElFX1BST1RPID0gc2hhcmVkS2V5JDEoJ0lFX1BST1RPJyk7XG52YXIgJE9iamVjdCQxID0gT2JqZWN0O1xudmFyIE9iamVjdFByb3RvdHlwZSQyID0gJE9iamVjdCQxLnByb3RvdHlwZTtcblxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRwcm90b3R5cGVvZiAtLSBzYWZlXG52YXIgb2JqZWN0R2V0UHJvdG90eXBlT2YgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIkMSA/ICRPYmplY3QkMS5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG4gIHZhciBvYmplY3QgPSB0b09iamVjdCRiKE8pO1xuICBpZiAoaGFzT3duJGEob2JqZWN0LCBJRV9QUk9UTykpIHJldHVybiBvYmplY3RbSUVfUFJPVE9dO1xuICB2YXIgY29uc3RydWN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIGlmIChpc0NhbGxhYmxlJDgoY29uc3RydWN0b3IpICYmIG9iamVjdCBpbnN0YW5jZW9mIGNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgJE9iamVjdCQxID8gT2JqZWN0UHJvdG90eXBlJDIgOiBudWxsO1xufTtcblxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQzID0gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDY7XG5cbnZhciBkZWZpbmVCdWlsdEluJDUgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW51bWVyYWJsZSkgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgZWxzZSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMyh0YXJnZXQsIGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGZhaWxzJG0gPSBmYWlscyR3O1xudmFyIGlzQ2FsbGFibGUkNyA9IGlzQ2FsbGFibGUkaTtcbnZhciBpc09iamVjdCRjID0gaXNPYmplY3QkajtcbnZhciBjcmVhdGUkYSA9IG9iamVjdENyZWF0ZTtcbnZhciBnZXRQcm90b3R5cGVPZiQ4ID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgZGVmaW5lQnVpbHRJbiQ0ID0gZGVmaW5lQnVpbHRJbiQ1O1xudmFyIHdlbGxLbm93blN5bWJvbCRpID0gd2VsbEtub3duU3ltYm9sJG07XG5cbnZhciBJVEVSQVRPUiQ2ID0gd2VsbEtub3duU3ltYm9sJGkoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyQxID0gZmFsc2U7XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlYCBvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSQxLCBQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUsIGFycmF5SXRlcmF0b3I7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLWFycmF5LXByb3RvdHlwZS1rZXlzIC0tIHNhZmUgKi9cbmlmIChbXS5rZXlzKSB7XG4gIGFycmF5SXRlcmF0b3IgPSBbXS5rZXlzKCk7XG4gIC8vIFNhZmFyaSA4IGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YFxuICBpZiAoISgnbmV4dCcgaW4gYXJyYXlJdGVyYXRvcikpIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMSA9IHRydWU7XG4gIGVsc2Uge1xuICAgIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mJDgoZ2V0UHJvdG90eXBlT2YkOChhcnJheUl0ZXJhdG9yKSk7XG4gICAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSkgSXRlcmF0b3JQcm90b3R5cGUkMSA9IFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxufVxuXG52YXIgTkVXX0lURVJBVE9SX1BST1RPVFlQRSA9ICFpc09iamVjdCRjKEl0ZXJhdG9yUHJvdG90eXBlJDEpIHx8IGZhaWxzJG0oZnVuY3Rpb24gKCkge1xuICB2YXIgdGVzdCA9IHt9O1xuICAvLyBGRjQ0LSBsZWdhY3kgaXRlcmF0b3JzIGNhc2VcbiAgcmV0dXJuIEl0ZXJhdG9yUHJvdG90eXBlJDFbSVRFUkFUT1IkNl0uY2FsbCh0ZXN0KSAhPT0gdGVzdDtcbn0pO1xuXG5pZiAoTkVXX0lURVJBVE9SX1BST1RPVFlQRSkgSXRlcmF0b3JQcm90b3R5cGUkMSA9IHt9O1xuZWxzZSBJdGVyYXRvclByb3RvdHlwZSQxID0gY3JlYXRlJGEoSXRlcmF0b3JQcm90b3R5cGUkMSk7XG5cbi8vIGAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0laXRlcmF0b3Jwcm90b3R5cGUlLUBAaXRlcmF0b3JcbmlmICghaXNDYWxsYWJsZSQ3KEl0ZXJhdG9yUHJvdG90eXBlJDFbSVRFUkFUT1IkNl0pKSB7XG4gIGRlZmluZUJ1aWx0SW4kNChJdGVyYXRvclByb3RvdHlwZSQxLCBJVEVSQVRPUiQ2LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xufVxuXG52YXIgaXRlcmF0b3JzQ29yZSA9IHtcbiAgSXRlcmF0b3JQcm90b3R5cGU6IEl0ZXJhdG9yUHJvdG90eXBlJDEsXG4gIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMkMVxufTtcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCQxID0gdG9TdHJpbmdUYWdTdXBwb3J0O1xudmFyIGNsYXNzb2YkYiA9IGNsYXNzb2YkZDtcblxuLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBUT19TVFJJTkdfVEFHX1NVUFBPUlQkMSA/IHt9LnRvU3RyaW5nIDogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnW29iamVjdCAnICsgY2xhc3NvZiRiKHRoaXMpICsgJ10nO1xufTtcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IHRvU3RyaW5nVGFnU3VwcG9ydDtcbnZhciBkZWZpbmVQcm9wZXJ0eSRkID0gb2JqZWN0RGVmaW5lUHJvcGVydHkuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMiA9IGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSQ2O1xudmFyIGhhc093biQ5ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB0b1N0cmluZyQ4ID0gb2JqZWN0VG9TdHJpbmc7XG52YXIgd2VsbEtub3duU3ltYm9sJGggPSB3ZWxsS25vd25TeW1ib2wkbTtcblxudmFyIFRPX1NUUklOR19UQUckMSA9IHdlbGxLbm93blN5bWJvbCRoKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgc2V0VG9TdHJpbmdUYWckNiA9IGZ1bmN0aW9uIChpdCwgVEFHLCBTVEFUSUMsIFNFVF9NRVRIT0QpIHtcbiAgaWYgKGl0KSB7XG4gICAgdmFyIHRhcmdldCA9IFNUQVRJQyA/IGl0IDogaXQucHJvdG90eXBlO1xuICAgIGlmICghaGFzT3duJDkodGFyZ2V0LCBUT19TVFJJTkdfVEFHJDEpKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eSRkKHRhcmdldCwgVE9fU1RSSU5HX1RBRyQxLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IFRBRyB9KTtcbiAgICB9XG4gICAgaWYgKFNFVF9NRVRIT0QgJiYgIVRPX1NUUklOR19UQUdfU1VQUE9SVCkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDIodGFyZ2V0LCAndG9TdHJpbmcnLCB0b1N0cmluZyQ4KTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBpdGVyYXRvcnMgPSB7fTtcblxudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gaXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBjcmVhdGUkOSA9IG9iamVjdENyZWF0ZTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMiA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xudmFyIHNldFRvU3RyaW5nVGFnJDUgPSBzZXRUb1N0cmluZ1RhZyQ2O1xudmFyIEl0ZXJhdG9ycyQ1ID0gaXRlcmF0b3JzO1xuXG52YXIgcmV0dXJuVGhpcyQxID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxudmFyIGl0ZXJhdG9yQ3JlYXRlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCwgRU5VTUVSQUJMRV9ORVhUKSB7XG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZSQ5KEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQyKCshRU5VTUVSQUJMRV9ORVhULCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWckNShJdGVyYXRvckNvbnN0cnVjdG9yLCBUT19TVFJJTkdfVEFHLCBmYWxzZSwgdHJ1ZSk7XG4gIEl0ZXJhdG9ycyQ1W1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcyQxO1xuICByZXR1cm4gSXRlcmF0b3JDb25zdHJ1Y3Rvcjtcbn07XG5cbnZhciB1bmN1cnJ5VGhpcyRrID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBhQ2FsbGFibGUkMyA9IGFDYWxsYWJsZSQ3O1xuXG52YXIgZnVuY3Rpb25VbmN1cnJ5VGhpc0FjY2Vzc29yID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCBtZXRob2QpIHtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG4gICAgcmV0dXJuIHVuY3VycnlUaGlzJGsoYUNhbGxhYmxlJDMoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIGtleSlbbWV0aG9kXSkpO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG52YXIgaXNDYWxsYWJsZSQ2ID0gaXNDYWxsYWJsZSRpO1xuXG52YXIgJFN0cmluZyQxID0gU3RyaW5nO1xudmFyICRUeXBlRXJyb3IkYSA9IFR5cGVFcnJvcjtcblxudmFyIGFQb3NzaWJsZVByb3RvdHlwZSQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnQgPT0gJ29iamVjdCcgfHwgaXNDYWxsYWJsZSQ2KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvciRhKFwiQ2FuJ3Qgc2V0IFwiICsgJFN0cmluZyQxKGFyZ3VtZW50KSArICcgYXMgYSBwcm90b3R5cGUnKTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvIC0tIHNhZmUgKi9cbnZhciB1bmN1cnJ5VGhpc0FjY2Vzc29yID0gZnVuY3Rpb25VbmN1cnJ5VGhpc0FjY2Vzc29yO1xudmFyIGFuT2JqZWN0JDkgPSBhbk9iamVjdCRkO1xudmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IGFQb3NzaWJsZVByb3RvdHlwZSQxO1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4vLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qtc2V0cHJvdG90eXBlb2YgLS0gc2FmZVxudmFyIG9iamVjdFNldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IGZ1bmN0aW9uICgpIHtcbiAgdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gIHZhciB0ZXN0ID0ge307XG4gIHZhciBzZXR0ZXI7XG4gIHRyeSB7XG4gICAgc2V0dGVyID0gdW5jdXJyeVRoaXNBY2Nlc3NvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJywgJ3NldCcpO1xuICAgIHNldHRlcih0ZXN0LCBbXSk7XG4gICAgQ09SUkVDVF9TRVRURVIgPSB0ZXN0IGluc3RhbmNlb2YgQXJyYXk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgYW5PYmplY3QkOShPKTtcbiAgICBhUG9zc2libGVQcm90b3R5cGUocHJvdG8pO1xuICAgIGlmIChDT1JSRUNUX1NFVFRFUikgc2V0dGVyKE8sIHByb3RvKTtcbiAgICBlbHNlIE8uX19wcm90b19fID0gcHJvdG87XG4gICAgcmV0dXJuIE87XG4gIH07XG59KCkgOiB1bmRlZmluZWQpO1xuXG52YXIgJCRNID0gX2V4cG9ydDtcbnZhciBjYWxsJDggPSBmdW5jdGlvbkNhbGw7XG52YXIgRnVuY3Rpb25OYW1lID0gZnVuY3Rpb25OYW1lO1xudmFyIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IgPSBpdGVyYXRvckNyZWF0ZUNvbnN0cnVjdG9yO1xudmFyIGdldFByb3RvdHlwZU9mJDcgPSBvYmplY3RHZXRQcm90b3R5cGVPZjtcbnZhciBzZXRUb1N0cmluZ1RhZyQ0ID0gc2V0VG9TdHJpbmdUYWckNjtcbnZhciBkZWZpbmVCdWlsdEluJDMgPSBkZWZpbmVCdWlsdEluJDU7XG52YXIgd2VsbEtub3duU3ltYm9sJGcgPSB3ZWxsS25vd25TeW1ib2wkbTtcbnZhciBJdGVyYXRvcnMkNCA9IGl0ZXJhdG9ycztcbnZhciBJdGVyYXRvcnNDb3JlID0gaXRlcmF0b3JzQ29yZTtcblxudmFyIFBST1BFUl9GVU5DVElPTl9OQU1FID0gRnVuY3Rpb25OYW1lLlBST1BFUjtcbkZ1bmN0aW9uTmFtZS5DT05GSUdVUkFCTEU7XG5JdGVyYXRvcnNDb3JlLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBJdGVyYXRvcnNDb3JlLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlM7XG52YXIgSVRFUkFUT1IkNSA9IHdlbGxLbm93blN5bWJvbCRnKCdpdGVyYXRvcicpO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG52YXIgaXRlcmF0b3JEZWZpbmUgPSBmdW5jdGlvbiAoSXRlcmFibGUsIE5BTUUsIEl0ZXJhdG9yQ29uc3RydWN0b3IsIG5leHQsIERFRkFVTFQsIElTX1NFVCwgRk9SQ0VEKSB7XG4gIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG5cbiAgdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gICAgaWYgKEtJTkQgPT09IERFRkFVTFQgJiYgZGVmYXVsdEl0ZXJhdG9yKSByZXR1cm4gZGVmYXVsdEl0ZXJhdG9yO1xuICAgIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcblxuICAgIHN3aXRjaCAoS0lORCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgRU5UUklFUzogcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcyk7IH07XG4gIH07XG5cbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUiQ1XVxuICAgIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ11cbiAgICB8fCBERUZBVUxUICYmIEl0ZXJhYmxlUHJvdG90eXBlW0RFRkFVTFRdO1xuICB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xuICB2YXIgYW55TmF0aXZlSXRlcmF0b3IgPSBOQU1FID09PSAnQXJyYXknID8gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcyB8fCBuYXRpdmVJdGVyYXRvciA6IG5hdGl2ZUl0ZXJhdG9yO1xuICB2YXIgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBtZXRob2RzLCBLRVk7XG5cbiAgLy8gZml4IG5hdGl2ZVxuICBpZiAoYW55TmF0aXZlSXRlcmF0b3IpIHtcbiAgICBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZiQ3KGFueU5hdGl2ZUl0ZXJhdG9yLmNhbGwobmV3IEl0ZXJhYmxlKCkpKTtcbiAgICBpZiAoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICAvLyBTZXQgQEB0b1N0cmluZ1RhZyB0byBuYXRpdmUgaXRlcmF0b3JzXG4gICAgICBzZXRUb1N0cmluZ1RhZyQ0KEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBJdGVyYXRvcnMkNFtUT19TVFJJTkdfVEFHXSA9IHJldHVyblRoaXM7XG4gICAgfVxuICB9XG5cbiAgLy8gZml4IEFycmF5LnByb3RvdHlwZS57IHZhbHVlcywgQEBpdGVyYXRvciB9Lm5hbWUgaW4gVjggLyBGRlxuICBpZiAoUFJPUEVSX0ZVTkNUSU9OX05BTUUgJiYgREVGQVVMVCA9PT0gVkFMVUVTICYmIG5hdGl2ZUl0ZXJhdG9yICYmIG5hdGl2ZUl0ZXJhdG9yLm5hbWUgIT09IFZBTFVFUykge1xuICAgIHtcbiAgICAgIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XG4gICAgICBkZWZhdWx0SXRlcmF0b3IgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7IHJldHVybiBjYWxsJDgobmF0aXZlSXRlcmF0b3IsIHRoaXMpOyB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChFTlRSSUVTKVxuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICAgICBkZWZpbmVCdWlsdEluJDMoSXRlcmFibGVQcm90b3R5cGUsIEtFWSwgbWV0aG9kc1tLRVldKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgJCRNKHsgdGFyZ2V0OiBOQU1FLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB9LCBtZXRob2RzKTtcbiAgfVxuXG4gIC8vIGRlZmluZSBpdGVyYXRvclxuICBpZiAoKEZPUkNFRCkgJiYgSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1IkNV0gIT09IGRlZmF1bHRJdGVyYXRvcikge1xuICAgIGRlZmluZUJ1aWx0SW4kMyhJdGVyYWJsZVByb3RvdHlwZSwgSVRFUkFUT1IkNSwgZGVmYXVsdEl0ZXJhdG9yLCB7IG5hbWU6IERFRkFVTFQgfSk7XG4gIH1cbiAgSXRlcmF0b3JzJDRbTkFNRV0gPSBkZWZhdWx0SXRlcmF0b3I7XG5cbiAgcmV0dXJuIG1ldGhvZHM7XG59O1xuXG4vLyBgQ3JlYXRlSXRlclJlc3VsdE9iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWl0ZXJyZXN1bHRvYmplY3RcbnZhciBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0JDMgPSBmdW5jdGlvbiAodmFsdWUsIGRvbmUpIHtcbiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiBkb25lIH07XG59O1xuXG52YXIgY2hhckF0JDIgPSBzdHJpbmdNdWx0aWJ5dGUuY2hhckF0O1xudmFyIHRvU3RyaW5nJDcgPSB0b1N0cmluZyRhO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkNSA9IGludGVybmFsU3RhdGU7XG52YXIgZGVmaW5lSXRlcmF0b3IkMiA9IGl0ZXJhdG9yRGVmaW5lO1xudmFyIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QkMiA9IGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QkMztcblxudmFyIFNUUklOR19JVEVSQVRPUiA9ICdTdHJpbmcgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUkNSA9IEludGVybmFsU3RhdGVNb2R1bGUkNS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSQyID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQ1LmdldHRlckZvcihTVFJJTkdfSVRFUkFUT1IpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxuZGVmaW5lSXRlcmF0b3IkMihTdHJpbmcsICdTdHJpbmcnLCBmdW5jdGlvbiAoaXRlcmF0ZWQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSQ1KHRoaXMsIHtcbiAgICB0eXBlOiBTVFJJTkdfSVRFUkFUT1IsXG4gICAgc3RyaW5nOiB0b1N0cmluZyQ3KGl0ZXJhdGVkKSxcbiAgICBpbmRleDogMFxuICB9KTtcbi8vIGAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lc3RyaW5naXRlcmF0b3Jwcm90b3R5cGUlLm5leHRcbn0sIGZ1bmN0aW9uIG5leHQoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUkMih0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0JDIodW5kZWZpbmVkLCB0cnVlKTtcbiAgcG9pbnQgPSBjaGFyQXQkMihzdHJpbmcsIGluZGV4KTtcbiAgc3RhdGUuaW5kZXggKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdCQyKHBvaW50LCBmYWxzZSk7XG59KTtcblxudmFyIGNhbGwkNyA9IGZ1bmN0aW9uQ2FsbDtcbnZhciBhbk9iamVjdCQ4ID0gYW5PYmplY3QkZDtcbnZhciBnZXRNZXRob2QkMSA9IGdldE1ldGhvZCQzO1xuXG52YXIgaXRlcmF0b3JDbG9zZSQyID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBraW5kLCB2YWx1ZSkge1xuICB2YXIgaW5uZXJSZXN1bHQsIGlubmVyRXJyb3I7XG4gIGFuT2JqZWN0JDgoaXRlcmF0b3IpO1xuICB0cnkge1xuICAgIGlubmVyUmVzdWx0ID0gZ2V0TWV0aG9kJDEoaXRlcmF0b3IsICdyZXR1cm4nKTtcbiAgICBpZiAoIWlubmVyUmVzdWx0KSB7XG4gICAgICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlubmVyUmVzdWx0ID0gY2FsbCQ3KGlubmVyUmVzdWx0LCBpdGVyYXRvcik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW5uZXJFcnJvciA9IHRydWU7XG4gICAgaW5uZXJSZXN1bHQgPSBlcnJvcjtcbiAgfVxuICBpZiAoa2luZCA9PT0gJ3Rocm93JykgdGhyb3cgdmFsdWU7XG4gIGlmIChpbm5lckVycm9yKSB0aHJvdyBpbm5lclJlc3VsdDtcbiAgYW5PYmplY3QkOChpbm5lclJlc3VsdCk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBhbk9iamVjdCQ3ID0gYW5PYmplY3QkZDtcbnZhciBpdGVyYXRvckNsb3NlJDEgPSBpdGVyYXRvckNsb3NlJDI7XG5cbi8vIGNhbGwgc29tZXRoaW5nIG9uIGl0ZXJhdG9yIHN0ZXAgd2l0aCBzYWZlIGNsb3Npbmcgb24gZXJyb3JcbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nJDEgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgRU5UUklFUykge1xuICB0cnkge1xuICAgIHJldHVybiBFTlRSSUVTID8gZm4oYW5PYmplY3QkNyh2YWx1ZSlbMF0sIHZhbHVlWzFdKSA6IGZuKHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpdGVyYXRvckNsb3NlJDEoaXRlcmF0b3IsICd0aHJvdycsIGVycm9yKTtcbiAgfVxufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCRmID0gd2VsbEtub3duU3ltYm9sJG07XG52YXIgSXRlcmF0b3JzJDMgPSBpdGVyYXRvcnM7XG5cbnZhciBJVEVSQVRPUiQ0ID0gd2VsbEtub3duU3ltYm9sJGYoJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUkZyA9IEFycmF5LnByb3RvdHlwZTtcblxuLy8gY2hlY2sgb24gZGVmYXVsdCBBcnJheSBpdGVyYXRvclxudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMkMy5BcnJheSA9PT0gaXQgfHwgQXJyYXlQcm90b3R5cGUkZ1tJVEVSQVRPUiQ0XSA9PT0gaXQpO1xufTtcblxudmFyIHVuY3VycnlUaGlzJGogPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGlzQ2FsbGFibGUkNSA9IGlzQ2FsbGFibGUkaTtcbnZhciBzdG9yZSA9IHNoYXJlZFN0b3JlO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHVuY3VycnlUaGlzJGooRnVuY3Rpb24udG9TdHJpbmcpO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAoIWlzQ2FsbGFibGUkNShzdG9yZS5pbnNwZWN0U291cmNlKSkge1xuICBzdG9yZS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuICB9O1xufVxuXG52YXIgaW5zcGVjdFNvdXJjZSQxID0gc3RvcmUuaW5zcGVjdFNvdXJjZTtcblxudmFyIHVuY3VycnlUaGlzJGkgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJGwgPSBmYWlscyR3O1xudmFyIGlzQ2FsbGFibGUkNCA9IGlzQ2FsbGFibGUkaTtcbnZhciBjbGFzc29mJGEgPSBjbGFzc29mJGQ7XG52YXIgZ2V0QnVpbHRJbiQ5ID0gZ2V0QnVpbHRJbiRjO1xudmFyIGluc3BlY3RTb3VyY2UgPSBpbnNwZWN0U291cmNlJDE7XG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xudmFyIGVtcHR5ID0gW107XG52YXIgY29uc3RydWN0JDMgPSBnZXRCdWlsdEluJDkoJ1JlZmxlY3QnLCAnY29uc3RydWN0Jyk7XG52YXIgY29uc3RydWN0b3JSZWdFeHAgPSAvXlxccyooPzpjbGFzc3xmdW5jdGlvbilcXGIvO1xudmFyIGV4ZWMkMiA9IHVuY3VycnlUaGlzJGkoY29uc3RydWN0b3JSZWdFeHAuZXhlYyk7XG52YXIgSU5DT1JSRUNUX1RPX1NUUklORyA9ICFjb25zdHJ1Y3RvclJlZ0V4cC50ZXN0KG5vb3ApO1xuXG52YXIgaXNDb25zdHJ1Y3Rvck1vZGVybiA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiAgaWYgKCFpc0NhbGxhYmxlJDQoYXJndW1lbnQpKSByZXR1cm4gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3RydWN0JDMobm9vcCwgZW1wdHksIGFyZ3VtZW50KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBpc0NvbnN0cnVjdG9yTGVnYWN5ID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuICBpZiAoIWlzQ2FsbGFibGUkNChhcmd1bWVudCkpIHJldHVybiBmYWxzZTtcbiAgc3dpdGNoIChjbGFzc29mJGEoYXJndW1lbnQpKSB7XG4gICAgY2FzZSAnQXN5bmNGdW5jdGlvbic6XG4gICAgY2FzZSAnR2VuZXJhdG9yRnVuY3Rpb24nOlxuICAgIGNhc2UgJ0FzeW5jR2VuZXJhdG9yRnVuY3Rpb24nOiByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyB3ZSBjYW4ndCBjaGVjayAucHJvdG90eXBlIHNpbmNlIGNvbnN0cnVjdG9ycyBwcm9kdWNlZCBieSAuYmluZCBoYXZlbid0IGl0XG4gICAgLy8gYEZ1bmN0aW9uI3RvU3RyaW5nYCB0aHJvd3Mgb24gc29tZSBidWlsdC1pdCBmdW5jdGlvbiBpbiBzb21lIGxlZ2FjeSBlbmdpbmVzXG4gICAgLy8gKGZvciBleGFtcGxlLCBgRE9NUXVhZGAgYW5kIHNpbWlsYXIgaW4gRkY0MS0pXG4gICAgcmV0dXJuIElOQ09SUkVDVF9UT19TVFJJTkcgfHwgISFleGVjJDIoY29uc3RydWN0b3JSZWdFeHAsIGluc3BlY3RTb3VyY2UoYXJndW1lbnQpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuaXNDb25zdHJ1Y3RvckxlZ2FjeS5zaGFtID0gdHJ1ZTtcblxuLy8gYElzQ29uc3RydWN0b3JgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NvbnN0cnVjdG9yXG52YXIgaXNDb25zdHJ1Y3RvciQ0ID0gIWNvbnN0cnVjdCQzIHx8IGZhaWxzJGwoZnVuY3Rpb24gKCkge1xuICB2YXIgY2FsbGVkO1xuICByZXR1cm4gaXNDb25zdHJ1Y3Rvck1vZGVybihpc0NvbnN0cnVjdG9yTW9kZXJuLmNhbGwpXG4gICAgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oT2JqZWN0KVxuICAgIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKGZ1bmN0aW9uICgpIHsgY2FsbGVkID0gdHJ1ZTsgfSlcbiAgICB8fCBjYWxsZWQ7XG59KSA/IGlzQ29uc3RydWN0b3JMZWdhY3kgOiBpc0NvbnN0cnVjdG9yTW9kZXJuO1xuXG52YXIgdG9Qcm9wZXJ0eUtleSQxID0gdG9Qcm9wZXJ0eUtleSQ0O1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlJDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSA9IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciQ1O1xuXG52YXIgY3JlYXRlUHJvcGVydHkkNiA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleSQxKGtleSk7XG4gIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpIGRlZmluZVByb3BlcnR5TW9kdWxlJDEuZihvYmplY3QsIHByb3BlcnR5S2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkMSgwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcbn07XG5cbnZhciBjbGFzc29mJDkgPSBjbGFzc29mJGQ7XG52YXIgZ2V0TWV0aG9kID0gZ2V0TWV0aG9kJDM7XG52YXIgaXNOdWxsT3JVbmRlZmluZWQkMyA9IGlzTnVsbE9yVW5kZWZpbmVkJDY7XG52YXIgSXRlcmF0b3JzJDIgPSBpdGVyYXRvcnM7XG52YXIgd2VsbEtub3duU3ltYm9sJGUgPSB3ZWxsS25vd25TeW1ib2wkbTtcblxudmFyIElURVJBVE9SJDMgPSB3ZWxsS25vd25TeW1ib2wkZSgnaXRlcmF0b3InKTtcblxudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDkgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc051bGxPclVuZGVmaW5lZCQzKGl0KSkgcmV0dXJuIGdldE1ldGhvZChpdCwgSVRFUkFUT1IkMylcbiAgICB8fCBnZXRNZXRob2QoaXQsICdAQGl0ZXJhdG9yJylcbiAgICB8fCBJdGVyYXRvcnMkMltjbGFzc29mJDkoaXQpXTtcbn07XG5cbnZhciBjYWxsJDYgPSBmdW5jdGlvbkNhbGw7XG52YXIgYUNhbGxhYmxlJDIgPSBhQ2FsbGFibGUkNztcbnZhciBhbk9iamVjdCQ2ID0gYW5PYmplY3QkZDtcbnZhciB0cnlUb1N0cmluZyQ0ID0gdHJ5VG9TdHJpbmckNjtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCQ4ID0gZ2V0SXRlcmF0b3JNZXRob2QkOTtcblxudmFyICRUeXBlRXJyb3IkOSA9IFR5cGVFcnJvcjtcblxudmFyIGdldEl0ZXJhdG9yJDIgPSBmdW5jdGlvbiAoYXJndW1lbnQsIHVzaW5nSXRlcmF0b3IpIHtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBnZXRJdGVyYXRvck1ldGhvZCQ4KGFyZ3VtZW50KSA6IHVzaW5nSXRlcmF0b3I7XG4gIGlmIChhQ2FsbGFibGUkMihpdGVyYXRvck1ldGhvZCkpIHJldHVybiBhbk9iamVjdCQ2KGNhbGwkNihpdGVyYXRvck1ldGhvZCwgYXJndW1lbnQpKTtcbiAgdGhyb3cgbmV3ICRUeXBlRXJyb3IkOSh0cnlUb1N0cmluZyQ0KGFyZ3VtZW50KSArICcgaXMgbm90IGl0ZXJhYmxlJyk7XG59O1xuXG52YXIgYmluZCQ3ID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjYWxsJDUgPSBmdW5jdGlvbkNhbGw7XG52YXIgdG9PYmplY3QkYSA9IHRvT2JqZWN0JGU7XG52YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyA9IGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmckMTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QkMSA9IGlzQXJyYXlJdGVyYXRvck1ldGhvZCQyO1xudmFyIGlzQ29uc3RydWN0b3IkMyA9IGlzQ29uc3RydWN0b3IkNDtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSRhID0gbGVuZ3RoT2ZBcnJheUxpa2UkYztcbnZhciBjcmVhdGVQcm9wZXJ0eSQ1ID0gY3JlYXRlUHJvcGVydHkkNjtcbnZhciBnZXRJdGVyYXRvciQxID0gZ2V0SXRlcmF0b3IkMjtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCQ3ID0gZ2V0SXRlcmF0b3JNZXRob2QkOTtcblxudmFyICRBcnJheSQzID0gQXJyYXk7XG5cbi8vIGBBcnJheS5mcm9tYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxudmFyIGFycmF5RnJvbSA9IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCRhKGFycmF5TGlrZSk7XG4gIHZhciBJU19DT05TVFJVQ1RPUiA9IGlzQ29uc3RydWN0b3IkMyh0aGlzKTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBtYXBmbiA9IGFyZ3VtZW50c0xlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIHZhciBtYXBwaW5nID0gbWFwZm4gIT09IHVuZGVmaW5lZDtcbiAgaWYgKG1hcHBpbmcpIG1hcGZuID0gYmluZCQ3KG1hcGZuLCBhcmd1bWVudHNMZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QkNyhPKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvciwgbmV4dCwgdmFsdWU7XG4gIC8vIGlmIHRoZSB0YXJnZXQgaXMgbm90IGl0ZXJhYmxlIG9yIGl0J3MgYW4gYXJyYXkgd2l0aCB0aGUgZGVmYXVsdCBpdGVyYXRvciAtIHVzZSBhIHNpbXBsZSBjYXNlXG4gIGlmIChpdGVyYXRvck1ldGhvZCAmJiAhKHRoaXMgPT09ICRBcnJheSQzICYmIGlzQXJyYXlJdGVyYXRvck1ldGhvZCQxKGl0ZXJhdG9yTWV0aG9kKSkpIHtcbiAgICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yJDEoTywgaXRlcmF0b3JNZXRob2QpO1xuICAgIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICAgIHJlc3VsdCA9IElTX0NPTlNUUlVDVE9SID8gbmV3IHRoaXMoKSA6IFtdO1xuICAgIGZvciAoOyEoc3RlcCA9IGNhbGwkNShuZXh0LCBpdGVyYXRvcikpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgIHZhbHVlID0gbWFwcGluZyA/IGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcoaXRlcmF0b3IsIG1hcGZuLCBbc3RlcC52YWx1ZSwgaW5kZXhdLCB0cnVlKSA6IHN0ZXAudmFsdWU7XG4gICAgICBjcmVhdGVQcm9wZXJ0eSQ1KHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkYShPKTtcbiAgICByZXN1bHQgPSBJU19DT05TVFJVQ1RPUiA/IG5ldyB0aGlzKGxlbmd0aCkgOiAkQXJyYXkkMyhsZW5ndGgpO1xuICAgIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICB2YWx1ZSA9IG1hcHBpbmcgPyBtYXBmbihPW2luZGV4XSwgaW5kZXgpIDogT1tpbmRleF07XG4gICAgICBjcmVhdGVQcm9wZXJ0eSQ1KHJlc3VsdCwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmVzdWx0Lmxlbmd0aCA9IGluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCRkID0gd2VsbEtub3duU3ltYm9sJG07XG5cbnZhciBJVEVSQVRPUiQyID0gd2VsbEtub3duU3ltYm9sJGQoJ2l0ZXJhdG9yJyk7XG52YXIgU0FGRV9DTE9TSU5HID0gZmFsc2U7XG5cbnRyeSB7XG4gIHZhciBjYWxsZWQgPSAwO1xuICB2YXIgaXRlcmF0b3JXaXRoUmV0dXJuID0ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGRvbmU6ICEhY2FsbGVkKysgfTtcbiAgICB9LFxuICAgICdyZXR1cm4nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBTQUZFX0NMT1NJTkcgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SJDJdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktZnJvbSwgbm8tdGhyb3ctbGl0ZXJhbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiQxID0gZnVuY3Rpb24gKGV4ZWMsIFNLSVBfQ0xPU0lORykge1xuICB0cnkge1xuICAgIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgcmV0dXJuIGZhbHNlOyB9IC8vIHdvcmthcm91bmQgb2Ygb2xkIFdlYktpdCArIGBldmFsYCBidWdcbiAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIG9iamVjdFtJVEVSQVRPUiQyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiBJVEVSQVRJT05fU1VQUE9SVCA9IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGV4ZWMob2JqZWN0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gSVRFUkFUSU9OX1NVUFBPUlQ7XG59O1xuXG52YXIgJCRMID0gX2V4cG9ydDtcbnZhciBmcm9tJDYgPSBhcnJheUZyb207XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uJDE7XG5cbnZhciBJTkNPUlJFQ1RfSVRFUkFUSU9OID0gIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LWZyb20gLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgQXJyYXkuZnJvbShpdGVyYWJsZSk7XG59KTtcblxuLy8gYEFycmF5LmZyb21gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5mcm9tXG4kJEwoeyB0YXJnZXQ6ICdBcnJheScsIHN0YXQ6IHRydWUsIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTiB9LCB7XG4gIGZyb206IGZyb20kNlxufSk7XG5cbnZhciBwYXRoJHIgPSBwYXRoJHc7XG5cbnZhciBmcm9tJDUgPSBwYXRoJHIuQXJyYXkuZnJvbTtcblxudmFyIHBhcmVudCQxOSA9IGZyb20kNTtcblxudmFyIGZyb20kNCA9IHBhcmVudCQxOTtcblxudmFyIGZyb20kMyA9IGZyb20kNDtcblxudmFyIF9BcnJheSRmcm9tJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZnJvbSQzKTtcblxudmFyIHRvSW5kZXhlZE9iamVjdCQ1ID0gdG9JbmRleGVkT2JqZWN0JGE7XG52YXIgSXRlcmF0b3JzJDEgPSBpdGVyYXRvcnM7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSQ0ID0gaW50ZXJuYWxTdGF0ZTtcbm9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgZGVmaW5lSXRlcmF0b3IkMSA9IGl0ZXJhdG9yRGVmaW5lO1xudmFyIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QkMSA9IGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QkMztcblxudmFyIEFSUkFZX0lURVJBVE9SID0gJ0FycmF5IEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlJDQgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDQuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUkMSA9IEludGVybmFsU3RhdGVNb2R1bGUkNC5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZW50cmllc1xuLy8gYEFycmF5LnByb3RvdHlwZS5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmtleXNcbi8vIGBBcnJheS5wcm90b3R5cGUudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4vLyBgQ3JlYXRlQXJyYXlJdGVyYXRvcmAgaW50ZXJuYWwgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZWFycmF5aXRlcmF0b3JcbmRlZmluZUl0ZXJhdG9yJDEoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICBzZXRJbnRlcm5hbFN0YXRlJDQodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0JDUoaXRlcmF0ZWQpLCAvLyB0YXJnZXRcbiAgICBpbmRleDogMCwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbiAgICBraW5kOiBraW5kICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtpbmRcbiAgfSk7XG4vLyBgJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlLm5leHRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lYXJyYXlpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlJDEodGhpcyk7XG4gIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQ7XG4gIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgrKztcbiAgaWYgKCF0YXJnZXQgfHwgaW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdCQxKHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbiAgc3dpdGNoIChraW5kKSB7XG4gICAgY2FzZSAna2V5cyc6IHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0JDEoaW5kZXgsIGZhbHNlKTtcbiAgICBjYXNlICd2YWx1ZXMnOiByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdCQxKHRhcmdldFtpbmRleF0sIGZhbHNlKTtcbiAgfSByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdCQxKFtpbmRleCwgdGFyZ2V0W2luZGV4XV0sIGZhbHNlKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZXVubWFwcGVkYXJndW1lbnRzb2JqZWN0XG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxuSXRlcmF0b3JzJDEuQXJndW1lbnRzID0gSXRlcmF0b3JzJDEuQXJyYXk7XG5cbnZhciBnZXRJdGVyYXRvck1ldGhvZCQ2ID0gZ2V0SXRlcmF0b3JNZXRob2QkOTtcblxudmFyIGdldEl0ZXJhdG9yTWV0aG9kXzEgPSBnZXRJdGVyYXRvck1ldGhvZCQ2O1xuXG4vLyBpdGVyYWJsZSBET00gY29sbGVjdGlvbnNcbi8vIGZsYWcgLSBgaXRlcmFibGVgIGludGVyZmFjZSAtICdlbnRyaWVzJywgJ2tleXMnLCAndmFsdWVzJywgJ2ZvckVhY2gnIG1ldGhvZHNcbnZhciBkb21JdGVyYWJsZXMgPSB7XG4gIENTU1J1bGVMaXN0OiAwLFxuICBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxuICBDU1NWYWx1ZUxpc3Q6IDAsXG4gIENsaWVudFJlY3RMaXN0OiAwLFxuICBET01SZWN0TGlzdDogMCxcbiAgRE9NU3RyaW5nTGlzdDogMCxcbiAgRE9NVG9rZW5MaXN0OiAxLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcbiAgRmlsZUxpc3Q6IDAsXG4gIEhUTUxBbGxDb2xsZWN0aW9uOiAwLFxuICBIVE1MQ29sbGVjdGlvbjogMCxcbiAgSFRNTEZvcm1FbGVtZW50OiAwLFxuICBIVE1MU2VsZWN0RWxlbWVudDogMCxcbiAgTWVkaWFMaXN0OiAwLFxuICBNaW1lVHlwZUFycmF5OiAwLFxuICBOYW1lZE5vZGVNYXA6IDAsXG4gIE5vZGVMaXN0OiAxLFxuICBQYWludFJlcXVlc3RMaXN0OiAwLFxuICBQbHVnaW46IDAsXG4gIFBsdWdpbkFycmF5OiAwLFxuICBTVkdMZW5ndGhMaXN0OiAwLFxuICBTVkdOdW1iZXJMaXN0OiAwLFxuICBTVkdQYXRoU2VnTGlzdDogMCxcbiAgU1ZHUG9pbnRMaXN0OiAwLFxuICBTVkdTdHJpbmdMaXN0OiAwLFxuICBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxuICBTb3VyY2VCdWZmZXJMaXN0OiAwLFxuICBTdHlsZVNoZWV0TGlzdDogMCxcbiAgVGV4dFRyYWNrQ3VlTGlzdDogMCxcbiAgVGV4dFRyYWNrTGlzdDogMCxcbiAgVG91Y2hMaXN0OiAwXG59O1xuXG52YXIgRE9NSXRlcmFibGVzJDIgPSBkb21JdGVyYWJsZXM7XG52YXIgZ2xvYmFsJGMgPSBnbG9iYWwkbjtcbnZhciBjbGFzc29mJDggPSBjbGFzc29mJGQ7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5JDEgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNjtcbnZhciBJdGVyYXRvcnMgPSBpdGVyYXRvcnM7XG52YXIgd2VsbEtub3duU3ltYm9sJGMgPSB3ZWxsS25vd25TeW1ib2wkbTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2wkYygndG9TdHJpbmdUYWcnKTtcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcyQyKSB7XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsJGNbQ09MTEVDVElPTl9OQU1FXTtcbiAgdmFyIENvbGxlY3Rpb25Qcm90b3R5cGUgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSAmJiBjbGFzc29mJDgoQ29sbGVjdGlvblByb3RvdHlwZSkgIT09IFRPX1NUUklOR19UQUcpIHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkMShDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCBDT0xMRUNUSU9OX05BTUUpO1xuICB9XG4gIEl0ZXJhdG9yc1tDT0xMRUNUSU9OX05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuXG52YXIgcGFyZW50JDE4ID0gZ2V0SXRlcmF0b3JNZXRob2RfMTtcblxuXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkNSA9IHBhcmVudCQxODtcblxudmFyIHBhcmVudCQxNyA9IGdldEl0ZXJhdG9yTWV0aG9kJDU7XG5cbnZhciBnZXRJdGVyYXRvck1ldGhvZCQ0ID0gcGFyZW50JDE3O1xuXG52YXIgcGFyZW50JDE2ID0gZ2V0SXRlcmF0b3JNZXRob2QkNDtcblxudmFyIGdldEl0ZXJhdG9yTWV0aG9kJDMgPSBwYXJlbnQkMTY7XG5cbnZhciBnZXRJdGVyYXRvck1ldGhvZCQyID0gZ2V0SXRlcmF0b3JNZXRob2QkMztcblxudmFyIF9nZXRJdGVyYXRvck1ldGhvZCQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGdldEl0ZXJhdG9yTWV0aG9kJDIpO1xuXG52YXIgZ2V0SXRlcmF0b3JNZXRob2QkMSA9IGdldEl0ZXJhdG9yTWV0aG9kJDI7XG5cbnZhciBfZ2V0SXRlcmF0b3JNZXRob2QgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZ2V0SXRlcmF0b3JNZXRob2QkMSk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSRjID0ge2V4cG9ydHM6IHt9fTtcblxudmFyICQkSyA9IF9leHBvcnQ7XG52YXIgREVTQ1JJUFRPUlMkOSA9IGRlc2NyaXB0b3JzO1xudmFyIGRlZmluZVByb3BlcnR5JGIgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbiQkSyh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogT2JqZWN0LmRlZmluZVByb3BlcnR5ICE9PSBkZWZpbmVQcm9wZXJ0eSRiLCBzaGFtOiAhREVTQ1JJUFRPUlMkOSB9LCB7XG4gIGRlZmluZVByb3BlcnR5OiBkZWZpbmVQcm9wZXJ0eSRiXG59KTtcblxudmFyIHBhdGgkcSA9IHBhdGgkdztcblxudmFyIE9iamVjdCQ1ID0gcGF0aCRxLk9iamVjdDtcblxudmFyIGRlZmluZVByb3BlcnR5JGEgPSBkZWZpbmVQcm9wZXJ0eSRjLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKSB7XG4gIHJldHVybiBPYmplY3QkNS5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTtcbn07XG5cbmlmIChPYmplY3QkNS5kZWZpbmVQcm9wZXJ0eS5zaGFtKSBkZWZpbmVQcm9wZXJ0eSRhLnNoYW0gPSB0cnVlO1xuXG52YXIgZGVmaW5lUHJvcGVydHlFeHBvcnRzID0gZGVmaW5lUHJvcGVydHkkYy5leHBvcnRzO1xuXG52YXIgcGFyZW50JDE1ID0gZGVmaW5lUHJvcGVydHlFeHBvcnRzO1xuXG52YXIgZGVmaW5lUHJvcGVydHkkOSA9IHBhcmVudCQxNTtcblxudmFyIHBhcmVudCQxNCA9IGRlZmluZVByb3BlcnR5JDk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQ4ID0gcGFyZW50JDE0O1xuXG52YXIgcGFyZW50JDEzID0gZGVmaW5lUHJvcGVydHkkODtcblxudmFyIGRlZmluZVByb3BlcnR5JDcgPSBwYXJlbnQkMTM7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQ2ID0gZGVmaW5lUHJvcGVydHkkNztcblxudmFyIF9PYmplY3QkZGVmaW5lUHJvcGVydHkkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhkZWZpbmVQcm9wZXJ0eSQ2KTtcblxudmFyIGNsYXNzb2YkNyA9IGNsYXNzb2ZSYXckMjtcblxuLy8gYElzQXJyYXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2FycmF5XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktaXNhcnJheSAtLSBzYWZlXG52YXIgaXNBcnJheSRlID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZ3VtZW50KSB7XG4gIHJldHVybiBjbGFzc29mJDcoYXJndW1lbnQpID09PSAnQXJyYXknO1xufTtcblxudmFyICRUeXBlRXJyb3IkOCA9IFR5cGVFcnJvcjtcbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gMHgxRkZGRkZGRkZGRkZGRjsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxuXG52YXIgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyJDMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID4gTUFYX1NBRkVfSU5URUdFUikgdGhyb3cgJFR5cGVFcnJvciQ4KCdNYXhpbXVtIGFsbG93ZWQgaW5kZXggZXhjZWVkZWQnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxudmFyIGlzQXJyYXkkZCA9IGlzQXJyYXkkZTtcbnZhciBpc0NvbnN0cnVjdG9yJDIgPSBpc0NvbnN0cnVjdG9yJDQ7XG52YXIgaXNPYmplY3QkYiA9IGlzT2JqZWN0JGo7XG52YXIgd2VsbEtub3duU3ltYm9sJGIgPSB3ZWxsS25vd25TeW1ib2wkbTtcblxudmFyIFNQRUNJRVMkMyA9IHdlbGxLbm93blN5bWJvbCRiKCdzcGVjaWVzJyk7XG52YXIgJEFycmF5JDIgPSBBcnJheTtcblxuLy8gYSBwYXJ0IG9mIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcbnZhciBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKG9yaWdpbmFsQXJyYXkpIHtcbiAgdmFyIEM7XG4gIGlmIChpc0FycmF5JGQob3JpZ2luYWxBcnJheSkpIHtcbiAgICBDID0gb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3RvcjtcbiAgICAvLyBjcm9zcy1yZWFsbSBmYWxsYmFja1xuICAgIGlmIChpc0NvbnN0cnVjdG9yJDIoQykgJiYgKEMgPT09ICRBcnJheSQyIHx8IGlzQXJyYXkkZChDLnByb3RvdHlwZSkpKSBDID0gdW5kZWZpbmVkO1xuICAgIGVsc2UgaWYgKGlzT2JqZWN0JGIoQykpIHtcbiAgICAgIEMgPSBDW1NQRUNJRVMkM107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIEMgPT09IHVuZGVmaW5lZCA/ICRBcnJheSQyIDogQztcbn07XG5cbnZhciBhcnJheVNwZWNpZXNDb25zdHJ1Y3RvciA9IGFycmF5U3BlY2llc0NvbnN0cnVjdG9yJDE7XG5cbi8vIGBBcnJheVNwZWNpZXNDcmVhdGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheXNwZWNpZXNjcmVhdGVcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUkMyA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5LCBsZW5ndGgpIHtcbiAgcmV0dXJuIG5ldyAoYXJyYXlTcGVjaWVzQ29uc3RydWN0b3Iob3JpZ2luYWxBcnJheSkpKGxlbmd0aCA9PT0gMCA/IDAgOiBsZW5ndGgpO1xufTtcblxudmFyIGZhaWxzJGsgPSBmYWlscyR3O1xudmFyIHdlbGxLbm93blN5bWJvbCRhID0gd2VsbEtub3duU3ltYm9sJG07XG52YXIgVjhfVkVSU0lPTiQxID0gZW5naW5lVjhWZXJzaW9uO1xuXG52YXIgU1BFQ0lFUyQyID0gd2VsbEtub3duU3ltYm9sJGEoJ3NwZWNpZXMnKTtcblxudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNSA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICAvLyBXZSBjYW4ndCB1c2UgdGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbiAgLy8gZGVvcHRpbWl6YXRpb24gYW5kIHNlcmlvdXMgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzY3N1xuICByZXR1cm4gVjhfVkVSU0lPTiQxID49IDUxIHx8ICFmYWlscyRrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBhcnJheS5jb25zdHJ1Y3RvciA9IHt9O1xuICAgIGNvbnN0cnVjdG9yW1NQRUNJRVMkMl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4geyBmb286IDEgfTtcbiAgICB9O1xuICAgIHJldHVybiBhcnJheVtNRVRIT0RfTkFNRV0oQm9vbGVhbikuZm9vICE9PSAxO1xuICB9KTtcbn07XG5cbnZhciAkJEogPSBfZXhwb3J0O1xudmFyIGZhaWxzJGogPSBmYWlscyR3O1xudmFyIGlzQXJyYXkkYyA9IGlzQXJyYXkkZTtcbnZhciBpc09iamVjdCRhID0gaXNPYmplY3QkajtcbnZhciB0b09iamVjdCQ5ID0gdG9PYmplY3QkZTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQ5ID0gbGVuZ3RoT2ZBcnJheUxpa2UkYztcbnZhciBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIkMiA9IGRvZXNOb3RFeGNlZWRTYWZlSW50ZWdlciQzO1xudmFyIGNyZWF0ZVByb3BlcnR5JDQgPSBjcmVhdGVQcm9wZXJ0eSQ2O1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSQyID0gYXJyYXlTcGVjaWVzQ3JlYXRlJDM7XG52YXIgYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQ0ID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCQ1O1xudmFyIHdlbGxLbm93blN5bWJvbCQ5ID0gd2VsbEtub3duU3ltYm9sJG07XG52YXIgVjhfVkVSU0lPTiA9IGVuZ2luZVY4VmVyc2lvbjtcblxudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFID0gd2VsbEtub3duU3ltYm9sJDkoJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xuXG4vLyBXZSBjYW4ndCB1c2UgdGhpcyBmZWF0dXJlIGRldGVjdGlvbiBpbiBWOCBzaW5jZSBpdCBjYXVzZXNcbi8vIGRlb3B0aW1pemF0aW9uIGFuZCBzZXJpb3VzIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNjc5XG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEVfU1VQUE9SVCA9IFY4X1ZFUlNJT04gPj0gNTEgfHwgIWZhaWxzJGooZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyYXkgPSBbXTtcbiAgYXJyYXlbSVNfQ09OQ0FUX1NQUkVBREFCTEVdID0gZmFsc2U7XG4gIHJldHVybiBhcnJheS5jb25jYXQoKVswXSAhPT0gYXJyYXk7XG59KTtcblxudmFyIGlzQ29uY2F0U3ByZWFkYWJsZSA9IGZ1bmN0aW9uIChPKSB7XG4gIGlmICghaXNPYmplY3QkYShPKSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgc3ByZWFkYWJsZSA9IE9bSVNfQ09OQ0FUX1NQUkVBREFCTEVdO1xuICByZXR1cm4gc3ByZWFkYWJsZSAhPT0gdW5kZWZpbmVkID8gISFzcHJlYWRhYmxlIDogaXNBcnJheSRjKE8pO1xufTtcblxudmFyIEZPUkNFRCRhID0gIUlTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgfHwgIWFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNCgnY29uY2F0Jyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuY29uY2F0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvbmNhdFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQGlzQ29uY2F0U3ByZWFkYWJsZSBhbmQgQEBzcGVjaWVzXG4kJEooeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBhcml0eTogMSwgZm9yY2VkOiBGT1JDRUQkYSB9LCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFycyAtLSByZXF1aXJlZCBmb3IgYC5sZW5ndGhgXG4gIGNvbmNhdDogZnVuY3Rpb24gY29uY2F0KGFyZykge1xuICAgIHZhciBPID0gdG9PYmplY3QkOSh0aGlzKTtcbiAgICB2YXIgQSA9IGFycmF5U3BlY2llc0NyZWF0ZSQyKE8sIDApO1xuICAgIHZhciBuID0gMDtcbiAgICB2YXIgaSwgaywgbGVuZ3RoLCBsZW4sIEU7XG4gICAgZm9yIChpID0gLTEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgRSA9IGkgPT09IC0xID8gTyA6IGFyZ3VtZW50c1tpXTtcbiAgICAgIGlmIChpc0NvbmNhdFNwcmVhZGFibGUoRSkpIHtcbiAgICAgICAgbGVuID0gbGVuZ3RoT2ZBcnJheUxpa2UkOShFKTtcbiAgICAgICAgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyJDIobiArIGxlbik7XG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBsZW47IGsrKywgbisrKSBpZiAoayBpbiBFKSBjcmVhdGVQcm9wZXJ0eSQ0KEEsIG4sIEVba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyJDIobiArIDEpO1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eSQ0KEEsIG4rKywgRSk7XG4gICAgICB9XG4gICAgfVxuICAgIEEubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzID0ge307XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBvYmplY3RLZXlzSW50ZXJuYWw7XG52YXIgZW51bUJ1Z0tleXMgPSBlbnVtQnVnS2V5cyQzO1xuXG52YXIgaGlkZGVuS2V5cyQyID0gZW51bUJ1Z0tleXMuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxub2JqZWN0R2V0T3duUHJvcGVydHlOYW1lcy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyQyKTtcbn07XG5cbnZhciBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwgPSB7fTtcblxudmFyIHRvQWJzb2x1dGVJbmRleCQzID0gdG9BYnNvbHV0ZUluZGV4JDU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkOCA9IGxlbmd0aE9mQXJyYXlMaWtlJGM7XG52YXIgY3JlYXRlUHJvcGVydHkkMyA9IGNyZWF0ZVByb3BlcnR5JDY7XG5cbnZhciAkQXJyYXkkMSA9IEFycmF5O1xudmFyIG1heCQyID0gTWF0aC5tYXg7XG5cbnZhciBhcnJheVNsaWNlU2ltcGxlID0gZnVuY3Rpb24gKE8sIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDgoTyk7XG4gIHZhciBrID0gdG9BYnNvbHV0ZUluZGV4JDMoc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgkMyhlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IGVuZCwgbGVuZ3RoKTtcbiAgdmFyIHJlc3VsdCA9ICRBcnJheSQxKG1heCQyKGZpbiAtIGssIDApKTtcbiAgdmFyIG4gPSAwO1xuICBmb3IgKDsgayA8IGZpbjsgaysrLCBuKyspIGNyZWF0ZVByb3BlcnR5JDMocmVzdWx0LCBuLCBPW2tdKTtcbiAgcmVzdWx0Lmxlbmd0aCA9IG47XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlICovXG52YXIgY2xhc3NvZiQ2ID0gY2xhc3NvZlJhdyQyO1xudmFyIHRvSW5kZXhlZE9iamVjdCQ0ID0gdG9JbmRleGVkT2JqZWN0JGE7XG52YXIgJGdldE93blByb3BlcnR5TmFtZXMkMSA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXMuZjtcbnZhciBhcnJheVNsaWNlJDMgPSBhcnJheVNsaWNlU2ltcGxlO1xuXG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc1xuICA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcblxudmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eU5hbWVzJDEoaXQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBhcnJheVNsaWNlJDMod2luZG93TmFtZXMpO1xuICB9XG59O1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG5vYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgcmV0dXJuIHdpbmRvd05hbWVzICYmIGNsYXNzb2YkNihpdCkgPT09ICdXaW5kb3cnXG4gICAgPyBnZXRXaW5kb3dOYW1lcyhpdClcbiAgICA6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzJDEodG9JbmRleGVkT2JqZWN0JDQoaXQpKTtcbn07XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSQ1ID0gb2JqZWN0RGVmaW5lUHJvcGVydHk7XG5cbnZhciBkZWZpbmVCdWlsdEluQWNjZXNzb3IkMyA9IGZ1bmN0aW9uICh0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5JDUuZih0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpO1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbFdyYXBwZWQgPSB7fTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQ4ID0gd2VsbEtub3duU3ltYm9sJG07XG5cbndlbGxLbm93blN5bWJvbFdyYXBwZWQuZiA9IHdlbGxLbm93blN5bWJvbCQ4O1xuXG52YXIgcGF0aCRwID0gcGF0aCR3O1xudmFyIGhhc093biQ4ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlJDEgPSB3ZWxsS25vd25TeW1ib2xXcmFwcGVkO1xudmFyIGRlZmluZVByb3BlcnR5JDQgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xuXG52YXIgd2VsbEtub3duU3ltYm9sRGVmaW5lID0gZnVuY3Rpb24gKE5BTUUpIHtcbiAgdmFyIFN5bWJvbCA9IHBhdGgkcC5TeW1ib2wgfHwgKHBhdGgkcC5TeW1ib2wgPSB7fSk7XG4gIGlmICghaGFzT3duJDgoU3ltYm9sLCBOQU1FKSkgZGVmaW5lUHJvcGVydHkkNChTeW1ib2wsIE5BTUUsIHtcbiAgICB2YWx1ZTogd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSQxLmYoTkFNRSlcbiAgfSk7XG59O1xuXG52YXIgY2FsbCQ0ID0gZnVuY3Rpb25DYWxsO1xudmFyIGdldEJ1aWx0SW4kOCA9IGdldEJ1aWx0SW4kYztcbnZhciB3ZWxsS25vd25TeW1ib2wkNyA9IHdlbGxLbm93blN5bWJvbCRtO1xudmFyIGRlZmluZUJ1aWx0SW4kMiA9IGRlZmluZUJ1aWx0SW4kNTtcblxudmFyIHN5bWJvbERlZmluZVRvUHJpbWl0aXZlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgU3ltYm9sID0gZ2V0QnVpbHRJbiQ4KCdTeW1ib2wnKTtcbiAgdmFyIFN5bWJvbFByb3RvdHlwZSA9IFN5bWJvbCAmJiBTeW1ib2wucHJvdG90eXBlO1xuICB2YXIgdmFsdWVPZiA9IFN5bWJvbFByb3RvdHlwZSAmJiBTeW1ib2xQcm90b3R5cGUudmFsdWVPZjtcbiAgdmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCQ3KCd0b1ByaW1pdGl2ZScpO1xuXG4gIGlmIChTeW1ib2xQcm90b3R5cGUgJiYgIVN5bWJvbFByb3RvdHlwZVtUT19QUklNSVRJVkVdKSB7XG4gICAgLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvcHJpbWl0aXZlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciAubGVuZ3RoXG4gICAgZGVmaW5lQnVpbHRJbiQyKFN5bWJvbFByb3RvdHlwZSwgVE9fUFJJTUlUSVZFLCBmdW5jdGlvbiAoaGludCkge1xuICAgICAgcmV0dXJuIGNhbGwkNCh2YWx1ZU9mLCB0aGlzKTtcbiAgICB9LCB7IGFyaXR5OiAxIH0pO1xuICB9XG59O1xuXG52YXIgYmluZCQ2ID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciB1bmN1cnJ5VGhpcyRoID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBJbmRleGVkT2JqZWN0JDEgPSBpbmRleGVkT2JqZWN0O1xudmFyIHRvT2JqZWN0JDggPSB0b09iamVjdCRlO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDcgPSBsZW5ndGhPZkFycmF5TGlrZSRjO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSQxID0gYXJyYXlTcGVjaWVzQ3JlYXRlJDM7XG5cbnZhciBwdXNoJGEgPSB1bmN1cnJ5VGhpcyRoKFtdLnB1c2gpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnsgZm9yRWFjaCwgbWFwLCBmaWx0ZXIsIHNvbWUsIGV2ZXJ5LCBmaW5kLCBmaW5kSW5kZXgsIGZpbHRlclJlamVjdCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kJDIgPSBmdW5jdGlvbiAoVFlQRSkge1xuICB2YXIgSVNfTUFQID0gVFlQRSA9PT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT09IDI7XG4gIHZhciBJU19TT01FID0gVFlQRSA9PT0gMztcbiAgdmFyIElTX0VWRVJZID0gVFlQRSA9PT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09PSA2O1xuICB2YXIgSVNfRklMVEVSX1JFSkVDVCA9IFRZUEUgPT09IDc7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT09IDUgfHwgSVNfRklORF9JTkRFWDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgY2FsbGJhY2tmbiwgdGhhdCwgc3BlY2lmaWNDcmVhdGUpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0JDgoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdCQxKE8pO1xuICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZCQ2KGNhbGxiYWNrZm4sIHRoYXQpO1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ3KHNlbGYpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZSQxO1xuICAgIHZhciB0YXJnZXQgPSBJU19NQVAgPyBjcmVhdGUoJHRoaXMsIGxlbmd0aCkgOiBJU19GSUxURVIgfHwgSVNfRklMVEVSX1JFSkVDVCA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbHVlLCByZXN1bHQ7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWx1ZSA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgdGFyZ2V0W2luZGV4XSA9IHJlc3VsdDsgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCkgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWx1ZTsgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHB1c2gkYSh0YXJnZXQsIHZhbHVlKTsgICAgICAvLyBmaWx0ZXJcbiAgICAgICAgfSBlbHNlIHN3aXRjaCAoVFlQRSkge1xuICAgICAgICAgIGNhc2UgNDogcmV0dXJuIGZhbHNlOyAgICAgICAgICAgICAvLyBldmVyeVxuICAgICAgICAgIGNhc2UgNzogcHVzaCRhKHRhcmdldCwgdmFsdWUpOyAgICAgIC8vIGZpbHRlclJlamVjdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiB0YXJnZXQ7XG4gIH07XG59O1xuXG52YXIgYXJyYXlJdGVyYXRpb24gPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbiAgZm9yRWFjaDogY3JlYXRlTWV0aG9kJDIoMCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUubWFwXG4gIG1hcDogY3JlYXRlTWV0aG9kJDIoMSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsdGVyXG4gIGZpbHRlcjogY3JlYXRlTWV0aG9kJDIoMiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcbiAgc29tZTogY3JlYXRlTWV0aG9kJDIoMyksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuICBldmVyeTogY3JlYXRlTWV0aG9kJDIoNCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbmRcbiAgZmluZDogY3JlYXRlTWV0aG9kJDIoNSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZEluZGV4XG4gIGZpbmRJbmRleDogY3JlYXRlTWV0aG9kJDIoNiksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyUmVqZWN0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtYXJyYXktZmlsdGVyaW5nXG4gIGZpbHRlclJlamVjdDogY3JlYXRlTWV0aG9kJDIoNylcbn07XG5cbnZhciAkJEkgPSBfZXhwb3J0O1xudmFyIGdsb2JhbCRiID0gZ2xvYmFsJG47XG52YXIgY2FsbCQzID0gZnVuY3Rpb25DYWxsO1xudmFyIHVuY3VycnlUaGlzJGcgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIERFU0NSSVBUT1JTJDggPSBkZXNjcmlwdG9ycztcbnZhciBOQVRJVkVfU1lNQk9MJDMgPSBzeW1ib2xDb25zdHJ1Y3RvckRldGVjdGlvbjtcbnZhciBmYWlscyRpID0gZmFpbHMkdztcbnZhciBoYXNPd24kNyA9IGhhc093blByb3BlcnR5XzE7XG52YXIgaXNQcm90b3R5cGVPZiRpID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBhbk9iamVjdCQ1ID0gYW5PYmplY3QkZDtcbnZhciB0b0luZGV4ZWRPYmplY3QkMyA9IHRvSW5kZXhlZE9iamVjdCRhO1xudmFyIHRvUHJvcGVydHlLZXkgPSB0b1Byb3BlcnR5S2V5JDQ7XG52YXIgJHRvU3RyaW5nID0gdG9TdHJpbmckYTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IkNTtcbnZhciBuYXRpdmVPYmplY3RDcmVhdGUgPSBvYmplY3RDcmVhdGU7XG52YXIgb2JqZWN0S2V5cyA9IG9iamVjdEtleXMkMztcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlJDIgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbCA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbDtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMiA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUkMiA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IG9iamVjdERlZmluZVByb3BlcnR5O1xudmFyIGRlZmluZVByb3BlcnRpZXNNb2R1bGUgPSBvYmplY3REZWZpbmVQcm9wZXJ0aWVzO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gb2JqZWN0UHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgZGVmaW5lQnVpbHRJbiQxID0gZGVmaW5lQnVpbHRJbiQ1O1xudmFyIGRlZmluZUJ1aWx0SW5BY2Nlc3NvciQyID0gZGVmaW5lQnVpbHRJbkFjY2Vzc29yJDM7XG52YXIgc2hhcmVkJDMgPSBzaGFyZWRFeHBvcnRzO1xudmFyIHNoYXJlZEtleSA9IHNoYXJlZEtleSQ0O1xudmFyIGhpZGRlbktleXMkMSA9IGhpZGRlbktleXMkNjtcbnZhciB1aWQkMSA9IHVpZCQ0O1xudmFyIHdlbGxLbm93blN5bWJvbCQ2ID0gd2VsbEtub3duU3ltYm9sJG07XG52YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IHdlbGxLbm93blN5bWJvbFdyYXBwZWQ7XG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGwgPSB3ZWxsS25vd25TeW1ib2xEZWZpbmU7XG52YXIgZGVmaW5lU3ltYm9sVG9QcmltaXRpdmUkMSA9IHN5bWJvbERlZmluZVRvUHJpbWl0aXZlO1xudmFyIHNldFRvU3RyaW5nVGFnJDMgPSBzZXRUb1N0cmluZ1RhZyQ2O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUkMyA9IGludGVybmFsU3RhdGU7XG52YXIgJGZvckVhY2gkMSA9IGFycmF5SXRlcmF0aW9uLmZvckVhY2g7XG5cbnZhciBISURERU4gPSBzaGFyZWRLZXkoJ2hpZGRlbicpO1xudmFyIFNZTUJPTCA9ICdTeW1ib2wnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQzID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQzLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQzLmdldHRlckZvcihTWU1CT0wpO1xuXG52YXIgT2JqZWN0UHJvdG90eXBlJDEgPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciAkU3ltYm9sID0gZ2xvYmFsJGIuU3ltYm9sO1xudmFyIFN5bWJvbFByb3RvdHlwZSA9ICRTeW1ib2wgJiYgJFN5bWJvbFtQUk9UT1RZUEVdO1xudmFyIFJhbmdlRXJyb3IkMSA9IGdsb2JhbCRiLlJhbmdlRXJyb3I7XG52YXIgVHlwZUVycm9yJDEgPSBnbG9iYWwkYi5UeXBlRXJyb3I7XG52YXIgUU9iamVjdCA9IGdsb2JhbCRiLlFPYmplY3Q7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUkMi5mO1xudmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzID0gZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmY7XG52YXIgbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xudmFyIHB1c2gkOSA9IHVuY3VycnlUaGlzJGcoW10ucHVzaCk7XG5cbnZhciBBbGxTeW1ib2xzID0gc2hhcmVkJDMoJ3N5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90b3R5cGVTeW1ib2xzID0gc2hhcmVkJDMoJ29wLXN5bWJvbHMnKTtcbnZhciBXZWxsS25vd25TeW1ib2xzU3RvcmUkMSA9IHNoYXJlZCQzKCd3a3MnKTtcblxuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgVVNFX1NFVFRFUiA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIGZhbGxiYWNrRGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAoTywgUCwgQXR0cmlidXRlcykge1xuICB2YXIgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKE9iamVjdFByb3RvdHlwZSQxLCBQKTtcbiAgaWYgKE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IpIGRlbGV0ZSBPYmplY3RQcm90b3R5cGUkMVtQXTtcbiAgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yICYmIE8gIT09IE9iamVjdFByb3RvdHlwZSQxKSB7XG4gICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlJDEsIFAsIE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IpO1xuICB9XG59O1xuXG52YXIgc2V0U3ltYm9sRGVzY3JpcHRvciA9IERFU0NSSVBUT1JTJDggJiYgZmFpbHMkaShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RDcmVhdGUobmF0aXZlRGVmaW5lUHJvcGVydHkoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT09IDc7XG59KSA/IGZhbGxiYWNrRGVmaW5lUHJvcGVydHkgOiBuYXRpdmVEZWZpbmVQcm9wZXJ0eTtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnLCBkZXNjcmlwdGlvbikge1xuICB2YXIgc3ltYm9sID0gQWxsU3ltYm9sc1t0YWddID0gbmF0aXZlT2JqZWN0Q3JlYXRlKFN5bWJvbFByb3RvdHlwZSk7XG4gIHNldEludGVybmFsU3RhdGUkMyhzeW1ib2wsIHtcbiAgICB0eXBlOiBTWU1CT0wsXG4gICAgdGFnOiB0YWcsXG4gICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uXG4gIH0pO1xuICBpZiAoIURFU0NSSVBUT1JTJDgpIHN5bWJvbC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICByZXR1cm4gc3ltYm9sO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgaWYgKE8gPT09IE9iamVjdFByb3RvdHlwZSQxKSAkZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCwgQXR0cmlidXRlcyk7XG4gIGFuT2JqZWN0JDUoTyk7XG4gIHZhciBrZXkgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdCQ1KEF0dHJpYnV0ZXMpO1xuICBpZiAoaGFzT3duJDcoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghQXR0cmlidXRlcy5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhc093biQ3KE8sIEhJRERFTikpIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIEhJRERFTiwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHt9KSk7XG4gICAgICBPW0hJRERFTl1ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChoYXNPd24kNyhPLCBISURERU4pICYmIE9bSElEREVOXVtrZXldKSBPW0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgQXR0cmlidXRlcyA9IG5hdGl2ZU9iamVjdENyZWF0ZShBdHRyaWJ1dGVzLCB7IGVudW1lcmFibGU6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzY3JpcHRvcihPLCBrZXksIEF0dHJpYnV0ZXMpO1xuICB9IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBrZXksIEF0dHJpYnV0ZXMpO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0JDUoTyk7XG4gIHZhciBwcm9wZXJ0aWVzID0gdG9JbmRleGVkT2JqZWN0JDMoUHJvcGVydGllcyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhwcm9wZXJ0aWVzKS5jb25jYXQoJGdldE93blByb3BlcnR5U3ltYm9scyhwcm9wZXJ0aWVzKSk7XG4gICRmb3JFYWNoJDEoa2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghREVTQ1JJUFRPUlMkOCB8fCBjYWxsJDMoJHByb3BlcnR5SXNFbnVtZXJhYmxlLCBwcm9wZXJ0aWVzLCBrZXkpKSAkZGVmaW5lUHJvcGVydHkoTywga2V5LCBwcm9wZXJ0aWVzW2tleV0pO1xuICB9KTtcbiAgcmV0dXJuIE87XG59O1xuXG52YXIgJGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyBuYXRpdmVPYmplY3RDcmVhdGUoTykgOiAkZGVmaW5lUHJvcGVydGllcyhuYXRpdmVPYmplY3RDcmVhdGUoTyksIFByb3BlcnRpZXMpO1xufTtcblxudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIFAgPSB0b1Byb3BlcnR5S2V5KFYpO1xuICB2YXIgZW51bWVyYWJsZSA9IGNhbGwkMyhuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSwgdGhpcywgUCk7XG4gIGlmICh0aGlzID09PSBPYmplY3RQcm90b3R5cGUkMSAmJiBoYXNPd24kNyhBbGxTeW1ib2xzLCBQKSAmJiAhaGFzT3duJDcoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGVudW1lcmFibGUgfHwgIWhhc093biQ3KHRoaXMsIFApIHx8ICFoYXNPd24kNyhBbGxTeW1ib2xzLCBQKSB8fCBoYXNPd24kNyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtQXVxuICAgID8gZW51bWVyYWJsZSA6IHRydWU7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIHZhciBpdCA9IHRvSW5kZXhlZE9iamVjdCQzKE8pO1xuICB2YXIga2V5ID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90b3R5cGUkMSAmJiBoYXNPd24kNyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXNPd24kNyhPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBrZXkpKSByZXR1cm47XG4gIHZhciBkZXNjcmlwdG9yID0gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoaXQsIGtleSk7XG4gIGlmIChkZXNjcmlwdG9yICYmIGhhc093biQ3KEFsbFN5bWJvbHMsIGtleSkgJiYgIShoYXNPd24kNyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSB7XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuICB2YXIgbmFtZXMgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKHRvSW5kZXhlZE9iamVjdCQzKE8pKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICAkZm9yRWFjaCQxKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCFoYXNPd24kNyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXNPd24kNyhoaWRkZW5LZXlzJDEsIGtleSkpIHB1c2gkOShyZXN1bHQsIGtleSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiAoTykge1xuICB2YXIgSVNfT0JKRUNUX1BST1RPVFlQRSA9IE8gPT09IE9iamVjdFByb3RvdHlwZSQxO1xuICB2YXIgbmFtZXMgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKElTX09CSkVDVF9QUk9UT1RZUEUgPyBPYmplY3RQcm90b3R5cGVTeW1ib2xzIDogdG9JbmRleGVkT2JqZWN0JDMoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoJDEobmFtZXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoaGFzT3duJDcoQWxsU3ltYm9scywga2V5KSAmJiAoIUlTX09CSkVDVF9QUk9UT1RZUEUgfHwgaGFzT3duJDcoT2JqZWN0UHJvdG90eXBlJDEsIGtleSkpKSB7XG4gICAgICBwdXNoJDkocmVzdWx0LCBBbGxTeW1ib2xzW2tleV0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBgU3ltYm9sYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wtY29uc3RydWN0b3JcbmlmICghTkFUSVZFX1NZTUJPTCQzKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKGlzUHJvdG90eXBlT2YkaShTeW1ib2xQcm90b3R5cGUsIHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yJDEoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9ICFhcmd1bWVudHMubGVuZ3RoIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogJHRvU3RyaW5nKGFyZ3VtZW50c1swXSk7XG4gICAgdmFyIHRhZyA9IHVpZCQxKGRlc2NyaXB0aW9uKTtcbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG90eXBlJDEpIGNhbGwkMyhzZXR0ZXIsIE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIHZhbHVlKTtcbiAgICAgIGlmIChoYXNPd24kNyh0aGlzLCBISURERU4pICYmIGhhc093biQ3KHRoaXNbSElEREVOXSwgdGFnKSkgdGhpc1tISURERU5dW3RhZ10gPSBmYWxzZTtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldFN5bWJvbERlc2NyaXB0b3IodGhpcywgdGFnLCBkZXNjcmlwdG9yKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgUmFuZ2VFcnJvciQxKSkgdGhyb3cgZXJyb3I7XG4gICAgICAgIGZhbGxiYWNrRGVmaW5lUHJvcGVydHkodGhpcywgdGFnLCBkZXNjcmlwdG9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChERVNDUklQVE9SUyQ4ICYmIFVTRV9TRVRURVIpIHNldFN5bWJvbERlc2NyaXB0b3IoT2JqZWN0UHJvdG90eXBlJDEsIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogc2V0dGVyIH0pO1xuICAgIHJldHVybiB3cmFwKHRhZywgZGVzY3JpcHRpb24pO1xuICB9O1xuXG4gIFN5bWJvbFByb3RvdHlwZSA9ICRTeW1ib2xbUFJPVE9UWVBFXTtcblxuICBkZWZpbmVCdWlsdEluJDEoU3ltYm9sUHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS50YWc7XG4gIH0pO1xuXG4gIGRlZmluZUJ1aWx0SW4kMSgkU3ltYm9sLCAnd2l0aG91dFNldHRlcicsIGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgIHJldHVybiB3cmFwKHVpZCQxKGRlc2NyaXB0aW9uKSwgZGVzY3JpcHRpb24pO1xuICB9KTtcblxuICBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mID0gJGRlZmluZVByb3BlcnR5O1xuICBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlLmYgPSAkZGVmaW5lUHJvcGVydGllcztcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlJDIuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUkMi5mID0gZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmYgPSAkZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDIuZiA9ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbiAgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZS5mID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gd3JhcCh3ZWxsS25vd25TeW1ib2wkNihuYW1lKSwgbmFtZSk7XG4gIH07XG5cbiAgaWYgKERFU0NSSVBUT1JTJDgpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1TeW1ib2wtZGVzY3JpcHRpb25cbiAgICBkZWZpbmVCdWlsdEluQWNjZXNzb3IkMihTeW1ib2xQcm90b3R5cGUsICdkZXNjcmlwdGlvbicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLmRlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbiQkSSh7IGdsb2JhbDogdHJ1ZSwgY29uc3RydWN0b3I6IHRydWUsIHdyYXA6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wkMywgc2hhbTogIU5BVElWRV9TWU1CT0wkMyB9LCB7XG4gIFN5bWJvbDogJFN5bWJvbFxufSk7XG5cbiRmb3JFYWNoJDEob2JqZWN0S2V5cyhXZWxsS25vd25TeW1ib2xzU3RvcmUkMSksIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlZmluZVdlbGxLbm93blN5bWJvbCRsKG5hbWUpO1xufSk7XG5cbiQkSSh7IHRhcmdldDogU1lNQk9MLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MJDMgfSwge1xuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgVVNFX1NFVFRFUiA9IHRydWU7IH0sXG4gIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBVU0VfU0VUVEVSID0gZmFsc2U7IH1cbn0pO1xuXG4kJEkoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MJDMsIHNoYW06ICFERVNDUklQVE9SUyQ4IH0sIHtcbiAgLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbiAgZGVmaW5lUHJvcGVydHk6ICRkZWZpbmVQcm9wZXJ0eSxcbiAgLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvclxufSk7XG5cbiQkSSh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wkMyB9LCB7XG4gIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXNcbn0pO1xuXG4vLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3ByaW1pdGl2ZVxuZGVmaW5lU3ltYm9sVG9QcmltaXRpdmUkMSgpO1xuXG4vLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXWAgcHJvcGVydHlcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnXG5zZXRUb1N0cmluZ1RhZyQzKCRTeW1ib2wsIFNZTUJPTCk7XG5cbmhpZGRlbktleXMkMVtISURERU5dID0gdHJ1ZTtcblxudmFyIE5BVElWRV9TWU1CT0wkMiA9IHN5bWJvbENvbnN0cnVjdG9yRGV0ZWN0aW9uO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBlcy9uby1zeW1ib2wgLS0gc2FmZSAqL1xudmFyIHN5bWJvbFJlZ2lzdHJ5RGV0ZWN0aW9uID0gTkFUSVZFX1NZTUJPTCQyICYmICEhU3ltYm9sWydmb3InXSAmJiAhIVN5bWJvbC5rZXlGb3I7XG5cbnZhciAkJEggPSBfZXhwb3J0O1xudmFyIGdldEJ1aWx0SW4kNyA9IGdldEJ1aWx0SW4kYztcbnZhciBoYXNPd24kNiA9IGhhc093blByb3BlcnR5XzE7XG52YXIgdG9TdHJpbmckNiA9IHRvU3RyaW5nJGE7XG52YXIgc2hhcmVkJDIgPSBzaGFyZWRFeHBvcnRzO1xudmFyIE5BVElWRV9TWU1CT0xfUkVHSVNUUlkkMSA9IHN5bWJvbFJlZ2lzdHJ5RGV0ZWN0aW9uO1xuXG52YXIgU3RyaW5nVG9TeW1ib2xSZWdpc3RyeSA9IHNoYXJlZCQyKCdzdHJpbmctdG8tc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSQxID0gc2hhcmVkJDIoJ3N5bWJvbC10by1zdHJpbmctcmVnaXN0cnknKTtcblxuLy8gYFN5bWJvbC5mb3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuZm9yXG4kJEgoeyB0YXJnZXQ6ICdTeW1ib2wnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MX1JFR0lTVFJZJDEgfSwge1xuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBzdHJpbmcgPSB0b1N0cmluZyQ2KGtleSk7XG4gICAgaWYgKGhhc093biQ2KFN0cmluZ1RvU3ltYm9sUmVnaXN0cnksIHN0cmluZykpIHJldHVybiBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ107XG4gICAgdmFyIHN5bWJvbCA9IGdldEJ1aWx0SW4kNygnU3ltYm9sJykoc3RyaW5nKTtcbiAgICBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ10gPSBzeW1ib2w7XG4gICAgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSQxW3N5bWJvbF0gPSBzdHJpbmc7XG4gICAgcmV0dXJuIHN5bWJvbDtcbiAgfVxufSk7XG5cbnZhciAkJEcgPSBfZXhwb3J0O1xudmFyIGhhc093biQ1ID0gaGFzT3duUHJvcGVydHlfMTtcbnZhciBpc1N5bWJvbCQyID0gaXNTeW1ib2wkNTtcbnZhciB0cnlUb1N0cmluZyQzID0gdHJ5VG9TdHJpbmckNjtcbnZhciBzaGFyZWQkMSA9IHNoYXJlZEV4cG9ydHM7XG52YXIgTkFUSVZFX1NZTUJPTF9SRUdJU1RSWSA9IHN5bWJvbFJlZ2lzdHJ5RGV0ZWN0aW9uO1xuXG52YXIgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSA9IHNoYXJlZCQxKCdzeW1ib2wtdG8tc3RyaW5nLXJlZ2lzdHJ5Jyk7XG5cbi8vIGBTeW1ib2wua2V5Rm9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLmtleWZvclxuJCRHKHsgdGFyZ2V0OiAnU3ltYm9sJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTF9SRUdJU1RSWSB9LCB7XG4gIGtleUZvcjogZnVuY3Rpb24ga2V5Rm9yKHN5bSkge1xuICAgIGlmICghaXNTeW1ib2wkMihzeW0pKSB0aHJvdyBuZXcgVHlwZUVycm9yKHRyeVRvU3RyaW5nJDMoc3ltKSArICcgaXMgbm90IGEgc3ltYm9sJyk7XG4gICAgaWYgKGhhc093biQ1KFN5bWJvbFRvU3RyaW5nUmVnaXN0cnksIHN5bSkpIHJldHVybiBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5W3N5bV07XG4gIH1cbn0pO1xuXG52YXIgdW5jdXJyeVRoaXMkZiA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaXNBcnJheSRiID0gaXNBcnJheSRlO1xudmFyIGlzQ2FsbGFibGUkMyA9IGlzQ2FsbGFibGUkaTtcbnZhciBjbGFzc29mJDUgPSBjbGFzc29mUmF3JDI7XG52YXIgdG9TdHJpbmckNSA9IHRvU3RyaW5nJGE7XG5cbnZhciBwdXNoJDggPSB1bmN1cnJ5VGhpcyRmKFtdLnB1c2gpO1xuXG52YXIgZ2V0SnNvblJlcGxhY2VyRnVuY3Rpb24gPSBmdW5jdGlvbiAocmVwbGFjZXIpIHtcbiAgaWYgKGlzQ2FsbGFibGUkMyhyZXBsYWNlcikpIHJldHVybiByZXBsYWNlcjtcbiAgaWYgKCFpc0FycmF5JGIocmVwbGFjZXIpKSByZXR1cm47XG4gIHZhciByYXdMZW5ndGggPSByZXBsYWNlci5sZW5ndGg7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3TGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxlbWVudCA9IHJlcGxhY2VyW2ldO1xuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PSAnc3RyaW5nJykgcHVzaCQ4KGtleXMsIGVsZW1lbnQpO1xuICAgIGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50ID09ICdudW1iZXInIHx8IGNsYXNzb2YkNShlbGVtZW50KSA9PT0gJ051bWJlcicgfHwgY2xhc3NvZiQ1KGVsZW1lbnQpID09PSAnU3RyaW5nJykgcHVzaCQ4KGtleXMsIHRvU3RyaW5nJDUoZWxlbWVudCkpO1xuICB9XG4gIHZhciBrZXlzTGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciByb290ID0gdHJ1ZTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKHJvb3QpIHtcbiAgICAgIHJvb3QgPSBmYWxzZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkkYih0aGlzKSkgcmV0dXJuIHZhbHVlO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5c0xlbmd0aDsgaisrKSBpZiAoa2V5c1tqXSA9PT0ga2V5KSByZXR1cm4gdmFsdWU7XG4gIH07XG59O1xuXG52YXIgJCRGID0gX2V4cG9ydDtcbnZhciBnZXRCdWlsdEluJDYgPSBnZXRCdWlsdEluJGM7XG52YXIgYXBwbHkkMyA9IGZ1bmN0aW9uQXBwbHk7XG52YXIgY2FsbCQyID0gZnVuY3Rpb25DYWxsO1xudmFyIHVuY3VycnlUaGlzJGUgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGZhaWxzJGggPSBmYWlscyR3O1xudmFyIGlzQ2FsbGFibGUkMiA9IGlzQ2FsbGFibGUkaTtcbnZhciBpc1N5bWJvbCQxID0gaXNTeW1ib2wkNTtcbnZhciBhcnJheVNsaWNlJDIgPSBhcnJheVNsaWNlJDU7XG52YXIgZ2V0UmVwbGFjZXJGdW5jdGlvbiA9IGdldEpzb25SZXBsYWNlckZ1bmN0aW9uO1xudmFyIE5BVElWRV9TWU1CT0wkMSA9IHN5bWJvbENvbnN0cnVjdG9yRGV0ZWN0aW9uO1xuXG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciAkc3RyaW5naWZ5ID0gZ2V0QnVpbHRJbiQ2KCdKU09OJywgJ3N0cmluZ2lmeScpO1xudmFyIGV4ZWMkMSA9IHVuY3VycnlUaGlzJGUoLy4vLmV4ZWMpO1xudmFyIGNoYXJBdCQxID0gdW5jdXJyeVRoaXMkZSgnJy5jaGFyQXQpO1xudmFyIGNoYXJDb2RlQXQgPSB1bmN1cnJ5VGhpcyRlKCcnLmNoYXJDb2RlQXQpO1xudmFyIHJlcGxhY2UkMSA9IHVuY3VycnlUaGlzJGUoJycucmVwbGFjZSk7XG52YXIgbnVtYmVyVG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyRlKDEuMC50b1N0cmluZyk7XG5cbnZhciB0ZXN0ZXIgPSAvW1xcdUQ4MDAtXFx1REZGRl0vZztcbnZhciBsb3cgPSAvXltcXHVEODAwLVxcdURCRkZdJC87XG52YXIgaGkgPSAvXltcXHVEQzAwLVxcdURGRkZdJC87XG5cbnZhciBXUk9OR19TWU1CT0xTX0NPTlZFUlNJT04gPSAhTkFUSVZFX1NZTUJPTCQxIHx8IGZhaWxzJGgoZnVuY3Rpb24gKCkge1xuICB2YXIgc3ltYm9sID0gZ2V0QnVpbHRJbiQ2KCdTeW1ib2wnKSgnc3RyaW5naWZ5IGRldGVjdGlvbicpO1xuICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fVxuICByZXR1cm4gJHN0cmluZ2lmeShbc3ltYm9sXSkgIT09ICdbbnVsbF0nXG4gICAgLy8gV2ViS2l0IGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyBudWxsXG4gICAgfHwgJHN0cmluZ2lmeSh7IGE6IHN5bWJvbCB9KSAhPT0gJ3t9J1xuICAgIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gICAgfHwgJHN0cmluZ2lmeShPYmplY3Qoc3ltYm9sKSkgIT09ICd7fSc7XG59KTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtd2VsbC1mb3JtZWQtc3RyaW5naWZ5XG52YXIgSUxMX0ZPUk1FRF9VTklDT0RFID0gZmFpbHMkaChmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAkc3RyaW5naWZ5KCdcXHVERjA2XFx1RDgzNCcpICE9PSAnXCJcXFxcdWRmMDZcXFxcdWQ4MzRcIidcbiAgICB8fCAkc3RyaW5naWZ5KCdcXHVERUFEJykgIT09ICdcIlxcXFx1ZGVhZFwiJztcbn0pO1xuXG52YXIgc3RyaW5naWZ5V2l0aFN5bWJvbHNGaXggPSBmdW5jdGlvbiAoaXQsIHJlcGxhY2VyKSB7XG4gIHZhciBhcmdzID0gYXJyYXlTbGljZSQyKGFyZ3VtZW50cyk7XG4gIHZhciAkcmVwbGFjZXIgPSBnZXRSZXBsYWNlckZ1bmN0aW9uKHJlcGxhY2VyKTtcbiAgaWYgKCFpc0NhbGxhYmxlJDIoJHJlcGxhY2VyKSAmJiAoaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbCQxKGl0KSkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICBhcmdzWzFdID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAvLyBzb21lIG9sZCBpbXBsZW1lbnRhdGlvbnMgKGxpa2UgV2ViS2l0KSBjb3VsZCBwYXNzIG51bWJlcnMgYXMga2V5c1xuICAgIGlmIChpc0NhbGxhYmxlJDIoJHJlcGxhY2VyKSkgdmFsdWUgPSBjYWxsJDIoJHJlcGxhY2VyLCB0aGlzLCAkU3RyaW5nKGtleSksIHZhbHVlKTtcbiAgICBpZiAoIWlzU3ltYm9sJDEodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gIH07XG4gIHJldHVybiBhcHBseSQzKCRzdHJpbmdpZnksIG51bGwsIGFyZ3MpO1xufTtcblxudmFyIGZpeElsbEZvcm1lZCA9IGZ1bmN0aW9uIChtYXRjaCwgb2Zmc2V0LCBzdHJpbmcpIHtcbiAgdmFyIHByZXYgPSBjaGFyQXQkMShzdHJpbmcsIG9mZnNldCAtIDEpO1xuICB2YXIgbmV4dCA9IGNoYXJBdCQxKHN0cmluZywgb2Zmc2V0ICsgMSk7XG4gIGlmICgoZXhlYyQxKGxvdywgbWF0Y2gpICYmICFleGVjJDEoaGksIG5leHQpKSB8fCAoZXhlYyQxKGhpLCBtYXRjaCkgJiYgIWV4ZWMkMShsb3csIHByZXYpKSkge1xuICAgIHJldHVybiAnXFxcXHUnICsgbnVtYmVyVG9TdHJpbmcoY2hhckNvZGVBdChtYXRjaCwgMCksIDE2KTtcbiAgfSByZXR1cm4gbWF0Y2g7XG59O1xuXG5pZiAoJHN0cmluZ2lmeSkge1xuICAvLyBgSlNPTi5zdHJpbmdpZnlgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5XG4gICQkRih7IHRhcmdldDogJ0pTT04nLCBzdGF0OiB0cnVlLCBhcml0eTogMywgZm9yY2VkOiBXUk9OR19TWU1CT0xTX0NPTlZFUlNJT04gfHwgSUxMX0ZPUk1FRF9VTklDT0RFIH0sIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0LCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICAgIHZhciBhcmdzID0gYXJyYXlTbGljZSQyKGFyZ3VtZW50cyk7XG4gICAgICB2YXIgcmVzdWx0ID0gYXBwbHkkMyhXUk9OR19TWU1CT0xTX0NPTlZFUlNJT04gPyBzdHJpbmdpZnlXaXRoU3ltYm9sc0ZpeCA6ICRzdHJpbmdpZnksIG51bGwsIGFyZ3MpO1xuICAgICAgcmV0dXJuIElMTF9GT1JNRURfVU5JQ09ERSAmJiB0eXBlb2YgcmVzdWx0ID09ICdzdHJpbmcnID8gcmVwbGFjZSQxKHJlc3VsdCwgdGVzdGVyLCBmaXhJbGxGb3JtZWQpIDogcmVzdWx0O1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciAkJEUgPSBfZXhwb3J0O1xudmFyIE5BVElWRV9TWU1CT0wgPSBzeW1ib2xDb25zdHJ1Y3RvckRldGVjdGlvbjtcbnZhciBmYWlscyRnID0gZmFpbHMkdztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciB0b09iamVjdCQ3ID0gdG9PYmplY3QkZTtcblxuLy8gVjggfiBDaHJvbWUgMzggYW5kIDM5IGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBmYWlscyBvbiBwcmltaXRpdmVzXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNDQzXG52YXIgRk9SQ0VEJDkgPSAhTkFUSVZFX1NZTUJPTCB8fCBmYWlscyRnKGZ1bmN0aW9uICgpIHsgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlJDEuZigxKTsgfSk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5c3ltYm9sc1xuJCRFKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQkOSB9LCB7XG4gIGdldE93blByb3BlcnR5U3ltYm9sczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gICAgdmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUkMS5mO1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gJGdldE93blByb3BlcnR5U3ltYm9scyh0b09iamVjdCQ3KGl0KSkgOiBbXTtcbiAgfVxufSk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkayA9IHdlbGxLbm93blN5bWJvbERlZmluZTtcblxuLy8gYFN5bWJvbC5hc3luY0l0ZXJhdG9yYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuYXN5bmNpdGVyYXRvclxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGsoJ2FzeW5jSXRlcmF0b3InKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRqID0gd2VsbEtub3duU3ltYm9sRGVmaW5lO1xuXG4vLyBgU3ltYm9sLmhhc0luc3RhbmNlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuaGFzaW5zdGFuY2VcbmRlZmluZVdlbGxLbm93blN5bWJvbCRqKCdoYXNJbnN0YW5jZScpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGkgPSB3ZWxsS25vd25TeW1ib2xEZWZpbmU7XG5cbi8vIGBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wuaXNjb25jYXRzcHJlYWRhYmxlXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkaSgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkaCA9IHdlbGxLbm93blN5bWJvbERlZmluZTtcblxuLy8gYFN5bWJvbC5pdGVyYXRvcmAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLml0ZXJhdG9yXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkaCgnaXRlcmF0b3InKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRnID0gd2VsbEtub3duU3ltYm9sRGVmaW5lO1xuXG4vLyBgU3ltYm9sLm1hdGNoYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wubWF0Y2hcbmRlZmluZVdlbGxLbm93blN5bWJvbCRnKCdtYXRjaCcpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGYgPSB3ZWxsS25vd25TeW1ib2xEZWZpbmU7XG5cbi8vIGBTeW1ib2wubWF0Y2hBbGxgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC5tYXRjaGFsbFxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGYoJ21hdGNoQWxsJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkZSA9IHdlbGxLbm93blN5bWJvbERlZmluZTtcblxuLy8gYFN5bWJvbC5yZXBsYWNlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wucmVwbGFjZVxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGUoJ3JlcGxhY2UnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRkID0gd2VsbEtub3duU3ltYm9sRGVmaW5lO1xuXG4vLyBgU3ltYm9sLnNlYXJjaGAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnNlYXJjaFxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGQoJ3NlYXJjaCcpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJGMgPSB3ZWxsS25vd25TeW1ib2xEZWZpbmU7XG5cbi8vIGBTeW1ib2wuc3BlY2llc2Agd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnNwZWNpZXNcbmRlZmluZVdlbGxLbm93blN5bWJvbCRjKCdzcGVjaWVzJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkYiA9IHdlbGxLbm93blN5bWJvbERlZmluZTtcblxuLy8gYFN5bWJvbC5zcGxpdGAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnNwbGl0XG5kZWZpbmVXZWxsS25vd25TeW1ib2wkYignc3BsaXQnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCRhID0gd2VsbEtub3duU3ltYm9sRGVmaW5lO1xudmFyIGRlZmluZVN5bWJvbFRvUHJpbWl0aXZlID0gc3ltYm9sRGVmaW5lVG9QcmltaXRpdmU7XG5cbi8vIGBTeW1ib2wudG9QcmltaXRpdmVgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN5bWJvbC50b3ByaW1pdGl2ZVxuZGVmaW5lV2VsbEtub3duU3ltYm9sJGEoJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBTeW1ib2wucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvcHJpbWl0aXZlXG5kZWZpbmVTeW1ib2xUb1ByaW1pdGl2ZSgpO1xuXG52YXIgZ2V0QnVpbHRJbiQ1ID0gZ2V0QnVpbHRJbiRjO1xudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQ5ID0gd2VsbEtub3duU3ltYm9sRGVmaW5lO1xudmFyIHNldFRvU3RyaW5nVGFnJDIgPSBzZXRUb1N0cmluZ1RhZyQ2O1xuXG4vLyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wudG9zdHJpbmd0YWdcbmRlZmluZVdlbGxLbm93blN5bWJvbCQ5KCd0b1N0cmluZ1RhZycpO1xuXG4vLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXWAgcHJvcGVydHlcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvc3RyaW5ndGFnXG5zZXRUb1N0cmluZ1RhZyQyKGdldEJ1aWx0SW4kNSgnU3ltYm9sJyksICdTeW1ib2wnKTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQ4ID0gd2VsbEtub3duU3ltYm9sRGVmaW5lO1xuXG4vLyBgU3ltYm9sLnVuc2NvcGFibGVzYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zeW1ib2wudW5zY29wYWJsZXNcbmRlZmluZVdlbGxLbm93blN5bWJvbCQ4KCd1bnNjb3BhYmxlcycpO1xuXG52YXIgZ2xvYmFsJGEgPSBnbG9iYWwkbjtcbnZhciBzZXRUb1N0cmluZ1RhZyQxID0gc2V0VG9TdHJpbmdUYWckNjtcblxuLy8gSlNPTltAQHRvU3RyaW5nVGFnXSBwcm9wZXJ0eVxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1qc29uLUBAdG9zdHJpbmd0YWdcbnNldFRvU3RyaW5nVGFnJDEoZ2xvYmFsJGEuSlNPTiwgJ0pTT04nLCB0cnVlKTtcblxudmFyIHBhdGgkbyA9IHBhdGgkdztcblxudmFyIHN5bWJvbCQ1ID0gcGF0aCRvLlN5bWJvbDtcblxudmFyIHBhcmVudCQxMiA9IHN5bWJvbCQ1O1xuXG5cbnZhciBzeW1ib2wkNCA9IHBhcmVudCQxMjtcblxudmFyIHdlbGxLbm93blN5bWJvbCQ1ID0gd2VsbEtub3duU3ltYm9sJG07XG52YXIgZGVmaW5lUHJvcGVydHkkMyA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG5cbnZhciBNRVRBREFUQSQxID0gd2VsbEtub3duU3ltYm9sJDUoJ21ldGFkYXRhJyk7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbi8vIEZ1bmN0aW9uLnByb3RvdHlwZVtAQG1ldGFkYXRhXVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZGVjb3JhdG9yLW1ldGFkYXRhXG5pZiAoRnVuY3Rpb25Qcm90b3R5cGVbTUVUQURBVEEkMV0gPT09IHVuZGVmaW5lZCkge1xuICBkZWZpbmVQcm9wZXJ0eSQzKEZ1bmN0aW9uUHJvdG90eXBlLCBNRVRBREFUQSQxLCB7XG4gICAgdmFsdWU6IG51bGxcbiAgfSk7XG59XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkNyA9IHdlbGxLbm93blN5bWJvbERlZmluZTtcblxuLy8gYFN5bWJvbC5hc3luY0Rpc3Bvc2VgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1hc3luYy1leHBsaWNpdC1yZXNvdXJjZS1tYW5hZ2VtZW50XG5kZWZpbmVXZWxsS25vd25TeW1ib2wkNygnYXN5bmNEaXNwb3NlJyk7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkNiA9IHdlbGxLbm93blN5bWJvbERlZmluZTtcblxuLy8gYFN5bWJvbC5kaXNwb3NlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZXhwbGljaXQtcmVzb3VyY2UtbWFuYWdlbWVudFxuZGVmaW5lV2VsbEtub3duU3ltYm9sJDYoJ2Rpc3Bvc2UnKTtcblxuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wkNSA9IHdlbGxLbm93blN5bWJvbERlZmluZTtcblxuLy8gYFN5bWJvbC5tZXRhZGF0YWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLWRlY29yYXRvcnNcbmRlZmluZVdlbGxLbm93blN5bWJvbCQ1KCdtZXRhZGF0YScpO1xuXG52YXIgcGFyZW50JDExID0gc3ltYm9sJDQ7XG5cblxuXG5cblxuXG52YXIgc3ltYm9sJDMgPSBwYXJlbnQkMTE7XG5cbnZhciBnZXRCdWlsdEluJDQgPSBnZXRCdWlsdEluJGM7XG52YXIgdW5jdXJyeVRoaXMkZCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG5cbnZhciBTeW1ib2wkNCA9IGdldEJ1aWx0SW4kNCgnU3ltYm9sJyk7XG52YXIga2V5Rm9yID0gU3ltYm9sJDQua2V5Rm9yO1xudmFyIHRoaXNTeW1ib2xWYWx1ZSQxID0gdW5jdXJyeVRoaXMkZChTeW1ib2wkNC5wcm90b3R5cGUudmFsdWVPZik7XG5cbi8vIGBTeW1ib2wuaXNSZWdpc3RlcmVkU3ltYm9sYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9wcm9wb3NhbC1zeW1ib2wtcHJlZGljYXRlcy8jc2VjLXN5bWJvbC1pc3JlZ2lzdGVyZWRzeW1ib2xcbnZhciBzeW1ib2xJc1JlZ2lzdGVyZWQgPSBTeW1ib2wkNC5pc1JlZ2lzdGVyZWRTeW1ib2wgfHwgZnVuY3Rpb24gaXNSZWdpc3RlcmVkU3ltYm9sKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGtleUZvcih0aGlzU3ltYm9sVmFsdWUkMSh2YWx1ZSkpICE9PSB1bmRlZmluZWQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgJCREID0gX2V4cG9ydDtcbnZhciBpc1JlZ2lzdGVyZWRTeW1ib2wkMSA9IHN5bWJvbElzUmVnaXN0ZXJlZDtcblxuLy8gYFN5bWJvbC5pc1JlZ2lzdGVyZWRTeW1ib2xgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL3Byb3Bvc2FsLXN5bWJvbC1wcmVkaWNhdGVzLyNzZWMtc3ltYm9sLWlzcmVnaXN0ZXJlZHN5bWJvbFxuJCREKHsgdGFyZ2V0OiAnU3ltYm9sJywgc3RhdDogdHJ1ZSB9LCB7XG4gIGlzUmVnaXN0ZXJlZFN5bWJvbDogaXNSZWdpc3RlcmVkU3ltYm9sJDFcbn0pO1xuXG52YXIgc2hhcmVkID0gc2hhcmVkRXhwb3J0cztcbnZhciBnZXRCdWlsdEluJDMgPSBnZXRCdWlsdEluJGM7XG52YXIgdW5jdXJyeVRoaXMkYyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaXNTeW1ib2wgPSBpc1N5bWJvbCQ1O1xudmFyIHdlbGxLbm93blN5bWJvbCQ0ID0gd2VsbEtub3duU3ltYm9sJG07XG5cbnZhciBTeW1ib2wkMyA9IGdldEJ1aWx0SW4kMygnU3ltYm9sJyk7XG52YXIgJGlzV2VsbEtub3duU3ltYm9sID0gU3ltYm9sJDMuaXNXZWxsS25vd25TeW1ib2w7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyQ0ID0gZ2V0QnVpbHRJbiQzKCdPYmplY3QnLCAnZ2V0T3duUHJvcGVydHlOYW1lcycpO1xudmFyIHRoaXNTeW1ib2xWYWx1ZSA9IHVuY3VycnlUaGlzJGMoU3ltYm9sJDMucHJvdG90eXBlLnZhbHVlT2YpO1xudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG5cbmZvciAodmFyIGkgPSAwLCBzeW1ib2xLZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyQ0KFN5bWJvbCQzKSwgc3ltYm9sS2V5c0xlbmd0aCA9IHN5bWJvbEtleXMubGVuZ3RoOyBpIDwgc3ltYm9sS2V5c0xlbmd0aDsgaSsrKSB7XG4gIC8vIHNvbWUgb2xkIGVuZ2luZXMgdGhyb3dzIG9uIGFjY2VzcyB0byBzb21lIGtleXMgbGlrZSBgYXJndW1lbnRzYCBvciBgY2FsbGVyYFxuICB0cnkge1xuICAgIHZhciBzeW1ib2xLZXkgPSBzeW1ib2xLZXlzW2ldO1xuICAgIGlmIChpc1N5bWJvbChTeW1ib2wkM1tzeW1ib2xLZXldKSkgd2VsbEtub3duU3ltYm9sJDQoc3ltYm9sS2V5KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxufVxuXG4vLyBgU3ltYm9sLmlzV2VsbEtub3duU3ltYm9sYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9wcm9wb3NhbC1zeW1ib2wtcHJlZGljYXRlcy8jc2VjLXN5bWJvbC1pc3dlbGxrbm93bnN5bWJvbFxuLy8gV2Ugc2hvdWxkIHBhdGNoIGl0IGZvciBuZXdseSBhZGRlZCB3ZWxsLWtub3duIHN5bWJvbHMuIElmIGl0J3Mgbm90IHJlcXVpcmVkLCB0aGlzIG1vZHVsZSBqdXN0IHdpbGwgbm90IGJlIGluamVjdGVkXG52YXIgc3ltYm9sSXNXZWxsS25vd24gPSBmdW5jdGlvbiBpc1dlbGxLbm93blN5bWJvbCh2YWx1ZSkge1xuICBpZiAoJGlzV2VsbEtub3duU3ltYm9sICYmICRpc1dlbGxLbm93blN5bWJvbCh2YWx1ZSkpIHJldHVybiB0cnVlO1xuICB0cnkge1xuICAgIHZhciBzeW1ib2wgPSB0aGlzU3ltYm9sVmFsdWUodmFsdWUpO1xuICAgIGZvciAodmFyIGogPSAwLCBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyQ0KFdlbGxLbm93blN5bWJvbHNTdG9yZSksIGtleXNMZW5ndGggPSBrZXlzLmxlbmd0aDsgaiA8IGtleXNMZW5ndGg7IGorKykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcSAtLSBwb2x5ZmlsbGVkIHN5bWJvbHMgY2FzZVxuICAgICAgaWYgKFdlbGxLbm93blN5bWJvbHNTdG9yZVtrZXlzW2pdXSA9PSBzeW1ib2wpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgJCRDID0gX2V4cG9ydDtcbnZhciBpc1dlbGxLbm93blN5bWJvbCQxID0gc3ltYm9sSXNXZWxsS25vd247XG5cbi8vIGBTeW1ib2wuaXNXZWxsS25vd25TeW1ib2xgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL3Byb3Bvc2FsLXN5bWJvbC1wcmVkaWNhdGVzLyNzZWMtc3ltYm9sLWlzd2VsbGtub3duc3ltYm9sXG4vLyBXZSBzaG91bGQgcGF0Y2ggaXQgZm9yIG5ld2x5IGFkZGVkIHdlbGwta25vd24gc3ltYm9scy4gSWYgaXQncyBub3QgcmVxdWlyZWQsIHRoaXMgbW9kdWxlIGp1c3Qgd2lsbCBub3QgYmUgaW5qZWN0ZWRcbiQkQyh7IHRhcmdldDogJ1N5bWJvbCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCB7XG4gIGlzV2VsbEtub3duU3ltYm9sOiBpc1dlbGxLbm93blN5bWJvbCQxXG59KTtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQ0ID0gd2VsbEtub3duU3ltYm9sRGVmaW5lO1xuXG4vLyBgU3ltYm9sLm1hdGNoZXJgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1wYXR0ZXJuLW1hdGNoaW5nXG5kZWZpbmVXZWxsS25vd25TeW1ib2wkNCgnbWF0Y2hlcicpO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDMgPSB3ZWxsS25vd25TeW1ib2xEZWZpbmU7XG5cbi8vIGBTeW1ib2wub2JzZXJ2YWJsZWAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcbmRlZmluZVdlbGxLbm93blN5bWJvbCQzKCdvYnNlcnZhYmxlJyk7XG5cbnZhciAkJEIgPSBfZXhwb3J0O1xudmFyIGlzUmVnaXN0ZXJlZFN5bWJvbCA9IHN5bWJvbElzUmVnaXN0ZXJlZDtcblxuLy8gYFN5bWJvbC5pc1JlZ2lzdGVyZWRgIG1ldGhvZFxuLy8gb2Jzb2xldGUgdmVyc2lvbiBvZiBodHRwczovL3RjMzkuZXMvcHJvcG9zYWwtc3ltYm9sLXByZWRpY2F0ZXMvI3NlYy1zeW1ib2wtaXNyZWdpc3RlcmVkc3ltYm9sXG4kJEIoeyB0YXJnZXQ6ICdTeW1ib2wnLCBzdGF0OiB0cnVlLCBuYW1lOiAnaXNSZWdpc3RlcmVkU3ltYm9sJyB9LCB7XG4gIGlzUmVnaXN0ZXJlZDogaXNSZWdpc3RlcmVkU3ltYm9sXG59KTtcblxudmFyICQkQSA9IF9leHBvcnQ7XG52YXIgaXNXZWxsS25vd25TeW1ib2wgPSBzeW1ib2xJc1dlbGxLbm93bjtcblxuLy8gYFN5bWJvbC5pc1dlbGxLbm93bmAgbWV0aG9kXG4vLyBvYnNvbGV0ZSB2ZXJzaW9uIG9mIGh0dHBzOi8vdGMzOS5lcy9wcm9wb3NhbC1zeW1ib2wtcHJlZGljYXRlcy8jc2VjLXN5bWJvbC1pc3dlbGxrbm93bnN5bWJvbFxuLy8gV2Ugc2hvdWxkIHBhdGNoIGl0IGZvciBuZXdseSBhZGRlZCB3ZWxsLWtub3duIHN5bWJvbHMuIElmIGl0J3Mgbm90IHJlcXVpcmVkLCB0aGlzIG1vZHVsZSBqdXN0IHdpbGwgbm90IGJlIGluamVjdGVkXG4kJEEoeyB0YXJnZXQ6ICdTeW1ib2wnLCBzdGF0OiB0cnVlLCBuYW1lOiAnaXNXZWxsS25vd25TeW1ib2wnLCBmb3JjZWQ6IHRydWUgfSwge1xuICBpc1dlbGxLbm93bjogaXNXZWxsS25vd25TeW1ib2xcbn0pO1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sJDIgPSB3ZWxsS25vd25TeW1ib2xEZWZpbmU7XG5cbi8vIGBTeW1ib2wubWV0YWRhdGFLZXlgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1kZWNvcmF0b3ItbWV0YWRhdGFcbmRlZmluZVdlbGxLbm93blN5bWJvbCQyKCdtZXRhZGF0YUtleScpO1xuXG4vLyBUT0RPOiByZW1vdmUgZnJvbSBgY29yZS1qc0A0YFxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCQxID0gd2VsbEtub3duU3ltYm9sRGVmaW5lO1xuXG4vLyBgU3ltYm9sLnBhdHRlcm5NYXRjaGAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXBhdHRlcm4tbWF0Y2hpbmdcbmRlZmluZVdlbGxLbm93blN5bWJvbCQxKCdwYXR0ZXJuTWF0Y2gnKTtcblxuLy8gVE9ETzogcmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSB3ZWxsS25vd25TeW1ib2xEZWZpbmU7XG5cbmRlZmluZVdlbGxLbm93blN5bWJvbCgncmVwbGFjZUFsbCcpO1xuXG52YXIgcGFyZW50JDEwID0gc3ltYm9sJDM7XG5cblxuXG5cbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG5cblxuXG5cblxuXG52YXIgc3ltYm9sJDIgPSBwYXJlbnQkMTA7XG5cbnZhciBzeW1ib2wkMSA9IHN5bWJvbCQyO1xuXG52YXIgX1N5bWJvbCQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHN5bWJvbCQxKTtcblxudmFyIFdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUkMSA9IHdlbGxLbm93blN5bWJvbFdyYXBwZWQ7XG5cbnZhciBpdGVyYXRvciQ0ID0gV3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSQxLmYoJ2l0ZXJhdG9yJyk7XG5cbnZhciBwYXJlbnQkJCA9IGl0ZXJhdG9yJDQ7XG5cblxudmFyIGl0ZXJhdG9yJDMgPSBwYXJlbnQkJDtcblxudmFyIHBhcmVudCRfID0gaXRlcmF0b3IkMztcblxudmFyIGl0ZXJhdG9yJDIgPSBwYXJlbnQkXztcblxudmFyIHBhcmVudCRaID0gaXRlcmF0b3IkMjtcblxudmFyIGl0ZXJhdG9yJDEgPSBwYXJlbnQkWjtcblxudmFyIGl0ZXJhdG9yID0gaXRlcmF0b3IkMTtcblxudmFyIF9TeW1ib2wkaXRlcmF0b3IgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoaXRlcmF0b3IpO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBfU3ltYm9sJDEgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgX1N5bWJvbCRpdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIF9TeW1ib2wkMSAmJiBvLmNvbnN0cnVjdG9yID09PSBfU3ltYm9sJDEgJiYgbyAhPT0gX1N5bWJvbCQxLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cblxudmFyIFdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUgPSB3ZWxsS25vd25TeW1ib2xXcmFwcGVkO1xuXG52YXIgdG9QcmltaXRpdmUkNCA9IFdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUuZigndG9QcmltaXRpdmUnKTtcblxudmFyIHBhcmVudCRZID0gdG9QcmltaXRpdmUkNDtcblxudmFyIHRvUHJpbWl0aXZlJDMgPSBwYXJlbnQkWTtcblxudmFyIHBhcmVudCRYID0gdG9QcmltaXRpdmUkMztcblxudmFyIHRvUHJpbWl0aXZlJDIgPSBwYXJlbnQkWDtcblxudmFyIHBhcmVudCRXID0gdG9QcmltaXRpdmUkMjtcblxudmFyIHRvUHJpbWl0aXZlJDEgPSBwYXJlbnQkVztcblxudmFyIHRvUHJpbWl0aXZlID0gdG9QcmltaXRpdmUkMTtcblxudmFyIF9TeW1ib2wkdG9QcmltaXRpdmUgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanModG9QcmltaXRpdmUpO1xuXG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbX1N5bWJvbCR0b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBfT2JqZWN0JGRlZmluZVByb3BlcnR5JDEodGFyZ2V0LCBfdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIF9PYmplY3QkZGVmaW5lUHJvcGVydHkkMShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG52YXIgJCR6ID0gX2V4cG9ydDtcbnZhciBpc0FycmF5JGEgPSBpc0FycmF5JGU7XG5cbi8vIGBBcnJheS5pc0FycmF5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkuaXNhcnJheVxuJCR6KHsgdGFyZ2V0OiAnQXJyYXknLCBzdGF0OiB0cnVlIH0sIHtcbiAgaXNBcnJheTogaXNBcnJheSRhXG59KTtcblxudmFyIHBhdGgkbiA9IHBhdGgkdztcblxudmFyIGlzQXJyYXkkOSA9IHBhdGgkbi5BcnJheS5pc0FycmF5O1xuXG52YXIgcGFyZW50JFYgPSBpc0FycmF5JDk7XG5cbnZhciBpc0FycmF5JDggPSBwYXJlbnQkVjtcblxudmFyIHBhcmVudCRVID0gaXNBcnJheSQ4O1xuXG52YXIgaXNBcnJheSQ3ID0gcGFyZW50JFU7XG5cbnZhciBwYXJlbnQkVCA9IGlzQXJyYXkkNztcblxudmFyIGlzQXJyYXkkNiA9IHBhcmVudCRUO1xuXG52YXIgaXNBcnJheSQ1ID0gaXNBcnJheSQ2O1xuXG52YXIgX0FycmF5JGlzQXJyYXkkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhpc0FycmF5JDUpO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChfQXJyYXkkaXNBcnJheSQxKGFycikpIHJldHVybiBhcnI7XG59XG5cbnZhciBERVNDUklQVE9SUyQ3ID0gZGVzY3JpcHRvcnM7XG52YXIgaXNBcnJheSQ0ID0gaXNBcnJheSRlO1xuXG52YXIgJFR5cGVFcnJvciQ3ID0gVHlwZUVycm9yO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ3ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gU2FmYXJpIDwgMTMgZG9lcyBub3QgdGhyb3cgYW4gZXJyb3IgaW4gdGhpcyBjYXNlXG52YXIgU0lMRU5UX09OX05PTl9XUklUQUJMRV9MRU5HVEhfU0VUID0gREVTQ1JJUFRPUlMkNyAmJiAhZnVuY3Rpb24gKCkge1xuICAvLyBtYWtlcyBubyBzZW5zZSB3aXRob3V0IHByb3BlciBzdHJpY3QgbW9kZSBzdXBwb3J0XG4gIGlmICh0aGlzICE9PSB1bmRlZmluZWQpIHJldHVybiB0cnVlO1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShbXSwgJ2xlbmd0aCcsIHsgd3JpdGFibGU6IGZhbHNlIH0pLmxlbmd0aCA9IDE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yO1xuICB9XG59KCk7XG5cbnZhciBhcnJheVNldExlbmd0aCA9IFNJTEVOVF9PTl9OT05fV1JJVEFCTEVfTEVOR1RIX1NFVCA/IGZ1bmN0aW9uIChPLCBsZW5ndGgpIHtcbiAgaWYgKGlzQXJyYXkkNChPKSAmJiAhZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDcoTywgJ2xlbmd0aCcpLndyaXRhYmxlKSB7XG4gICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IkNygnQ2Fubm90IHNldCByZWFkIG9ubHkgLmxlbmd0aCcpO1xuICB9IHJldHVybiBPLmxlbmd0aCA9IGxlbmd0aDtcbn0gOiBmdW5jdGlvbiAoTywgbGVuZ3RoKSB7XG4gIHJldHVybiBPLmxlbmd0aCA9IGxlbmd0aDtcbn07XG5cbnZhciAkJHkgPSBfZXhwb3J0O1xudmFyIHRvT2JqZWN0JDYgPSB0b09iamVjdCRlO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlJDYgPSBsZW5ndGhPZkFycmF5TGlrZSRjO1xudmFyIHNldEFycmF5TGVuZ3RoJDEgPSBhcnJheVNldExlbmd0aDtcbnZhciBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIkMSA9IGRvZXNOb3RFeGNlZWRTYWZlSW50ZWdlciQzO1xudmFyIGZhaWxzJGYgPSBmYWlscyR3O1xuXG52YXIgSU5DT1JSRUNUX1RPX0xFTkdUSCA9IGZhaWxzJGYoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW10ucHVzaC5jYWxsKHsgbGVuZ3RoOiAweDEwMDAwMDAwMCB9LCAxKSAhPT0gNDI5NDk2NzI5Nztcbn0pO1xuXG4vLyBWOCBhbmQgU2FmYXJpIDw9IDE1LjQsIEZGIDwgMjMgdGhyb3dzIEludGVybmFsRXJyb3Jcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTEyNjgxXG52YXIgcHJvcGVyRXJyb3JPbk5vbldyaXRhYmxlTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShbXSwgJ2xlbmd0aCcsIHsgd3JpdGFibGU6IGZhbHNlIH0pLnB1c2goKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3I7XG4gIH1cbn07XG5cbnZhciBGT1JDRUQkOCA9IElOQ09SUkVDVF9UT19MRU5HVEggfHwgIXByb3BlckVycm9yT25Ob25Xcml0YWJsZUxlbmd0aCgpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnB1c2hgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucHVzaFxuJCR5KHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgYXJpdHk6IDEsIGZvcmNlZDogRk9SQ0VEJDggfSwge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxuICBwdXNoOiBmdW5jdGlvbiBwdXNoKGl0ZW0pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0JDYodGhpcyk7XG4gICAgdmFyIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlJDYoTyk7XG4gICAgdmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIkMShsZW4gKyBhcmdDb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdDb3VudDsgaSsrKSB7XG4gICAgICBPW2xlbl0gPSBhcmd1bWVudHNbaV07XG4gICAgICBsZW4rKztcbiAgICB9XG4gICAgc2V0QXJyYXlMZW5ndGgkMShPLCBsZW4pO1xuICAgIHJldHVybiBsZW47XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJGcgPSBlbnRyeVZpcnR1YWwkaTtcblxudmFyIHB1c2gkNyA9IGVudHJ5VmlydHVhbCRnKCdBcnJheScpLnB1c2g7XG5cbnZhciBpc1Byb3RvdHlwZU9mJGggPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCRlID0gcHVzaCQ3O1xuXG52YXIgQXJyYXlQcm90b3R5cGUkZiA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIHB1c2gkNiA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQucHVzaDtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSRmIHx8IChpc1Byb3RvdHlwZU9mJGgoQXJyYXlQcm90b3R5cGUkZiwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkZi5wdXNoKSA/IG1ldGhvZCRlIDogb3duO1xufTtcblxudmFyIHBhcmVudCRTID0gcHVzaCQ2O1xuXG52YXIgcHVzaCQ1ID0gcGFyZW50JFM7XG5cbnZhciBwYXJlbnQkUiA9IHB1c2gkNTtcblxudmFyIHB1c2gkNCA9IHBhcmVudCRSO1xuXG52YXIgcGFyZW50JFEgPSBwdXNoJDQ7XG5cbnZhciBwdXNoJDMgPSBwYXJlbnQkUTtcblxudmFyIHB1c2gkMiA9IHB1c2gkMztcblxudmFyIF9wdXNoSW5zdGFuY2VQcm9wZXJ0eSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhwdXNoJDIpO1xuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQociwgbCkge1xuICB2YXIgdCA9IG51bGwgPT0gciA/IG51bGwgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBfU3ltYm9sJDEgJiYgX2dldEl0ZXJhdG9yTWV0aG9kJDEocikgfHwgcltcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChudWxsICE9IHQpIHtcbiAgICB2YXIgZSxcbiAgICAgIG4sXG4gICAgICBpLFxuICAgICAgdSxcbiAgICAgIGEgPSBbXSxcbiAgICAgIGYgPSAhMCxcbiAgICAgIG8gPSAhMTtcbiAgICB0cnkge1xuICAgICAgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkge1xuICAgICAgICBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47XG4gICAgICAgIGYgPSAhMTtcbiAgICAgIH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChfcHVzaEluc3RhbmNlUHJvcGVydHkoYSkuY2FsbChhLCBlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSAhMCwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHRbXCJyZXR1cm5cIl0gJiYgKHUgPSB0W1wicmV0dXJuXCJdKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChvKSB0aHJvdyBuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxufVxuXG52YXIgJCR4ID0gX2V4cG9ydDtcbnZhciBpc0FycmF5JDMgPSBpc0FycmF5JGU7XG52YXIgaXNDb25zdHJ1Y3RvciQxID0gaXNDb25zdHJ1Y3RvciQ0O1xudmFyIGlzT2JqZWN0JDkgPSBpc09iamVjdCRqO1xudmFyIHRvQWJzb2x1dGVJbmRleCQyID0gdG9BYnNvbHV0ZUluZGV4JDU7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNSA9IGxlbmd0aE9mQXJyYXlMaWtlJGM7XG52YXIgdG9JbmRleGVkT2JqZWN0JDIgPSB0b0luZGV4ZWRPYmplY3QkYTtcbnZhciBjcmVhdGVQcm9wZXJ0eSQyID0gY3JlYXRlUHJvcGVydHkkNjtcbnZhciB3ZWxsS25vd25TeW1ib2wkMyA9IHdlbGxLbm93blN5bWJvbCRtO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkMyA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNTtcbnZhciBuYXRpdmVTbGljZSA9IGFycmF5U2xpY2UkNTtcblxudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQkMyA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkMygnc2xpY2UnKTtcblxudmFyIFNQRUNJRVMkMSA9IHdlbGxLbm93blN5bWJvbCQzKCdzcGVjaWVzJyk7XG52YXIgJEFycmF5ID0gQXJyYXk7XG52YXIgbWF4JDEgPSBNYXRoLm1heDtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5zbGljZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zbGljZVxuLy8gZmFsbGJhY2sgZm9yIG5vdCBhcnJheS1saWtlIEVTMyBzdHJpbmdzIGFuZCBET00gb2JqZWN0c1xuJCR4KHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCQzIH0sIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCQyKHRoaXMpO1xuICAgIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSQ1KE8pO1xuICAgIHZhciBrID0gdG9BYnNvbHV0ZUluZGV4JDIoc3RhcnQsIGxlbmd0aCk7XG4gICAgdmFyIGZpbiA9IHRvQWJzb2x1dGVJbmRleCQyKGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kLCBsZW5ndGgpO1xuICAgIC8vIGlubGluZSBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBmb3IgdXNhZ2UgbmF0aXZlIGBBcnJheSNzbGljZWAgd2hlcmUgaXQncyBwb3NzaWJsZVxuICAgIHZhciBDb25zdHJ1Y3RvciwgcmVzdWx0LCBuO1xuICAgIGlmIChpc0FycmF5JDMoTykpIHtcbiAgICAgIENvbnN0cnVjdG9yID0gTy5jb25zdHJ1Y3RvcjtcbiAgICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgICBpZiAoaXNDb25zdHJ1Y3RvciQxKENvbnN0cnVjdG9yKSAmJiAoQ29uc3RydWN0b3IgPT09ICRBcnJheSB8fCBpc0FycmF5JDMoQ29uc3RydWN0b3IucHJvdG90eXBlKSkpIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0JDkoQ29uc3RydWN0b3IpKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gQ29uc3RydWN0b3JbU1BFQ0lFUyQxXTtcbiAgICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBudWxsKSBDb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gJEFycmF5IHx8IENvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZVNsaWNlKE8sIGssIGZpbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdCA9IG5ldyAoQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCA/ICRBcnJheSA6IENvbnN0cnVjdG9yKShtYXgkMShmaW4gLSBrLCAwKSk7XG4gICAgZm9yIChuID0gMDsgayA8IGZpbjsgaysrLCBuKyspIGlmIChrIGluIE8pIGNyZWF0ZVByb3BlcnR5JDIocmVzdWx0LCBuLCBPW2tdKTtcbiAgICByZXN1bHQubGVuZ3RoID0gbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCRmID0gZW50cnlWaXJ0dWFsJGk7XG5cbnZhciBzbGljZSQ2ID0gZW50cnlWaXJ0dWFsJGYoJ0FycmF5Jykuc2xpY2U7XG5cbnZhciBpc1Byb3RvdHlwZU9mJGcgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCRkID0gc2xpY2UkNjtcblxudmFyIEFycmF5UHJvdG90eXBlJGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBzbGljZSQ1ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5zbGljZTtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSRlIHx8IChpc1Byb3RvdHlwZU9mJGcoQXJyYXlQcm90b3R5cGUkZSwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkZS5zbGljZSkgPyBtZXRob2QkZCA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkUCA9IHNsaWNlJDU7XG5cbnZhciBzbGljZSQ0ID0gcGFyZW50JFA7XG5cbnZhciBwYXJlbnQkTyA9IHNsaWNlJDQ7XG5cbnZhciBzbGljZSQzID0gcGFyZW50JE87XG5cbnZhciBwYXJlbnQkTiA9IHNsaWNlJDM7XG5cbnZhciBzbGljZSQyID0gcGFyZW50JE47XG5cbnZhciBzbGljZSQxID0gc2xpY2UkMjtcblxudmFyIF9zbGljZUluc3RhbmNlUHJvcGVydHkkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzbGljZSQxKTtcblxudmFyIHBhcmVudCRNID0gZnJvbSQ0O1xuXG52YXIgZnJvbSQyID0gcGFyZW50JE07XG5cbnZhciBwYXJlbnQkTCA9IGZyb20kMjtcblxudmFyIGZyb20kMSA9IHBhcmVudCRMO1xuXG52YXIgZnJvbSA9IGZyb20kMTtcblxudmFyIF9BcnJheSRmcm9tID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGZyb20pO1xuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQ3KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNyhvLCBtaW5MZW4pIHtcbiAgdmFyIF9jb250ZXh0O1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNyhvLCBtaW5MZW4pO1xuICB2YXIgbiA9IF9zbGljZUluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dCwgOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gX0FycmF5JGZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNyhvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ3KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChfQXJyYXkkaXNBcnJheSQxKGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ3KGFycik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIF9TeW1ib2wkMSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBfZ2V0SXRlcmF0b3JNZXRob2QkMShpdGVyKSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBfQXJyYXkkZnJvbShpdGVyKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ3KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbnZhciBzeW1ib2wgPSBzeW1ib2wkNDtcblxudmFyIF9TeW1ib2wgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoc3ltYm9sKTtcblxudmFyIGVudHJ5VmlydHVhbCRlID0gZW50cnlWaXJ0dWFsJGk7XG5cbnZhciBjb25jYXQkNCA9IGVudHJ5VmlydHVhbCRlKCdBcnJheScpLmNvbmNhdDtcblxudmFyIGlzUHJvdG90eXBlT2YkZiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJGMgPSBjb25jYXQkNDtcblxudmFyIEFycmF5UHJvdG90eXBlJGQgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBjb25jYXQkMyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuY29uY2F0O1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJGQgfHwgKGlzUHJvdG90eXBlT2YkZihBcnJheVByb3RvdHlwZSRkLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSRkLmNvbmNhdCkgPyBtZXRob2QkYyA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkSyA9IGNvbmNhdCQzO1xuXG52YXIgY29uY2F0JDIgPSBwYXJlbnQkSztcblxudmFyIGNvbmNhdCQxID0gY29uY2F0JDI7XG5cbnZhciBfY29uY2F0SW5zdGFuY2VQcm9wZXJ0eSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhjb25jYXQkMSk7XG5cbnZhciBzbGljZSA9IHNsaWNlJDQ7XG5cbnZhciBfc2xpY2VJbnN0YW5jZVByb3BlcnR5ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHNsaWNlKTtcblxudmFyIGdldEJ1aWx0SW4kMiA9IGdldEJ1aWx0SW4kYztcbnZhciB1bmN1cnJ5VGhpcyRiID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBhbk9iamVjdCQ0ID0gYW5PYmplY3QkZDtcblxudmFyIGNvbmNhdCA9IHVuY3VycnlUaGlzJGIoW10uY29uY2F0KTtcblxuLy8gYWxsIG9iamVjdCBrZXlzLCBpbmNsdWRlcyBub24tZW51bWVyYWJsZSBhbmQgc3ltYm9sc1xudmFyIG93bktleXMkNSA9IGdldEJ1aWx0SW4kMignUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUkMS5mKGFuT2JqZWN0JDQoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8gY29uY2F0KGtleXMsIGdldE93blByb3BlcnR5U3ltYm9scyhpdCkpIDoga2V5cztcbn07XG5cbnZhciBpc0FycmF5JDIgPSBpc0FycmF5JDg7XG5cbnZhciBfQXJyYXkkaXNBcnJheSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhpc0FycmF5JDIpO1xuXG52YXIgJCR3ID0gX2V4cG9ydDtcbnZhciAkbWFwID0gYXJyYXlJdGVyYXRpb24ubWFwO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkMiA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNTtcblxudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQkMiA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkMignbWFwJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUubWFwYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbiQkdyh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQkMiB9LCB7XG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCRkID0gZW50cnlWaXJ0dWFsJGk7XG5cbnZhciBtYXAkNiA9IGVudHJ5VmlydHVhbCRkKCdBcnJheScpLm1hcDtcblxudmFyIGlzUHJvdG90eXBlT2YkZSA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJGIgPSBtYXAkNjtcblxudmFyIEFycmF5UHJvdG90eXBlJGMgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBtYXAkNSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQubWFwO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJGMgfHwgKGlzUHJvdG90eXBlT2YkZShBcnJheVByb3RvdHlwZSRjLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSRjLm1hcCkgPyBtZXRob2QkYiA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkSiA9IG1hcCQ1O1xuXG52YXIgbWFwJDQgPSBwYXJlbnQkSjtcblxudmFyIG1hcCQzID0gbWFwJDQ7XG5cbnZhciBfbWFwSW5zdGFuY2VQcm9wZXJ0eSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhtYXAkMyk7XG5cbnZhciAkJHYgPSBfZXhwb3J0O1xudmFyIHRvT2JqZWN0JDUgPSB0b09iamVjdCRlO1xudmFyIG5hdGl2ZUtleXMgPSBvYmplY3RLZXlzJDM7XG52YXIgZmFpbHMkZSA9IGZhaWxzJHc7XG5cbnZhciBGQUlMU19PTl9QUklNSVRJVkVTJDMgPSBmYWlscyRlKGZ1bmN0aW9uICgpIHsgbmF0aXZlS2V5cygxKTsgfSk7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4kJHYoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMkMyB9LCB7XG4gIGtleXM6IGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyh0b09iamVjdCQ1KGl0KSk7XG4gIH1cbn0pO1xuXG52YXIgcGF0aCRtID0gcGF0aCR3O1xuXG52YXIga2V5cyQyID0gcGF0aCRtLk9iamVjdC5rZXlzO1xuXG52YXIgcGFyZW50JEkgPSBrZXlzJDI7XG5cbnZhciBrZXlzJDEgPSBwYXJlbnQkSTtcblxudmFyIGtleXMgPSBrZXlzJDE7XG5cbnZhciBfT2JqZWN0JGtleXMgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoa2V5cyk7XG5cbi8vIFRPRE86IFJlbW92ZSBmcm9tIGBjb3JlLWpzQDRgXG52YXIgJCR1ID0gX2V4cG9ydDtcbnZhciB1bmN1cnJ5VGhpcyRhID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcblxudmFyICREYXRlID0gRGF0ZTtcbnZhciB0aGlzVGltZVZhbHVlID0gdW5jdXJyeVRoaXMkYSgkRGF0ZS5wcm90b3R5cGUuZ2V0VGltZSk7XG5cbi8vIGBEYXRlLm5vd2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWRhdGUubm93XG4kJHUoeyB0YXJnZXQ6ICdEYXRlJywgc3RhdDogdHJ1ZSB9LCB7XG4gIG5vdzogZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiB0aGlzVGltZVZhbHVlKG5ldyAkRGF0ZSgpKTtcbiAgfVxufSk7XG5cbnZhciBwYXRoJGwgPSBwYXRoJHc7XG5cbnZhciBub3ckMyA9IHBhdGgkbC5EYXRlLm5vdztcblxudmFyIHBhcmVudCRIID0gbm93JDM7XG5cbnZhciBub3ckMiA9IHBhcmVudCRIO1xuXG52YXIgbm93JDEgPSBub3ckMjtcblxudmFyIF9EYXRlJG5vdyA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhub3ckMSk7XG5cbnZhciBmYWlscyRkID0gZmFpbHMkdztcblxudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QkNiA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSwgYXJndW1lbnQpIHtcbiAgdmFyIG1ldGhvZCA9IFtdW01FVEhPRF9OQU1FXTtcbiAgcmV0dXJuICEhbWV0aG9kICYmIGZhaWxzJGQoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGwgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgICBtZXRob2QuY2FsbChudWxsLCBhcmd1bWVudCB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiAxOyB9LCAxKTtcbiAgfSk7XG59O1xuXG52YXIgJGZvckVhY2ggPSBhcnJheUl0ZXJhdGlvbi5mb3JFYWNoO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QkNSA9IGFycmF5TWV0aG9kSXNTdHJpY3QkNjtcblxudmFyIFNUUklDVF9NRVRIT0QkMyA9IGFycmF5TWV0aG9kSXNTdHJpY3QkNSgnZm9yRWFjaCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZvckVhY2hgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxudmFyIGFycmF5Rm9yRWFjaCA9ICFTVFJJQ1RfTUVUSE9EJDMgPyBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tYXJyYXktcHJvdG90eXBlLWZvcmVhY2ggLS0gc2FmZVxufSA6IFtdLmZvckVhY2g7XG5cbnZhciAkJHQgPSBfZXhwb3J0O1xudmFyIGZvckVhY2gkNiA9IGFycmF5Rm9yRWFjaDtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1wcm90b3R5cGUtZm9yZWFjaCAtLSBzYWZlXG4kJHQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IFtdLmZvckVhY2ggIT09IGZvckVhY2gkNiB9LCB7XG4gIGZvckVhY2g6IGZvckVhY2gkNlxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkYyA9IGVudHJ5VmlydHVhbCRpO1xuXG52YXIgZm9yRWFjaCQ1ID0gZW50cnlWaXJ0dWFsJGMoJ0FycmF5JykuZm9yRWFjaDtcblxudmFyIHBhcmVudCRHID0gZm9yRWFjaCQ1O1xuXG52YXIgZm9yRWFjaCQ0ID0gcGFyZW50JEc7XG5cbnZhciBjbGFzc29mJDQgPSBjbGFzc29mJGQ7XG52YXIgaGFzT3duJDQgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzUHJvdG90eXBlT2YkZCA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJGEgPSBmb3JFYWNoJDQ7XG5cbnZhciBBcnJheVByb3RvdHlwZSRiID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgRE9NSXRlcmFibGVzJDEgPSB7XG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgTm9kZUxpc3Q6IHRydWVcbn07XG5cbnZhciBmb3JFYWNoJDMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmZvckVhY2g7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkYiB8fCAoaXNQcm90b3R5cGVPZiRkKEFycmF5UHJvdG90eXBlJGIsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJGIuZm9yRWFjaClcbiAgICB8fCBoYXNPd24kNChET01JdGVyYWJsZXMkMSwgY2xhc3NvZiQ0KGl0KSkgPyBtZXRob2QkYSA6IG93bjtcbn07XG5cbnZhciBmb3JFYWNoJDIgPSBmb3JFYWNoJDM7XG5cbnZhciBfZm9yRWFjaEluc3RhbmNlUHJvcGVydHkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZm9yRWFjaCQyKTtcblxudmFyICQkcyA9IF9leHBvcnQ7XG52YXIgdW5jdXJyeVRoaXMkOSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaXNBcnJheSQxID0gaXNBcnJheSRlO1xuXG52YXIgbmF0aXZlUmV2ZXJzZSA9IHVuY3VycnlUaGlzJDkoW10ucmV2ZXJzZSk7XG52YXIgdGVzdCQxID0gWzEsIDJdO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnJldmVyc2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUucmV2ZXJzZVxuLy8gZml4IGZvciBTYWZhcmkgMTIuMCBidWdcbi8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xODg3OTRcbiQkcyh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogU3RyaW5nKHRlc3QkMSkgPT09IFN0cmluZyh0ZXN0JDEucmV2ZXJzZSgpKSB9LCB7XG4gIHJldmVyc2U6IGZ1bmN0aW9uIHJldmVyc2UoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtYXNzaWduIC0tIGRpcnR5IGhhY2tcbiAgICBpZiAoaXNBcnJheSQxKHRoaXMpKSB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIHJldHVybiBuYXRpdmVSZXZlcnNlKHRoaXMpO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCRiID0gZW50cnlWaXJ0dWFsJGk7XG5cbnZhciByZXZlcnNlJDMgPSBlbnRyeVZpcnR1YWwkYignQXJyYXknKS5yZXZlcnNlO1xuXG52YXIgaXNQcm90b3R5cGVPZiRjID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkOSA9IHJldmVyc2UkMztcblxudmFyIEFycmF5UHJvdG90eXBlJGEgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciByZXZlcnNlJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LnJldmVyc2U7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkYSB8fCAoaXNQcm90b3R5cGVPZiRjKEFycmF5UHJvdG90eXBlJGEsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJGEucmV2ZXJzZSkgPyBtZXRob2QkOSA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkRiA9IHJldmVyc2UkMjtcblxudmFyIHJldmVyc2UkMSA9IHBhcmVudCRGO1xuXG52YXIgcmV2ZXJzZSA9IHJldmVyc2UkMTtcblxudmFyIF9yZXZlcnNlSW5zdGFuY2VQcm9wZXJ0eSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhyZXZlcnNlKTtcblxudmFyIHRyeVRvU3RyaW5nJDIgPSB0cnlUb1N0cmluZyQ2O1xuXG52YXIgJFR5cGVFcnJvciQ2ID0gVHlwZUVycm9yO1xuXG52YXIgZGVsZXRlUHJvcGVydHlPclRocm93JDIgPSBmdW5jdGlvbiAoTywgUCkge1xuICBpZiAoIWRlbGV0ZSBPW1BdKSB0aHJvdyBuZXcgJFR5cGVFcnJvciQ2KCdDYW5ub3QgZGVsZXRlIHByb3BlcnR5ICcgKyB0cnlUb1N0cmluZyQyKFApICsgJyBvZiAnICsgdHJ5VG9TdHJpbmckMihPKSk7XG59O1xuXG52YXIgJCRyID0gX2V4cG9ydDtcbnZhciB0b09iamVjdCQ0ID0gdG9PYmplY3QkZTtcbnZhciB0b0Fic29sdXRlSW5kZXgkMSA9IHRvQWJzb2x1dGVJbmRleCQ1O1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSB0b0ludGVnZXJPckluZmluaXR5JDQ7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkNCA9IGxlbmd0aE9mQXJyYXlMaWtlJGM7XG52YXIgc2V0QXJyYXlMZW5ndGggPSBhcnJheVNldExlbmd0aDtcbnZhciBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIgPSBkb2VzTm90RXhjZWVkU2FmZUludGVnZXIkMztcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSBhcnJheVNwZWNpZXNDcmVhdGUkMztcbnZhciBjcmVhdGVQcm9wZXJ0eSQxID0gY3JlYXRlUHJvcGVydHkkNjtcbnZhciBkZWxldGVQcm9wZXJ0eU9yVGhyb3ckMSA9IGRlbGV0ZVByb3BlcnR5T3JUaHJvdyQyO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkMSA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkNTtcblxudmFyIEhBU19TUEVDSUVTX1NVUFBPUlQkMSA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQkMSgnc3BsaWNlJyk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5zcGxpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc3BsaWNlXG4vLyB3aXRoIGFkZGluZyBzdXBwb3J0IG9mIEBAc3BlY2llc1xuJCRyKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhSEFTX1NQRUNJRVNfU1VQUE9SVCQxIH0sIHtcbiAgc3BsaWNlOiBmdW5jdGlvbiBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50IC8qICwgLi4uaXRlbXMgKi8pIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0JDQodGhpcyk7XG4gICAgdmFyIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlJDQoTyk7XG4gICAgdmFyIGFjdHVhbFN0YXJ0ID0gdG9BYnNvbHV0ZUluZGV4JDEoc3RhcnQsIGxlbik7XG4gICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGluc2VydENvdW50LCBhY3R1YWxEZWxldGVDb3VudCwgQSwgaywgZnJvbSwgdG87XG4gICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA9PT0gMCkge1xuICAgICAgaW5zZXJ0Q291bnQgPSBhY3R1YWxEZWxldGVDb3VudCA9IDA7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNMZW5ndGggPT09IDEpIHtcbiAgICAgIGluc2VydENvdW50ID0gMDtcbiAgICAgIGFjdHVhbERlbGV0ZUNvdW50ID0gbGVuIC0gYWN0dWFsU3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc2VydENvdW50ID0gYXJndW1lbnRzTGVuZ3RoIC0gMjtcbiAgICAgIGFjdHVhbERlbGV0ZUNvdW50ID0gbWluKG1heCh0b0ludGVnZXJPckluZmluaXR5KGRlbGV0ZUNvdW50KSwgMCksIGxlbiAtIGFjdHVhbFN0YXJ0KTtcbiAgICB9XG4gICAgZG9lc05vdEV4Y2VlZFNhZmVJbnRlZ2VyKGxlbiArIGluc2VydENvdW50IC0gYWN0dWFsRGVsZXRlQ291bnQpO1xuICAgIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgYWN0dWFsRGVsZXRlQ291bnQpO1xuICAgIGZvciAoayA9IDA7IGsgPCBhY3R1YWxEZWxldGVDb3VudDsgaysrKSB7XG4gICAgICBmcm9tID0gYWN0dWFsU3RhcnQgKyBrO1xuICAgICAgaWYgKGZyb20gaW4gTykgY3JlYXRlUHJvcGVydHkkMShBLCBrLCBPW2Zyb21dKTtcbiAgICB9XG4gICAgQS5sZW5ndGggPSBhY3R1YWxEZWxldGVDb3VudDtcbiAgICBpZiAoaW5zZXJ0Q291bnQgPCBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgZm9yIChrID0gYWN0dWFsU3RhcnQ7IGsgPCBsZW4gLSBhY3R1YWxEZWxldGVDb3VudDsgaysrKSB7XG4gICAgICAgIGZyb20gPSBrICsgYWN0dWFsRGVsZXRlQ291bnQ7XG4gICAgICAgIHRvID0gayArIGluc2VydENvdW50O1xuICAgICAgICBpZiAoZnJvbSBpbiBPKSBPW3RvXSA9IE9bZnJvbV07XG4gICAgICAgIGVsc2UgZGVsZXRlUHJvcGVydHlPclRocm93JDEoTywgdG8pO1xuICAgICAgfVxuICAgICAgZm9yIChrID0gbGVuOyBrID4gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQgKyBpbnNlcnRDb3VudDsgay0tKSBkZWxldGVQcm9wZXJ0eU9yVGhyb3ckMShPLCBrIC0gMSk7XG4gICAgfSBlbHNlIGlmIChpbnNlcnRDb3VudCA+IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICBmb3IgKGsgPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudDsgayA+IGFjdHVhbFN0YXJ0OyBrLS0pIHtcbiAgICAgICAgZnJvbSA9IGsgKyBhY3R1YWxEZWxldGVDb3VudCAtIDE7XG4gICAgICAgIHRvID0gayArIGluc2VydENvdW50IC0gMTtcbiAgICAgICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO1xuICAgICAgICBlbHNlIGRlbGV0ZVByb3BlcnR5T3JUaHJvdyQxKE8sIHRvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChrID0gMDsgayA8IGluc2VydENvdW50OyBrKyspIHtcbiAgICAgIE9bayArIGFjdHVhbFN0YXJ0XSA9IGFyZ3VtZW50c1trICsgMl07XG4gICAgfVxuICAgIHNldEFycmF5TGVuZ3RoKE8sIGxlbiAtIGFjdHVhbERlbGV0ZUNvdW50ICsgaW5zZXJ0Q291bnQpO1xuICAgIHJldHVybiBBO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCRhID0gZW50cnlWaXJ0dWFsJGk7XG5cbnZhciBzcGxpY2UkNCA9IGVudHJ5VmlydHVhbCRhKCdBcnJheScpLnNwbGljZTtcblxudmFyIGlzUHJvdG90eXBlT2YkYiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJDggPSBzcGxpY2UkNDtcblxudmFyIEFycmF5UHJvdG90eXBlJDkgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBzcGxpY2UkMyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuc3BsaWNlO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDkgfHwgKGlzUHJvdG90eXBlT2YkYihBcnJheVByb3RvdHlwZSQ5LCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQ5LnNwbGljZSkgPyBtZXRob2QkOCA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkRSA9IHNwbGljZSQzO1xuXG52YXIgc3BsaWNlJDIgPSBwYXJlbnQkRTtcblxudmFyIHNwbGljZSQxID0gc3BsaWNlJDI7XG5cbnZhciBfc3BsaWNlSW5zdGFuY2VQcm9wZXJ0eSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzcGxpY2UkMSk7XG5cbnZhciAkJHEgPSBfZXhwb3J0O1xudmFyICRpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMuaW5jbHVkZXM7XG52YXIgZmFpbHMkYyA9IGZhaWxzJHc7XG5cbi8vIEZGOTkrIGJ1Z1xudmFyIEJST0tFTl9PTl9TUEFSU0UgPSBmYWlscyRjKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLWFycmF5LXByb3RvdHlwZS1pbmNsdWRlcyAtLSBkZXRlY3Rpb25cbiAgcmV0dXJuICFBcnJheSgxKS5pbmNsdWRlcygpO1xufSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiQkcSh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogQlJPS0VOX09OX1NQQVJTRSB9LCB7XG4gIGluY2x1ZGVzOiBmdW5jdGlvbiBpbmNsdWRlcyhlbCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gJGluY2x1ZGVzKHRoaXMsIGVsLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJDkgPSBlbnRyeVZpcnR1YWwkaTtcblxudmFyIGluY2x1ZGVzJDQgPSBlbnRyeVZpcnR1YWwkOSgnQXJyYXknKS5pbmNsdWRlcztcblxudmFyIGlzT2JqZWN0JDggPSBpc09iamVjdCRqO1xudmFyIGNsYXNzb2YkMyA9IGNsYXNzb2ZSYXckMjtcbnZhciB3ZWxsS25vd25TeW1ib2wkMiA9IHdlbGxLbm93blN5bWJvbCRtO1xuXG52YXIgTUFUQ0gkMSA9IHdlbGxLbm93blN5bWJvbCQyKCdtYXRjaCcpO1xuXG4vLyBgSXNSZWdFeHBgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc3JlZ2V4cFxudmFyIGlzUmVnZXhwID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpc1JlZ0V4cDtcbiAgcmV0dXJuIGlzT2JqZWN0JDgoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSCQxXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjbGFzc29mJDMoaXQpID09PSAnUmVnRXhwJyk7XG59O1xuXG52YXIgaXNSZWdFeHAgPSBpc1JlZ2V4cDtcblxudmFyICRUeXBlRXJyb3IkNSA9IFR5cGVFcnJvcjtcblxudmFyIG5vdEFSZWdleHAgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGlzUmVnRXhwKGl0KSkge1xuICAgIHRocm93IG5ldyAkVHlwZUVycm9yJDUoXCJUaGUgbWV0aG9kIGRvZXNuJ3QgYWNjZXB0IHJlZ3VsYXIgZXhwcmVzc2lvbnNcIik7XG4gIH0gcmV0dXJuIGl0O1xufTtcblxudmFyIHdlbGxLbm93blN5bWJvbCQxID0gd2VsbEtub3duU3ltYm9sJG07XG5cbnZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCQxKCdtYXRjaCcpO1xuXG52YXIgY29ycmVjdElzUmVnZXhwTG9naWMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgdmFyIHJlZ2V4cCA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgfSBjYXRjaCAoZXJyb3IxKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlZ2V4cFtNQVRDSF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHsgLyogZW1wdHkgKi8gfVxuICB9IHJldHVybiBmYWxzZTtcbn07XG5cbnZhciAkJHAgPSBfZXhwb3J0O1xudmFyIHVuY3VycnlUaGlzJDggPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIG5vdEFSZWdFeHAgPSBub3RBUmVnZXhwO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUkMSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNTtcbnZhciB0b1N0cmluZyQ0ID0gdG9TdHJpbmckYTtcbnZhciBjb3JyZWN0SXNSZWdFeHBMb2dpYyA9IGNvcnJlY3RJc1JlZ2V4cExvZ2ljO1xuXG52YXIgc3RyaW5nSW5kZXhPZiA9IHVuY3VycnlUaGlzJDgoJycuaW5kZXhPZik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlc1xuJCRwKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogIWNvcnJlY3RJc1JlZ0V4cExvZ2ljKCdpbmNsdWRlcycpIH0sIHtcbiAgaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHJldHVybiAhIX5zdHJpbmdJbmRleE9mKFxuICAgICAgdG9TdHJpbmckNChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlJDEodGhpcykpLFxuICAgICAgdG9TdHJpbmckNChub3RBUmVnRXhwKHNlYXJjaFN0cmluZykpLFxuICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWRcbiAgICApO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCQ4ID0gZW50cnlWaXJ0dWFsJGk7XG5cbnZhciBpbmNsdWRlcyQzID0gZW50cnlWaXJ0dWFsJDgoJ1N0cmluZycpLmluY2x1ZGVzO1xuXG52YXIgaXNQcm90b3R5cGVPZiRhID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBhcnJheU1ldGhvZCA9IGluY2x1ZGVzJDQ7XG52YXIgc3RyaW5nTWV0aG9kID0gaW5jbHVkZXMkMztcblxudmFyIEFycmF5UHJvdG90eXBlJDggPSBBcnJheS5wcm90b3R5cGU7XG52YXIgU3RyaW5nUHJvdG90eXBlID0gU3RyaW5nLnByb3RvdHlwZTtcblxudmFyIGluY2x1ZGVzJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmluY2x1ZGVzO1xuICBpZiAoaXQgPT09IEFycmF5UHJvdG90eXBlJDggfHwgKGlzUHJvdG90eXBlT2YkYShBcnJheVByb3RvdHlwZSQ4LCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQ4LmluY2x1ZGVzKSkgcmV0dXJuIGFycmF5TWV0aG9kO1xuICBpZiAodHlwZW9mIGl0ID09ICdzdHJpbmcnIHx8IGl0ID09PSBTdHJpbmdQcm90b3R5cGUgfHwgKGlzUHJvdG90eXBlT2YkYShTdHJpbmdQcm90b3R5cGUsIGl0KSAmJiBvd24gPT09IFN0cmluZ1Byb3RvdHlwZS5pbmNsdWRlcykpIHtcbiAgICByZXR1cm4gc3RyaW5nTWV0aG9kO1xuICB9IHJldHVybiBvd247XG59O1xuXG52YXIgcGFyZW50JEQgPSBpbmNsdWRlcyQyO1xuXG52YXIgaW5jbHVkZXMkMSA9IHBhcmVudCREO1xuXG52YXIgaW5jbHVkZXMgPSBpbmNsdWRlcyQxO1xuXG52YXIgX2luY2x1ZGVzSW5zdGFuY2VQcm9wZXJ0eSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhpbmNsdWRlcyk7XG5cbnZhciAkJG8gPSBfZXhwb3J0O1xudmFyIGZhaWxzJGIgPSBmYWlscyR3O1xudmFyIHRvT2JqZWN0JDMgPSB0b09iamVjdCRlO1xudmFyIG5hdGl2ZUdldFByb3RvdHlwZU9mID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gY29ycmVjdFByb3RvdHlwZUdldHRlcjtcblxudmFyIEZBSUxTX09OX1BSSU1JVElWRVMkMiA9IGZhaWxzJGIoZnVuY3Rpb24gKCkgeyBuYXRpdmVHZXRQcm90b3R5cGVPZigxKTsgfSk7XG5cbi8vIGBPYmplY3QuZ2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2ZcbiQkbyh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUyQyLCBzaGFtOiAhQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSIH0sIHtcbiAgZ2V0UHJvdG90eXBlT2Y6IGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7XG4gICAgcmV0dXJuIG5hdGl2ZUdldFByb3RvdHlwZU9mKHRvT2JqZWN0JDMoaXQpKTtcbiAgfVxufSk7XG5cbnZhciBwYXRoJGsgPSBwYXRoJHc7XG5cbnZhciBnZXRQcm90b3R5cGVPZiQ2ID0gcGF0aCRrLk9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHBhcmVudCRDID0gZ2V0UHJvdG90eXBlT2YkNjtcblxudmFyIGdldFByb3RvdHlwZU9mJDUgPSBwYXJlbnQkQztcblxudmFyIGdldFByb3RvdHlwZU9mJDQgPSBnZXRQcm90b3R5cGVPZiQ1O1xuXG52YXIgX09iamVjdCRnZXRQcm90b3R5cGVPZiQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGdldFByb3RvdHlwZU9mJDQpO1xuXG52YXIgJCRuID0gX2V4cG9ydDtcbnZhciAkZmlsdGVyID0gYXJyYXlJdGVyYXRpb24uZmlsdGVyO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0JDU7XG5cbnZhciBIQVNfU1BFQ0lFU19TVVBQT1JUID0gYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnZmlsdGVyJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbiQkbih7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIUhBU19TUEVDSUVTX1NVUFBPUlQgfSwge1xuICBmaWx0ZXI6IGZ1bmN0aW9uIGZpbHRlcihjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZmlsdGVyKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkNyA9IGVudHJ5VmlydHVhbCRpO1xuXG52YXIgZmlsdGVyJDMgPSBlbnRyeVZpcnR1YWwkNygnQXJyYXknKS5maWx0ZXI7XG5cbnZhciBpc1Byb3RvdHlwZU9mJDkgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCQ3ID0gZmlsdGVyJDM7XG5cbnZhciBBcnJheVByb3RvdHlwZSQ3ID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgZmlsdGVyJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmZpbHRlcjtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQ3IHx8IChpc1Byb3RvdHlwZU9mJDkoQXJyYXlQcm90b3R5cGUkNywgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkNy5maWx0ZXIpID8gbWV0aG9kJDcgOiBvd247XG59O1xuXG52YXIgcGFyZW50JEIgPSBmaWx0ZXIkMjtcblxudmFyIGZpbHRlciQxID0gcGFyZW50JEI7XG5cbnZhciBmaWx0ZXIgPSBmaWx0ZXIkMTtcblxudmFyIF9maWx0ZXJJbnN0YW5jZVByb3BlcnR5ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGZpbHRlcik7XG5cbi8vIGEgc3RyaW5nIG9mIGFsbCB2YWxpZCB1bmljb2RlIHdoaXRlc3BhY2VzXG52YXIgd2hpdGVzcGFjZXMkMyA9ICdcXHUwMDA5XFx1MDAwQVxcdTAwMEJcXHUwMDBDXFx1MDAwRFxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTIwMDBcXHUyMDAxXFx1MjAwMicgK1xuICAnXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XFx1MjAyOVxcdUZFRkYnO1xuXG52YXIgdW5jdXJyeVRoaXMkNyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUkNTtcbnZhciB0b1N0cmluZyQzID0gdG9TdHJpbmckYTtcbnZhciB3aGl0ZXNwYWNlcyQyID0gd2hpdGVzcGFjZXMkMztcblxudmFyIHJlcGxhY2UgPSB1bmN1cnJ5VGhpcyQ3KCcnLnJlcGxhY2UpO1xudmFyIGx0cmltID0gUmVnRXhwKCdeWycgKyB3aGl0ZXNwYWNlcyQyICsgJ10rJyk7XG52YXIgcnRyaW0gPSBSZWdFeHAoJyhefFteJyArIHdoaXRlc3BhY2VzJDIgKyAnXSlbJyArIHdoaXRlc3BhY2VzJDIgKyAnXSskJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbSwgdHJpbVN0YXJ0LCB0cmltRW5kLCB0cmltTGVmdCwgdHJpbVJpZ2h0IH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QkMSA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMpIHtcbiAgICB2YXIgc3RyaW5nID0gdG9TdHJpbmckMyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgaWYgKFRZUEUgJiAxKSBzdHJpbmcgPSByZXBsYWNlKHN0cmluZywgbHRyaW0sICcnKTtcbiAgICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHJlcGxhY2Uoc3RyaW5nLCBydHJpbSwgJyQxJyk7XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfTtcbn07XG5cbnZhciBzdHJpbmdUcmltID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1MZWZ0LCB0cmltU3RhcnQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbXN0YXJ0XG4gIHN0YXJ0OiBjcmVhdGVNZXRob2QkMSgxKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUueyB0cmltUmlnaHQsIHRyaW1FbmQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbWVuZFxuICBlbmQ6IGNyZWF0ZU1ldGhvZCQxKDIpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS50cmltYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1cbiAgdHJpbTogY3JlYXRlTWV0aG9kJDEoMylcbn07XG5cbnZhciBnbG9iYWwkOSA9IGdsb2JhbCRuO1xudmFyIGZhaWxzJGEgPSBmYWlscyR3O1xudmFyIHVuY3VycnlUaGlzJDYgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIHRvU3RyaW5nJDIgPSB0b1N0cmluZyRhO1xudmFyIHRyaW0kMSA9IHN0cmluZ1RyaW0udHJpbTtcbnZhciB3aGl0ZXNwYWNlcyQxID0gd2hpdGVzcGFjZXMkMztcblxudmFyICRwYXJzZUludCQxID0gZ2xvYmFsJDkucGFyc2VJbnQ7XG52YXIgU3ltYm9sJDIgPSBnbG9iYWwkOS5TeW1ib2w7XG52YXIgSVRFUkFUT1IkMSA9IFN5bWJvbCQyICYmIFN5bWJvbCQyLml0ZXJhdG9yO1xudmFyIGhleCA9IC9eWystXT8weC9pO1xudmFyIGV4ZWMgPSB1bmN1cnJ5VGhpcyQ2KGhleC5leGVjKTtcbnZhciBGT1JDRUQkNyA9ICRwYXJzZUludCQxKHdoaXRlc3BhY2VzJDEgKyAnMDgnKSAhPT0gOCB8fCAkcGFyc2VJbnQkMSh3aGl0ZXNwYWNlcyQxICsgJzB4MTYnKSAhPT0gMjJcbiAgLy8gTVMgRWRnZSAxOC0gYnJva2VuIHdpdGggYm94ZWQgc3ltYm9sc1xuICB8fCAoSVRFUkFUT1IkMSAmJiAhZmFpbHMkYShmdW5jdGlvbiAoKSB7ICRwYXJzZUludCQxKE9iamVjdChJVEVSQVRPUiQxKSk7IH0pKTtcblxuLy8gYHBhcnNlSW50YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcGFyc2VpbnQtc3RyaW5nLXJhZGl4XG52YXIgbnVtYmVyUGFyc2VJbnQgPSBGT1JDRUQkNyA/IGZ1bmN0aW9uIHBhcnNlSW50KHN0cmluZywgcmFkaXgpIHtcbiAgdmFyIFMgPSB0cmltJDEodG9TdHJpbmckMihzdHJpbmcpKTtcbiAgcmV0dXJuICRwYXJzZUludCQxKFMsIChyYWRpeCA+Pj4gMCkgfHwgKGV4ZWMoaGV4LCBTKSA/IDE2IDogMTApKTtcbn0gOiAkcGFyc2VJbnQkMTtcblxudmFyICQkbSA9IF9leHBvcnQ7XG52YXIgJHBhcnNlSW50ID0gbnVtYmVyUGFyc2VJbnQ7XG5cbi8vIGBwYXJzZUludGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXBhcnNlaW50LXN0cmluZy1yYWRpeFxuJCRtKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHBhcnNlSW50ICE9PSAkcGFyc2VJbnQgfSwge1xuICBwYXJzZUludDogJHBhcnNlSW50XG59KTtcblxudmFyIHBhdGgkaiA9IHBhdGgkdztcblxudmFyIF9wYXJzZUludCQzID0gcGF0aCRqLnBhcnNlSW50O1xuXG52YXIgcGFyZW50JEEgPSBfcGFyc2VJbnQkMztcblxudmFyIF9wYXJzZUludCQyID0gcGFyZW50JEE7XG5cbnZhciBfcGFyc2VJbnQgPSBfcGFyc2VJbnQkMjtcblxudmFyIF9wYXJzZUludCQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKF9wYXJzZUludCk7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLWFycmF5LXByb3RvdHlwZS1pbmRleG9mIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG52YXIgJCRsID0gX2V4cG9ydDtcbnZhciB1bmN1cnJ5VGhpcyQ1ID0gZnVuY3Rpb25VbmN1cnJ5VGhpc0NsYXVzZTtcbnZhciAkaW5kZXhPZiA9IGFycmF5SW5jbHVkZXMuaW5kZXhPZjtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0JDQgPSBhcnJheU1ldGhvZElzU3RyaWN0JDY7XG5cbnZhciBuYXRpdmVJbmRleE9mID0gdW5jdXJyeVRoaXMkNShbXS5pbmRleE9mKTtcblxudmFyIE5FR0FUSVZFX1pFUk8gPSAhIW5hdGl2ZUluZGV4T2YgJiYgMSAvIG5hdGl2ZUluZGV4T2YoWzFdLCAxLCAtMCkgPCAwO1xudmFyIEZPUkNFRCQ2ID0gTkVHQVRJVkVfWkVSTyB8fCAhYXJyYXlNZXRob2RJc1N0cmljdCQ0KCdpbmRleE9mJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuaW5kZXhPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4kJGwoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCQ2IH0sIHtcbiAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ID0gMCAqLykge1xuICAgIHZhciBmcm9tSW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gTkVHQVRJVkVfWkVST1xuICAgICAgLy8gY29udmVydCAtMCB0byArMFxuICAgICAgPyBuYXRpdmVJbmRleE9mKHRoaXMsIHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCkgfHwgMFxuICAgICAgOiAkaW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXgpO1xuICB9XG59KTtcblxudmFyIGVudHJ5VmlydHVhbCQ2ID0gZW50cnlWaXJ0dWFsJGk7XG5cbnZhciBpbmRleE9mJDMgPSBlbnRyeVZpcnR1YWwkNignQXJyYXknKS5pbmRleE9mO1xuXG52YXIgaXNQcm90b3R5cGVPZiQ4ID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkNiA9IGluZGV4T2YkMztcblxudmFyIEFycmF5UHJvdG90eXBlJDYgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBpbmRleE9mJDIgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIG93biA9IGl0LmluZGV4T2Y7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkNiB8fCAoaXNQcm90b3R5cGVPZiQ4KEFycmF5UHJvdG90eXBlJDYsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDYuaW5kZXhPZikgPyBtZXRob2QkNiA6IG93bjtcbn07XG5cbnZhciBwYXJlbnQkeiA9IGluZGV4T2YkMjtcblxudmFyIGluZGV4T2YkMSA9IHBhcmVudCR6O1xuXG52YXIgaW5kZXhPZiA9IGluZGV4T2YkMTtcblxudmFyIF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhpbmRleE9mKTtcblxuLy8gVE9ETzogUmVtb3ZlIGZyb20gYGNvcmUtanNANGBcbnZhciAkJGsgPSBfZXhwb3J0O1xudmFyIERFU0NSSVBUT1JTJDYgPSBkZXNjcmlwdG9ycztcbnZhciBjcmVhdGUkOCA9IG9iamVjdENyZWF0ZTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG4kJGsoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBzaGFtOiAhREVTQ1JJUFRPUlMkNiB9LCB7XG4gIGNyZWF0ZTogY3JlYXRlJDhcbn0pO1xuXG52YXIgcGF0aCRpID0gcGF0aCR3O1xuXG52YXIgT2JqZWN0JDQgPSBwYXRoJGkuT2JqZWN0O1xuXG52YXIgY3JlYXRlJDcgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCkge1xuICByZXR1cm4gT2JqZWN0JDQuY3JlYXRlKFAsIEQpO1xufTtcblxudmFyIHBhcmVudCR5ID0gY3JlYXRlJDc7XG5cbnZhciBjcmVhdGUkNiA9IHBhcmVudCR5O1xuXG52YXIgY3JlYXRlJDUgPSBjcmVhdGUkNjtcblxudmFyIF9PYmplY3QkY3JlYXRlJDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoY3JlYXRlJDUpO1xuXG52YXIgcGF0aCRoID0gcGF0aCR3O1xudmFyIGFwcGx5JDIgPSBmdW5jdGlvbkFwcGx5O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tanNvbiAtLSBzYWZlXG5pZiAoIXBhdGgkaC5KU09OKSBwYXRoJGguSlNPTiA9IHsgc3RyaW5naWZ5OiBKU09OLnN0cmluZ2lmeSB9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnMgLS0gcmVxdWlyZWQgZm9yIGAubGVuZ3RoYFxudmFyIHN0cmluZ2lmeSQyID0gZnVuY3Rpb24gc3RyaW5naWZ5KGl0LCByZXBsYWNlciwgc3BhY2UpIHtcbiAgcmV0dXJuIGFwcGx5JDIocGF0aCRoLkpTT04uc3RyaW5naWZ5LCBudWxsLCBhcmd1bWVudHMpO1xufTtcblxudmFyIHBhcmVudCR4ID0gc3RyaW5naWZ5JDI7XG5cbnZhciBzdHJpbmdpZnkkMSA9IHBhcmVudCR4O1xuXG52YXIgc3RyaW5naWZ5ID0gc3RyaW5naWZ5JDE7XG5cbnZhciBfSlNPTiRzdHJpbmdpZnkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoc3RyaW5naWZ5KTtcblxuLyogZ2xvYmFsIEJ1biAtLSBEZW5vIGNhc2UgKi9cbnZhciBlbmdpbmVJc0J1biA9IHR5cGVvZiBCdW4gPT0gJ2Z1bmN0aW9uJyAmJiBCdW4gJiYgdHlwZW9mIEJ1bi52ZXJzaW9uID09ICdzdHJpbmcnO1xuXG52YXIgJFR5cGVFcnJvciQ0ID0gVHlwZUVycm9yO1xuXG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgkMSA9IGZ1bmN0aW9uIChwYXNzZWQsIHJlcXVpcmVkKSB7XG4gIGlmIChwYXNzZWQgPCByZXF1aXJlZCkgdGhyb3cgbmV3ICRUeXBlRXJyb3IkNCgnTm90IGVub3VnaCBhcmd1bWVudHMnKTtcbiAgcmV0dXJuIHBhc3NlZDtcbn07XG5cbnZhciBnbG9iYWwkOCA9IGdsb2JhbCRuO1xudmFyIGFwcGx5JDEgPSBmdW5jdGlvbkFwcGx5O1xudmFyIGlzQ2FsbGFibGUkMSA9IGlzQ2FsbGFibGUkaTtcbnZhciBFTkdJTkVfSVNfQlVOID0gZW5naW5lSXNCdW47XG52YXIgVVNFUl9BR0VOVCA9IGVuZ2luZVVzZXJBZ2VudDtcbnZhciBhcnJheVNsaWNlJDEgPSBhcnJheVNsaWNlJDU7XG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGggPSB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCQxO1xuXG52YXIgRnVuY3Rpb24kMSA9IGdsb2JhbCQ4LkZ1bmN0aW9uO1xuLy8gZGlydHkgSUU5LSBhbmQgQnVuIDAuMy4wLSBjaGVja3NcbnZhciBXUkFQID0gL01TSUUgLlxcLi8udGVzdChVU0VSX0FHRU5UKSB8fCBFTkdJTkVfSVNfQlVOICYmIChmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZXJzaW9uID0gZ2xvYmFsJDguQnVuLnZlcnNpb24uc3BsaXQoJy4nKTtcbiAgcmV0dXJuIHZlcnNpb24ubGVuZ3RoIDwgMyB8fCB2ZXJzaW9uWzBdID09PSAnMCcgJiYgKHZlcnNpb25bMV0gPCAzIHx8IHZlcnNpb25bMV0gPT09ICczJyAmJiB2ZXJzaW9uWzJdID09PSAnMCcpO1xufSkoKTtcblxuLy8gSUU5LSAvIEJ1biAwLjMuMC0gc2V0VGltZW91dCAvIHNldEludGVydmFsIC8gc2V0SW1tZWRpYXRlIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3RpbWVycy1hbmQtdXNlci1wcm9tcHRzLmh0bWwjdGltZXJzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vb3Zlbi1zaC9idW4vaXNzdWVzLzE2MzNcbnZhciBzY2hlZHVsZXJzRml4JDIgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBoYXNUaW1lQXJnKSB7XG4gIHZhciBmaXJzdFBhcmFtSW5kZXggPSBoYXNUaW1lQXJnID8gMiA6IDE7XG4gIHJldHVybiBXUkFQID8gZnVuY3Rpb24gKGhhbmRsZXIsIHRpbWVvdXQgLyogLCAuLi5hcmd1bWVudHMgKi8pIHtcbiAgICB2YXIgYm91bmRBcmdzID0gdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSkgPiBmaXJzdFBhcmFtSW5kZXg7XG4gICAgdmFyIGZuID0gaXNDYWxsYWJsZSQxKGhhbmRsZXIpID8gaGFuZGxlciA6IEZ1bmN0aW9uJDEoaGFuZGxlcik7XG4gICAgdmFyIHBhcmFtcyA9IGJvdW5kQXJncyA/IGFycmF5U2xpY2UkMShhcmd1bWVudHMsIGZpcnN0UGFyYW1JbmRleCkgOiBbXTtcbiAgICB2YXIgY2FsbGJhY2sgPSBib3VuZEFyZ3MgPyBmdW5jdGlvbiAoKSB7XG4gICAgICBhcHBseSQxKGZuLCB0aGlzLCBwYXJhbXMpO1xuICAgIH0gOiBmbjtcbiAgICByZXR1cm4gaGFzVGltZUFyZyA/IHNjaGVkdWxlcihjYWxsYmFjaywgdGltZW91dCkgOiBzY2hlZHVsZXIoY2FsbGJhY2spO1xuICB9IDogc2NoZWR1bGVyO1xufTtcblxudmFyICQkaiA9IF9leHBvcnQ7XG52YXIgZ2xvYmFsJDcgPSBnbG9iYWwkbjtcbnZhciBzY2hlZHVsZXJzRml4JDEgPSBzY2hlZHVsZXJzRml4JDI7XG5cbnZhciBzZXRJbnRlcnZhbCQyID0gc2NoZWR1bGVyc0ZpeCQxKGdsb2JhbCQ3LnNldEludGVydmFsLCB0cnVlKTtcblxuLy8gQnVuIC8gSUU5LSBzZXRJbnRlcnZhbCBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgZml4XG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS90aW1lcnMtYW5kLXVzZXItcHJvbXB0cy5odG1sI2RvbS1zZXRpbnRlcnZhbFxuJCRqKHsgZ2xvYmFsOiB0cnVlLCBiaW5kOiB0cnVlLCBmb3JjZWQ6IGdsb2JhbCQ3LnNldEludGVydmFsICE9PSBzZXRJbnRlcnZhbCQyIH0sIHtcbiAgc2V0SW50ZXJ2YWw6IHNldEludGVydmFsJDJcbn0pO1xuXG52YXIgJCRpID0gX2V4cG9ydDtcbnZhciBnbG9iYWwkNiA9IGdsb2JhbCRuO1xudmFyIHNjaGVkdWxlcnNGaXggPSBzY2hlZHVsZXJzRml4JDI7XG5cbnZhciBzZXRUaW1lb3V0JDMgPSBzY2hlZHVsZXJzRml4KGdsb2JhbCQ2LnNldFRpbWVvdXQsIHRydWUpO1xuXG4vLyBCdW4gLyBJRTktIHNldFRpbWVvdXQgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZpeFxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdGltZXJzLWFuZC11c2VyLXByb21wdHMuaHRtbCNkb20tc2V0dGltZW91dFxuJCRpKHsgZ2xvYmFsOiB0cnVlLCBiaW5kOiB0cnVlLCBmb3JjZWQ6IGdsb2JhbCQ2LnNldFRpbWVvdXQgIT09IHNldFRpbWVvdXQkMyB9LCB7XG4gIHNldFRpbWVvdXQ6IHNldFRpbWVvdXQkM1xufSk7XG5cbnZhciBwYXRoJGcgPSBwYXRoJHc7XG5cbnZhciBzZXRUaW1lb3V0JDIgPSBwYXRoJGcuc2V0VGltZW91dDtcblxudmFyIHNldFRpbWVvdXQkMSA9IHNldFRpbWVvdXQkMjtcblxudmFyIF9zZXRUaW1lb3V0ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHNldFRpbWVvdXQkMSk7XG5cbnZhciB0b09iamVjdCQyID0gdG9PYmplY3QkZTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSB0b0Fic29sdXRlSW5kZXgkNTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQzID0gbGVuZ3RoT2ZBcnJheUxpa2UkYztcblxuLy8gYEFycmF5LnByb3RvdHlwZS5maWxsYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbGxcbnZhciBhcnJheUZpbGwgPSBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQgPSAwLCBlbmQgPSBAbGVuZ3RoICovKSB7XG4gIHZhciBPID0gdG9PYmplY3QkMih0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDMoTyk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50c0xlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gIHZhciBlbmRQb3MgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCk7XG4gIHdoaWxlIChlbmRQb3MgPiBpbmRleCkgT1tpbmRleCsrXSA9IHZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cbnZhciAkJGggPSBfZXhwb3J0O1xudmFyIGZpbGwkNCA9IGFycmF5RmlsbDtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5maWxsYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbGxcbiQkaCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUgfSwge1xuICBmaWxsOiBmaWxsJDRcbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJDUgPSBlbnRyeVZpcnR1YWwkaTtcblxudmFyIGZpbGwkMyA9IGVudHJ5VmlydHVhbCQ1KCdBcnJheScpLmZpbGw7XG5cbnZhciBpc1Byb3RvdHlwZU9mJDcgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCQ1ID0gZmlsbCQzO1xuXG52YXIgQXJyYXlQcm90b3R5cGUkNSA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIGZpbGwkMiA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuZmlsbDtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQ1IHx8IChpc1Byb3RvdHlwZU9mJDcoQXJyYXlQcm90b3R5cGUkNSwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkNS5maWxsKSA/IG1ldGhvZCQ1IDogb3duO1xufTtcblxudmFyIHBhcmVudCR3ID0gZmlsbCQyO1xuXG52YXIgZmlsbCQxID0gcGFyZW50JHc7XG5cbnZhciBmaWxsID0gZmlsbCQxO1xuXG52YXIgX2ZpbGxJbnN0YW5jZVByb3BlcnR5ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGZpbGwpO1xuXG4vKiEgSGFtbWVyLkpTIC0gdjIuMC4xNy1yYyAtIDIwMTktMTItMTZcbiAqIGh0dHA6Ly9uYXZlci5naXRodWIuaW8vZWdqc1xuICpcbiAqIEZvcmtlZCBCeSBOYXZlciBlZ2pzXG4gKiBDb3B5cmlnaHQgKGMpIGhhbW1lcmpzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZCQxKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWxmO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0gey4uLk9iamVjdH0gb2JqZWN0c190b19hc3NpZ25cbiAqIEByZXR1cm5zIHtPYmplY3R9IHRhcmdldFxuICovXG52YXIgYXNzaWduO1xuXG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgIH1cblxuICAgIHZhciBvdXRwdXQgPSBPYmplY3QodGFyZ2V0KTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMTsgaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcblxuICAgICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkICYmIHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBuZXh0S2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkobmV4dEtleSkpIHtcbiAgICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IHNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xufSBlbHNlIHtcbiAgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbn1cblxudmFyIGFzc2lnbiQxID0gYXNzaWduO1xuXG52YXIgVkVORE9SX1BSRUZJWEVTID0gWycnLCAnd2Via2l0JywgJ01veicsICdNUycsICdtcycsICdvJ107XG52YXIgVEVTVF9FTEVNRU5UID0gdHlwZW9mIGRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiID8ge1xuICBzdHlsZToge31cbn0gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbnZhciBUWVBFX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcbnZhciByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgYWJzJDEgPSBNYXRoLmFicztcbnZhciBub3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZ2V0IHRoZSBwcmVmaXhlZCBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJucyB7U3RyaW5nfFVuZGVmaW5lZH0gcHJlZml4ZWRcbiAqL1xuXG5mdW5jdGlvbiBwcmVmaXhlZChvYmosIHByb3BlcnR5KSB7XG4gIHZhciBwcmVmaXg7XG4gIHZhciBwcm9wO1xuICB2YXIgY2FtZWxQcm9wID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBWRU5ET1JfUFJFRklYRVMubGVuZ3RoKSB7XG4gICAgcHJlZml4ID0gVkVORE9SX1BSRUZJWEVTW2ldO1xuICAgIHByb3AgPSBwcmVmaXggPyBwcmVmaXggKyBjYW1lbFByb3AgOiBwcm9wZXJ0eTtcblxuICAgIGlmIChwcm9wIGluIG9iaikge1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tbmV3LWZ1bmMsIG5vLW5lc3RlZC10ZXJuYXJ5ICovXG52YXIgd2luO1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAvLyB3aW5kb3cgaXMgdW5kZWZpbmVkIGluIG5vZGUuanNcbiAgd2luID0ge307XG59IGVsc2Uge1xuICB3aW4gPSB3aW5kb3c7XG59XG5cbnZhciBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gPSBwcmVmaXhlZChURVNUX0VMRU1FTlQuc3R5bGUsICd0b3VjaEFjdGlvbicpO1xudmFyIE5BVElWRV9UT1VDSF9BQ1RJT04gPSBQUkVGSVhFRF9UT1VDSF9BQ1RJT04gIT09IHVuZGVmaW5lZDtcbmZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uUHJvcHMoKSB7XG4gIGlmICghTkFUSVZFX1RPVUNIX0FDVElPTikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB0b3VjaE1hcCA9IHt9O1xuICB2YXIgY3NzU3VwcG9ydHMgPSB3aW4uQ1NTICYmIHdpbi5DU1Muc3VwcG9ydHM7XG4gIFsnYXV0bycsICdtYW5pcHVsYXRpb24nLCAncGFuLXknLCAncGFuLXgnLCAncGFuLXggcGFuLXknLCAnbm9uZSddLmZvckVhY2goZnVuY3Rpb24gKHZhbCkge1xuICAgIC8vIElmIGNzcy5zdXBwb3J0cyBpcyBub3Qgc3VwcG9ydGVkIGJ1dCB0aGVyZSBpcyBuYXRpdmUgdG91Y2gtYWN0aW9uIGFzc3VtZSBpdCBzdXBwb3J0c1xuICAgIC8vIGFsbCB2YWx1ZXMuIFRoaXMgaXMgdGhlIGNhc2UgZm9yIElFIDEwIGFuZCAxMS5cbiAgICByZXR1cm4gdG91Y2hNYXBbdmFsXSA9IGNzc1N1cHBvcnRzID8gd2luLkNTUy5zdXBwb3J0cygndG91Y2gtYWN0aW9uJywgdmFsKSA6IHRydWU7XG4gIH0pO1xuICByZXR1cm4gdG91Y2hNYXA7XG59XG5cbnZhciBUT1VDSF9BQ1RJT05fQ09NUFVURSA9ICdjb21wdXRlJztcbnZhciBUT1VDSF9BQ1RJT05fQVVUTyA9ICdhdXRvJztcbnZhciBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OID0gJ21hbmlwdWxhdGlvbic7IC8vIG5vdCBpbXBsZW1lbnRlZFxuXG52YXIgVE9VQ0hfQUNUSU9OX05PTkUgPSAnbm9uZSc7XG52YXIgVE9VQ0hfQUNUSU9OX1BBTl9YID0gJ3Bhbi14JztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1kgPSAncGFuLXknO1xudmFyIFRPVUNIX0FDVElPTl9NQVAgPSBnZXRUb3VjaEFjdGlvblByb3BzKCk7XG5cbnZhciBNT0JJTEVfUkVHRVggPSAvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkL2k7XG52YXIgU1VQUE9SVF9UT1VDSCA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbjtcbnZhciBTVVBQT1JUX1BPSU5URVJfRVZFTlRTID0gcHJlZml4ZWQod2luLCAnUG9pbnRlckV2ZW50JykgIT09IHVuZGVmaW5lZDtcbnZhciBTVVBQT1JUX09OTFlfVE9VQ0ggPSBTVVBQT1JUX1RPVUNIICYmIE1PQklMRV9SRUdFWC50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElOUFVUX1RZUEVfVE9VQ0ggPSAndG91Y2gnO1xudmFyIElOUFVUX1RZUEVfUEVOID0gJ3Blbic7XG52YXIgSU5QVVRfVFlQRV9NT1VTRSA9ICdtb3VzZSc7XG52YXIgSU5QVVRfVFlQRV9LSU5FQ1QgPSAna2luZWN0JztcbnZhciBDT01QVVRFX0lOVEVSVkFMID0gMjU7XG52YXIgSU5QVVRfU1RBUlQgPSAxO1xudmFyIElOUFVUX01PVkUgPSAyO1xudmFyIElOUFVUX0VORCA9IDQ7XG52YXIgSU5QVVRfQ0FOQ0VMID0gODtcbnZhciBESVJFQ1RJT05fTk9ORSA9IDE7XG52YXIgRElSRUNUSU9OX0xFRlQgPSAyO1xudmFyIERJUkVDVElPTl9SSUdIVCA9IDQ7XG52YXIgRElSRUNUSU9OX1VQID0gODtcbnZhciBESVJFQ1RJT05fRE9XTiA9IDE2O1xudmFyIERJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0xFRlQgfCBESVJFQ1RJT05fUklHSFQ7XG52YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XG52YXIgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xudmFyIFBST1BTX1hZID0gWyd4JywgJ3knXTtcbnZhciBQUk9QU19DTElFTlRfWFkgPSBbJ2NsaWVudFgnLCAnY2xpZW50WSddO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiB3YWxrIG9iamVjdHMgYW5kIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICB2YXIgaTtcblxuICBpZiAoIW9iaikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmouZm9yRWFjaCkge1xuICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgb2JqLmxlbmd0aCkge1xuICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICBpKys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogbGV0IGEgYm9vbGVhbiB2YWx1ZSBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBtdXN0IHJldHVybiBhIGJvb2xlYW5cbiAqIHRoaXMgZmlyc3QgaXRlbSBpbiBhcmdzIHdpbGwgYmUgdXNlZCBhcyB0aGUgY29udGV4dFxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cblxuZnVuY3Rpb24gYm9vbE9yRm4odmFsLCBhcmdzKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSBUWVBFX0ZVTkNUSU9OKSB7XG4gICAgcmV0dXJuIHZhbC5hcHBseShhcmdzID8gYXJnc1swXSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogc21hbGwgaW5kZXhPZiB3cmFwcGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHJldHVybnMge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGluU3RyKHN0ciwgZmluZCkge1xuICByZXR1cm4gc3RyLmluZGV4T2YoZmluZCkgPiAtMTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogd2hlbiB0aGUgdG91Y2hBY3Rpb25zIGFyZSBjb2xsZWN0ZWQgdGhleSBhcmUgbm90IGEgdmFsaWQgdmFsdWUsIHNvIHdlIG5lZWQgdG8gY2xlYW4gdGhpbmdzIHVwLiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0aW9uc1xuICogQHJldHVybnMgeyp9XG4gKi9cblxuZnVuY3Rpb24gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucykge1xuICAvLyBub25lXG4gIGlmIChpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkpIHtcbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX05PTkU7XG4gIH1cblxuICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKTsgLy8gaWYgYm90aCBwYW4teCBhbmQgcGFuLXkgYXJlIHNldCAoZGlmZmVyZW50IHJlY29nbml6ZXJzXG4gIC8vIGZvciBkaWZmZXJlbnQgZGlyZWN0aW9ucywgZS5nLiBob3Jpem9udGFsIHBhbiBidXQgdmVydGljYWwgc3dpcGU/KVxuICAvLyB3ZSBuZWVkIG5vbmUgKGFzIG90aGVyd2lzZSB3aXRoIHBhbi14IHBhbi15IGNvbWJpbmVkIG5vbmUgb2YgdGhlc2VcbiAgLy8gcmVjb2duaXplcnMgd2lsbCB3b3JrLCBzaW5jZSB0aGUgYnJvd3NlciB3b3VsZCBoYW5kbGUgYWxsIHBhbm5pbmdcblxuICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgcmV0dXJuIFRPVUNIX0FDVElPTl9OT05FO1xuICB9IC8vIHBhbi14IE9SIHBhbi15XG5cblxuICBpZiAoaGFzUGFuWCB8fCBoYXNQYW5ZKSB7XG4gICAgcmV0dXJuIGhhc1BhblggPyBUT1VDSF9BQ1RJT05fUEFOX1ggOiBUT1VDSF9BQ1RJT05fUEFOX1k7XG4gIH0gLy8gbWFuaXB1bGF0aW9uXG5cblxuICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTikpIHtcbiAgICByZXR1cm4gVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTjtcbiAgfVxuXG4gIHJldHVybiBUT1VDSF9BQ1RJT05fQVVUTztcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogVG91Y2ggQWN0aW9uXG4gKiBzZXRzIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBvciB1c2VzIHRoZSBqcyBhbHRlcm5hdGl2ZVxuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBUb3VjaEFjdGlvbiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRvdWNoQWN0aW9uKG1hbmFnZXIsIHZhbHVlKSB7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLnNldCh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHNldCB0aGUgdG91Y2hBY3Rpb24gdmFsdWUgb24gdGhlIGVsZW1lbnQgb3IgZW5hYmxlIHRoZSBwb2x5ZmlsbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gVG91Y2hBY3Rpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyBmaW5kIG91dCB0aGUgdG91Y2gtYWN0aW9uIGJ5IHRoZSBldmVudCBoYW5kbGVyc1xuICAgIGlmICh2YWx1ZSA9PT0gVE9VQ0hfQUNUSU9OX0NPTVBVVEUpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5jb21wdXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKE5BVElWRV9UT1VDSF9BQ1RJT04gJiYgdGhpcy5tYW5hZ2VyLmVsZW1lbnQuc3R5bGUgJiYgVE9VQ0hfQUNUSU9OX01BUFt2YWx1ZV0pIHtcbiAgICAgIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlW1BSRUZJWEVEX1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmFjdGlvbnMgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGp1c3QgcmUtc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZVxuICAgKi9cblxuXG4gIF9wcm90by51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdGhpcy5zZXQodGhpcy5tYW5hZ2VyLm9wdGlvbnMudG91Y2hBY3Rpb24pO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcmVjb2duaXplcidzIHNldHRpbmdzXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHZhbHVlXG4gICAqL1xuXG5cbiAgX3Byb3RvLmNvbXB1dGUgPSBmdW5jdGlvbiBjb21wdXRlKCkge1xuICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgZWFjaCh0aGlzLm1hbmFnZXIucmVjb2duaXplcnMsIGZ1bmN0aW9uIChyZWNvZ25pemVyKSB7XG4gICAgICBpZiAoYm9vbE9yRm4ocmVjb2duaXplci5vcHRpb25zLmVuYWJsZSwgW3JlY29nbml6ZXJdKSkge1xuICAgICAgICBhY3Rpb25zID0gYWN0aW9ucy5jb25jYXQocmVjb2duaXplci5nZXRUb3VjaEFjdGlvbigpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucy5qb2luKCcgJykpO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogdGhpcyBtZXRob2QgaXMgY2FsbGVkIG9uIGVhY2ggaW5wdXQgY3ljbGUgYW5kIHByb3ZpZGVzIHRoZSBwcmV2ZW50aW5nIG9mIHRoZSBicm93c2VyIGJlaGF2aW9yXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKi9cblxuXG4gIF9wcm90by5wcmV2ZW50RGVmYXVsdHMgPSBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdHMoaW5wdXQpIHtcbiAgICB2YXIgc3JjRXZlbnQgPSBpbnB1dC5zcmNFdmVudDtcbiAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQub2Zmc2V0RGlyZWN0aW9uOyAvLyBpZiB0aGUgdG91Y2ggYWN0aW9uIGRpZCBwcmV2ZW50ZWQgb25jZSB0aGlzIHNlc3Npb25cblxuICAgIGlmICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wcmV2ZW50ZWQpIHtcbiAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgdmFyIGhhc05vbmUgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fTk9ORSkgJiYgIVRPVUNIX0FDVElPTl9NQVBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICAgIHZhciBoYXNQYW5ZID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9ZKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1ldO1xuICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1hdO1xuXG4gICAgaWYgKGhhc05vbmUpIHtcbiAgICAgIC8vIGRvIG5vdCBwcmV2ZW50IGRlZmF1bHRzIGlmIHRoaXMgaXMgYSB0YXAgZ2VzdHVyZVxuICAgICAgdmFyIGlzVGFwUG9pbnRlciA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gMTtcbiAgICAgIHZhciBpc1RhcE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCAyO1xuICAgICAgdmFyIGlzVGFwVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgMjUwO1xuXG4gICAgICBpZiAoaXNUYXBQb2ludGVyICYmIGlzVGFwTW92ZW1lbnQgJiYgaXNUYXBUb3VjaFRpbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgIC8vIGBwYW4teCBwYW4teWAgbWVhbnMgYnJvd3NlciBoYW5kbGVzIGFsbCBzY3JvbGxpbmcvcGFubmluZywgZG8gbm90IHByZXZlbnRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaGFzTm9uZSB8fCBoYXNQYW5ZICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMIHx8IGhhc1BhblggJiYgZGlyZWN0aW9uICYgRElSRUNUSU9OX1ZFUlRJQ0FMKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmV2ZW50U3JjKHNyY0V2ZW50KTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjYWxsIHByZXZlbnREZWZhdWx0IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIncyBkZWZhdWx0IGJlaGF2aW9yIChzY3JvbGxpbmcgaW4gbW9zdCBjYXNlcylcbiAgICogQHBhcmFtIHtPYmplY3R9IHNyY0V2ZW50XG4gICAqL1xuXG5cbiAgX3Byb3RvLnByZXZlbnRTcmMgPSBmdW5jdGlvbiBwcmV2ZW50U3JjKHNyY0V2ZW50KSB7XG4gICAgdGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkID0gdHJ1ZTtcbiAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIHJldHVybiBUb3VjaEFjdGlvbjtcbn0oKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZmluZCBpZiBhIG5vZGUgaXMgaW4gdGhlIGdpdmVuIHBhcmVudFxuICogQG1ldGhvZCBoYXNQYXJlbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybiB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaGFzUGFyZW50KG5vZGUsIHBhcmVudCkge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlID09PSBwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCB0aGUgY2VudGVyIG9mIGFsbCB0aGUgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50ZXJzXG4gKiBAcmV0dXJuIHtPYmplY3R9IGNlbnRlciBjb250YWlucyBgeGAgYW5kIGB5YCBwcm9wZXJ0aWVzXG4gKi9cblxuZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50ZXJzKSB7XG4gIHZhciBwb2ludGVyc0xlbmd0aCA9IHBvaW50ZXJzLmxlbmd0aDsgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcblxuICBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WCksXG4gICAgICB5OiByb3VuZChwb2ludGVyc1swXS5jbGllbnRZKVxuICAgIH07XG4gIH1cblxuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgcG9pbnRlcnNMZW5ndGgpIHtcbiAgICB4ICs9IHBvaW50ZXJzW2ldLmNsaWVudFg7XG4gICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xuICAgIGkrKztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcm91bmQoeCAvIHBvaW50ZXJzTGVuZ3RoKSxcbiAgICB5OiByb3VuZCh5IC8gcG9pbnRlcnNMZW5ndGgpXG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGNyZWF0ZSBhIHNpbXBsZSBjbG9uZSBmcm9tIHRoZSBpbnB1dCB1c2VkIGZvciBzdG9yYWdlIG9mIGZpcnN0SW5wdXQgYW5kIGZpcnN0TXVsdGlwbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICogQHJldHVybnMge09iamVjdH0gY2xvbmVkSW5wdXREYXRhXG4gKi9cblxuZnVuY3Rpb24gc2ltcGxlQ2xvbmVJbnB1dERhdGEoaW5wdXQpIHtcbiAgLy8gbWFrZSBhIHNpbXBsZSBjb3B5IG9mIHRoZSBwb2ludGVycyBiZWNhdXNlIHdlIHdpbGwgZ2V0IGEgcmVmZXJlbmNlIGlmIHdlIGRvbid0XG4gIC8vIHdlIG9ubHkgbmVlZCBjbGllbnRYWSBmb3IgdGhlIGNhbGN1bGF0aW9uc1xuICB2YXIgcG9pbnRlcnMgPSBbXTtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgaW5wdXQucG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgcG9pbnRlcnNbaV0gPSB7XG4gICAgICBjbGllbnRYOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRYKSxcbiAgICAgIGNsaWVudFk6IHJvdW5kKGlucHV0LnBvaW50ZXJzW2ldLmNsaWVudFkpXG4gICAgfTtcbiAgICBpKys7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRpbWVTdGFtcDogbm93KCksXG4gICAgcG9pbnRlcnM6IHBvaW50ZXJzLFxuICAgIGNlbnRlcjogZ2V0Q2VudGVyKHBvaW50ZXJzKSxcbiAgICBkZWx0YVg6IGlucHV0LmRlbHRhWCxcbiAgICBkZWx0YVk6IGlucHV0LmRlbHRhWVxuICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjYWxjdWxhdGUgdGhlIGFic29sdXRlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50c1xuICogQHBhcmFtIHtPYmplY3R9IHAxIHt4LCB5fVxuICogQHBhcmFtIHtPYmplY3R9IHAyIHt4LCB5fVxuICogQHBhcmFtIHtBcnJheX0gW3Byb3BzXSBjb250YWluaW5nIHggYW5kIHkga2V5c1xuICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZVxuICovXG5cbmZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMiwgcHJvcHMpIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHByb3BzID0gUFJPUFNfWFk7XG4gIH1cblxuICB2YXIgeCA9IHAyW3Byb3BzWzBdXSAtIHAxW3Byb3BzWzBdXTtcbiAgdmFyIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGNhbGN1bGF0ZSB0aGUgYW5nbGUgYmV0d2VlbiB0d28gY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwMVxuICogQHBhcmFtIHtPYmplY3R9IHAyXG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGFuZ2xlXG4gKi9cblxuZnVuY3Rpb24gZ2V0QW5nbGUocDEsIHAyLCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgfVxuXG4gIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dO1xuICB2YXIgeSA9IHAyW3Byb3BzWzFdXSAtIHAxW3Byb3BzWzFdXTtcbiAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBnZXREaXJlY3Rpb24oeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiBESVJFQ1RJT05fTk9ORTtcbiAgfVxuXG4gIGlmIChhYnMkMSh4KSA+PSBhYnMkMSh5KSkge1xuICAgIHJldHVybiB4IDwgMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICB9XG5cbiAgcmV0dXJuIHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KSB7XG4gIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXI7IC8vIGxldCB7IG9mZnNldERlbHRhOm9mZnNldCA9IHt9LCBwcmV2RGVsdGEgPSB7fSwgcHJldklucHV0ID0ge30gfSA9IHNlc3Npb247XG4gIC8vIGpzY3MgdGhyb3dpbmcgZXJyb3Igb24gZGVmYWx1dCBkZXN0cnVjdHVyZWQgdmFsdWVzIGFuZCB3aXRob3V0IGRlZmF1bHRzIHRlc3RzIGZhaWxcblxuICB2YXIgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSB8fCB7fTtcbiAgdmFyIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhIHx8IHt9O1xuICB2YXIgcHJldklucHV0ID0gc2Vzc2lvbi5wcmV2SW5wdXQgfHwge307XG5cbiAgaWYgKGlucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfU1RBUlQgfHwgcHJldklucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfRU5EKSB7XG4gICAgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgPSB7XG4gICAgICB4OiBwcmV2SW5wdXQuZGVsdGFYIHx8IDAsXG4gICAgICB5OiBwcmV2SW5wdXQuZGVsdGFZIHx8IDBcbiAgICB9O1xuICAgIG9mZnNldCA9IHNlc3Npb24ub2Zmc2V0RGVsdGEgPSB7XG4gICAgICB4OiBjZW50ZXIueCxcbiAgICAgIHk6IGNlbnRlci55XG4gICAgfTtcbiAgfVxuXG4gIGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICBpbnB1dC5kZWx0YVkgPSBwcmV2RGVsdGEueSArIChjZW50ZXIueSAtIG9mZnNldC55KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gKi9cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgeCwgeSkge1xuICByZXR1cm4ge1xuICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcbiAgICB5OiB5IC8gZGVsdGFUaW1lIHx8IDBcbiAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogY2FsY3VsYXRlIHRoZSBzY2FsZSBmYWN0b3IgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZVxuICovXG5cbmZ1bmN0aW9uIGdldFNjYWxlKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGdldERpc3RhbmNlKGVuZFswXSwgZW5kWzFdLCBQUk9QU19DTElFTlRfWFkpIC8gZ2V0RGlzdGFuY2Uoc3RhcnRbMF0sIHN0YXJ0WzFdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gcG9pbnRlcnNldHNcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gcm90YXRpb25cbiAqL1xuXG5mdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBnZXRBbmdsZShlbmRbMV0sIGVuZFswXSwgUFJPUFNfQ0xJRU5UX1hZKSArIGdldEFuZ2xlKHN0YXJ0WzFdLCBzdGFydFswXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogdmVsb2NpdHkgaXMgY2FsY3VsYXRlZCBldmVyeSB4IG1zXG4gKiBAcGFyYW0ge09iamVjdH0gc2Vzc2lvblxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gKi9cblxuZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gIHZhciBsYXN0ID0gc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgfHwgaW5wdXQ7XG4gIHZhciBkZWx0YVRpbWUgPSBpbnB1dC50aW1lU3RhbXAgLSBsYXN0LnRpbWVTdGFtcDtcbiAgdmFyIHZlbG9jaXR5O1xuICB2YXIgdmVsb2NpdHlYO1xuICB2YXIgdmVsb2NpdHlZO1xuICB2YXIgZGlyZWN0aW9uO1xuXG4gIGlmIChpbnB1dC5ldmVudFR5cGUgIT09IElOUFVUX0NBTkNFTCAmJiAoZGVsdGFUaW1lID4gQ09NUFVURV9JTlRFUlZBTCB8fCBsYXN0LnZlbG9jaXR5ID09PSB1bmRlZmluZWQpKSB7XG4gICAgdmFyIGRlbHRhWCA9IGlucHV0LmRlbHRhWCAtIGxhc3QuZGVsdGFYO1xuICAgIHZhciBkZWx0YVkgPSBpbnB1dC5kZWx0YVkgLSBsYXN0LmRlbHRhWTtcbiAgICB2YXIgdiA9IGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgIHZlbG9jaXR5WCA9IHYueDtcbiAgICB2ZWxvY2l0eVkgPSB2Lnk7XG4gICAgdmVsb2NpdHkgPSBhYnMkMSh2LngpID4gYWJzJDEodi55KSA/IHYueCA6IHYueTtcbiAgICBkaXJlY3Rpb24gPSBnZXREaXJlY3Rpb24oZGVsdGFYLCBkZWx0YVkpO1xuICAgIHNlc3Npb24ubGFzdEludGVydmFsID0gaW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIGxhdGVzdCB2ZWxvY2l0eSBpbmZvIGlmIGl0IGRvZXNuJ3Qgb3ZlcnRha2UgYSBtaW5pbXVtIHBlcmlvZFxuICAgIHZlbG9jaXR5ID0gbGFzdC52ZWxvY2l0eTtcbiAgICB2ZWxvY2l0eVggPSBsYXN0LnZlbG9jaXR5WDtcbiAgICB2ZWxvY2l0eVkgPSBsYXN0LnZlbG9jaXR5WTtcbiAgICBkaXJlY3Rpb24gPSBsYXN0LmRpcmVjdGlvbjtcbiAgfVxuXG4gIGlucHV0LnZlbG9jaXR5ID0gdmVsb2NpdHk7XG4gIGlucHV0LnZlbG9jaXR5WCA9IHZlbG9jaXR5WDtcbiAgaW5wdXQudmVsb2NpdHlZID0gdmVsb2NpdHlZO1xuICBpbnB1dC5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG59XG5cbi8qKlxuKiBAcHJpdmF0ZVxuICogZXh0ZW5kIHRoZSBkYXRhIHdpdGggc29tZSB1c2FibGUgcHJvcGVydGllcyBsaWtlIHNjYWxlLCByb3RhdGUsIHZlbG9jaXR5IGV0Y1xuICogQHBhcmFtIHtPYmplY3R9IG1hbmFnZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5cbmZ1bmN0aW9uIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpIHtcbiAgdmFyIHNlc3Npb24gPSBtYW5hZ2VyLnNlc3Npb247XG4gIHZhciBwb2ludGVycyA9IGlucHV0LnBvaW50ZXJzO1xuICB2YXIgcG9pbnRlcnNMZW5ndGggPSBwb2ludGVycy5sZW5ndGg7IC8vIHN0b3JlIHRoZSBmaXJzdCBpbnB1dCB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGFuZCBkaXJlY3Rpb25cblxuICBpZiAoIXNlc3Npb24uZmlyc3RJbnB1dCkge1xuICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgfSAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXG5cblxuICBpZiAocG9pbnRlcnNMZW5ndGggPiAxICYmICFzZXNzaW9uLmZpcnN0TXVsdGlwbGUpIHtcbiAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBzaW1wbGVDbG9uZUlucHV0RGF0YShpbnB1dCk7XG4gIH0gZWxzZSBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICBzZXNzaW9uLmZpcnN0TXVsdGlwbGUgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBmaXJzdElucHV0ID0gc2Vzc2lvbi5maXJzdElucHV0LFxuICAgICAgZmlyc3RNdWx0aXBsZSA9IHNlc3Npb24uZmlyc3RNdWx0aXBsZTtcbiAgdmFyIG9mZnNldENlbnRlciA9IGZpcnN0TXVsdGlwbGUgPyBmaXJzdE11bHRpcGxlLmNlbnRlciA6IGZpcnN0SW5wdXQuY2VudGVyO1xuICB2YXIgY2VudGVyID0gaW5wdXQuY2VudGVyID0gZ2V0Q2VudGVyKHBvaW50ZXJzKTtcbiAgaW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gIGlucHV0LmRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGZpcnN0SW5wdXQudGltZVN0YW1wO1xuICBpbnB1dC5hbmdsZSA9IGdldEFuZ2xlKG9mZnNldENlbnRlciwgY2VudGVyKTtcbiAgaW5wdXQuZGlzdGFuY2UgPSBnZXREaXN0YW5jZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG4gIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KTtcbiAgaW5wdXQub2Zmc2V0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgdmFyIG92ZXJhbGxWZWxvY2l0eSA9IGdldFZlbG9jaXR5KGlucHV0LmRlbHRhVGltZSwgaW5wdXQuZGVsdGFYLCBpbnB1dC5kZWx0YVkpO1xuICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYID0gb3ZlcmFsbFZlbG9jaXR5Lng7XG4gIGlucHV0Lm92ZXJhbGxWZWxvY2l0eVkgPSBvdmVyYWxsVmVsb2NpdHkueTtcbiAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5ID0gYWJzJDEob3ZlcmFsbFZlbG9jaXR5LngpID4gYWJzJDEob3ZlcmFsbFZlbG9jaXR5LnkpID8gb3ZlcmFsbFZlbG9jaXR5LnggOiBvdmVyYWxsVmVsb2NpdHkueTtcbiAgaW5wdXQuc2NhbGUgPSBmaXJzdE11bHRpcGxlID8gZ2V0U2NhbGUoZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMTtcbiAgaW5wdXQucm90YXRpb24gPSBmaXJzdE11bHRpcGxlID8gZ2V0Um90YXRpb24oZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMDtcbiAgaW5wdXQubWF4UG9pbnRlcnMgPSAhc2Vzc2lvbi5wcmV2SW5wdXQgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiBpbnB1dC5wb2ludGVycy5sZW5ndGggPiBzZXNzaW9uLnByZXZJbnB1dC5tYXhQb2ludGVycyA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6IHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzO1xuICBjb21wdXRlSW50ZXJ2YWxJbnB1dERhdGEoc2Vzc2lvbiwgaW5wdXQpOyAvLyBmaW5kIHRoZSBjb3JyZWN0IHRhcmdldFxuXG4gIHZhciB0YXJnZXQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xuICB2YXIgc3JjRXZlbnRUYXJnZXQ7XG5cbiAgaWYgKHNyY0V2ZW50LmNvbXBvc2VkUGF0aCkge1xuICAgIHNyY0V2ZW50VGFyZ2V0ID0gc3JjRXZlbnQuY29tcG9zZWRQYXRoKClbMF07XG4gIH0gZWxzZSBpZiAoc3JjRXZlbnQucGF0aCkge1xuICAgIHNyY0V2ZW50VGFyZ2V0ID0gc3JjRXZlbnQucGF0aFswXTtcbiAgfSBlbHNlIHtcbiAgICBzcmNFdmVudFRhcmdldCA9IHNyY0V2ZW50LnRhcmdldDtcbiAgfVxuXG4gIGlmIChoYXNQYXJlbnQoc3JjRXZlbnRUYXJnZXQsIHRhcmdldCkpIHtcbiAgICB0YXJnZXQgPSBzcmNFdmVudFRhcmdldDtcbiAgfVxuXG4gIGlucHV0LnRhcmdldCA9IHRhcmdldDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogaGFuZGxlIGlucHV0IGV2ZW50c1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuXG5mdW5jdGlvbiBpbnB1dEhhbmRsZXIobWFuYWdlciwgZXZlbnRUeXBlLCBpbnB1dCkge1xuICB2YXIgcG9pbnRlcnNMZW4gPSBpbnB1dC5wb2ludGVycy5sZW5ndGg7XG4gIHZhciBjaGFuZ2VkUG9pbnRlcnNMZW4gPSBpbnB1dC5jaGFuZ2VkUG9pbnRlcnMubGVuZ3RoO1xuICB2YXIgaXNGaXJzdCA9IGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwO1xuICB2YXIgaXNGaW5hbCA9IGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwO1xuICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xuICBpbnB1dC5pc0ZpbmFsID0gISFpc0ZpbmFsO1xuXG4gIGlmIChpc0ZpcnN0KSB7XG4gICAgbWFuYWdlci5zZXNzaW9uID0ge307XG4gIH0gLy8gc291cmNlIGV2ZW50IGlzIHRoZSBub3JtYWxpemVkIHZhbHVlIG9mIHRoZSBkb21FdmVudHNcbiAgLy8gbGlrZSAndG91Y2hzdGFydCwgbW91c2V1cCwgcG9pbnRlcmRvd24nXG5cblxuICBpbnB1dC5ldmVudFR5cGUgPSBldmVudFR5cGU7IC8vIGNvbXB1dGUgc2NhbGUsIHJvdGF0aW9uIGV0Y1xuXG4gIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpOyAvLyBlbWl0IHNlY3JldCBldmVudFxuXG4gIG1hbmFnZXIuZW1pdCgnaGFtbWVyLmlucHV0JywgaW5wdXQpO1xuICBtYW5hZ2VyLnJlY29nbml6ZShpbnB1dCk7XG4gIG1hbmFnZXIuc2Vzc2lvbi5wcmV2SW5wdXQgPSBpbnB1dDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogc3BsaXQgc3RyaW5nIG9uIHdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtBcnJheX0gd29yZHNcbiAqL1xuZnVuY3Rpb24gc3BsaXRTdHIoc3RyKSB7XG4gIHJldHVybiBzdHIudHJpbSgpLnNwbGl0KC9cXHMrL2cpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBhZGRFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiByZW1vdmVFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cblxuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGFyZ2V0LCB0eXBlcywgaGFuZGxlcikge1xuICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgdGhlIHdpbmRvdyBvYmplY3Qgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0RvY3VtZW50Vmlld3xXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvd0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG4gIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyB8fCB3aW5kb3c7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG52YXIgSW5wdXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbnB1dChtYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRUYXJnZXQ7IC8vIHNtYWxsZXIgd3JhcHBlciBhcm91bmQgdGhlIGhhbmRsZXIsIGZvciB0aGUgc2NvcGUgYW5kIHRoZSBlbmFibGVkIHN0YXRlIG9mIHRoZSBtYW5hZ2VyLFxuICAgIC8vIHNvIHdoZW4gZGlzYWJsZWQgdGhlIGlucHV0IGV2ZW50cyBhcmUgY29tcGxldGVseSBieXBhc3NlZC5cblxuICAgIHRoaXMuZG9tSGFuZGxlciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgaWYgKGJvb2xPckZuKG1hbmFnZXIub3B0aW9ucy5lbmFibGUsIFttYW5hZ2VyXSkpIHtcbiAgICAgICAgc2VsZi5oYW5kbGVyKGV2KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pbml0KCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHNob3VsZCBoYW5kbGUgdGhlIGlucHV0RXZlbnQgZGF0YSBhbmQgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgICogQHZpcnR1YWxcbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gSW5wdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcigpIHt9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogYmluZCB0aGUgZXZlbnRzXG4gICAqL1xuXG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KCkge1xuICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICB0aGlzLmV2VGFyZ2V0ICYmIGFkZEV2ZW50TGlzdGVuZXJzKHRoaXMudGFyZ2V0LCB0aGlzLmV2VGFyZ2V0LCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIHRoaXMuZXZXaW4gJiYgYWRkRXZlbnRMaXN0ZW5lcnMoZ2V0V2luZG93Rm9yRWxlbWVudCh0aGlzLmVsZW1lbnQpLCB0aGlzLmV2V2luLCB0aGlzLmRvbUhhbmRsZXIpO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogdW5iaW5kIHRoZSBldmVudHNcbiAgICovXG5cblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ldkVsICYmIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMuZWxlbWVudCwgdGhpcy5ldkVsLCB0aGlzLmRvbUhhbmRsZXIpO1xuICAgIHRoaXMuZXZUYXJnZXQgJiYgcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy50YXJnZXQsIHRoaXMuZXZUYXJnZXQsIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgdGhpcy5ldldpbiAmJiByZW1vdmVFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gIH07XG5cbiAgcmV0dXJuIElucHV0O1xufSgpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBmaW5kIGlmIGEgYXJyYXkgY29udGFpbnMgdGhlIG9iamVjdCB1c2luZyBpbmRleE9mIG9yIGEgc2ltcGxlIHBvbHlGaWxsXG4gKiBAcGFyYW0ge0FycmF5fSBzcmNcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZpbmRCeUtleV1cbiAqIEByZXR1cm4ge0Jvb2xlYW58TnVtYmVyfSBmYWxzZSB3aGVuIG5vdCBmb3VuZCwgb3IgdGhlIGluZGV4XG4gKi9cbmZ1bmN0aW9uIGluQXJyYXkoc3JjLCBmaW5kLCBmaW5kQnlLZXkpIHtcbiAgaWYgKHNyYy5pbmRleE9mICYmICFmaW5kQnlLZXkpIHtcbiAgICByZXR1cm4gc3JjLmluZGV4T2YoZmluZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICBpZiAoZmluZEJ5S2V5ICYmIHNyY1tpXVtmaW5kQnlLZXldID09IGZpbmQgfHwgIWZpbmRCeUtleSAmJiBzcmNbaV0gPT09IGZpbmQpIHtcbiAgICAgICAgLy8gZG8gbm90IHVzZSA9PT0gaGVyZSwgdGVzdCBmYWlsc1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cblxuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxufVxuXG52YXIgUE9JTlRFUl9JTlBVVF9NQVAgPSB7XG4gIHBvaW50ZXJkb3duOiBJTlBVVF9TVEFSVCxcbiAgcG9pbnRlcm1vdmU6IElOUFVUX01PVkUsXG4gIHBvaW50ZXJ1cDogSU5QVVRfRU5ELFxuICBwb2ludGVyY2FuY2VsOiBJTlBVVF9DQU5DRUwsXG4gIHBvaW50ZXJvdXQ6IElOUFVUX0NBTkNFTFxufTsgLy8gaW4gSUUxMCB0aGUgcG9pbnRlciB0eXBlcyBpcyBkZWZpbmVkIGFzIGFuIGVudW1cblxudmFyIElFMTBfUE9JTlRFUl9UWVBFX0VOVU0gPSB7XG4gIDI6IElOUFVUX1RZUEVfVE9VQ0gsXG4gIDM6IElOUFVUX1RZUEVfUEVOLFxuICA0OiBJTlBVVF9UWVBFX01PVVNFLFxuICA1OiBJTlBVVF9UWVBFX0tJTkVDVCAvLyBzZWUgaHR0cHM6Ly90d2l0dGVyLmNvbS9qYWNvYnJvc3NpL3N0YXR1cy80ODA1OTY0Mzg0ODk4OTA4MTZcblxufTtcbnZhciBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ3BvaW50ZXJkb3duJztcbnZhciBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAncG9pbnRlcm1vdmUgcG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwnOyAvLyBJRTEwIGhhcyBwcmVmaXhlZCBzdXBwb3J0LCBhbmQgY2FzZS1zZW5zaXRpdmVcblxuaWYgKHdpbi5NU1BvaW50ZXJFdmVudCAmJiAhd2luLlBvaW50ZXJFdmVudCkge1xuICBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTID0gJ01TUG9pbnRlckRvd24nO1xuICBQT0lOVEVSX1dJTkRPV19FVkVOVFMgPSAnTVNQb2ludGVyTW92ZSBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogUG9pbnRlciBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG5cbnZhciBQb2ludGVyRXZlbnRJbnB1dCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0lucHV0KSB7XG4gIF9pbmhlcml0c0xvb3NlKFBvaW50ZXJFdmVudElucHV0LCBfSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIFBvaW50ZXJFdmVudElucHV0KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBwcm90byA9IFBvaW50ZXJFdmVudElucHV0LnByb3RvdHlwZTtcbiAgICBwcm90by5ldkVsID0gUE9JTlRFUl9FTEVNRU5UX0VWRU5UUztcbiAgICBwcm90by5ldldpbiA9IFBPSU5URVJfV0lORE9XX0VWRU5UUztcbiAgICBfdGhpcyA9IF9JbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMuc3RvcmUgPSBfdGhpcy5tYW5hZ2VyLnNlc3Npb24ucG9pbnRlckV2ZW50cyA9IFtdO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gUG9pbnRlckV2ZW50SW5wdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgIHZhciBzdG9yZSA9IHRoaXMuc3RvcmU7XG4gICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmYWxzZTtcbiAgICB2YXIgZXZlbnRUeXBlTm9ybWFsaXplZCA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdtcycsICcnKTtcbiAgICB2YXIgZXZlbnRUeXBlID0gUE9JTlRFUl9JTlBVVF9NQVBbZXZlbnRUeXBlTm9ybWFsaXplZF07XG4gICAgdmFyIHBvaW50ZXJUeXBlID0gSUUxMF9QT0lOVEVSX1RZUEVfRU5VTVtldi5wb2ludGVyVHlwZV0gfHwgZXYucG9pbnRlclR5cGU7XG4gICAgdmFyIGlzVG91Y2ggPSBwb2ludGVyVHlwZSA9PT0gSU5QVVRfVFlQRV9UT1VDSDsgLy8gZ2V0IGluZGV4IG9mIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcblxuICAgIHZhciBzdG9yZUluZGV4ID0gaW5BcnJheShzdG9yZSwgZXYucG9pbnRlcklkLCAncG9pbnRlcklkJyk7IC8vIHN0YXJ0IGFuZCBtb3VzZSBtdXN0IGJlIGRvd25cblxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiAoZXYuYnV0dG9uID09PSAwIHx8IGlzVG91Y2gpKSB7XG4gICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgc3RvcmUucHVzaChldik7XG4gICAgICAgIHN0b3JlSW5kZXggPSBzdG9yZS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgIHJlbW92ZVBvaW50ZXIgPSB0cnVlO1xuICAgIH0gLy8gaXQgbm90IGZvdW5kLCBzbyB0aGUgcG9pbnRlciBoYXNuJ3QgYmVlbiBkb3duIChzbyBpdCdzIHByb2JhYmx5IGEgaG92ZXIpXG5cblxuICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gdXBkYXRlIHRoZSBldmVudCBpbiB0aGUgc3RvcmVcblxuXG4gICAgc3RvcmVbc3RvcmVJbmRleF0gPSBldjtcbiAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICBwb2ludGVyczogc3RvcmUsXG4gICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICBzcmNFdmVudDogZXZcbiAgICB9KTtcblxuICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XG4gICAgICAvLyByZW1vdmUgZnJvbSB0aGUgc3RvcmVcbiAgICAgIHN0b3JlLnNwbGljZShzdG9yZUluZGV4LCAxKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFBvaW50ZXJFdmVudElucHV0O1xufShJbnB1dCk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGNvbnZlcnQgYXJyYXktbGlrZSBvYmplY3RzIHRvIHJlYWwgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkob2JqKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiB1bmlxdWUgYXJyYXkgd2l0aCBvYmplY3RzIGJhc2VkIG9uIGEga2V5IChsaWtlICdpZCcpIG9yIGp1c3QgYnkgdGhlIGFycmF5J3MgdmFsdWVcbiAqIEBwYXJhbSB7QXJyYXl9IHNyYyBbe2lkOjF9LHtpZDoyfSx7aWQ6MX1dXG4gKiBAcGFyYW0ge1N0cmluZ30gW2tleV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NvcnQ9RmFsc2VdXG4gKiBAcmV0dXJucyB7QXJyYXl9IFt7aWQ6MX0se2lkOjJ9XVxuICovXG5cbmZ1bmN0aW9uIHVuaXF1ZUFycmF5KHNyYywga2V5LCBzb3J0KSB7XG4gIHZhciByZXN1bHRzID0gW107XG4gIHZhciB2YWx1ZXMgPSBbXTtcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgc3JjLmxlbmd0aCkge1xuICAgIHZhciB2YWwgPSBrZXkgPyBzcmNbaV1ba2V5XSA6IHNyY1tpXTtcblxuICAgIGlmIChpbkFycmF5KHZhbHVlcywgdmFsKSA8IDApIHtcbiAgICAgIHJlc3VsdHMucHVzaChzcmNbaV0pO1xuICAgIH1cblxuICAgIHZhbHVlc1tpXSA9IHZhbDtcbiAgICBpKys7XG4gIH1cblxuICBpZiAoc29ydCkge1xuICAgIGlmICgha2V5KSB7XG4gICAgICByZXN1bHRzID0gcmVzdWx0cy5zb3J0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFba2V5XSA+IGJba2V5XTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG52YXIgVE9VQ0hfSU5QVVRfTUFQID0ge1xuICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgdG91Y2htb3ZlOiBJTlBVVF9NT1ZFLFxuICB0b3VjaGVuZDogSU5QVVRfRU5ELFxuICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xudmFyIFRPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogTXVsdGktdXNlciB0b3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuXG52YXIgVG91Y2hJbnB1dCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0lucHV0KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRvdWNoSW5wdXQsIF9JbnB1dCk7XG5cbiAgZnVuY3Rpb24gVG91Y2hJbnB1dCgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBUb3VjaElucHV0LnByb3RvdHlwZS5ldlRhcmdldCA9IFRPVUNIX1RBUkdFVF9FVkVOVFM7XG4gICAgX3RoaXMgPSBfSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnRhcmdldElkcyA9IHt9OyAvLyB0aGlzLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBUb3VjaElucHV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXIoZXYpIHtcbiAgICB2YXIgdHlwZSA9IFRPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcbiAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG5cbiAgICBpZiAoIXRvdWNoZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgIHNyY0V2ZW50OiBldlxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBUb3VjaElucHV0O1xufShJbnB1dCk7XG5cbmZ1bmN0aW9uIGdldFRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgdmFyIGFsbFRvdWNoZXMgPSB0b0FycmF5KGV2LnRvdWNoZXMpO1xuICB2YXIgdGFyZ2V0SWRzID0gdGhpcy50YXJnZXRJZHM7IC8vIHdoZW4gdGhlcmUgaXMgb25seSBvbmUgdG91Y2gsIHRoZSBwcm9jZXNzIGNhbiBiZSBzaW1wbGlmaWVkXG5cbiAgaWYgKHR5cGUgJiAoSU5QVVRfU1RBUlQgfCBJTlBVVF9NT1ZFKSAmJiBhbGxUb3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHRhcmdldElkc1thbGxUb3VjaGVzWzBdLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICByZXR1cm4gW2FsbFRvdWNoZXMsIGFsbFRvdWNoZXNdO1xuICB9XG5cbiAgdmFyIGk7XG4gIHZhciB0YXJnZXRUb3VjaGVzO1xuICB2YXIgY2hhbmdlZFRvdWNoZXMgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcbiAgdmFyIGNoYW5nZWRUYXJnZXRUb3VjaGVzID0gW107XG4gIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldDsgLy8gZ2V0IHRhcmdldCB0b3VjaGVzIGZyb20gdG91Y2hlc1xuXG4gIHRhcmdldFRvdWNoZXMgPSBhbGxUb3VjaGVzLmZpbHRlcihmdW5jdGlvbiAodG91Y2gpIHtcbiAgICByZXR1cm4gaGFzUGFyZW50KHRvdWNoLnRhcmdldCwgdGFyZ2V0KTtcbiAgfSk7IC8vIGNvbGxlY3QgdG91Y2hlc1xuXG4gIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCB0YXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgdGFyZ2V0SWRzW3RhcmdldFRvdWNoZXNbaV0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgaSsrO1xuICAgIH1cbiAgfSAvLyBmaWx0ZXIgY2hhbmdlZCB0b3VjaGVzIHRvIG9ubHkgY29udGFpbiB0b3VjaGVzIHRoYXQgZXhpc3QgaW4gdGhlIGNvbGxlY3RlZCB0YXJnZXQgaWRzXG5cblxuICBpID0gMDtcblxuICB3aGlsZSAoaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgIGlmICh0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgIGNoYW5nZWRUYXJnZXRUb3VjaGVzLnB1c2goY2hhbmdlZFRvdWNoZXNbaV0pO1xuICAgIH0gLy8gY2xlYW51cCByZW1vdmVkIHRvdWNoZXNcblxuXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgZGVsZXRlIHRhcmdldElkc1tjaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyXTtcbiAgICB9XG5cbiAgICBpKys7XG4gIH1cblxuICBpZiAoIWNoYW5nZWRUYXJnZXRUb3VjaGVzLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBbLy8gbWVyZ2UgdGFyZ2V0VG91Y2hlcyB3aXRoIGNoYW5nZWRUYXJnZXRUb3VjaGVzIHNvIGl0IGNvbnRhaW5zIEFMTCB0b3VjaGVzLCBpbmNsdWRpbmcgJ2VuZCcgYW5kICdjYW5jZWwnXG4gIHVuaXF1ZUFycmF5KHRhcmdldFRvdWNoZXMuY29uY2F0KGNoYW5nZWRUYXJnZXRUb3VjaGVzKSwgJ2lkZW50aWZpZXInLCB0cnVlKSwgY2hhbmdlZFRhcmdldFRvdWNoZXNdO1xufVxuXG52YXIgTU9VU0VfSU5QVVRfTUFQID0ge1xuICBtb3VzZWRvd246IElOUFVUX1NUQVJULFxuICBtb3VzZW1vdmU6IElOUFVUX01PVkUsXG4gIG1vdXNldXA6IElOUFVUX0VORFxufTtcbnZhciBNT1VTRV9FTEVNRU5UX0VWRU5UUyA9ICdtb3VzZWRvd24nO1xudmFyIE1PVVNFX1dJTkRPV19FVkVOVFMgPSAnbW91c2Vtb3ZlIG1vdXNldXAnO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogTW91c2UgZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIE1vdXNlSW5wdXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9JbnB1dCkge1xuICBfaW5oZXJpdHNMb29zZShNb3VzZUlucHV0LCBfSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIE1vdXNlSW5wdXQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHByb3RvID0gTW91c2VJbnB1dC5wcm90b3R5cGU7XG4gICAgcHJvdG8uZXZFbCA9IE1PVVNFX0VMRU1FTlRfRVZFTlRTO1xuICAgIHByb3RvLmV2V2luID0gTU9VU0VfV0lORE9XX0VWRU5UUztcbiAgICBfdGhpcyA9IF9JbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMucHJlc3NlZCA9IGZhbHNlOyAvLyBtb3VzZWRvd24gc3RhdGVcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogaGFuZGxlIG1vdXNlIGV2ZW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gTW91c2VJbnB1dC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmhhbmRsZXIgPSBmdW5jdGlvbiBoYW5kbGVyKGV2KSB7XG4gICAgdmFyIGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTsgLy8gb24gc3RhcnQgd2Ugd2FudCB0byBoYXZlIHRoZSBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG5cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgZXYuYnV0dG9uID09PSAwKSB7XG4gICAgICB0aGlzLnByZXNzZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9NT1ZFICYmIGV2LndoaWNoICE9PSAxKSB7XG4gICAgICBldmVudFR5cGUgPSBJTlBVVF9FTkQ7XG4gICAgfSAvLyBtb3VzZSBtdXN0IGJlIGRvd25cblxuXG4gICAgaWYgKCF0aGlzLnByZXNzZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnRUeXBlICYgSU5QVVRfRU5EKSB7XG4gICAgICB0aGlzLnByZXNzZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgZXZlbnRUeXBlLCB7XG4gICAgICBwb2ludGVyczogW2V2XSxcbiAgICAgIGNoYW5nZWRQb2ludGVyczogW2V2XSxcbiAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX01PVVNFLFxuICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIE1vdXNlSW5wdXQ7XG59KElucHV0KTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ29tYmluZWQgdG91Y2ggYW5kIG1vdXNlIGlucHV0XG4gKlxuICogVG91Y2ggaGFzIGEgaGlnaGVyIHByaW9yaXR5IHRoZW4gbW91c2UsIGFuZCB3aGlsZSB0b3VjaGluZyBubyBtb3VzZSBldmVudHMgYXJlIGFsbG93ZWQuXG4gKiBUaGlzIGJlY2F1c2UgdG91Y2ggZGV2aWNlcyBhbHNvIGVtaXQgbW91c2UgZXZlbnRzIHdoaWxlIGRvaW5nIGEgdG91Y2guXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cbnZhciBERURVUF9USU1FT1VUID0gMjUwMDtcbnZhciBERURVUF9ESVNUQU5DRSA9IDI1O1xuXG5mdW5jdGlvbiBzZXRMYXN0VG91Y2goZXZlbnREYXRhKSB7XG4gIHZhciBfZXZlbnREYXRhJGNoYW5nZWRQb2kgPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzLFxuICAgICAgdG91Y2ggPSBfZXZlbnREYXRhJGNoYW5nZWRQb2lbMF07XG5cbiAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMucHJpbWFyeVRvdWNoKSB7XG4gICAgdmFyIGxhc3RUb3VjaCA9IHtcbiAgICAgIHg6IHRvdWNoLmNsaWVudFgsXG4gICAgICB5OiB0b3VjaC5jbGllbnRZXG4gICAgfTtcbiAgICB2YXIgbHRzID0gdGhpcy5sYXN0VG91Y2hlcztcbiAgICB0aGlzLmxhc3RUb3VjaGVzLnB1c2gobGFzdFRvdWNoKTtcblxuICAgIHZhciByZW1vdmVMYXN0VG91Y2ggPSBmdW5jdGlvbiByZW1vdmVMYXN0VG91Y2goKSB7XG4gICAgICB2YXIgaSA9IGx0cy5pbmRleE9mKGxhc3RUb3VjaCk7XG5cbiAgICAgIGlmIChpID4gLTEpIHtcbiAgICAgICAgbHRzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2V0VGltZW91dChyZW1vdmVMYXN0VG91Y2gsIERFRFVQX1RJTUVPVVQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFRvdWNoZXMoZXZlbnRUeXBlLCBldmVudERhdGEpIHtcbiAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgdGhpcy5wcmltYXJ5VG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdLmlkZW50aWZpZXI7XG4gICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgfSBlbHNlIGlmIChldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgIHNldExhc3RUb3VjaC5jYWxsKHRoaXMsIGV2ZW50RGF0YSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTeW50aGV0aWNFdmVudChldmVudERhdGEpIHtcbiAgdmFyIHggPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WDtcbiAgdmFyIHkgPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGFzdFRvdWNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdCA9IHRoaXMubGFzdFRvdWNoZXNbaV07XG4gICAgdmFyIGR4ID0gTWF0aC5hYnMoeCAtIHQueCk7XG4gICAgdmFyIGR5ID0gTWF0aC5hYnMoeSAtIHQueSk7XG5cbiAgICBpZiAoZHggPD0gREVEVVBfRElTVEFOQ0UgJiYgZHkgPD0gREVEVVBfRElTVEFOQ0UpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFRvdWNoTW91c2VJbnB1dCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIHZhciBUb3VjaE1vdXNlSW5wdXQgPVxuICAvKiNfX1BVUkVfXyovXG4gIGZ1bmN0aW9uIChfSW5wdXQpIHtcbiAgICBfaW5oZXJpdHNMb29zZShUb3VjaE1vdXNlSW5wdXQsIF9JbnB1dCk7XG5cbiAgICBmdW5jdGlvbiBUb3VjaE1vdXNlSW5wdXQoX21hbmFnZXIsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXM7XG5cbiAgICAgIF90aGlzID0gX0lucHV0LmNhbGwodGhpcywgX21hbmFnZXIsIGNhbGxiYWNrKSB8fCB0aGlzO1xuXG4gICAgICBfdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24gKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSkge1xuICAgICAgICB2YXIgaXNUb3VjaCA9IGlucHV0RGF0YS5wb2ludGVyVHlwZSA9PT0gSU5QVVRfVFlQRV9UT1VDSDtcbiAgICAgICAgdmFyIGlzTW91c2UgPSBpbnB1dERhdGEucG9pbnRlclR5cGUgPT09IElOUFVUX1RZUEVfTU9VU0U7XG5cbiAgICAgICAgaWYgKGlzTW91c2UgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcyAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gd2hlbiB3ZSdyZSBpbiBhIHRvdWNoIGV2ZW50LCByZWNvcmQgdG91Y2hlcyB0byAgZGUtZHVwZSBzeW50aGV0aWMgbW91c2UgZXZlbnRcblxuXG4gICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgcmVjb3JkVG91Y2hlcy5jYWxsKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQkMShfYXNzZXJ0VGhpc0luaXRpYWxpemVkJDEoX3RoaXMpKSwgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdXNlICYmIGlzU3ludGhldGljRXZlbnQuY2FsbChfYXNzZXJ0VGhpc0luaXRpYWxpemVkJDEoX2Fzc2VydFRoaXNJbml0aWFsaXplZCQxKF90aGlzKSksIGlucHV0RGF0YSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5jYWxsYmFjayhtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpO1xuICAgICAgfTtcblxuICAgICAgX3RoaXMudG91Y2ggPSBuZXcgVG91Y2hJbnB1dChfdGhpcy5tYW5hZ2VyLCBfdGhpcy5oYW5kbGVyKTtcbiAgICAgIF90aGlzLm1vdXNlID0gbmV3IE1vdXNlSW5wdXQoX3RoaXMubWFuYWdlciwgX3RoaXMuaGFuZGxlcik7XG4gICAgICBfdGhpcy5wcmltYXJ5VG91Y2ggPSBudWxsO1xuICAgICAgX3RoaXMubGFzdFRvdWNoZXMgPSBbXTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBoYW5kbGUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0RXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG5cblxuICAgIHZhciBfcHJvdG8gPSBUb3VjaE1vdXNlSW5wdXQucHJvdG90eXBlO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICAgIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMudG91Y2guZGVzdHJveSgpO1xuICAgICAgdGhpcy5tb3VzZS5kZXN0cm95KCk7XG4gICAgfTtcblxuICAgIHJldHVybiBUb3VjaE1vdXNlSW5wdXQ7XG4gIH0oSW5wdXQpO1xuXG4gIHJldHVybiBUb3VjaE1vdXNlSW5wdXQ7XG59KCk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGNyZWF0ZSBuZXcgaW5wdXQgdHlwZSBtYW5hZ2VyXG4gKiBjYWxsZWQgYnkgdGhlIE1hbmFnZXIgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gKiBAcmV0dXJucyB7SW5wdXR9XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlSW5wdXRJbnN0YW5jZShtYW5hZ2VyKSB7XG4gIHZhciBUeXBlOyAvLyBsZXQgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xuXG4gIHZhciBpbnB1dENsYXNzID0gbWFuYWdlci5vcHRpb25zLmlucHV0Q2xhc3M7XG5cbiAgaWYgKGlucHV0Q2xhc3MpIHtcbiAgICBUeXBlID0gaW5wdXRDbGFzcztcbiAgfSBlbHNlIGlmIChTVVBQT1JUX1BPSU5URVJfRVZFTlRTKSB7XG4gICAgVHlwZSA9IFBvaW50ZXJFdmVudElucHV0O1xuICB9IGVsc2UgaWYgKFNVUFBPUlRfT05MWV9UT1VDSCkge1xuICAgIFR5cGUgPSBUb3VjaElucHV0O1xuICB9IGVsc2UgaWYgKCFTVVBQT1JUX1RPVUNIKSB7XG4gICAgVHlwZSA9IE1vdXNlSW5wdXQ7XG4gIH0gZWxzZSB7XG4gICAgVHlwZSA9IFRvdWNoTW91c2VJbnB1dDtcbiAgfVxuXG4gIHJldHVybiBuZXcgVHlwZShtYW5hZ2VyLCBpbnB1dEhhbmRsZXIpO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgZm4gb24gZWFjaCBlbnRyeVxuICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXG4gKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7KnxBcnJheX0gYXJnXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGludm9rZUFycmF5QXJnKGFyZywgZm4sIGNvbnRleHQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgIGVhY2goYXJnLCBjb250ZXh0W2ZuXSwgY29udGV4dCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBTVEFURV9QT1NTSUJMRSA9IDE7XG52YXIgU1RBVEVfQkVHQU4gPSAyO1xudmFyIFNUQVRFX0NIQU5HRUQgPSA0O1xudmFyIFNUQVRFX0VOREVEID0gODtcbnZhciBTVEFURV9SRUNPR05JWkVEID0gU1RBVEVfRU5ERUQ7XG52YXIgU1RBVEVfQ0FOQ0VMTEVEID0gMTY7XG52YXIgU1RBVEVfRkFJTEVEID0gMzI7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIGdldCBhIHVuaXF1ZSBpZFxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlSWRcbiAqL1xudmFyIF91bmlxdWVJZCA9IDE7XG5mdW5jdGlvbiB1bmlxdWVJZCgpIHtcbiAgcmV0dXJuIF91bmlxdWVJZCsrO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgYSByZWNvZ25pemVyIGJ5IG5hbWUgaWYgaXQgaXMgYm91bmQgdG8gYSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSBvdGhlclJlY29nbml6ZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICogQHJldHVybnMge1JlY29nbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XG4gIHZhciBtYW5hZ2VyID0gcmVjb2duaXplci5tYW5hZ2VyO1xuXG4gIGlmIChtYW5hZ2VyKSB7XG4gICAgcmV0dXJuIG1hbmFnZXIuZ2V0KG90aGVyUmVjb2duaXplcik7XG4gIH1cblxuICByZXR1cm4gb3RoZXJSZWNvZ25pemVyO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBnZXQgYSB1c2FibGUgc3RyaW5nLCB1c2VkIGFzIGV2ZW50IHBvc3RmaXhcbiAqIEBwYXJhbSB7Y29uc3RhbnR9IHN0YXRlXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdGF0ZVxuICovXG5cbmZ1bmN0aW9uIHN0YXRlU3RyKHN0YXRlKSB7XG4gIGlmIChzdGF0ZSAmIFNUQVRFX0NBTkNFTExFRCkge1xuICAgIHJldHVybiAnY2FuY2VsJztcbiAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0VOREVEKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQ0hBTkdFRCkge1xuICAgIHJldHVybiAnbW92ZSc7XG4gIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9CRUdBTikge1xuICAgIHJldHVybiAnc3RhcnQnO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBSZWNvZ25pemVyIGZsb3cgZXhwbGFpbmVkOyAqXG4gKiBBbGwgcmVjb2duaXplcnMgaGF2ZSB0aGUgaW5pdGlhbCBzdGF0ZSBvZiBQT1NTSUJMRSB3aGVuIGEgaW5wdXQgc2Vzc2lvbiBzdGFydHMuXG4gKiBUaGUgZGVmaW5pdGlvbiBvZiBhIGlucHV0IHNlc3Npb24gaXMgZnJvbSB0aGUgZmlyc3QgaW5wdXQgdW50aWwgdGhlIGxhc3QgaW5wdXQsIHdpdGggYWxsIGl0J3MgbW92ZW1lbnQgaW4gaXQuICpcbiAqIEV4YW1wbGUgc2Vzc2lvbiBmb3IgbW91c2UtaW5wdXQ6IG1vdXNlZG93biAtPiBtb3VzZW1vdmUgLT4gbW91c2V1cFxuICpcbiAqIE9uIGVhY2ggcmVjb2duaXppbmcgY3ljbGUgKHNlZSBNYW5hZ2VyLnJlY29nbml6ZSkgdGhlIC5yZWNvZ25pemUoKSBtZXRob2QgaXMgZXhlY3V0ZWRcbiAqIHdoaWNoIGRldGVybWluZXMgd2l0aCBzdGF0ZSBpdCBzaG91bGQgYmUuXG4gKlxuICogSWYgdGhlIHJlY29nbml6ZXIgaGFzIHRoZSBzdGF0ZSBGQUlMRUQsIENBTkNFTExFRCBvciBSRUNPR05JWkVEIChlcXVhbHMgRU5ERUQpLCBpdCBpcyByZXNldCB0b1xuICogUE9TU0lCTEUgdG8gZ2l2ZSBpdCBhbm90aGVyIGNoYW5nZSBvbiB0aGUgbmV4dCBjeWNsZS5cbiAqXG4gKiAgICAgICAgICAgICAgIFBvc3NpYmxlXG4gKiAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgKy0tLS0tKy0tLS0tLS0tLS0tLS0tLStcbiAqICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgKy0tLS0tKy0tLS0tKyAgICAgICAgICAgICAgIHxcbiAqICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgIHxcbiAqICAgRmFpbGVkICAgICAgQ2FuY2VsbGVkICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLSstLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgUmVjb2duaXplZCAgICAgICBCZWdhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGFuZ2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRW5kZWQvUmVjb2duaXplZFxuICovXG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJlY29nbml6ZXJcbiAqIEV2ZXJ5IHJlY29nbml6ZXIgbmVlZHMgdG8gZXh0ZW5kIGZyb20gdGhpcyBjbGFzcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqL1xuXG52YXIgUmVjb2duaXplciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7XG4gICAgICBlbmFibGU6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcbiAgICB0aGlzLmlkID0gdW5pcXVlSWQoKTtcbiAgICB0aGlzLm1hbmFnZXIgPSBudWxsOyAvLyBkZWZhdWx0IGlzIGVuYWJsZSB0cnVlXG5cbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfUE9TU0lCTEU7XG4gICAgdGhpcy5zaW11bHRhbmVvdXMgPSB7fTtcbiAgICB0aGlzLnJlcXVpcmVGYWlsID0gW107XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHNldCBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge1JlY29nbml6ZXJ9XG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQob3B0aW9ucykge1xuICAgIGFzc2lnbiQxKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7IC8vIGFsc28gdXBkYXRlIHRoZSB0b3VjaEFjdGlvbiwgaW4gY2FzZSBzb21ldGhpbmcgY2hhbmdlZCBhYm91dCB0aGUgZGlyZWN0aW9ucy9lbmFibGVkIHN0YXRlXG5cbiAgICB0aGlzLm1hbmFnZXIgJiYgdGhpcy5tYW5hZ2VyLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmVjb2duaXplIHNpbXVsdGFuZW91cyB3aXRoIGFuIG90aGVyIHJlY29nbml6ZXIuXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAqL1xuXG5cbiAgX3Byb3RvLnJlY29nbml6ZVdpdGggPSBmdW5jdGlvbiByZWNvZ25pemVXaXRoKG90aGVyUmVjb2duaXplcikge1xuICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBzaW11bHRhbmVvdXMgPSB0aGlzLnNpbXVsdGFuZW91cztcbiAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG5cbiAgICBpZiAoIXNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdKSB7XG4gICAgICBzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSA9IG90aGVyUmVjb2duaXplcjtcbiAgICAgIG90aGVyUmVjb2duaXplci5yZWNvZ25pemVXaXRoKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZHJvcCB0aGUgc2ltdWx0YW5lb3VzIGxpbmsuIGl0IGRvZXNudCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAqL1xuXG5cbiAgX3Byb3RvLmRyb3BSZWNvZ25pemVXaXRoID0gZnVuY3Rpb24gZHJvcFJlY29nbml6ZVdpdGgob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICBkZWxldGUgdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHJlY29nbml6ZXIgY2FuIG9ubHkgcnVuIHdoZW4gYW4gb3RoZXIgaXMgZmFpbGluZ1xuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgKi9cblxuXG4gIF9wcm90by5yZXF1aXJlRmFpbHVyZSA9IGZ1bmN0aW9uIHJlcXVpcmVGYWlsdXJlKG90aGVyUmVjb2duaXplcikge1xuICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgcmVxdWlyZUZhaWwgPSB0aGlzLnJlcXVpcmVGYWlsO1xuICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcblxuICAgIGlmIChpbkFycmF5KHJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpID09PSAtMSkge1xuICAgICAgcmVxdWlyZUZhaWwucHVzaChvdGhlclJlY29nbml6ZXIpO1xuICAgICAgb3RoZXJSZWNvZ25pemVyLnJlcXVpcmVGYWlsdXJlKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZHJvcCB0aGUgcmVxdWlyZUZhaWx1cmUgbGluay4gaXQgZG9lcyBub3QgcmVtb3ZlIHRoZSBsaW5rIG9uIHRoZSBvdGhlciByZWNvZ25pemVyLlxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgKi9cblxuXG4gIF9wcm90by5kcm9wUmVxdWlyZUZhaWx1cmUgPSBmdW5jdGlvbiBkcm9wUmVxdWlyZUZhaWx1cmUob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBvdGhlclJlY29nbml6ZXIgPSBnZXRSZWNvZ25pemVyQnlOYW1lSWZNYW5hZ2VyKG90aGVyUmVjb2duaXplciwgdGhpcyk7XG4gICAgdmFyIGluZGV4ID0gaW5BcnJheSh0aGlzLnJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpO1xuXG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHRoaXMucmVxdWlyZUZhaWwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGhhcyByZXF1aXJlIGZhaWx1cmVzIGJvb2xlYW5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuXG5cbiAgX3Byb3RvLmhhc1JlcXVpcmVGYWlsdXJlcyA9IGZ1bmN0aW9uIGhhc1JlcXVpcmVGYWlsdXJlcygpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1aXJlRmFpbC5sZW5ndGggPiAwO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogaWYgdGhlIHJlY29nbml6ZXIgY2FuIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cblxuXG4gIF9wcm90by5jYW5SZWNvZ25pemVXaXRoID0gZnVuY3Rpb24gY2FuUmVjb2duaXplV2l0aChvdGhlclJlY29nbml6ZXIpIHtcbiAgICByZXR1cm4gISF0aGlzLnNpbXVsdGFuZW91c1tvdGhlclJlY29nbml6ZXIuaWRdO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogWW91IHNob3VsZCB1c2UgYHRyeUVtaXRgIGluc3RlYWQgb2YgYGVtaXRgIGRpcmVjdGx5IHRvIGNoZWNrXG4gICAqIHRoYXQgYWxsIHRoZSBuZWVkZWQgcmVjb2duaXplcnMgaGFzIGZhaWxlZCBiZWZvcmUgZW1pdHRpbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKi9cblxuXG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG4gICAgZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoZXZlbnQsIGlucHV0KTtcbiAgICB9IC8vICdwYW5zdGFydCcgYW5kICdwYW5tb3ZlJ1xuXG5cbiAgICBpZiAoc3RhdGUgPCBTVEFURV9FTkRFRCkge1xuICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgIH1cblxuICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50KTsgLy8gc2ltcGxlICdldmVudE5hbWUnIGV2ZW50c1xuXG4gICAgaWYgKGlucHV0LmFkZGl0aW9uYWxFdmVudCkge1xuICAgICAgLy8gYWRkaXRpb25hbCBldmVudChwYW5sZWZ0LCBwYW5yaWdodCwgcGluY2hpbiwgcGluY2hvdXQuLi4pXG4gICAgICBlbWl0KGlucHV0LmFkZGl0aW9uYWxFdmVudCk7XG4gICAgfSAvLyBwYW5lbmQgYW5kIHBhbmNhbmNlbFxuXG5cbiAgICBpZiAoc3RhdGUgPj0gU1RBVEVfRU5ERUQpIHtcbiAgICAgIGVtaXQoc2VsZi5vcHRpb25zLmV2ZW50ICsgc3RhdGVTdHIoc3RhdGUpKTtcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBDaGVjayB0aGF0IGFsbCB0aGUgcmVxdWlyZSBmYWlsdXJlIHJlY29nbml6ZXJzIGhhcyBmYWlsZWQsXG4gICAqIGlmIHRydWUsIGl0IGVtaXRzIGEgZ2VzdHVyZSBldmVudCxcbiAgICogb3RoZXJ3aXNlLCBzZXR1cCB0aGUgc3RhdGUgdG8gRkFJTEVELlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICovXG5cblxuICBfcHJvdG8udHJ5RW1pdCA9IGZ1bmN0aW9uIHRyeUVtaXQoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5jYW5FbWl0KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoaW5wdXQpO1xuICAgIH0gLy8gaXQncyBmYWlsaW5nIGFueXdheVxuXG5cbiAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogY2FuIHdlIGVtaXQ/XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cblxuXG4gIF9wcm90by5jYW5FbWl0ID0gZnVuY3Rpb24gY2FuRW1pdCgpIHtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoKSB7XG4gICAgICBpZiAoISh0aGlzLnJlcXVpcmVGYWlsW2ldLnN0YXRlICYgKFNUQVRFX0ZBSUxFRCB8IFNUQVRFX1BPU1NJQkxFKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiB1cGRhdGUgdGhlIHJlY29nbml6ZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgKi9cblxuXG4gIF9wcm90by5yZWNvZ25pemUgPSBmdW5jdGlvbiByZWNvZ25pemUoaW5wdXREYXRhKSB7XG4gICAgLy8gbWFrZSBhIG5ldyBjb3B5IG9mIHRoZSBpbnB1dERhdGFcbiAgICAvLyBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBpbnB1dERhdGEgd2l0aG91dCBtZXNzaW5nIHVwIHRoZSBvdGhlciByZWNvZ25pemVyc1xuICAgIHZhciBpbnB1dERhdGFDbG9uZSA9IGFzc2lnbiQxKHt9LCBpbnB1dERhdGEpOyAvLyBpcyBpcyBlbmFibGVkIGFuZCBhbGxvdyByZWNvZ25pemluZz9cblxuICAgIGlmICghYm9vbE9yRm4odGhpcy5vcHRpb25zLmVuYWJsZSwgW3RoaXMsIGlucHV0RGF0YUNsb25lXSkpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyByZXNldCB3aGVuIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZFxuXG5cbiAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9SRUNPR05JWkVEIHwgU1RBVEVfQ0FOQ0VMTEVEIHwgU1RBVEVfRkFJTEVEKSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSB0aGlzLnByb2Nlc3MoaW5wdXREYXRhQ2xvbmUpOyAvLyB0aGUgcmVjb2duaXplciBoYXMgcmVjb2duaXplZCBhIGdlc3R1cmVcbiAgICAvLyBzbyB0cmlnZ2VyIGFuIGV2ZW50XG5cbiAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9CRUdBTiB8IFNUQVRFX0NIQU5HRUQgfCBTVEFURV9FTkRFRCB8IFNUQVRFX0NBTkNFTExFRCkpIHtcbiAgICAgIHRoaXMudHJ5RW1pdChpbnB1dERhdGFDbG9uZSk7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmV0dXJuIHRoZSBzdGF0ZSBvZiB0aGUgcmVjb2duaXplclxuICAgKiB0aGUgYWN0dWFsIHJlY29nbml6aW5nIGhhcHBlbnMgaW4gdGhpcyBtZXRob2RcbiAgICogQHZpcnR1YWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgKiBAcmV0dXJucyB7Y29uc3RhbnR9IFNUQVRFXG4gICAqL1xuXG4gIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cblxuXG4gIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcyhpbnB1dERhdGEpIHt9O1xuICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiByZXR1cm4gdGhlIHByZWZlcnJlZCB0b3VjaC1hY3Rpb25cbiAgICogQHZpcnR1YWxcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKi9cblxuXG4gIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge307XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBjYWxsZWQgd2hlbiB0aGUgZ2VzdHVyZSBpc24ndCBhbGxvd2VkIHRvIHJlY29nbml6ZVxuICAgKiBsaWtlIHdoZW4gYW5vdGhlciBpcyBiZWluZyByZWNvZ25pemVkIG9yIGl0IGlzIGRpc2FibGVkXG4gICAqIEB2aXJ0dWFsXG4gICAqL1xuXG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7fTtcblxuICByZXR1cm4gUmVjb2duaXplcjtcbn0oKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQSB0YXAgaXMgcmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvaW5nIGEgc21hbGwgdGFwL2NsaWNrLiBNdWx0aXBsZSB0YXBzIGFyZSByZWNvZ25pemVkIGlmIHRoZXkgb2NjdXJcbiAqIGJldHdlZW4gdGhlIGdpdmVuIGludGVydmFsIGFuZCBwb3NpdGlvbi4gVGhlIGRlbGF5IG9wdGlvbiBjYW4gYmUgdXNlZCB0byByZWNvZ25pemUgbXVsdGktdGFwcyB3aXRob3V0IGZpcmluZ1xuICogYSBzaW5nbGUgdGFwLlxuICpcbiAqIFRoZSBldmVudERhdGEgZnJvbSB0aGUgZW1pdHRlZCBldmVudCBjb250YWlucyB0aGUgcHJvcGVydHkgYHRhcENvdW50YCwgd2hpY2ggY29udGFpbnMgdGhlIGFtb3VudCBvZlxuICogbXVsdGktdGFwcyBiZWluZyByZWNvZ25pemVkLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cblxudmFyIFRhcFJlY29nbml6ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9SZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRhcFJlY29nbml6ZXIsIF9SZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBUYXBSZWNvZ25pemVyKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVjb2duaXplci5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgIGV2ZW50OiAndGFwJyxcbiAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgdGFwczogMSxcbiAgICAgIGludGVydmFsOiAzMDAsXG4gICAgICAvLyBtYXggdGltZSBiZXR3ZWVuIHRoZSBtdWx0aS10YXAgdGFwc1xuICAgICAgdGltZTogMjUwLFxuICAgICAgLy8gbWF4IHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgZG93biAobGlrZSBmaW5nZXIgb24gdGhlIHNjcmVlbilcbiAgICAgIHRocmVzaG9sZDogOSxcbiAgICAgIC8vIGEgbWluaW1hbCBtb3ZlbWVudCBpcyBvaywgYnV0IGtlZXAgaXQgbG93XG4gICAgICBwb3NUaHJlc2hvbGQ6IDEwXG4gICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7IC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcbiAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcblxuICAgIF90aGlzLnBUaW1lID0gZmFsc2U7XG4gICAgX3RoaXMucENlbnRlciA9IGZhbHNlO1xuICAgIF90aGlzLl90aW1lciA9IG51bGw7XG4gICAgX3RoaXMuX2lucHV0ID0gbnVsbDtcbiAgICBfdGhpcy5jb3VudCA9IDA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRhcFJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTl07XG4gIH07XG5cbiAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKGlucHV0KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgdmFyIHZhbGlkVG91Y2hUaW1lID0gaW5wdXQuZGVsdGFUaW1lIDwgb3B0aW9ucy50aW1lO1xuICAgIHRoaXMucmVzZXQoKTtcblxuICAgIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCAmJiB0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgIH0gLy8gd2Ugb25seSBhbGxvdyBsaXR0bGUgbW92ZW1lbnRcbiAgICAvLyBhbmQgd2UndmUgcmVhY2hlZCBhbiBlbmQgZXZlbnQsIHNvIGEgdGFwIGlzIHBvc3NpYmxlXG5cblxuICAgIGlmICh2YWxpZE1vdmVtZW50ICYmIHZhbGlkVG91Y2hUaW1lICYmIHZhbGlkUG9pbnRlcnMpIHtcbiAgICAgIGlmIChpbnB1dC5ldmVudFR5cGUgIT09IElOUFVUX0VORCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsaWRJbnRlcnZhbCA9IHRoaXMucFRpbWUgPyBpbnB1dC50aW1lU3RhbXAgLSB0aGlzLnBUaW1lIDwgb3B0aW9ucy5pbnRlcnZhbCA6IHRydWU7XG4gICAgICB2YXIgdmFsaWRNdWx0aVRhcCA9ICF0aGlzLnBDZW50ZXIgfHwgZ2V0RGlzdGFuY2UodGhpcy5wQ2VudGVyLCBpbnB1dC5jZW50ZXIpIDwgb3B0aW9ucy5wb3NUaHJlc2hvbGQ7XG4gICAgICB0aGlzLnBUaW1lID0gaW5wdXQudGltZVN0YW1wO1xuICAgICAgdGhpcy5wQ2VudGVyID0gaW5wdXQuY2VudGVyO1xuXG4gICAgICBpZiAoIXZhbGlkTXVsdGlUYXAgfHwgIXZhbGlkSW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvdW50ICs9IDE7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7IC8vIGlmIHRhcCBjb3VudCBtYXRjaGVzIHdlIGhhdmUgcmVjb2duaXplZCBpdCxcbiAgICAgIC8vIGVsc2UgaXQgaGFzIGJlZ2FuIHJlY29nbml6aW5nLi4uXG5cbiAgICAgIHZhciB0YXBDb3VudCA9IHRoaXMuY291bnQgJSBvcHRpb25zLnRhcHM7XG5cbiAgICAgIGlmICh0YXBDb3VudCA9PT0gMCkge1xuICAgICAgICAvLyBubyBmYWlsaW5nIHJlcXVpcmVtZW50cywgaW1tZWRpYXRlbHkgdHJpZ2dlciB0aGUgdGFwIGV2ZW50XG4gICAgICAgIC8vIG9yIHdhaXQgYXMgbG9uZyBhcyB0aGUgbXVsdGl0YXAgaW50ZXJ2YWwgdG8gdHJpZ2dlclxuICAgICAgICBpZiAoIXRoaXMuaGFzUmVxdWlyZUZhaWx1cmVzKCkpIHtcbiAgICAgICAgICByZXR1cm4gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMyLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcblxuICAgICAgICAgICAgX3RoaXMyLnRyeUVtaXQoKTtcbiAgICAgICAgICB9LCBvcHRpb25zLmludGVydmFsKTtcbiAgICAgICAgICByZXR1cm4gU1RBVEVfQkVHQU47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICB9O1xuXG4gIF9wcm90by5mYWlsVGltZW91dCA9IGZ1bmN0aW9uIGZhaWxUaW1lb3V0KCkge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMy5zdGF0ZSA9IFNUQVRFX0ZBSUxFRDtcbiAgICB9LCB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwpO1xuICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgfTtcblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgIHRoaXMuX2lucHV0LnRhcENvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgIHRoaXMubWFuYWdlci5lbWl0KHRoaXMub3B0aW9ucy5ldmVudCwgdGhpcy5faW5wdXQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGFwUmVjb2duaXplcjtcbn0oUmVjb2duaXplcik7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFRoaXMgcmVjb2duaXplciBpcyBqdXN0IHVzZWQgYXMgYSBiYXNlIGZvciB0aGUgc2ltcGxlIGF0dHJpYnV0ZSByZWNvZ25pemVycy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5cbnZhciBBdHRyUmVjb2duaXplciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlY29nbml6ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoQXR0clJlY29nbml6ZXIsIF9SZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBBdHRyUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBfUmVjb2duaXplci5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFVzZWQgdG8gY2hlY2sgaWYgaXQgdGhlIHJlY29nbml6ZXIgcmVjZWl2ZXMgdmFsaWQgaW5wdXQsIGxpa2UgaW5wdXQuZGlzdGFuY2UgPiAxMC5cbiAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gcmVjb2duaXplZFxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBBdHRyUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmF0dHJUZXN0ID0gZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICB2YXIgb3B0aW9uUG9pbnRlcnMgPSB0aGlzLm9wdGlvbnMucG9pbnRlcnM7XG4gICAgcmV0dXJuIG9wdGlvblBvaW50ZXJzID09PSAwIHx8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9uUG9pbnRlcnM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBQcm9jZXNzIHRoZSBpbnB1dCBhbmQgcmV0dXJuIHRoZSBzdGF0ZSBmb3IgdGhlIHJlY29nbml6ZXJcbiAgICogQG1lbWJlcm9mIEF0dHJSZWNvZ25pemVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKiBAcmV0dXJucyB7Kn0gU3RhdGVcbiAgICovXG5cblxuICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MoaW5wdXQpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIHZhciBldmVudFR5cGUgPSBpbnB1dC5ldmVudFR5cGU7XG4gICAgdmFyIGlzUmVjb2duaXplZCA9IHN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCk7XG4gICAgdmFyIGlzVmFsaWQgPSB0aGlzLmF0dHJUZXN0KGlucHV0KTsgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxuXG4gICAgaWYgKGlzUmVjb2duaXplZCAmJiAoZXZlbnRUeXBlICYgSU5QVVRfQ0FOQ0VMIHx8ICFpc1ZhbGlkKSkge1xuICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfQ0FOQ0VMTEVEO1xuICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcbiAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlIHwgU1RBVEVfRU5ERUQ7XG4gICAgICB9IGVsc2UgaWYgKCEoc3RhdGUgJiBTVEFURV9CRUdBTikpIHtcbiAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DSEFOR0VEO1xuICAgIH1cblxuICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gIH07XG5cbiAgcmV0dXJuIEF0dHJSZWNvZ25pemVyO1xufShSZWNvZ25pemVyKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogZGlyZWN0aW9uIGNvbnMgdG8gc3RyaW5nXG4gKiBAcGFyYW0ge2NvbnN0YW50fSBkaXJlY3Rpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gZGlyZWN0aW9uU3RyKGRpcmVjdGlvbikge1xuICBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fRE9XTikge1xuICAgIHJldHVybiAnZG93bic7XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBESVJFQ1RJT05fVVApIHtcbiAgICByZXR1cm4gJ3VwJztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9MRUZUKSB7XG4gICAgcmV0dXJuICdsZWZ0JztcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9SSUdIVCkge1xuICAgIHJldHVybiAncmlnaHQnO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBQYW5cbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGFuZCBtb3ZlZCBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cblxudmFyIFBhblJlY29nbml6ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9BdHRyUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShQYW5SZWNvZ25pemVyLCBfQXR0clJlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIFBhblJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9BdHRyUmVjb2duaXplci5jYWxsKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgIGV2ZW50OiAncGFuJyxcbiAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICBwb2ludGVyczogMSxcbiAgICAgIGRpcmVjdGlvbjogRElSRUNUSU9OX0FMTFxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICAgIF90aGlzLnBYID0gbnVsbDtcbiAgICBfdGhpcy5wWSA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBhblJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICAgIHZhciBhY3Rpb25zID0gW107XG5cbiAgICBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1kpO1xuICAgIH1cblxuICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgIGFjdGlvbnMucHVzaChUT1VDSF9BQ1RJT05fUEFOX1gpO1xuICAgIH1cblxuICAgIHJldHVybiBhY3Rpb25zO1xuICB9O1xuXG4gIF9wcm90by5kaXJlY3Rpb25UZXN0ID0gZnVuY3Rpb24gZGlyZWN0aW9uVGVzdChpbnB1dCkge1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBoYXNNb3ZlZCA9IHRydWU7XG4gICAgdmFyIGRpc3RhbmNlID0gaW5wdXQuZGlzdGFuY2U7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcbiAgICB2YXIgeCA9IGlucHV0LmRlbHRhWDtcbiAgICB2YXIgeSA9IGlucHV0LmRlbHRhWTsgLy8gbG9jayB0byBheGlzP1xuXG4gICAgaWYgKCEoZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb24pKSB7XG4gICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICBkaXJlY3Rpb24gPSB4ID09PSAwID8gRElSRUNUSU9OX05PTkUgOiB4IDwgMCA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICBoYXNNb3ZlZCA9IHggIT09IHRoaXMucFg7XG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFYKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IHkgPT09IDAgPyBESVJFQ1RJT05fTk9ORSA6IHkgPCAwID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgIGhhc01vdmVkID0geSAhPT0gdGhpcy5wWTtcbiAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICByZXR1cm4gaGFzTW92ZWQgJiYgZGlzdGFuY2UgPiBvcHRpb25zLnRocmVzaG9sZCAmJiBkaXJlY3Rpb24gJiBvcHRpb25zLmRpcmVjdGlvbjtcbiAgfTtcblxuICBfcHJvdG8uYXR0clRlc3QgPSBmdW5jdGlvbiBhdHRyVGVzdChpbnB1dCkge1xuICAgIHJldHVybiBBdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgKCAvLyByZXBsYWNlIHdpdGggYSBzdXBlciBjYWxsXG4gICAgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOIHx8ICEodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKSAmJiB0aGlzLmRpcmVjdGlvblRlc3QoaW5wdXQpKTtcbiAgfTtcblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICB0aGlzLnBYID0gaW5wdXQuZGVsdGFYO1xuICAgIHRoaXMucFkgPSBpbnB1dC5kZWx0YVk7XG4gICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xuXG4gICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgaW5wdXQuYWRkaXRpb25hbEV2ZW50ID0gdGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIF9BdHRyUmVjb2duaXplci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgfTtcblxuICByZXR1cm4gUGFuUmVjb2duaXplcjtcbn0oQXR0clJlY29nbml6ZXIpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBTd2lwZVxuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIG1vdmluZyBmYXN0ICh2ZWxvY2l0eSksIHdpdGggZW5vdWdoIGRpc3RhbmNlIGluIHRoZSBhbGxvd2VkIGRpcmVjdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuXG52YXIgU3dpcGVSZWNvZ25pemVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQXR0clJlY29nbml6ZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3dpcGVSZWNvZ25pemVyLCBfQXR0clJlY29nbml6ZXIpO1xuXG4gIGZ1bmN0aW9uIFN3aXBlUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBldmVudDogJ3N3aXBlJyxcbiAgICAgIHRocmVzaG9sZDogMTAsXG4gICAgICB2ZWxvY2l0eTogMC4zLFxuICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTCB8IERJUkVDVElPTl9WRVJUSUNBTCxcbiAgICAgIHBvaW50ZXJzOiAxXG4gICAgfSwgb3B0aW9ucykpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3dpcGVSZWNvZ25pemVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0VG91Y2hBY3Rpb24gPSBmdW5jdGlvbiBnZXRUb3VjaEFjdGlvbigpIHtcbiAgICByZXR1cm4gUGFuUmVjb2duaXplci5wcm90b3R5cGUuZ2V0VG91Y2hBY3Rpb24uY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uYXR0clRlc3QgPSBmdW5jdGlvbiBhdHRyVGVzdChpbnB1dCkge1xuICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICAgIHZhciB2ZWxvY2l0eTtcblxuICAgIGlmIChkaXJlY3Rpb24gJiAoRElSRUNUSU9OX0hPUklaT05UQUwgfCBESVJFQ1RJT05fVkVSVElDQUwpKSB7XG4gICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eTtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9IT1JJWk9OVEFMKSB7XG4gICAgICB2ZWxvY2l0eSA9IGlucHV0Lm92ZXJhbGxWZWxvY2l0eVg7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WTtcbiAgICB9XG5cbiAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiBkaXJlY3Rpb24gJiBpbnB1dC5vZmZzZXREaXJlY3Rpb24gJiYgaW5wdXQuZGlzdGFuY2UgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkICYmIGlucHV0Lm1heFBvaW50ZXJzID09PSB0aGlzLm9wdGlvbnMucG9pbnRlcnMgJiYgYWJzJDEodmVsb2NpdHkpID4gdGhpcy5vcHRpb25zLnZlbG9jaXR5ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORDtcbiAgfTtcblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gZGlyZWN0aW9uU3RyKGlucHV0Lm9mZnNldERpcmVjdGlvbik7XG5cbiAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQgKyBkaXJlY3Rpb24sIGlucHV0KTtcbiAgICB9XG5cbiAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIGlucHV0KTtcbiAgfTtcblxuICByZXR1cm4gU3dpcGVSZWNvZ25pemVyO1xufShBdHRyUmVjb2duaXplcik7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFBpbmNoXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cblxudmFyIFBpbmNoUmVjb2duaXplciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0F0dHJSZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBpbmNoUmVjb2duaXplciwgX0F0dHJSZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBQaW5jaFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgZXZlbnQ6ICdwaW5jaCcsXG4gICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICBwb2ludGVyczogMlxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBpbmNoUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gIH07XG5cbiAgX3Byb3RvLmF0dHJUZXN0ID0gZnVuY3Rpb24gYXR0clRlc3QoaW5wdXQpIHtcbiAgICByZXR1cm4gX0F0dHJSZWNvZ25pemVyLnByb3RvdHlwZS5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJiAoTWF0aC5hYnMoaW5wdXQuc2NhbGUgLSAxKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgfTtcblxuICBfcHJvdG8uZW1pdCA9IGZ1bmN0aW9uIGVtaXQoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcbiAgICAgIHZhciBpbk91dCA9IGlucHV0LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JztcbiAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGluT3V0O1xuICAgIH1cblxuICAgIF9BdHRyUmVjb2duaXplci5wcm90b3R5cGUuZW1pdC5jYWxsKHRoaXMsIGlucHV0KTtcbiAgfTtcblxuICByZXR1cm4gUGluY2hSZWNvZ25pemVyO1xufShBdHRyUmVjb2duaXplcik7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIFJvdGF0ZVxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuXG52YXIgUm90YXRlUmVjb2duaXplciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0F0dHJSZWNvZ25pemVyKSB7XG4gIF9pbmhlcml0c0xvb3NlKFJvdGF0ZVJlY29nbml6ZXIsIF9BdHRyUmVjb2duaXplcik7XG5cbiAgZnVuY3Rpb24gUm90YXRlUmVjb2duaXplcihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBfQXR0clJlY29nbml6ZXIuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICBldmVudDogJ3JvdGF0ZScsXG4gICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICBwb2ludGVyczogMlxuICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJvdGF0ZVJlY29nbml6ZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRUb3VjaEFjdGlvbiA9IGZ1bmN0aW9uIGdldFRvdWNoQWN0aW9uKCkge1xuICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX05PTkVdO1xuICB9O1xuXG4gIF9wcm90by5hdHRyVGVzdCA9IGZ1bmN0aW9uIGF0dHJUZXN0KGlucHV0KSB7XG4gICAgcmV0dXJuIF9BdHRyUmVjb2duaXplci5wcm90b3R5cGUuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiYgKE1hdGguYWJzKGlucHV0LnJvdGF0aW9uKSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgfHwgdGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOKTtcbiAgfTtcblxuICByZXR1cm4gUm90YXRlUmVjb2duaXplcjtcbn0oQXR0clJlY29nbml6ZXIpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBQcmVzc1xuICogUmVjb2duaXplZCB3aGVuIHRoZSBwb2ludGVyIGlzIGRvd24gZm9yIHggbXMgd2l0aG91dCBhbnkgbW92ZW1lbnQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFJlY29nbml6ZXJcbiAqL1xuXG52YXIgUHJlc3NSZWNvZ25pemVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUmVjb2duaXplcikge1xuICBfaW5oZXJpdHNMb29zZShQcmVzc1JlY29nbml6ZXIsIF9SZWNvZ25pemVyKTtcblxuICBmdW5jdGlvbiBQcmVzc1JlY29nbml6ZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBfdGhpcyA9IF9SZWNvZ25pemVyLmNhbGwodGhpcywgX2V4dGVuZHMoe1xuICAgICAgZXZlbnQ6ICdwcmVzcycsXG4gICAgICBwb2ludGVyczogMSxcbiAgICAgIHRpbWU6IDI1MSxcbiAgICAgIC8vIG1pbmltYWwgdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBwcmVzc2VkXG4gICAgICB0aHJlc2hvbGQ6IDlcbiAgICB9LCBvcHRpb25zKSkgfHwgdGhpcztcbiAgICBfdGhpcy5fdGltZXIgPSBudWxsO1xuICAgIF90aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFByZXNzUmVjb2duaXplci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFRvdWNoQWN0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fQVVUT107XG4gIH07XG5cbiAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzKGlucHV0KSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICB2YXIgdmFsaWRNb3ZlbWVudCA9IGlucHV0LmRpc3RhbmNlIDwgb3B0aW9ucy50aHJlc2hvbGQ7XG4gICAgdmFyIHZhbGlkVGltZSA9IGlucHV0LmRlbHRhVGltZSA+IG9wdGlvbnMudGltZTtcbiAgICB0aGlzLl9pbnB1dCA9IGlucHV0OyAvLyB3ZSBvbmx5IGFsbG93IGxpdHRsZSBtb3ZlbWVudFxuICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcblxuICAgIGlmICghdmFsaWRNb3ZlbWVudCB8fCAhdmFsaWRQb2ludGVycyB8fCBpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9TVEFSVCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcblxuICAgICAgICBfdGhpczIudHJ5RW1pdCgpO1xuICAgICAgfSwgb3B0aW9ucy50aW1lKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgcmV0dXJuIFNUQVRFX1JFQ09HTklaRUQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZXIpO1xuICB9O1xuXG4gIF9wcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChpbnB1dCkge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlucHV0ICYmIGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX0VORCkge1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgXCJ1cFwiLCBpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50LCB0aGlzLl9pbnB1dCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBQcmVzc1JlY29nbml6ZXI7XG59KFJlY29nbml6ZXIpO1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzZXQgaWYgRE9NIGV2ZW50cyBhcmUgYmVpbmcgdHJpZ2dlcmVkLlxuICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRvbUV2ZW50czogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIFRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5L2ZhbGxiYWNrLlxuICAgKiBXaGVuIHNldCB0byBgY29tcHV0ZWAgaXQgd2lsbCBtYWdpY2FsbHkgc2V0IHRoZSBjb3JyZWN0IHZhbHVlIGJhc2VkIG9uIHRoZSBhZGRlZCByZWNvZ25pemVycy5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICogQGRlZmF1bHQgY29tcHV0ZVxuICAgKi9cbiAgdG91Y2hBY3Rpb246IFRPVUNIX0FDVElPTl9DT01QVVRFLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgZW5hYmxlOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXG4gICAqIENoYW5nZSB0aGUgcGFyZW50IGlucHV0IHRhcmdldCBlbGVtZW50LlxuICAgKiBJZiBOdWxsLCB0aGVuIGl0IGlzIGJlaW5nIHNldCB0aGUgdG8gbWFpbiBlbGVtZW50LlxuICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKi9cbiAgaW5wdXRUYXJnZXQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIGZvcmNlIGFuIGlucHV0IGNsYXNzXG4gICAqIEB0eXBlIHtOdWxsfEZ1bmN0aW9ufVxuICAgKiBAZGVmYXVsdCBudWxsXG4gICAqL1xuICBpbnB1dENsYXNzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxuICAgKiBBZGQgdGhlbSB0byB0aGlzIG1ldGhvZCBhbmQgdGhleSB3aWxsIGJlIHNldCB3aGVuIGNyZWF0aW5nIGEgbmV3IE1hbmFnZXIuXG4gICAqIEBuYW1lc3BhY2VcbiAgICovXG4gIGNzc1Byb3BzOiB7XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBEaXNhYmxlcyB0ZXh0IHNlbGVjdGlvbiB0byBpbXByb3ZlIHRoZSBkcmFnZ2luZyBnZXN0dXJlLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgKi9cbiAgICB1c2VyU2VsZWN0OiBcIm5vbmVcIixcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogRGlzYWJsZSB0aGUgV2luZG93cyBQaG9uZSBncmlwcGVycyB3aGVuIHByZXNzaW5nIGFuIGVsZW1lbnQuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgKi9cbiAgICB0b3VjaFNlbGVjdDogXCJub25lXCIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIERpc2FibGVzIHRoZSBkZWZhdWx0IGNhbGxvdXQgc2hvd24gd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQuXG4gICAgICogT24gaU9TLCB3aGVuIHlvdSB0b3VjaCBhbmQgaG9sZCBhIHRvdWNoIHRhcmdldCBzdWNoIGFzIGEgbGluaywgU2FmYXJpIGRpc3BsYXlzXG4gICAgICogYSBjYWxsb3V0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxpbmsuIFRoaXMgcHJvcGVydHkgYWxsb3dzIHlvdSB0byBkaXNhYmxlIHRoYXQgY2FsbG91dC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAqL1xuICAgIHRvdWNoQ2FsbG91dDogXCJub25lXCIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIHpvb21pbmcgaXMgZW5hYmxlZC4gVXNlZCBieSBJRTEwPlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICovXG4gICAgY29udGVudFpvb21pbmc6IFwibm9uZVwiLFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgKi9cbiAgICB1c2VyRHJhZzogXCJub25lXCIsXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIE92ZXJyaWRlcyB0aGUgaGlnaGxpZ2h0IGNvbG9yIHNob3duIHdoZW4gdGhlIHVzZXIgdGFwcyBhIGxpbmsgb3IgYSBKYXZhU2NyaXB0XG4gICAgICogY2xpY2thYmxlIGVsZW1lbnQgaW4gaU9TLiBUaGlzIHByb3BlcnR5IG9iZXlzIHRoZSBhbHBoYSB2YWx1ZSwgaWYgc3BlY2lmaWVkLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgJ3JnYmEoMCwwLDAsMCknXG4gICAgICovXG4gICAgdGFwSGlnaGxpZ2h0Q29sb3I6IFwicmdiYSgwLDAsMCwwKVwiXG4gIH1cbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKiBEZWZhdWx0IHJlY29nbml6ZXIgc2V0dXAgd2hlbiBjYWxsaW5nIGBIYW1tZXIoKWBcbiAqIFdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlciB0aGVzZSB3aWxsIGJlIHNraXBwZWQuXG4gKiBUaGlzIGlzIHNlcGFyYXRlZCB3aXRoIG90aGVyIGRlZmF1bHRzIGJlY2F1c2Ugb2YgdHJlZS1zaGFraW5nLlxuICogQHR5cGUge0FycmF5fVxuICovXG5cbnZhciBwcmVzZXQgPSBbW1JvdGF0ZVJlY29nbml6ZXIsIHtcbiAgZW5hYmxlOiBmYWxzZVxufV0sIFtQaW5jaFJlY29nbml6ZXIsIHtcbiAgZW5hYmxlOiBmYWxzZVxufSwgWydyb3RhdGUnXV0sIFtTd2lwZVJlY29nbml6ZXIsIHtcbiAgZGlyZWN0aW9uOiBESVJFQ1RJT05fSE9SSVpPTlRBTFxufV0sIFtQYW5SZWNvZ25pemVyLCB7XG4gIGRpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUxcbn0sIFsnc3dpcGUnXV0sIFtUYXBSZWNvZ25pemVyXSwgW1RhcFJlY29nbml6ZXIsIHtcbiAgZXZlbnQ6ICdkb3VibGV0YXAnLFxuICB0YXBzOiAyXG59LCBbJ3RhcCddXSwgW1ByZXNzUmVjb2duaXplcl1dO1xuXG52YXIgU1RPUCA9IDE7XG52YXIgRk9SQ0VEX1NUT1AgPSAyO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogYWRkL3JlbW92ZSB0aGUgY3NzIHByb3BlcnRpZXMgYXMgZGVmaW5lZCBpbiBtYW5hZ2VyLm9wdGlvbnMuY3NzUHJvcHNcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtCb29sZWFufSBhZGRcbiAqL1xuXG5mdW5jdGlvbiB0b2dnbGVDc3NQcm9wcyhtYW5hZ2VyLCBhZGQpIHtcbiAgdmFyIGVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG5cbiAgaWYgKCFlbGVtZW50LnN0eWxlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHByb3A7XG4gIGVhY2gobWFuYWdlci5vcHRpb25zLmNzc1Byb3BzLCBmdW5jdGlvbiAodmFsdWUsIG5hbWUpIHtcbiAgICBwcm9wID0gcHJlZml4ZWQoZWxlbWVudC5zdHlsZSwgbmFtZSk7XG5cbiAgICBpZiAoYWRkKSB7XG4gICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdID0gZWxlbWVudC5zdHlsZVtwcm9wXTtcbiAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IG1hbmFnZXIub2xkQ3NzUHJvcHNbcHJvcF0gfHwgXCJcIjtcbiAgICB9XG4gIH0pO1xuXG4gIGlmICghYWRkKSB7XG4gICAgbWFuYWdlci5vbGRDc3NQcm9wcyA9IHt9O1xuICB9XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKiB0cmlnZ2VyIGRvbSBldmVudFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICovXG5cblxuZnVuY3Rpb24gdHJpZ2dlckRvbUV2ZW50KGV2ZW50LCBkYXRhKSB7XG4gIHZhciBnZXN0dXJlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO1xuICBnZXN0dXJlRXZlbnQuaW5pdEV2ZW50KGV2ZW50LCB0cnVlLCB0cnVlKTtcbiAgZ2VzdHVyZUV2ZW50Lmdlc3R1cmUgPSBkYXRhO1xuICBkYXRhLnRhcmdldC5kaXNwYXRjaEV2ZW50KGdlc3R1cmVFdmVudCk7XG59XG4vKipcbiogQHByaXZhdGVcbiAqIE1hbmFnZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxudmFyIE1hbmFnZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduJDEoe30sIGRlZmF1bHRzLCBvcHRpb25zIHx8IHt9KTtcbiAgICB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgPSB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgfHwgZWxlbWVudDtcbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgdGhpcy5yZWNvZ25pemVycyA9IFtdO1xuICAgIHRoaXMub2xkQ3NzUHJvcHMgPSB7fTtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuaW5wdXQgPSBjcmVhdGVJbnB1dEluc3RhbmNlKHRoaXMpO1xuICAgIHRoaXMudG91Y2hBY3Rpb24gPSBuZXcgVG91Y2hBY3Rpb24odGhpcywgdGhpcy5vcHRpb25zLnRvdWNoQWN0aW9uKTtcbiAgICB0b2dnbGVDc3NQcm9wcyh0aGlzLCB0cnVlKTtcbiAgICBlYWNoKHRoaXMub3B0aW9ucy5yZWNvZ25pemVycywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciByZWNvZ25pemVyID0gX3RoaXMuYWRkKG5ldyBpdGVtWzBdKGl0ZW1bMV0pKTtcblxuICAgICAgaXRlbVsyXSAmJiByZWNvZ25pemVyLnJlY29nbml6ZVdpdGgoaXRlbVsyXSk7XG4gICAgICBpdGVtWzNdICYmIHJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUoaXRlbVszXSk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIHNldCBvcHRpb25zXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtNYW5hZ2VyfVxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBNYW5hZ2VyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24gc2V0KG9wdGlvbnMpIHtcbiAgICBhc3NpZ24kMSh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpOyAvLyBPcHRpb25zIHRoYXQgbmVlZCBhIGxpdHRsZSBtb3JlIHNldHVwXG5cbiAgICBpZiAob3B0aW9ucy50b3VjaEFjdGlvbikge1xuICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbnB1dFRhcmdldCkge1xuICAgICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJzIGFuZCByZWluaXRpYWxpemVcbiAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgdGhpcy5pbnB1dC50YXJnZXQgPSBvcHRpb25zLmlucHV0VGFyZ2V0O1xuICAgICAgdGhpcy5pbnB1dC5pbml0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBzdG9wIHJlY29nbml6aW5nIGZvciB0aGlzIHNlc3Npb24uXG4gICAqIFRoaXMgc2Vzc2lvbiB3aWxsIGJlIGRpc2NhcmRlZCwgd2hlbiBhIG5ldyBbaW5wdXRdc3RhcnQgZXZlbnQgaXMgZmlyZWQuXG4gICAqIFdoZW4gZm9yY2VkLCB0aGUgcmVjb2duaXplciBjeWNsZSBpcyBzdG9wcGVkIGltbWVkaWF0ZWx5LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmb3JjZV1cbiAgICovXG5cblxuICBfcHJvdG8uc3RvcCA9IGZ1bmN0aW9uIHN0b3AoZm9yY2UpIHtcbiAgICB0aGlzLnNlc3Npb24uc3RvcHBlZCA9IGZvcmNlID8gRk9SQ0VEX1NUT1AgOiBTVE9QO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcnVuIHRoZSByZWNvZ25pemVycyFcbiAgICogY2FsbGVkIGJ5IHRoZSBpbnB1dEhhbmRsZXIgZnVuY3Rpb24gb24gZXZlcnkgbW92ZW1lbnQgb2YgdGhlIHBvaW50ZXJzICh0b3VjaGVzKVxuICAgKiBpdCB3YWxrcyB0aHJvdWdoIGFsbCB0aGUgcmVjb2duaXplcnMgYW5kIHRyaWVzIHRvIGRldGVjdCB0aGUgZ2VzdHVyZSB0aGF0IGlzIGJlaW5nIG1hZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0RGF0YVxuICAgKi9cblxuXG4gIF9wcm90by5yZWNvZ25pemUgPSBmdW5jdGlvbiByZWNvZ25pemUoaW5wdXREYXRhKSB7XG4gICAgdmFyIHNlc3Npb24gPSB0aGlzLnNlc3Npb247XG5cbiAgICBpZiAoc2Vzc2lvbi5zdG9wcGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBydW4gdGhlIHRvdWNoLWFjdGlvbiBwb2x5ZmlsbFxuXG5cbiAgICB0aGlzLnRvdWNoQWN0aW9uLnByZXZlbnREZWZhdWx0cyhpbnB1dERhdGEpO1xuICAgIHZhciByZWNvZ25pemVyO1xuICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7IC8vIHRoaXMgaG9sZHMgdGhlIHJlY29nbml6ZXIgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgIC8vIHNvIHRoZSByZWNvZ25pemVyJ3Mgc3RhdGUgbmVlZHMgdG8gYmUgQkVHQU4sIENIQU5HRUQsIEVOREVEIG9yIFJFQ09HTklaRURcbiAgICAvLyBpZiBubyByZWNvZ25pemVyIGlzIGRldGVjdGluZyBhIHRoaW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgXG5cbiAgICB2YXIgY3VyUmVjb2duaXplciA9IHNlc3Npb24uY3VyUmVjb2duaXplcjsgLy8gcmVzZXQgd2hlbiB0aGUgbGFzdCByZWNvZ25pemVyIGlzIHJlY29nbml6ZWRcbiAgICAvLyBvciB3aGVuIHdlJ3JlIGluIGEgbmV3IHNlc3Npb25cblxuICAgIGlmICghY3VyUmVjb2duaXplciB8fCBjdXJSZWNvZ25pemVyICYmIGN1clJlY29nbml6ZXIuc3RhdGUgJiBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSBudWxsO1xuICAgICAgY3VyUmVjb2duaXplciA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCByZWNvZ25pemVycy5sZW5ndGgpIHtcbiAgICAgIHJlY29nbml6ZXIgPSByZWNvZ25pemVyc1tpXTsgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxuICAgICAgLy8gMS4gICBhbGxvdyBpZiB0aGUgc2Vzc2lvbiBpcyBOT1QgZm9yY2VkIHN0b3BwZWQgKHNlZSB0aGUgLnN0b3AoKSBtZXRob2QpXG4gICAgICAvLyAyLiAgIGFsbG93IGlmIHdlIHN0aWxsIGhhdmVuJ3QgcmVjb2duaXplZCBhIGdlc3R1cmUgaW4gdGhpcyBzZXNzaW9uLCBvciB0aGUgdGhpcyByZWNvZ25pemVyIGlzIHRoZSBvbmVcbiAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgLy8gMy4gICBhbGxvdyBpZiB0aGUgcmVjb2duaXplciBpcyBhbGxvd2VkIHRvIHJ1biBzaW11bHRhbmVvdXMgd2l0aCB0aGUgY3VycmVudCByZWNvZ25pemVkIHJlY29nbml6ZXIuXG4gICAgICAvLyAgICAgIHRoaXMgY2FuIGJlIHNldHVwIHdpdGggdGhlIGByZWNvZ25pemVXaXRoKClgIG1ldGhvZCBvbiB0aGUgcmVjb2duaXplci5cblxuICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCAhPT0gRk9SQ0VEX1NUT1AgJiYgKCAvLyAxXG4gICAgICAhY3VyUmVjb2duaXplciB8fCByZWNvZ25pemVyID09PSBjdXJSZWNvZ25pemVyIHx8IC8vIDJcbiAgICAgIHJlY29nbml6ZXIuY2FuUmVjb2duaXplV2l0aChjdXJSZWNvZ25pemVyKSkpIHtcbiAgICAgICAgLy8gM1xuICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZShpbnB1dERhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjb2duaXplci5yZXNldCgpO1xuICAgICAgfSAvLyBpZiB0aGUgcmVjb2duaXplciBoYXMgYmVlbiByZWNvZ25pemluZyB0aGUgaW5wdXQgYXMgYSB2YWxpZCBnZXN0dXJlLCB3ZSB3YW50IHRvIHN0b3JlIHRoaXMgb25lIGFzIHRoZVxuICAgICAgLy8gY3VycmVudCBhY3RpdmUgcmVjb2duaXplci4gYnV0IG9ubHkgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGFuIGFjdGl2ZSByZWNvZ25pemVyXG5cblxuICAgICAgaWYgKCFjdXJSZWNvZ25pemVyICYmIHJlY29nbml6ZXIuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQpKSB7XG4gICAgICAgIHNlc3Npb24uY3VyUmVjb2duaXplciA9IHJlY29nbml6ZXI7XG4gICAgICAgIGN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgfVxuXG4gICAgICBpKys7XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogZ2V0IGEgcmVjb2duaXplciBieSBpdHMgZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgKiBAcmV0dXJucyB7UmVjb2duaXplcnxOdWxsfVxuICAgKi9cblxuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQocmVjb2duaXplcikge1xuICAgIGlmIChyZWNvZ25pemVyIGluc3RhbmNlb2YgUmVjb2duaXplcikge1xuICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgfVxuXG4gICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWNvZ25pemVyc1tpXS5vcHRpb25zLmV2ZW50ID09PSByZWNvZ25pemVyKSB7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgLyoqXG4gICAqIEBwcml2YXRlIGFkZCBhIHJlY29nbml6ZXIgdG8gdGhlIG1hbmFnZXJcbiAgICogZXhpc3RpbmcgcmVjb2duaXplcnMgd2l0aCB0aGUgc2FtZSBldmVudCBuYW1lIHdpbGwgYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IHJlY29nbml6ZXJcbiAgICogQHJldHVybnMge1JlY29nbml6ZXJ8TWFuYWdlcn1cbiAgICovXG5cblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKHJlY29nbml6ZXIpIHtcbiAgICBpZiAoaW52b2tlQXJyYXlBcmcocmVjb2duaXplciwgXCJhZGRcIiwgdGhpcykpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gLy8gcmVtb3ZlIGV4aXN0aW5nXG5cblxuICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KHJlY29nbml6ZXIub3B0aW9ucy5ldmVudCk7XG5cbiAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgIHRoaXMucmVtb3ZlKGV4aXN0aW5nKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlY29nbml6ZXJzLnB1c2gocmVjb2duaXplcik7XG4gICAgcmVjb2duaXplci5tYW5hZ2VyID0gdGhpcztcbiAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgIHJldHVybiByZWNvZ25pemVyO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogcmVtb3ZlIGEgcmVjb2duaXplciBieSBuYW1lIG9yIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVjb2duaXplcnxTdHJpbmd9IHJlY29nbml6ZXJcbiAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAqL1xuXG5cbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShyZWNvZ25pemVyKSB7XG4gICAgaWYgKGludm9rZUFycmF5QXJnKHJlY29nbml6ZXIsIFwicmVtb3ZlXCIsIHRoaXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0UmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpOyAvLyBsZXQncyBtYWtlIHN1cmUgdGhpcyByZWNvZ25pemVyIGV4aXN0c1xuXG4gICAgaWYgKHJlY29nbml6ZXIpIHtcbiAgICAgIHZhciByZWNvZ25pemVycyA9IHRoaXMucmVjb2duaXplcnM7XG4gICAgICB2YXIgaW5kZXggPSBpbkFycmF5KHJlY29nbml6ZXJzLCB0YXJnZXRSZWNvZ25pemVyKTtcblxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICByZWNvZ25pemVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLnRvdWNoQWN0aW9uLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogYmluZCBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgKi9cblxuXG4gIF9wcm90by5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50cywgaGFuZGxlcikge1xuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCB8fCBoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XG4gICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXJzW2V2ZW50XSB8fCBbXTtcbiAgICAgIGhhbmRsZXJzW2V2ZW50XS5wdXNoKGhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvKipcbiAgICogQHByaXZhdGUgdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl1cbiAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgKi9cblxuXG4gIF9wcm90by5vZmYgPSBmdW5jdGlvbiBvZmYoZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzO1xuICAgIGVhY2goc3BsaXRTdHIoZXZlbnRzKSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZXJzW2V2ZW50XSAmJiBoYW5kbGVyc1tldmVudF0uc3BsaWNlKGluQXJyYXkoaGFuZGxlcnNbZXZlbnRdLCBoYW5kbGVyKSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZSBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuXG5cbiAgX3Byb3RvLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBkYXRhKSB7XG4gICAgLy8gd2UgYWxzbyB3YW50IHRvIHRyaWdnZXIgZG9tIGV2ZW50c1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZG9tRXZlbnRzKSB7XG4gICAgICB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpO1xuICAgIH0gLy8gbm8gaGFuZGxlcnMsIHNvIHNraXAgaXQgYWxsXG5cblxuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnNbZXZlbnRdICYmIHRoaXMuaGFuZGxlcnNbZXZlbnRdLnNsaWNlKCk7XG5cbiAgICBpZiAoIWhhbmRsZXJzIHx8ICFoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkYXRhLnR5cGUgPSBldmVudDtcblxuICAgIGRhdGEucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBkYXRhLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcblxuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChpIDwgaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICBoYW5kbGVyc1tpXShkYXRhKTtcbiAgICAgIGkrKztcbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBkZXN0cm95IHRoZSBtYW5hZ2VyIGFuZCB1bmJpbmRzIGFsbCBldmVudHNcbiAgICogaXQgZG9lc24ndCB1bmJpbmQgZG9tIGV2ZW50cywgdGhhdCBpcyB0aGUgdXNlciBvd24gcmVzcG9uc2liaWxpdHlcbiAgICovXG5cblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5lbGVtZW50ICYmIHRvZ2dsZUNzc1Byb3BzKHRoaXMsIGZhbHNlKTtcbiAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgdGhpcy5zZXNzaW9uID0ge307XG4gICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gTWFuYWdlcjtcbn0oKTtcblxudmFyIFNJTkdMRV9UT1VDSF9JTlBVVF9NQVAgPSB7XG4gIHRvdWNoc3RhcnQ6IElOUFVUX1NUQVJULFxuICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gIHRvdWNoZW5kOiBJTlBVVF9FTkQsXG4gIHRvdWNoY2FuY2VsOiBJTlBVVF9DQU5DRUxcbn07XG52YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG52YXIgU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuLyoqXG4gKiBAcHJpdmF0ZVxuICogVG91Y2ggZXZlbnRzIGlucHV0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIElucHV0XG4gKi9cblxudmFyIFNpbmdsZVRvdWNoSW5wdXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9JbnB1dCkge1xuICBfaW5oZXJpdHNMb29zZShTaW5nbGVUb3VjaElucHV0LCBfSW5wdXQpO1xuXG4gIGZ1bmN0aW9uIFNpbmdsZVRvdWNoSW5wdXQoKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIHByb3RvID0gU2luZ2xlVG91Y2hJbnB1dC5wcm90b3R5cGU7XG4gICAgcHJvdG8uZXZUYXJnZXQgPSBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICBwcm90by5ldldpbiA9IFNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTO1xuICAgIF90aGlzID0gX0lucHV0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNpbmdsZVRvdWNoSW5wdXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlcihldikge1xuICAgIHZhciB0eXBlID0gU0lOR0xFX1RPVUNIX0lOUFVUX01BUFtldi50eXBlXTsgLy8gc2hvdWxkIHdlIGhhbmRsZSB0aGUgdG91Y2ggZXZlbnRzP1xuXG4gICAgaWYgKHR5cGUgPT09IElOUFVUX1NUQVJUKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRvdWNoZXMgPSBub3JtYWxpemVTaW5nbGVUb3VjaGVzLmNhbGwodGhpcywgZXYsIHR5cGUpOyAvLyB3aGVuIGRvbmUsIHJlc2V0IHRoZSBzdGFydGVkIHN0YXRlXG5cbiAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHRvdWNoZXNbMF0ubGVuZ3RoIC0gdG91Y2hlc1sxXS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2sodGhpcy5tYW5hZ2VyLCB0eXBlLCB7XG4gICAgICBwb2ludGVyczogdG91Y2hlc1swXSxcbiAgICAgIGNoYW5nZWRQb2ludGVyczogdG91Y2hlc1sxXSxcbiAgICAgIHBvaW50ZXJUeXBlOiBJTlBVVF9UWVBFX1RPVUNILFxuICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFNpbmdsZVRvdWNoSW5wdXQ7XG59KElucHV0KTtcblxuZnVuY3Rpb24gbm9ybWFsaXplU2luZ2xlVG91Y2hlcyhldiwgdHlwZSkge1xuICB2YXIgYWxsID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgdmFyIGNoYW5nZWQgPSB0b0FycmF5KGV2LmNoYW5nZWRUb3VjaGVzKTtcblxuICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgYWxsID0gdW5pcXVlQXJyYXkoYWxsLmNvbmNhdChjaGFuZ2VkKSwgJ2lkZW50aWZpZXInLCB0cnVlKTtcbiAgfVxuXG4gIHJldHVybiBbYWxsLCBjaGFuZ2VkXTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogd3JhcCBhIG1ldGhvZCB3aXRoIGEgZGVwcmVjYXRpb24gd2FybmluZyBhbmQgc3RhY2sgdHJhY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHdyYXBwaW5nIHRoZSBzdXBwbGllZCBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZShtZXRob2QsIG5hbWUsIG1lc3NhZ2UpIHtcbiAgdmFyIGRlcHJlY2F0aW9uTWVzc2FnZSA9IFwiREVQUkVDQVRFRCBNRVRIT0Q6IFwiICsgbmFtZSArIFwiXFxuXCIgKyBtZXNzYWdlICsgXCIgQVQgXFxuXCI7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGUgPSBuZXcgRXJyb3IoJ2dldC1zdGFjay10cmFjZScpO1xuICAgIHZhciBzdGFjayA9IGUgJiYgZS5zdGFjayA/IGUuc3RhY2sucmVwbGFjZSgvXlteXFwoXSs/W1xcbiRdL2dtLCAnJykucmVwbGFjZSgvXlxccythdFxccysvZ20sICcnKS5yZXBsYWNlKC9eT2JqZWN0Ljxhbm9ueW1vdXM+XFxzKlxcKC9nbSwgJ3thbm9ueW1vdXN9KClAJykgOiAnVW5rbm93biBTdGFjayBUcmFjZSc7XG4gICAgdmFyIGxvZyA9IHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS53YXJuIHx8IHdpbmRvdy5jb25zb2xlLmxvZyk7XG5cbiAgICBpZiAobG9nKSB7XG4gICAgICBsb2cuY2FsbCh3aW5kb3cuY29uc29sZSwgZGVwcmVjYXRpb25NZXNzYWdlLCBzdGFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cblxudmFyIGV4dGVuZCA9IGRlcHJlY2F0ZShmdW5jdGlvbiAoZGVzdCwgc3JjLCBtZXJnZSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XG4gIHZhciBpID0gMDtcblxuICB3aGlsZSAoaSA8IGtleXMubGVuZ3RoKSB7XG4gICAgaWYgKCFtZXJnZSB8fCBtZXJnZSAmJiBkZXN0W2tleXNbaV1dID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlc3Rba2V5c1tpXV0gPSBzcmNba2V5c1tpXV07XG4gICAgfVxuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59LCAnZXh0ZW5kJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogbWVyZ2UgdGhlIHZhbHVlcyBmcm9tIHNyYyBpbiB0aGUgZGVzdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGRlc3Qgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gYnkgc3JjXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG5cbnZhciBtZXJnZSQyID0gZGVwcmVjYXRlKGZ1bmN0aW9uIChkZXN0LCBzcmMpIHtcbiAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xufSwgJ21lcmdlJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogc2ltcGxlIGNsYXNzIGluaGVyaXRhbmNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGlsZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gYmFzZVxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXVxuICovXG5cbmZ1bmN0aW9uIGluaGVyaXQoY2hpbGQsIGJhc2UsIHByb3BlcnRpZXMpIHtcbiAgdmFyIGJhc2VQID0gYmFzZS5wcm90b3R5cGU7XG4gIHZhciBjaGlsZFA7XG4gIGNoaWxkUCA9IGNoaWxkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZVApO1xuICBjaGlsZFAuY29uc3RydWN0b3IgPSBjaGlsZDtcbiAgY2hpbGRQLl9zdXBlciA9IGJhc2VQO1xuXG4gIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgYXNzaWduJDEoY2hpbGRQLCBwcm9wZXJ0aWVzKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBzaW1wbGUgZnVuY3Rpb24gYmluZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGJpbmRGbihmbiwgY29udGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24gYm91bmRGbigpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogU2ltcGxlIHdheSB0byBjcmVhdGUgYSBtYW5hZ2VyIHdpdGggYSBkZWZhdWx0IHNldCBvZiByZWNvZ25pemVycy5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBIYW1tZXIkMiA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIHZhciBIYW1tZXIgPVxuICAvKipcbiAgICAqIEBwcml2YXRlXG4gICAgKiBAY29uc3Qge3N0cmluZ31cbiAgICAqL1xuICBmdW5jdGlvbiBIYW1tZXIoZWxlbWVudCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IE1hbmFnZXIoZWxlbWVudCwgX2V4dGVuZHMoe1xuICAgICAgcmVjb2duaXplcnM6IHByZXNldC5jb25jYXQoKVxuICAgIH0sIG9wdGlvbnMpKTtcbiAgfTtcblxuICBIYW1tZXIuVkVSU0lPTiA9IFwiMi4wLjE3LXJjXCI7XG4gIEhhbW1lci5ESVJFQ1RJT05fQUxMID0gRElSRUNUSU9OX0FMTDtcbiAgSGFtbWVyLkRJUkVDVElPTl9ET1dOID0gRElSRUNUSU9OX0RPV047XG4gIEhhbW1lci5ESVJFQ1RJT05fTEVGVCA9IERJUkVDVElPTl9MRUZUO1xuICBIYW1tZXIuRElSRUNUSU9OX1JJR0hUID0gRElSRUNUSU9OX1JJR0hUO1xuICBIYW1tZXIuRElSRUNUSU9OX1VQID0gRElSRUNUSU9OX1VQO1xuICBIYW1tZXIuRElSRUNUSU9OX0hPUklaT05UQUwgPSBESVJFQ1RJT05fSE9SSVpPTlRBTDtcbiAgSGFtbWVyLkRJUkVDVElPTl9WRVJUSUNBTCA9IERJUkVDVElPTl9WRVJUSUNBTDtcbiAgSGFtbWVyLkRJUkVDVElPTl9OT05FID0gRElSRUNUSU9OX05PTkU7XG4gIEhhbW1lci5ESVJFQ1RJT05fRE9XTiA9IERJUkVDVElPTl9ET1dOO1xuICBIYW1tZXIuSU5QVVRfU1RBUlQgPSBJTlBVVF9TVEFSVDtcbiAgSGFtbWVyLklOUFVUX01PVkUgPSBJTlBVVF9NT1ZFO1xuICBIYW1tZXIuSU5QVVRfRU5EID0gSU5QVVRfRU5EO1xuICBIYW1tZXIuSU5QVVRfQ0FOQ0VMID0gSU5QVVRfQ0FOQ0VMO1xuICBIYW1tZXIuU1RBVEVfUE9TU0lCTEUgPSBTVEFURV9QT1NTSUJMRTtcbiAgSGFtbWVyLlNUQVRFX0JFR0FOID0gU1RBVEVfQkVHQU47XG4gIEhhbW1lci5TVEFURV9DSEFOR0VEID0gU1RBVEVfQ0hBTkdFRDtcbiAgSGFtbWVyLlNUQVRFX0VOREVEID0gU1RBVEVfRU5ERUQ7XG4gIEhhbW1lci5TVEFURV9SRUNPR05JWkVEID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgSGFtbWVyLlNUQVRFX0NBTkNFTExFRCA9IFNUQVRFX0NBTkNFTExFRDtcbiAgSGFtbWVyLlNUQVRFX0ZBSUxFRCA9IFNUQVRFX0ZBSUxFRDtcbiAgSGFtbWVyLk1hbmFnZXIgPSBNYW5hZ2VyO1xuICBIYW1tZXIuSW5wdXQgPSBJbnB1dDtcbiAgSGFtbWVyLlRvdWNoQWN0aW9uID0gVG91Y2hBY3Rpb247XG4gIEhhbW1lci5Ub3VjaElucHV0ID0gVG91Y2hJbnB1dDtcbiAgSGFtbWVyLk1vdXNlSW5wdXQgPSBNb3VzZUlucHV0O1xuICBIYW1tZXIuUG9pbnRlckV2ZW50SW5wdXQgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgSGFtbWVyLlRvdWNoTW91c2VJbnB1dCA9IFRvdWNoTW91c2VJbnB1dDtcbiAgSGFtbWVyLlNpbmdsZVRvdWNoSW5wdXQgPSBTaW5nbGVUb3VjaElucHV0O1xuICBIYW1tZXIuUmVjb2duaXplciA9IFJlY29nbml6ZXI7XG4gIEhhbW1lci5BdHRyUmVjb2duaXplciA9IEF0dHJSZWNvZ25pemVyO1xuICBIYW1tZXIuVGFwID0gVGFwUmVjb2duaXplcjtcbiAgSGFtbWVyLlBhbiA9IFBhblJlY29nbml6ZXI7XG4gIEhhbW1lci5Td2lwZSA9IFN3aXBlUmVjb2duaXplcjtcbiAgSGFtbWVyLlBpbmNoID0gUGluY2hSZWNvZ25pemVyO1xuICBIYW1tZXIuUm90YXRlID0gUm90YXRlUmVjb2duaXplcjtcbiAgSGFtbWVyLlByZXNzID0gUHJlc3NSZWNvZ25pemVyO1xuICBIYW1tZXIub24gPSBhZGRFdmVudExpc3RlbmVycztcbiAgSGFtbWVyLm9mZiA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzO1xuICBIYW1tZXIuZWFjaCA9IGVhY2g7XG4gIEhhbW1lci5tZXJnZSA9IG1lcmdlJDI7XG4gIEhhbW1lci5leHRlbmQgPSBleHRlbmQ7XG4gIEhhbW1lci5iaW5kRm4gPSBiaW5kRm47XG4gIEhhbW1lci5hc3NpZ24gPSBhc3NpZ24kMTtcbiAgSGFtbWVyLmluaGVyaXQgPSBpbmhlcml0O1xuICBIYW1tZXIuYmluZEZuID0gYmluZEZuO1xuICBIYW1tZXIucHJlZml4ZWQgPSBwcmVmaXhlZDtcbiAgSGFtbWVyLnRvQXJyYXkgPSB0b0FycmF5O1xuICBIYW1tZXIuaW5BcnJheSA9IGluQXJyYXk7XG4gIEhhbW1lci51bmlxdWVBcnJheSA9IHVuaXF1ZUFycmF5O1xuICBIYW1tZXIuc3BsaXRTdHIgPSBzcGxpdFN0cjtcbiAgSGFtbWVyLmJvb2xPckZuID0gYm9vbE9yRm47XG4gIEhhbW1lci5oYXNQYXJlbnQgPSBoYXNQYXJlbnQ7XG4gIEhhbW1lci5hZGRFdmVudExpc3RlbmVycyA9IGFkZEV2ZW50TGlzdGVuZXJzO1xuICBIYW1tZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSByZW1vdmVFdmVudExpc3RlbmVycztcbiAgSGFtbWVyLmRlZmF1bHRzID0gYXNzaWduJDEoe30sIGRlZmF1bHRzLCB7XG4gICAgcHJlc2V0OiBwcmVzZXRcbiAgfSk7XG4gIHJldHVybiBIYW1tZXI7XG59KCk7XG5cbi8vICBzdHlsZSBsb2FkZXIgYnV0IGJ5IHNjcmlwdCB0YWcsIG5vdCBieSB0aGUgbG9hZGVyLlxuXG5IYW1tZXIkMi5kZWZhdWx0cztcblxudmFyIFJlYWxIYW1tZXIgPSBIYW1tZXIkMjtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgX1N5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBfZ2V0SXRlcmF0b3JNZXRob2QobykgfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKF9BcnJheSRpc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ2KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ2KG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQxNzsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDYobywgbWluTGVuKTsgdmFyIG4gPSBfc2xpY2VJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MTcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQxNywgOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gX0FycmF5JGZyb20kMShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ2KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDYoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cblxuLyoqXHJcbiAqIFVzZSB0aGlzIHN5bWJvbCB0byBkZWxldGUgcHJvcGVyaWVzIGluIGRlZXBPYmplY3RBc3NpZ24uXHJcbiAqL1xuX1N5bWJvbChcIkRFTEVURVwiKTtcblxuLyoqXHJcbiAqIFNlZWRhYmxlLCBmYXN0IGFuZCByZWFzb25hYmx5IGdvb2QgKG5vdCBjcnlwdG8gYnV0IG1vcmUgdGhhbiBva2F5IGZvciBvdXJcclxuICogbmVlZHMpIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBBZGFwdGVkIGZyb20ge0BsaW5rIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDExMDQyOTEwMDczNi9odHRwOi8vYmFhZ29lLmNvbTo4MC9lbi9SYW5kb21NdXNpbmdzL2phdmFzY3JpcHR9LlxyXG4gKiBPcmlnaW5hbCBhbGdvcml0aG0gY3JlYXRlZCBieSBKb2hhbm5lcyBCYWFnw7hlIFxcPGJhYWdvZVxcQGJhYWdvZS5jb21cXD4gaW4gMjAxMC5cclxuICovXG4vKipcclxuICogQ3JlYXRlIGEgc2VlZGVkIHBzZXVkbyByYW5kb20gZ2VuZXJhdG9yIGJhc2VkIG9uIEFsZWEgYnkgSm9oYW5uZXMgQmFhZ8O4ZS5cclxuICpcclxuICogQHBhcmFtIHNlZWQgLSBBbGwgc3VwcGxpZWQgYXJndW1lbnRzIHdpbGwgYmUgdXNlZCBhcyBhIHNlZWQuIEluIGNhc2Ugbm90aGluZ1xyXG4gKiBpcyBzdXBwbGllZCB0aGUgY3VycmVudCB0aW1lIHdpbGwgYmUgdXNlZCB0byBzZWVkIHRoZSBnZW5lcmF0b3IuXHJcbiAqIEByZXR1cm5zIEEgcmVhZHkgdG8gdXNlIHNlZWRlZCBnZW5lcmF0b3IuXHJcbiAqL1xuZnVuY3Rpb24gQWxlYSgpIHtcbiAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBzZWVkID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgc2VlZFtfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG4gIHJldHVybiBBbGVhSW1wbGVtZW50YXRpb24oc2VlZC5sZW5ndGggPyBzZWVkIDogW19EYXRlJG5vdygpXSk7XG59XG4vKipcclxuICogQW4gaW1wbGVtZW50YXRpb24gb2YgW1tBbGVhXV0gd2l0aG91dCB1c2VyIGlucHV0IHZhbGlkYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSBzZWVkIC0gVGhlIGRhdGEgdGhhdCB3aWxsIGJlIHVzZWQgdG8gc2VlZCB0aGUgZ2VuZXJhdG9yLlxyXG4gKiBAcmV0dXJucyBBIHJlYWR5IHRvIHVzZSBzZWVkZWQgZ2VuZXJhdG9yLlxyXG4gKi9cbmZ1bmN0aW9uIEFsZWFJbXBsZW1lbnRhdGlvbihzZWVkKSB7XG4gIHZhciBfbWFzaFNlZWQgPSBtYXNoU2VlZChzZWVkKSxcbiAgICBfbWFzaFNlZWQyID0gX3NsaWNlZFRvQXJyYXkoX21hc2hTZWVkLCAzKSxcbiAgICBzMCA9IF9tYXNoU2VlZDJbMF0sXG4gICAgczEgPSBfbWFzaFNlZWQyWzFdLFxuICAgIHMyID0gX21hc2hTZWVkMlsyXTtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmFuZG9tID0gZnVuY3Rpb24gcmFuZG9tKCkge1xuICAgIHZhciB0ID0gMjA5MTYzOSAqIHMwICsgYyAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gICAgczAgPSBzMTtcbiAgICBzMSA9IHMyO1xuICAgIHJldHVybiBzMiA9IHQgLSAoYyA9IHQgfCAwKTtcbiAgfTtcbiAgcmFuZG9tLnVpbnQzMiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgfTsgLy8gMl4zMlxuICByYW5kb20uZnJhY3Q1MyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmFuZG9tKCkgKyAocmFuZG9tKCkgKiAweDIwMDAwMCB8IDApICogMS4xMTAyMjMwMjQ2MjUxNTY1ZS0xNjtcbiAgfTsgLy8gMl4tNTNcbiAgcmFuZG9tLmFsZ29yaXRobSA9IFwiQWxlYVwiO1xuICByYW5kb20uc2VlZCA9IHNlZWQ7XG4gIHJhbmRvbS52ZXJzaW9uID0gXCIwLjlcIjtcbiAgcmV0dXJuIHJhbmRvbTtcbn1cbi8qKlxyXG4gKiBUdXJuIGFyYml0cmFyeSBkYXRhIGludG8gdmFsdWVzIFtbQWxlYUltcGxlbWVudGF0aW9uXV0gY2FuIHVzZSB0byBnZW5lcmF0ZVxyXG4gKiByYW5kb20gbnVtYmVycy5cclxuICpcclxuICogQHBhcmFtIHNlZWQgLSBBcmJpdHJhcnkgZGF0YSB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGUgc2VlZC5cclxuICogQHJldHVybnMgVGhyZWUgbnVtYmVycyB0byB1c2UgYXMgaW5pdGlhbCB2YWx1ZXMgZm9yIFtbQWxlYUltcGxlbWVudGF0aW9uXV0uXHJcbiAqL1xuZnVuY3Rpb24gbWFzaFNlZWQoKSB7XG4gIHZhciBtYXNoID0gTWFzaCgpO1xuICB2YXIgczAgPSBtYXNoKFwiIFwiKTtcbiAgdmFyIHMxID0gbWFzaChcIiBcIik7XG4gIHZhciBzMiA9IG1hc2goXCIgXCIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHMwIC09IG1hc2goaSA8IDAgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2ldKTtcbiAgICBpZiAoczAgPCAwKSB7XG4gICAgICBzMCArPSAxO1xuICAgIH1cbiAgICBzMSAtPSBtYXNoKGkgPCAwIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gaSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpXSk7XG4gICAgaWYgKHMxIDwgMCkge1xuICAgICAgczEgKz0gMTtcbiAgICB9XG4gICAgczIgLT0gbWFzaChpIDwgMCB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaV0pO1xuICAgIGlmIChzMiA8IDApIHtcbiAgICAgIHMyICs9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBbczAsIHMxLCBzMl07XG59XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IG1hc2ggZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEByZXR1cm5zIEEgbm9ucHVyZSBmdW5jdGlvbiB0aGF0IHRha2VzIGFyYml0cmFyeSBbW01hc2hhYmxlXV0gZGF0YSBhbmQgdHVybnNcclxuICogdGhlbSBpbnRvIG51bWJlcnMuXHJcbiAqL1xuZnVuY3Rpb24gTWFzaCgpIHtcbiAgdmFyIG4gPSAweGVmYzgyNDlkO1xuICByZXR1cm4gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgc3RyaW5nID0gZGF0YS50b1N0cmluZygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuICs9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgdmFyIGggPSAwLjAyNTE5NjAzMjgyNDE2OTM4ICogbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgaCAqPSBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBuICs9IGggKiAweDEwMDAwMDAwMDsgLy8gMl4zMlxuICAgIH1cblxuICAgIHJldHVybiAobiA+Pj4gMCkgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICB9O1xufVxuXG4vKipcbiAqIFNldHVwIGEgbW9jayBoYW1tZXIuanMgb2JqZWN0LCBmb3IgdW5pdCB0ZXN0aW5nLlxuICpcbiAqIEluc3BpcmF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vdWJlci9kZWNrLmdsL3B1bGwvNjU4XG4gKlxuICogQHJldHVybnMge3tvbjogbm9vcCwgb2ZmOiBub29wLCBkZXN0cm95OiBub29wLCBlbWl0OiBub29wLCBnZXQ6IGdldH19XG4gKi9cbmZ1bmN0aW9uIGhhbW1lck1vY2soKSB7XG4gIHZhciBub29wID0gZnVuY3Rpb24gbm9vcCgpIHt9O1xuICByZXR1cm4ge1xuICAgIG9uOiBub29wLFxuICAgIG9mZjogbm9vcCxcbiAgICBkZXN0cm95OiBub29wLFxuICAgIGVtaXQ6IG5vb3AsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzZXQ6IG5vb3BcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxudmFyIEhhbW1lciQxID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5IYW1tZXIgfHwgUmVhbEhhbW1lciA6IGZ1bmN0aW9uICgpIHtcbiAgLy8gaGFtbWVyLmpzIGlzIG9ubHkgYXZhaWxhYmxlIGluIGEgYnJvd3Nlciwgbm90IGluIG5vZGUuanMuIFJlcGxhY2luZyBpdCB3aXRoIGEgbW9jayBvYmplY3QuXG4gIHJldHVybiBoYW1tZXJNb2NrKCk7XG59O1xuXG4vKipcbiAqIFR1cm4gYW4gZWxlbWVudCBpbnRvIGFuIGNsaWNrVG9Vc2UgZWxlbWVudC5cbiAqIFdoZW4gbm90IGFjdGl2ZSwgdGhlIGVsZW1lbnQgaGFzIGEgdHJhbnNwYXJlbnQgb3ZlcmxheS4gV2hlbiB0aGUgb3ZlcmxheSBpc1xuICogY2xpY2tlZCwgdGhlIG1vZGUgaXMgY2hhbmdlZCB0byBhY3RpdmUuXG4gKiBXaGVuIGFjdGl2ZSwgdGhlIGVsZW1lbnQgaXMgZGlzcGxheWVkIHdpdGggYSBibHVlIGJvcmRlciBhcm91bmQgaXQsIGFuZFxuICogdGhlIGludGVyYWN0aXZlIGNvbnRlbnRzIG9mIHRoZSBlbGVtZW50IGNhbiBiZSB1c2VkLiBXaGVuIGNsaWNrZWQgb3V0c2lkZVxuICogdGhlIGVsZW1lbnQsIHRoZSBlbGVtZW50cyBtb2RlIGlzIGNoYW5nZWQgdG8gaW5hY3RpdmUuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXJcbiAqIEBjbGFzcyBBY3RpdmF0b3JcbiAqL1xuZnVuY3Rpb24gQWN0aXZhdG9yJDEoY29udGFpbmVyKSB7XG4gIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgX2NvbnRleHQzO1xuICB0aGlzLl9jbGVhbnVwUXVldWUgPSBbXTtcbiAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgdGhpcy5fZG9tID0ge1xuICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgIG92ZXJsYXk6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgfTtcbiAgdGhpcy5fZG9tLm92ZXJsYXkuY2xhc3NMaXN0LmFkZChcInZpcy1vdmVybGF5XCIpO1xuICB0aGlzLl9kb20uY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2RvbS5vdmVybGF5KTtcbiAgdGhpcy5fY2xlYW51cFF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIF90aGlzLl9kb20ub3ZlcmxheS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF90aGlzLl9kb20ub3ZlcmxheSk7XG4gIH0pO1xuICB2YXIgaGFtbWVyID0gSGFtbWVyJDEodGhpcy5fZG9tLm92ZXJsYXkpO1xuICBoYW1tZXIub24oXCJ0YXBcIiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQzID0gdGhpcy5fb25UYXBPdmVybGF5KS5jYWxsKF9jb250ZXh0MywgdGhpcykpO1xuICB0aGlzLl9jbGVhbnVwUXVldWUucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAvLyBGSVhNRTogY2xlYW5pbmcgdXAgaGFtbWVyIGluc3RhbmNlcyBkb2Vzbid0IHdvcmsgKFRpbWVsaW5lIG5vdCByZW1vdmVkXG4gICAgLy8gZnJvbSBtZW1vcnkpXG4gIH0pO1xuXG4gIC8vIGJsb2NrIGFsbCB0b3VjaCBldmVudHMgKGV4Y2VwdCB0YXApXG4gIHZhciBldmVudHMgPSBbXCJ0YXBcIiwgXCJkb3VibGV0YXBcIiwgXCJwcmVzc1wiLCBcInBpbmNoXCIsIFwicGFuXCIsIFwicGFuc3RhcnRcIiwgXCJwYW5tb3ZlXCIsIFwicGFuZW5kXCJdO1xuICBfZm9yRWFjaEluc3RhbmNlUHJvcGVydHkoZXZlbnRzKS5jYWxsKGV2ZW50cywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaGFtbWVyLm9uKGV2ZW50LCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBhdHRhY2ggYSBjbGljayBldmVudCB0byB0aGUgd2luZG93LCBpbiBvcmRlciB0byBkZWFjdGl2YXRlIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSB0aGUgdGltZWxpbmVcbiAgaWYgKGRvY3VtZW50ICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICB0aGlzLl9vbkNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoIV9oYXNQYXJlbnQoZXZlbnQudGFyZ2V0LCBjb250YWluZXIpKSB7XG4gICAgICAgIF90aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX29uQ2xpY2spO1xuICAgIHRoaXMuX2NsZWFudXBRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIF90aGlzLl9vbkNsaWNrKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHByZXBhcmUgZXNjYXBlIGtleSBsaXN0ZW5lciBmb3IgZGVhY3RpdmF0aW5nIHdoZW4gYWN0aXZlXG4gIHRoaXMuX2VzY0xpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKFwia2V5XCIgaW4gZXZlbnQgPyBldmVudC5rZXkgPT09IFwiRXNjYXBlXCIgOiBldmVudC5rZXlDb2RlID09PSAyNyAvKiB0aGUga2V5Q29kZSBpcyBmb3IgSUUxMSAqLykge1xuICAgICAgX3RoaXMuZGVhY3RpdmF0ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gdHVybiBpbnRvIGFuIGV2ZW50IGVtaXR0ZXJcbkVtaXR0ZXIoQWN0aXZhdG9yJDEucHJvdG90eXBlKTtcblxuLy8gVGhlIGN1cnJlbnRseSBhY3RpdmUgYWN0aXZhdG9yXG5BY3RpdmF0b3IkMS5jdXJyZW50ID0gbnVsbDtcblxuLyoqXG4gKiBEZXN0cm95IHRoZSBhY3RpdmF0b3IuIENsZWFucyB1cCBhbGwgY3JlYXRlZCBET00gYW5kIGV2ZW50IGxpc3RlbmVyc1xuICovXG5BY3RpdmF0b3IkMS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9jb250ZXh0NCwgX2NvbnRleHQ1O1xuICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ2KF9yZXZlcnNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDQgPSBfc3BsaWNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDUgPSB0aGlzLl9jbGVhbnVwUXVldWUpLmNhbGwoX2NvbnRleHQ1LCAwKSkuY2FsbChfY29udGV4dDQpKSxcbiAgICBfc3RlcDI7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IF9zdGVwMi52YWx1ZTtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IyLmYoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBY3RpdmF0ZSB0aGUgZWxlbWVudFxuICogT3ZlcmxheSBpcyBoaWRkZW4sIGVsZW1lbnQgaXMgZGVjb3JhdGVkIHdpdGggYSBibHVlIHNoYWRvdyBib3JkZXJcbiAqL1xuQWN0aXZhdG9yJDEucHJvdG90eXBlLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAvLyB3ZSBhbGxvdyBvbmx5IG9uZSBhY3RpdmUgYWN0aXZhdG9yIGF0IGEgdGltZVxuICBpZiAoQWN0aXZhdG9yJDEuY3VycmVudCkge1xuICAgIEFjdGl2YXRvciQxLmN1cnJlbnQuZGVhY3RpdmF0ZSgpO1xuICB9XG4gIEFjdGl2YXRvciQxLmN1cnJlbnQgPSB0aGlzO1xuICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gIHRoaXMuX2RvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgdGhpcy5fZG9tLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidmlzLWFjdGl2ZVwiKTtcbiAgdGhpcy5lbWl0KFwiY2hhbmdlXCIpO1xuICB0aGlzLmVtaXQoXCJhY3RpdmF0ZVwiKTtcblxuICAvLyB1Z2x5IGhhY2s6IGJpbmQgRVNDIGFmdGVyIGVtaXR0aW5nIHRoZSBldmVudHMsIGFzIHRoZSBOZXR3b3JrIHJlYmluZHMgYWxsXG4gIC8vIGtleWJvYXJkIGV2ZW50cyBvbiBhICdjaGFuZ2UnIGV2ZW50XG4gIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fZXNjTGlzdGVuZXIpO1xufTtcblxuLyoqXG4gKiBEZWFjdGl2YXRlIHRoZSBlbGVtZW50XG4gKiBPdmVybGF5IGlzIGRpc3BsYXllZCBvbiB0b3Agb2YgdGhlIGVsZW1lbnRcbiAqL1xuQWN0aXZhdG9yJDEucHJvdG90eXBlLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIHRoaXMuX2RvbS5vdmVybGF5LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gIHRoaXMuX2RvbS5jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShcInZpcy1hY3RpdmVcIik7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5fZXNjTGlzdGVuZXIpO1xuICB0aGlzLmVtaXQoXCJjaGFuZ2VcIik7XG4gIHRoaXMuZW1pdChcImRlYWN0aXZhdGVcIik7XG59O1xuXG4vKipcbiAqIEhhbmRsZSBhIHRhcCBldmVudDogYWN0aXZhdGUgdGhlIGNvbnRhaW5lclxuICpcbiAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICogQHByaXZhdGVcbiAqL1xuQWN0aXZhdG9yJDEucHJvdG90eXBlLl9vblRhcE92ZXJsYXkgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgLy8gYWN0aXZhdGUgdGhlIGNvbnRhaW5lclxuICB0aGlzLmFjdGl2YXRlKCk7XG4gIGV2ZW50LnNyY0V2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufTtcblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgdGhlIGVsZW1lbnQgaGFzIHRoZSByZXF1ZXN0ZWQgcGFyZW50IGVsZW1lbnQgc29tZXdoZXJlIGluXG4gKiBpdHMgY2hhaW4gb2YgcGFyZW50IG5vZGVzLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSB3aGVuIHRoZSBwYXJlbnQgaXMgZm91bmQgc29tZXdoZXJlIGluIHRoZVxuICogICAgICAgICAgICAgICAgICAgIGNoYWluIG9mIHBhcmVudCBub2Rlcy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9oYXNQYXJlbnQoZWxlbWVudCwgcGFyZW50KSB7XG4gIHdoaWxlIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQ29sb3IgUkVzXG52YXIgZnVsbEhleFJFID0gL14jPyhbYS1mXFxkXXsyfSkoW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KSQvaTtcbnZhciBzaG9ydEhleFJFID0gL14jPyhbYS1mXFxkXSkoW2EtZlxcZF0pKFthLWZcXGRdKSQvaTtcbnZhciByZ2JSRSA9IC9ecmdiXFwoICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKiwgKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqLCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICpcXCkkL2k7XG52YXIgcmdiYVJFID0gL15yZ2JhXFwoICooMT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkgKiwgKigxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSAqLCAqKDE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pICosICooWzAxXXwwP1xcLlxcZCspICpcXCkkL2k7XG4vKipcclxuICogUmVtb3ZlIGV2ZXJ5dGhpbmcgaW4gdGhlIERPTSBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSBET01vYmplY3QgLSBOb2RlIHdob3NlIGNoaWxkIG5vZGVzIHdpbGwgYmUgcmVjdXJzaXZlbHkgZGVsZXRlZC5cclxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVET01EZWxldGUoRE9Nb2JqZWN0KSB7XG4gIGlmIChET01vYmplY3QpIHtcbiAgICB3aGlsZSAoRE9Nb2JqZWN0Lmhhc0NoaWxkTm9kZXMoKSA9PT0gdHJ1ZSkge1xuICAgICAgdmFyIGNoaWxkID0gRE9Nb2JqZWN0LmZpcnN0Q2hpbGQ7XG4gICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgcmVjdXJzaXZlRE9NRGVsZXRlKGNoaWxkKTtcbiAgICAgICAgRE9Nb2JqZWN0LnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxyXG4gKiBUZXN0IHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGEgc3RyaW5nLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBJbnB1dCB2YWx1ZSBvZiB1bmtub3duIHR5cGUuXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgc3RyaW5nLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn1cbi8qKlxyXG4gKiBUZXN0IHdoZXRoZXIgZ2l2ZW4gb2JqZWN0IGlzIGEgb2JqZWN0IChub3QgcHJpbWl0aXZlIG9yIG51bGwpLlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgLSBJbnB1dCB2YWx1ZSBvZiB1bmtub3duIHR5cGUuXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgbm90IG51bGwgb2JqZWN0LCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QkNyh2YWx1ZSkge1xuICByZXR1cm4gX3R5cGVvZih2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGw7XG59XG4vKipcclxuICogQ29weSBwcm9wZXJ0eSBmcm9tIGIgdG8gYSBpZiBwcm9wZXJ0eSBwcmVzZW50IGluIGEuXHJcbiAqIElmIHByb3BlcnR5IGluIGIgZXhwbGljaXRseSBzZXQgdG8gbnVsbCwgZGVsZXRlIGl0IGlmIGBhbGxvd0RlbGV0aW9uYCBzZXQuXHJcbiAqXHJcbiAqIEludGVybmFsIGhlbHBlciByb3V0aW5lLCBzaG91bGQgbm90IGJlIGV4cG9ydGVkLiBOb3QgYWRkZWQgdG8gYGV4cG9ydHNgIGZvciB0aGF0IHJlYXNvbi5cclxuICpcclxuICogQHBhcmFtIGEgLSBUYXJnZXQgb2JqZWN0LlxyXG4gKiBAcGFyYW0gYiAtIFNvdXJjZSBvYmplY3QuXHJcbiAqIEBwYXJhbSBwcm9wIC0gTmFtZSBvZiBwcm9wZXJ0eSB0byBjb3B5IGZyb20gYiB0byBhLlxyXG4gKiBAcGFyYW0gYWxsb3dEZWxldGlvbiAtIElmIHRydWUsIGRlbGV0ZSBwcm9wZXJ0eSBpbiBhIGlmIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwgaW4gYi5cclxuICovXG5mdW5jdGlvbiBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbikge1xuICB2YXIgZG9EZWxldGlvbiA9IGZhbHNlO1xuICBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSkge1xuICAgIGRvRGVsZXRpb24gPSBiW3Byb3BdID09PSBudWxsICYmIGFbcHJvcF0gIT09IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoZG9EZWxldGlvbikge1xuICAgIGRlbGV0ZSBhW3Byb3BdO1xuICB9IGVsc2Uge1xuICAgIGFbcHJvcF0gPSBiW3Byb3BdOyAvLyBSZW1lbWJlciwgdGhpcyBpcyBhIHJlZmVyZW5jZSBjb3B5IVxuICB9XG59XG4vKipcclxuICogRmlsbCBhbiBvYmplY3Qgd2l0aCBhIHBvc3NpYmx5IHBhcnRpYWxseSBkZWZpbmVkIG90aGVyIG9iamVjdC5cclxuICpcclxuICogT25seSBjb3BpZXMgdmFsdWVzIGZvciB0aGUgcHJvcGVydGllcyBhbHJlYWR5IHByZXNlbnQgaW4gYS5cclxuICogVGhhdCBtZWFucyBhbiBvYmplY3QgaXMgbm90IGNyZWF0ZWQgb24gYSBwcm9wZXJ0eSBpZiBvbmx5IHRoZSBiIG9iamVjdCBoYXMgaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBhIC0gVGhlIG9iamVjdCB0aGF0IHdpbGwgaGF2ZSBpdCdzIHByb3BlcnRpZXMgdXBkYXRlZC5cclxuICogQHBhcmFtIGIgLSBUaGUgb2JqZWN0IHdpdGggcHJvcGVydHkgdXBkYXRlcy5cclxuICogQHBhcmFtIGFsbG93RGVsZXRpb24gLSBJZiB0cnVlLCBkZWxldGUgcHJvcGVydGllcyBpbiBhIHRoYXQgYXJlIGV4cGxpY2l0bHkgc2V0IHRvIG51bGwgaW4gYi5cclxuICovXG5mdW5jdGlvbiBmaWxsSWZEZWZpbmVkKGEsIGIpIHtcbiAgdmFyIGFsbG93RGVsZXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAvLyBOT1RFOiBpdGVyYXRpb24gb2YgcHJvcGVydGllcyBvZiBhXG4gIC8vIE5PVEU6IHByb3RvdHlwZSBwcm9wZXJ0aWVzIGl0ZXJhdGVkIG92ZXIgYXMgd2VsbFxuICBmb3IgKHZhciBwcm9wIGluIGEpIHtcbiAgICBpZiAoYltwcm9wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoYltwcm9wXSA9PT0gbnVsbCB8fCBfdHlwZW9mKGJbcHJvcF0pICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIC8vIE5vdGU6IHR5cGVvZiBudWxsID09PSAnb2JqZWN0J1xuICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYVByb3AgPSBhW3Byb3BdO1xuICAgICAgICB2YXIgYlByb3AgPSBiW3Byb3BdO1xuICAgICAgICBpZiAoaXNPYmplY3QkNyhhUHJvcCkgJiYgaXNPYmplY3QkNyhiUHJvcCkpIHtcbiAgICAgICAgICBmaWxsSWZEZWZpbmVkKGFQcm9wLCBiUHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxyXG4gKiBFeHRlbmQgb2JqZWN0IGEgd2l0aCBzZWxlY3RlZCBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxyXG4gKiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkIHZhbHVlcyBhcmUgY29waWVkLlxyXG4gKlxyXG4gKiBAcmVtYXJrc1xyXG4gKiBQcmV2aW91cyB2ZXJzaW9uIG9mIHRoaXMgcm91dGluZSBpbXBsaWVkIHRoYXQgbXVsdGlwbGUgc291cmNlIG9iamVjdHMgY291bGRcclxuICogYmUgdXNlZDsgaG93ZXZlciwgdGhlIGltcGxlbWVudGF0aW9uIHdhcyAqKndyb25nKiouIFNpbmNlIG11bHRpcGxlIChcXD4xKVxyXG4gKiBzb3VyY2VzIHdlcmVuJ3QgdXNlZCBhbnl3aGVyZSBpbiB0aGUgYHZpcy5qc2AgY29kZSwgdGhpcyBoYXMgYmVlbiByZW1vdmVkXHJcbiAqIEBwYXJhbSBwcm9wcyAtIE5hbWVzIG9mIGZpcnN0LWxldmVsIHByb3BlcnRpZXMgdG8gY29weSBvdmVyLlxyXG4gKiBAcGFyYW0gYSAtIFRhcmdldCBvYmplY3QuXHJcbiAqIEBwYXJhbSBiIC0gU291cmNlIG9iamVjdC5cclxuICogQHBhcmFtIGFsbG93RGVsZXRpb24gLSBJZiB0cnVlLCBkZWxldGUgcHJvcGVydHkgaW4gYSBpZiBleHBsaWNpdGx5IHNldCB0byBudWxsIGluIGIuXHJcbiAqIEByZXR1cm5zIEFyZ3VtZW50IGEuXHJcbiAqL1xuZnVuY3Rpb24gc2VsZWN0aXZlRGVlcEV4dGVuZChwcm9wcywgYSwgYikge1xuICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gIC8vIFRPRE86IGFkZCBzdXBwb3J0IGZvciBBcnJheXMgdG8gZGVlcEV4dGVuZFxuICBpZiAoX0FycmF5JGlzQXJyYXkoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmRcIik7XG4gIH1cbiAgZm9yICh2YXIgcCA9IDA7IHAgPCBwcm9wcy5sZW5ndGg7IHArKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbcF07XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwcm9wKSkge1xuICAgICAgaWYgKGJbcHJvcF0gJiYgYltwcm9wXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgIGlmIChhW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhW3Byb3BdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgIGRlZXBFeHRlbmQoYVtwcm9wXSwgYltwcm9wXSwgZmFsc2UsIGFsbG93RGVsZXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfQXJyYXkkaXNBcnJheShiW3Byb3BdKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IGRlZXBFeHRlbmRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufVxuLyoqXHJcbiAqIEV4dGVuZCBvYmplY3QgYGFgIHdpdGggcHJvcGVydGllcyBvZiBvYmplY3QgYGJgLCBpZ25vcmluZyBwcm9wZXJ0aWVzIHdoaWNoXHJcbiAqIGFyZSBleHBsaWNpdGx5IHNwZWNpZmllZCB0byBiZSBleGNsdWRlZC5cclxuICpcclxuICogQHJlbWFya3NcclxuICogVGhlIHByb3BlcnRpZXMgb2YgYGJgIGFyZSBjb25zaWRlcmVkIGZvciBjb3B5aW5nLiBQcm9wZXJ0aWVzIHdoaWNoIGFyZVxyXG4gKiB0aGVtc2VsdmVzIG9iamVjdHMgYXJlIGFyZSBhbHNvIGV4dGVuZGVkLiBPbmx5IHByb3BlcnRpZXMgd2l0aCBkZWZpbmVkXHJcbiAqIHZhbHVlcyBhcmUgY29waWVkLlxyXG4gKiBAcGFyYW0gcHJvcHNUb0V4Y2x1ZGUgLSBOYW1lcyBvZiBwcm9wZXJ0aWVzIHdoaWNoIHNob3VsZCAqbm90KiBiZSBjb3BpZWQuXHJcbiAqIEBwYXJhbSBhIC0gT2JqZWN0IHRvIGV4dGVuZC5cclxuICogQHBhcmFtIGIgLSBPYmplY3QgdG8gdGFrZSBwcm9wZXJ0aWVzIGZyb20gZm9yIGV4dGVuc2lvbi5cclxuICogQHBhcmFtIGFsbG93RGVsZXRpb24gLSBJZiB0cnVlLCBkZWxldGUgcHJvcGVydGllcyBpbiBhIHRoYXQgYXJlIGV4cGxpY2l0bHlcclxuICogc2V0IHRvIG51bGwgaW4gYi5cclxuICogQHJldHVybnMgQXJndW1lbnQgYS5cclxuICovXG5mdW5jdGlvbiBzZWxlY3RpdmVOb3REZWVwRXh0ZW5kKHByb3BzVG9FeGNsdWRlLCBhLCBiKSB7XG4gIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgLy8gVE9ETzogYWRkIHN1cHBvcnQgZm9yIEFycmF5cyB0byBkZWVwRXh0ZW5kXG4gIC8vIE5PVEU6IGFycmF5IHByb3BlcnRpZXMgaGF2ZSBhbiBlbHNlLWJlbG93OyBhcHBhcmVudGx5LCB0aGVyZSBpcyBhIHByb2JsZW0gaGVyZS5cbiAgaWYgKF9BcnJheSRpc0FycmF5KGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5cyBhcmUgbm90IHN1cHBvcnRlZCBieSBkZWVwRXh0ZW5kXCIpO1xuICB9XG4gIGZvciAodmFyIHByb3AgaW4gYikge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHByb3ApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9IC8vIEhhbmRsZSBsb2NhbCBwcm9wZXJ0aWVzIG9ubHlcbiAgICBpZiAoX2luY2x1ZGVzSW5zdGFuY2VQcm9wZXJ0eShwcm9wc1RvRXhjbHVkZSkuY2FsbChwcm9wc1RvRXhjbHVkZSwgcHJvcCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gLy8gSW4gZXhjbHVzaW9uIGxpc3QsIHNraXBcbiAgICBpZiAoYltwcm9wXSAmJiBiW3Byb3BdLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgIGlmIChhW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYVtwcm9wXSA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGFbcHJvcF0uY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICBkZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0pOyAvLyBOT1RFOiBhbGxvd0RlbGV0aW9uIG5vdCBwcm9wYWdhdGVkIVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX0FycmF5JGlzQXJyYXkoYltwcm9wXSkpIHtcbiAgICAgIGFbcHJvcF0gPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYltwcm9wXS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhW3Byb3BdLnB1c2goYltwcm9wXVtpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvcHlPckRlbGV0ZShhLCBiLCBwcm9wLCBhbGxvd0RlbGV0aW9uKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59XG4vKipcclxuICogRGVlcCBleHRlbmQgYW4gb2JqZWN0IGEgd2l0aCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cclxuICpcclxuICogQHBhcmFtIGEgLSBUYXJnZXQgb2JqZWN0LlxyXG4gKiBAcGFyYW0gYiAtIFNvdXJjZSBvYmplY3QuXHJcbiAqIEBwYXJhbSBwcm90b0V4dGVuZCAtIElmIHRydWUsIHRoZSBwcm90b3R5cGUgdmFsdWVzIHdpbGwgYWxzbyBiZSBleHRlbmRlZC5cclxuICogKFRoYXQgaXMgdGhlIG9wdGlvbnMgb2JqZWN0cyB0aGF0IGluaGVyaXQgZnJvbSBvdGhlcnMgd2lsbCBhbHNvIGdldCB0aGVcclxuICogaW5oZXJpdGVkIG9wdGlvbnMpLlxyXG4gKiBAcGFyYW0gYWxsb3dEZWxldGlvbiAtIElmIHRydWUsIHRoZSB2YWx1ZXMgb2YgZmllbGRzIHRoYXQgYXJlIG51bGwgd2lsbCBiZSBkZWxldGVkLlxyXG4gKiBAcmV0dXJucyBBcmd1bWVudCBhLlxyXG4gKi9cbmZ1bmN0aW9uIGRlZXBFeHRlbmQoYSwgYikge1xuICB2YXIgcHJvdG9FeHRlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICB2YXIgYWxsb3dEZWxldGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gIGZvciAodmFyIHByb3AgaW4gYikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcHJvcCkgfHwgcHJvdG9FeHRlbmQgPT09IHRydWUpIHtcbiAgICAgIGlmIChfdHlwZW9mKGJbcHJvcF0pID09PSBcIm9iamVjdFwiICYmIGJbcHJvcF0gIT09IG51bGwgJiYgX09iamVjdCRnZXRQcm90b3R5cGVPZiQxKGJbcHJvcF0pID09PSBPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgIGlmIChhW3Byb3BdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhW3Byb3BdID0gZGVlcEV4dGVuZCh7fSwgYltwcm9wXSwgcHJvdG9FeHRlbmQpOyAvLyBOT1RFOiBhbGxvd0RlbGV0aW9uIG5vdCBwcm9wYWdhdGVkIVxuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2YoYVtwcm9wXSkgPT09IFwib2JqZWN0XCIgJiYgYVtwcm9wXSAhPT0gbnVsbCAmJiBfT2JqZWN0JGdldFByb3RvdHlwZU9mJDEoYVtwcm9wXSkgPT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgICBkZWVwRXh0ZW5kKGFbcHJvcF0sIGJbcHJvcF0sIHByb3RvRXh0ZW5kKTsgLy8gTk9URTogYWxsb3dEZWxldGlvbiBub3QgcHJvcGFnYXRlZCFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3B5T3JEZWxldGUoYSwgYiwgcHJvcCwgYWxsb3dEZWxldGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoX0FycmF5JGlzQXJyYXkoYltwcm9wXSkpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0NjtcbiAgICAgICAgYVtwcm9wXSA9IF9zbGljZUluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQ2ID0gYltwcm9wXSkuY2FsbChfY29udGV4dDYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weU9yRGVsZXRlKGEsIGIsIHByb3AsIGFsbG93RGVsZXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn1cbi8qKlxyXG4gKiBVc2VkIHRvIGV4dGVuZCBhbiBhcnJheSBhbmQgY29weSBpdC4gVGhpcyBpcyB1c2VkIHRvIHByb3BhZ2F0ZSBwYXRocyByZWN1cnNpdmVseS5cclxuICpcclxuICogQHBhcmFtIGFyciAtIEZpcnN0IHBhcnQuXHJcbiAqIEBwYXJhbSBuZXdWYWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSBhYWRkZWQgaW50byB0aGUgYXJyYXkuXHJcbiAqIEByZXR1cm5zIEEgbmV3IGFycmF5IHdpdGggYWxsIGl0ZW1zIGZyb20gYXJyIGFuZCBuZXdWYWx1ZSAod2hpY2ggaXMgbGFzdCkuXHJcbiAqL1xuZnVuY3Rpb24gY29weUFuZEV4dGVuZEFycmF5KGFyciwgbmV3VmFsdWUpIHtcbiAgdmFyIF9jb250ZXh0NztcbiAgcmV0dXJuIF9jb25jYXRJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0NyA9IFtdKS5jYWxsKF9jb250ZXh0NywgX3RvQ29uc3VtYWJsZUFycmF5KGFyciksIFtuZXdWYWx1ZV0pO1xufVxuLyoqXHJcbiAqIFVzZWQgdG8gZXh0ZW5kIGFuIGFycmF5IGFuZCBjb3B5IGl0LiBUaGlzIGlzIHVzZWQgdG8gcHJvcGFnYXRlIHBhdGhzIHJlY3Vyc2l2ZWx5LlxyXG4gKlxyXG4gKiBAcGFyYW0gYXJyIC0gVGhlIGFycmF5IHRvIGJlIGNvcGllZC5cclxuICogQHJldHVybnMgU2hhbGxvdyBjb3B5IG9mIGFyci5cclxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoYXJyKSB7XG4gIHJldHVybiBfc2xpY2VJbnN0YW5jZVByb3BlcnR5KGFycikuY2FsbChhcnIpO1xufVxuLyoqXHJcbiAqIFJldHJpZXZlIHRoZSBhYnNvbHV0ZSBsZWZ0IHZhbHVlIG9mIGEgRE9NIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSBlbGVtIC0gQSBkb20gZWxlbWVudCwgZm9yIGV4YW1wbGUgYSBkaXYuXHJcbiAqIEByZXR1cm5zIFRoZSBhYnNvbHV0ZSBsZWZ0IHBvc2l0aW9uIG9mIHRoaXMgZWxlbWVudCBpbiB0aGUgYnJvd3NlciBwYWdlLlxyXG4gKi9cbmZ1bmN0aW9uIGdldEFic29sdXRlTGVmdChlbGVtKSB7XG4gIHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG59XG4vKipcclxuICogUmV0cmlldmUgdGhlIGFic29sdXRlIHRvcCB2YWx1ZSBvZiBhIERPTSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gZWxlbSAtIEEgZG9tIGVsZW1lbnQsIGZvciBleGFtcGxlIGEgZGl2LlxyXG4gKiBAcmV0dXJucyBUaGUgYWJzb2x1dGUgdG9wIHBvc2l0aW9uIG9mIHRoaXMgZWxlbWVudCBpbiB0aGUgYnJvd3NlciBwYWdlLlxyXG4gKi9cbmZ1bmN0aW9uIGdldEFic29sdXRlVG9wKGVsZW0pIHtcbiAgcmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xufVxuLyoqXHJcbiAqIEZvciBlYWNoIG1ldGhvZCBmb3IgYm90aCBhcnJheXMgYW5kIG9iamVjdHMuXHJcbiAqIEluIGNhc2Ugb2YgYW4gYXJyYXksIHRoZSBidWlsdC1pbiBBcnJheS5mb3JFYWNoKCkgaXMgYXBwbGllZCAoKipObywgaXQncyBub3QhKiopLlxyXG4gKiBJbiBjYXNlIG9mIGFuIE9iamVjdCwgdGhlIG1ldGhvZCBsb29wcyBvdmVyIGFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSBvYmplY3QgLSBBbiBPYmplY3Qgb3IgQXJyYXkgdG8gYmUgaXRlcmF0ZWQgb3Zlci5cclxuICogQHBhcmFtIGNhbGxiYWNrIC0gQXJyYXkuZm9yRWFjaC1saWtlIGNhbGxiYWNrLlxyXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gkMShvYmplY3QsIGNhbGxiYWNrKSB7XG4gIGlmIChfQXJyYXkkaXNBcnJheShvYmplY3QpKSB7XG4gICAgLy8gYXJyYXlcbiAgICB2YXIgbGVuID0gb2JqZWN0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjYWxsYmFjayhvYmplY3RbaV0sIGksIG9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIG9iamVjdFxuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgIGNhbGxiYWNrKG9iamVjdFtrZXldLCBrZXksIG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcclxuICogQ29udmVydCBoZXggY29sb3Igc3RyaW5nIGludG8gUkdCIGNvbG9yIG9iamVjdC5cclxuICpcclxuICogQHJlbWFya3NcclxuICoge0BsaW5rIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTYyMzgzOC9yZ2ItdG8taGV4LWFuZC1oZXgtdG8tcmdifVxyXG4gKiBAcGFyYW0gaGV4IC0gSGV4IGNvbG9yIHN0cmluZyAoMyBvciA2IGRpZ2l0cywgd2l0aCBvciB3aXRob3V0ICMpLlxyXG4gKiBAcmV0dXJucyBSR0IgY29sb3Igb2JqZWN0LlxyXG4gKi9cbmZ1bmN0aW9uIGhleFRvUkdCKGhleCkge1xuICB2YXIgcmVzdWx0O1xuICBzd2l0Y2ggKGhleC5sZW5ndGgpIHtcbiAgICBjYXNlIDM6XG4gICAgY2FzZSA0OlxuICAgICAgcmVzdWx0ID0gc2hvcnRIZXhSRS5leGVjKGhleCk7XG4gICAgICByZXR1cm4gcmVzdWx0ID8ge1xuICAgICAgICByOiBfcGFyc2VJbnQkMShyZXN1bHRbMV0gKyByZXN1bHRbMV0sIDE2KSxcbiAgICAgICAgZzogX3BhcnNlSW50JDEocmVzdWx0WzJdICsgcmVzdWx0WzJdLCAxNiksXG4gICAgICAgIGI6IF9wYXJzZUludCQxKHJlc3VsdFszXSArIHJlc3VsdFszXSwgMTYpXG4gICAgICB9IDogbnVsbDtcbiAgICBjYXNlIDY6XG4gICAgY2FzZSA3OlxuICAgICAgcmVzdWx0ID0gZnVsbEhleFJFLmV4ZWMoaGV4KTtcbiAgICAgIHJldHVybiByZXN1bHQgPyB7XG4gICAgICAgIHI6IF9wYXJzZUludCQxKHJlc3VsdFsxXSwgMTYpLFxuICAgICAgICBnOiBfcGFyc2VJbnQkMShyZXN1bHRbMl0sIDE2KSxcbiAgICAgICAgYjogX3BhcnNlSW50JDEocmVzdWx0WzNdLCAxNilcbiAgICAgIH0gOiBudWxsO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuLyoqXHJcbiAqIFRoaXMgZnVuY3Rpb24gdGFrZXMgc3RyaW5nIGNvbG9yIGluIGhleCBvciBSR0IgZm9ybWF0IGFuZCBhZGRzIHRoZSBvcGFjaXR5LCBSR0JBIGlzIHBhc3NlZCB0aHJvdWdoIHVuY2hhbmdlZC5cclxuICpcclxuICogQHBhcmFtIGNvbG9yIC0gVGhlIGNvbG9yIHN0cmluZyAoaGV4LCBSR0IsIFJHQkEpLlxyXG4gKiBAcGFyYW0gb3BhY2l0eSAtIFRoZSBuZXcgb3BhY2l0eS5cclxuICogQHJldHVybnMgUkdCQSBzdHJpbmcsIGZvciBleGFtcGxlICdyZ2JhKDI1NSwgMCwgMTI3LCAwLjMpJy5cclxuICovXG5mdW5jdGlvbiBvdmVycmlkZU9wYWNpdHkoY29sb3IsIG9wYWNpdHkpIHtcbiAgaWYgKF9pbmNsdWRlc0luc3RhbmNlUHJvcGVydHkoY29sb3IpLmNhbGwoY29sb3IsIFwicmdiYVwiKSkge1xuICAgIHJldHVybiBjb2xvcjtcbiAgfSBlbHNlIGlmIChfaW5jbHVkZXNJbnN0YW5jZVByb3BlcnR5KGNvbG9yKS5jYWxsKGNvbG9yLCBcInJnYlwiKSkge1xuICAgIHZhciByZ2IgPSBjb2xvci5zdWJzdHIoX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KGNvbG9yKS5jYWxsKGNvbG9yLCBcIihcIikgKyAxKS5yZXBsYWNlKFwiKVwiLCBcIlwiKS5zcGxpdChcIixcIik7XG4gICAgcmV0dXJuIFwicmdiYShcIiArIHJnYlswXSArIFwiLFwiICsgcmdiWzFdICsgXCIsXCIgKyByZ2JbMl0gKyBcIixcIiArIG9wYWNpdHkgKyBcIilcIjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX3JnYiA9IGhleFRvUkdCKGNvbG9yKTtcbiAgICBpZiAoX3JnYiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcInJnYmEoXCIgKyBfcmdiLnIgKyBcIixcIiArIF9yZ2IuZyArIFwiLFwiICsgX3JnYi5iICsgXCIsXCIgKyBvcGFjaXR5ICsgXCIpXCI7XG4gICAgfVxuICB9XG59XG4vKipcclxuICogQ29udmVydCBSR0IgXFw8MCwgMjU1XFw+IGludG8gaGV4IGNvbG9yIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHJlZCAtIFJlZCBjaGFubmVsLlxyXG4gKiBAcGFyYW0gZ3JlZW4gLSBHcmVlbiBjaGFubmVsLlxyXG4gKiBAcGFyYW0gYmx1ZSAtIEJsdWUgY2hhbm5lbC5cclxuICogQHJldHVybnMgSGV4IGNvbG9yIHN0cmluZyAoZm9yIGV4YW1wbGU6ICcjMGFjZGMwJykuXHJcbiAqL1xuZnVuY3Rpb24gUkdCVG9IZXgocmVkLCBncmVlbiwgYmx1ZSkge1xuICB2YXIgX2NvbnRleHQxMDtcbiAgcmV0dXJuIFwiI1wiICsgX3NsaWNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDEwID0gKCgxIDw8IDI0KSArIChyZWQgPDwgMTYpICsgKGdyZWVuIDw8IDgpICsgYmx1ZSkudG9TdHJpbmcoMTYpKS5jYWxsKF9jb250ZXh0MTAsIDEpO1xufVxuLyoqXHJcbiAqIFBhcnNlIGEgY29sb3IgcHJvcGVydHkgaW50byBhbiBvYmplY3Qgd2l0aCBib3JkZXIsIGJhY2tncm91bmQsIGFuZCBoaWdobGlnaHQgY29sb3JzLlxyXG4gKlxyXG4gKiBAcGFyYW0gaW5wdXRDb2xvciAtIFNob3J0aGFuZCBjb2xvciBzdHJpbmcgb3IgaW5wdXQgY29sb3Igb2JqZWN0LlxyXG4gKiBAcGFyYW0gZGVmYXVsdENvbG9yIC0gRnVsbCBjb2xvciBvYmplY3QgdG8gZmlsbCBpbiBtaXNzaW5nIHZhbHVlcyBpbiBpbnB1dENvbG9yLlxyXG4gKiBAcmV0dXJucyBDb2xvciBvYmplY3QuXHJcbiAqL1xuZnVuY3Rpb24gcGFyc2VDb2xvcihpbnB1dENvbG9yLCBkZWZhdWx0Q29sb3IpIHtcbiAgaWYgKGlzU3RyaW5nKGlucHV0Q29sb3IpKSB7XG4gICAgdmFyIGNvbG9yU3RyID0gaW5wdXRDb2xvcjtcbiAgICBpZiAoaXNWYWxpZFJHQihjb2xvclN0cikpIHtcbiAgICAgIHZhciBfY29udGV4dDExO1xuICAgICAgdmFyIHJnYiA9IF9tYXBJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MTEgPSBjb2xvclN0ci5zdWJzdHIoNCkuc3Vic3RyKDAsIGNvbG9yU3RyLmxlbmd0aCAtIDUpLnNwbGl0KFwiLFwiKSkuY2FsbChfY29udGV4dDExLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF9wYXJzZUludCQxKHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgY29sb3JTdHIgPSBSR0JUb0hleChyZ2JbMF0sIHJnYlsxXSwgcmdiWzJdKTtcbiAgICB9XG4gICAgaWYgKGlzVmFsaWRIZXgoY29sb3JTdHIpID09PSB0cnVlKSB7XG4gICAgICB2YXIgaHN2ID0gaGV4VG9IU1YoY29sb3JTdHIpO1xuICAgICAgdmFyIGxpZ2h0ZXJDb2xvckhTViA9IHtcbiAgICAgICAgaDogaHN2LmgsXG4gICAgICAgIHM6IGhzdi5zICogMC44LFxuICAgICAgICB2OiBNYXRoLm1pbigxLCBoc3YudiAqIDEuMDIpXG4gICAgICB9O1xuICAgICAgdmFyIGRhcmtlckNvbG9ySFNWID0ge1xuICAgICAgICBoOiBoc3YuaCxcbiAgICAgICAgczogTWF0aC5taW4oMSwgaHN2LnMgKiAxLjI1KSxcbiAgICAgICAgdjogaHN2LnYgKiAwLjhcbiAgICAgIH07XG4gICAgICB2YXIgZGFya2VyQ29sb3JIZXggPSBIU1ZUb0hleChkYXJrZXJDb2xvckhTVi5oLCBkYXJrZXJDb2xvckhTVi5zLCBkYXJrZXJDb2xvckhTVi52KTtcbiAgICAgIHZhciBsaWdodGVyQ29sb3JIZXggPSBIU1ZUb0hleChsaWdodGVyQ29sb3JIU1YuaCwgbGlnaHRlckNvbG9ySFNWLnMsIGxpZ2h0ZXJDb2xvckhTVi52KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhY2tncm91bmQ6IGNvbG9yU3RyLFxuICAgICAgICBib3JkZXI6IGRhcmtlckNvbG9ySGV4LFxuICAgICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBsaWdodGVyQ29sb3JIZXgsXG4gICAgICAgICAgYm9yZGVyOiBkYXJrZXJDb2xvckhleFxuICAgICAgICB9LFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGxpZ2h0ZXJDb2xvckhleCxcbiAgICAgICAgICBib3JkZXI6IGRhcmtlckNvbG9ySGV4XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhY2tncm91bmQ6IGNvbG9yU3RyLFxuICAgICAgICBib3JkZXI6IGNvbG9yU3RyLFxuICAgICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBjb2xvclN0cixcbiAgICAgICAgICBib3JkZXI6IGNvbG9yU3RyXG4gICAgICAgIH0sXG4gICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogY29sb3JTdHIsXG4gICAgICAgICAgYm9yZGVyOiBjb2xvclN0clxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVmYXVsdENvbG9yKSB7XG4gICAgICB2YXIgY29sb3IgPSB7XG4gICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuYmFja2dyb3VuZCB8fCBkZWZhdWx0Q29sb3IuYmFja2dyb3VuZCxcbiAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmJvcmRlciB8fCBkZWZhdWx0Q29sb3IuYm9yZGVyLFxuICAgICAgICBoaWdobGlnaHQ6IGlzU3RyaW5nKGlucHV0Q29sb3IuaGlnaGxpZ2h0KSA/IHtcbiAgICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuaGlnaGxpZ2h0LFxuICAgICAgICAgIGJhY2tncm91bmQ6IGlucHV0Q29sb3IuaGlnaGxpZ2h0XG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5oaWdobGlnaHQgJiYgaW5wdXRDb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZCB8fCBkZWZhdWx0Q29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQsXG4gICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhpZ2hsaWdodCAmJiBpbnB1dENvbG9yLmhpZ2hsaWdodC5ib3JkZXIgfHwgZGVmYXVsdENvbG9yLmhpZ2hsaWdodC5ib3JkZXJcbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IGlzU3RyaW5nKGlucHV0Q29sb3IuaG92ZXIpID8ge1xuICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ob3ZlcixcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmhvdmVyXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhvdmVyICYmIGlucHV0Q29sb3IuaG92ZXIuYm9yZGVyIHx8IGRlZmF1bHRDb2xvci5ob3Zlci5ib3JkZXIsXG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5ob3ZlciAmJiBpbnB1dENvbG9yLmhvdmVyLmJhY2tncm91bmQgfHwgZGVmYXVsdENvbG9yLmhvdmVyLmJhY2tncm91bmRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBjb2xvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jb2xvciA9IHtcbiAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5iYWNrZ3JvdW5kIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmJvcmRlciB8fCB1bmRlZmluZWQsXG4gICAgICAgIGhpZ2hsaWdodDogaXNTdHJpbmcoaW5wdXRDb2xvci5oaWdobGlnaHQpID8ge1xuICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5oaWdobGlnaHQsXG4gICAgICAgICAgYmFja2dyb3VuZDogaW5wdXRDb2xvci5oaWdobGlnaHRcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmhpZ2hsaWdodCAmJiBpbnB1dENvbG9yLmhpZ2hsaWdodC5iYWNrZ3JvdW5kIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICBib3JkZXI6IGlucHV0Q29sb3IuaGlnaGxpZ2h0ICYmIGlucHV0Q29sb3IuaGlnaGxpZ2h0LmJvcmRlciB8fCB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgaG92ZXI6IGlzU3RyaW5nKGlucHV0Q29sb3IuaG92ZXIpID8ge1xuICAgICAgICAgIGJvcmRlcjogaW5wdXRDb2xvci5ob3ZlcixcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmhvdmVyXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgYm9yZGVyOiBpbnB1dENvbG9yLmhvdmVyICYmIGlucHV0Q29sb3IuaG92ZXIuYm9yZGVyIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBpbnB1dENvbG9yLmhvdmVyICYmIGlucHV0Q29sb3IuaG92ZXIuYmFja2dyb3VuZCB8fCB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBfY29sb3I7XG4gICAgfVxuICB9XG59XG4vKipcclxuICogQ29udmVydCBSR0IgXFw8MCwgMjU1XFw+IGludG8gSFNWIG9iamVjdC5cclxuICpcclxuICogQHJlbWFya3NcclxuICoge0BsaW5rIGh0dHA6Ly93d3cuamF2YXNjcmlwdGVyLm5ldC9mYXEvcmdiMmhzdi5odG19XHJcbiAqIEBwYXJhbSByZWQgLSBSZWQgY2hhbm5lbC5cclxuICogQHBhcmFtIGdyZWVuIC0gR3JlZW4gY2hhbm5lbC5cclxuICogQHBhcmFtIGJsdWUgLSBCbHVlIGNoYW5uZWwuXHJcbiAqIEByZXR1cm5zIEhTViBjb2xvciBvYmplY3QuXHJcbiAqL1xuZnVuY3Rpb24gUkdCVG9IU1YocmVkLCBncmVlbiwgYmx1ZSkge1xuICByZWQgPSByZWQgLyAyNTU7XG4gIGdyZWVuID0gZ3JlZW4gLyAyNTU7XG4gIGJsdWUgPSBibHVlIC8gMjU1O1xuICB2YXIgbWluUkdCID0gTWF0aC5taW4ocmVkLCBNYXRoLm1pbihncmVlbiwgYmx1ZSkpO1xuICB2YXIgbWF4UkdCID0gTWF0aC5tYXgocmVkLCBNYXRoLm1heChncmVlbiwgYmx1ZSkpO1xuICAvLyBCbGFjay1ncmF5LXdoaXRlXG4gIGlmIChtaW5SR0IgPT09IG1heFJHQikge1xuICAgIHJldHVybiB7XG4gICAgICBoOiAwLFxuICAgICAgczogMCxcbiAgICAgIHY6IG1pblJHQlxuICAgIH07XG4gIH1cbiAgLy8gQ29sb3JzIG90aGVyIHRoYW4gYmxhY2stZ3JheS13aGl0ZTpcbiAgdmFyIGQgPSByZWQgPT09IG1pblJHQiA/IGdyZWVuIC0gYmx1ZSA6IGJsdWUgPT09IG1pblJHQiA/IHJlZCAtIGdyZWVuIDogYmx1ZSAtIHJlZDtcbiAgdmFyIGggPSByZWQgPT09IG1pblJHQiA/IDMgOiBibHVlID09PSBtaW5SR0IgPyAxIDogNTtcbiAgdmFyIGh1ZSA9IDYwICogKGggLSBkIC8gKG1heFJHQiAtIG1pblJHQikpIC8gMzYwO1xuICB2YXIgc2F0dXJhdGlvbiA9IChtYXhSR0IgLSBtaW5SR0IpIC8gbWF4UkdCO1xuICB2YXIgdmFsdWUgPSBtYXhSR0I7XG4gIHJldHVybiB7XG4gICAgaDogaHVlLFxuICAgIHM6IHNhdHVyYXRpb24sXG4gICAgdjogdmFsdWVcbiAgfTtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0IEhTViBcXDwwLCAxXFw+IGludG8gUkdCIGNvbG9yIG9iamVjdC5cclxuICpcclxuICogQHJlbWFya3NcclxuICoge0BsaW5rIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21qaWphY2tzb24vNTMxMTI1Nn1cclxuICogQHBhcmFtIGggLSBIdWUuXHJcbiAqIEBwYXJhbSBzIC0gU2F0dXJhdGlvbi5cclxuICogQHBhcmFtIHYgLSBWYWx1ZS5cclxuICogQHJldHVybnMgUkdCIGNvbG9yIG9iamVjdC5cclxuICovXG5mdW5jdGlvbiBIU1ZUb1JHQihoLCBzLCB2KSB7XG4gIHZhciByO1xuICB2YXIgZztcbiAgdmFyIGI7XG4gIHZhciBpID0gTWF0aC5mbG9vcihoICogNik7XG4gIHZhciBmID0gaCAqIDYgLSBpO1xuICB2YXIgcCA9IHYgKiAoMSAtIHMpO1xuICB2YXIgcSA9IHYgKiAoMSAtIGYgKiBzKTtcbiAgdmFyIHQgPSB2ICogKDEgLSAoMSAtIGYpICogcyk7XG4gIHN3aXRjaCAoaSAlIDYpIHtcbiAgICBjYXNlIDA6XG4gICAgICByID0gdiwgZyA9IHQsIGIgPSBwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgciA9IHEsIGcgPSB2LCBiID0gcDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIHIgPSBwLCBnID0gdiwgYiA9IHQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICByID0gcCwgZyA9IHEsIGIgPSB2O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgciA9IHQsIGcgPSBwLCBiID0gdjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNTpcbiAgICAgIHIgPSB2LCBnID0gcCwgYiA9IHE7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4ge1xuICAgIHI6IE1hdGguZmxvb3IociAqIDI1NSksXG4gICAgZzogTWF0aC5mbG9vcihnICogMjU1KSxcbiAgICBiOiBNYXRoLmZsb29yKGIgKiAyNTUpXG4gIH07XG59XG4vKipcclxuICogQ29udmVydCBIU1YgXFw8MCwgMVxcPiBpbnRvIGhleCBjb2xvciBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBoIC0gSHVlLlxyXG4gKiBAcGFyYW0gcyAtIFNhdHVyYXRpb24uXHJcbiAqIEBwYXJhbSB2IC0gVmFsdWUuXHJcbiAqIEByZXR1cm5zIEhleCBjb2xvciBzdHJpbmcuXHJcbiAqL1xuZnVuY3Rpb24gSFNWVG9IZXgoaCwgcywgdikge1xuICB2YXIgcmdiID0gSFNWVG9SR0IoaCwgcywgdik7XG4gIHJldHVybiBSR0JUb0hleChyZ2IuciwgcmdiLmcsIHJnYi5iKTtcbn1cbi8qKlxyXG4gKiBDb252ZXJ0IGhleCBjb2xvciBzdHJpbmcgaW50byBIU1YgXFw8MCwgMVxcPi5cclxuICpcclxuICogQHBhcmFtIGhleCAtIEhleCBjb2xvciBzdHJpbmcuXHJcbiAqIEByZXR1cm5zIEhTViBjb2xvciBvYmplY3QuXHJcbiAqL1xuZnVuY3Rpb24gaGV4VG9IU1YoaGV4KSB7XG4gIHZhciByZ2IgPSBoZXhUb1JHQihoZXgpO1xuICBpZiAoIXJnYikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCInXCIuY29uY2F0KGhleCwgXCInIGlzIG5vdCBhIHZhbGlkIGNvbG9yLlwiKSk7XG4gIH1cbiAgcmV0dXJuIFJHQlRvSFNWKHJnYi5yLCByZ2IuZywgcmdiLmIpO1xufVxuLyoqXHJcbiAqIFZhbGlkYXRlIGhleCBjb2xvciBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSBoZXggLSBVbmtub3duIHN0cmluZyB0aGF0IG1heSBjb250YWluIGEgY29sb3IuXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHN0cmluZyBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRIZXgoaGV4KSB7XG4gIHZhciBpc09rID0gLyheI1swLTlBLUZdezZ9JCl8KF4jWzAtOUEtRl17M30kKS9pLnRlc3QoaGV4KTtcbiAgcmV0dXJuIGlzT2s7XG59XG4vKipcclxuICogVmFsaWRhdGUgUkdCIGNvbG9yIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHJnYiAtIFVua25vd24gc3RyaW5nIHRoYXQgbWF5IGNvbnRhaW4gYSBjb2xvci5cclxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIHZhbGlkLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFJHQihyZ2IpIHtcbiAgcmV0dXJuIHJnYlJFLnRlc3QocmdiKTtcbn1cbi8qKlxyXG4gKiBWYWxpZGF0ZSBSR0JBIGNvbG9yIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHJnYmEgLSBVbmtub3duIHN0cmluZyB0aGF0IG1heSBjb250YWluIGEgY29sb3IuXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHN0cmluZyBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRSR0JBKHJnYmEpIHtcbiAgcmV0dXJuIHJnYmFSRS50ZXN0KHJnYmEpO1xufVxuLyoqXHJcbiAqIFRoaXMgcmVjdXJzaXZlbHkgcmVkaXJlY3RzIHRoZSBwcm90b3R5cGUgb2YgSlNPTiBvYmplY3RzIHRvIHRoZSByZWZlcmVuY2VPYmplY3QuXHJcbiAqIFRoaXMgaXMgdXNlZCBmb3IgZGVmYXVsdCBvcHRpb25zLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVmZXJlbmNlT2JqZWN0IC0gVGhlIG9yaWdpbmFsIG9iamVjdC5cclxuICogQHJldHVybnMgVGhlIEVsZW1lbnQgaWYgdGhlIHJlZmVyZW5jZU9iamVjdCBpcyBhbiBFbGVtZW50LCBvciBhIG5ldyBvYmplY3QgaW5oZXJpdGluZyBmcm9tIHRoZSByZWZlcmVuY2VPYmplY3QuXHJcbiAqL1xuZnVuY3Rpb24gYnJpZGdlT2JqZWN0KHJlZmVyZW5jZU9iamVjdCkge1xuICBpZiAocmVmZXJlbmNlT2JqZWN0ID09PSBudWxsIHx8IF90eXBlb2YocmVmZXJlbmNlT2JqZWN0KSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChyZWZlcmVuY2VPYmplY3QgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgLy8gQXZvaWQgYnJpZGdpbmcgRE9NIG9iamVjdHNcbiAgICByZXR1cm4gcmVmZXJlbmNlT2JqZWN0O1xuICB9XG4gIHZhciBvYmplY3RUbyA9IF9PYmplY3QkY3JlYXRlJDEocmVmZXJlbmNlT2JqZWN0KTtcbiAgZm9yICh2YXIgaSBpbiByZWZlcmVuY2VPYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZmVyZW5jZU9iamVjdCwgaSkpIHtcbiAgICAgIGlmIChfdHlwZW9mKHJlZmVyZW5jZU9iamVjdFtpXSkgPT0gXCJvYmplY3RcIikge1xuICAgICAgICBvYmplY3RUb1tpXSA9IGJyaWRnZU9iamVjdChyZWZlcmVuY2VPYmplY3RbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0VG87XG59XG4vKipcclxuICogVGhpcyBpcyB1c2VkIHRvIHNldCB0aGUgb3B0aW9ucyBvZiBzdWJvYmplY3RzIGluIHRoZSBvcHRpb25zIG9iamVjdC5cclxuICpcclxuICogQSByZXF1aXJlbWVudCBvZiB0aGVzZSBzdWJvYmplY3RzIGlzIHRoYXQgdGhleSBoYXZlIGFuICdlbmFibGVkJyBlbGVtZW50XHJcbiAqIHdoaWNoIGlzIG9wdGlvbmFsIGZvciB0aGUgdXNlciBidXQgbWFuZGF0b3J5IGZvciB0aGUgcHJvZ3JhbS5cclxuICpcclxuICogVGhlIGFkZGVkIHZhbHVlIGhlcmUgb2YgdGhlIG1lcmdlIGlzIHRoYXQgb3B0aW9uICdlbmFibGVkJyBpcyBzZXQgYXMgcmVxdWlyZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBtZXJnZVRhcmdldCAtIEVpdGhlciB0aGlzLm9wdGlvbnMgb3IgdGhlIG9wdGlvbnMgdXNlZCBmb3IgdGhlIGdyb3Vwcy5cclxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxyXG4gKiBAcGFyYW0gb3B0aW9uIC0gT3B0aW9uIGtleSBpbiB0aGUgb3B0aW9ucyBhcmd1bWVudC5cclxuICogQHBhcmFtIGdsb2JhbE9wdGlvbnMgLSBHbG9iYWwgb3B0aW9ucywgcGFzc2VkIGluIHRvIGRldGVybWluZSB2YWx1ZSBvZiBvcHRpb24gJ2VuYWJsZWQnLlxyXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyhtZXJnZVRhcmdldCwgb3B0aW9ucywgb3B0aW9uKSB7XG4gIHZhciBnbG9iYWxPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgLy8gTG9jYWwgaGVscGVyc1xuICB2YXIgaXNQcmVzZW50ID0gZnVuY3Rpb24gaXNQcmVzZW50KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgb2JqICE9PSB1bmRlZmluZWQ7XG4gIH07XG4gIHZhciBpc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgIHJldHVybiBvYmogIT09IG51bGwgJiYgX3R5cGVvZihvYmopID09PSBcIm9iamVjdFwiO1xuICB9O1xuICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzQ0OTEyODcvMTIyMzUzMVxuICB2YXIgaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkob2JqKSB7XG4gICAgZm9yICh2YXIgeCBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCB4KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICAvLyBHdWFyZHNcbiAgaWYgKCFpc09iamVjdChtZXJnZVRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgbWVyZ2VUYXJnZXQgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIH1cbiAgaWYgKCFpc09iamVjdChvcHRpb25zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtZXRlciBvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICB9XG4gIGlmICghaXNQcmVzZW50KG9wdGlvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgb3B0aW9uIG11c3QgaGF2ZSBhIHZhbHVlXCIpO1xuICB9XG4gIGlmICghaXNPYmplY3QoZ2xvYmFsT3B0aW9ucykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJhbWV0ZXIgZ2xvYmFsT3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgfVxuICAvL1xuICAvLyBBY3R1YWwgbWVyZ2Ugcm91dGluZSwgc2VwYXJhdGVkIGZyb20gbWFpbiBsb2dpY1xuICAvLyBPbmx5IGEgc2luZ2xlIGxldmVsIG9mIG9wdGlvbnMgaXMgbWVyZ2VkLiBEZWVwZXIgbGV2ZWxzIGFyZSByZWYnZC4gVGhpcyBtYXkgYWN0dWFsbHkgYmUgYW4gaXNzdWUuXG4gIC8vXG4gIHZhciBkb01lcmdlID0gZnVuY3Rpb24gZG9NZXJnZSh0YXJnZXQsIG9wdGlvbnMsIG9wdGlvbikge1xuICAgIGlmICghaXNPYmplY3QodGFyZ2V0W29wdGlvbl0pKSB7XG4gICAgICB0YXJnZXRbb3B0aW9uXSA9IHt9O1xuICAgIH1cbiAgICB2YXIgc3JjID0gb3B0aW9uc1tvcHRpb25dO1xuICAgIHZhciBkc3QgPSB0YXJnZXRbb3B0aW9uXTtcbiAgICBmb3IgKHZhciBwcm9wIGluIHNyYykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHByb3ApKSB7XG4gICAgICAgIGRzdFtwcm9wXSA9IHNyY1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIExvY2FsIGluaXRpYWxpemF0aW9uXG4gIHZhciBzcmNPcHRpb24gPSBvcHRpb25zW29wdGlvbl07XG4gIHZhciBnbG9iYWxQYXNzZWQgPSBpc09iamVjdChnbG9iYWxPcHRpb25zKSAmJiAhaXNFbXB0eShnbG9iYWxPcHRpb25zKTtcbiAgdmFyIGdsb2JhbE9wdGlvbiA9IGdsb2JhbFBhc3NlZCA/IGdsb2JhbE9wdGlvbnNbb3B0aW9uXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGdsb2JhbEVuYWJsZWQgPSBnbG9iYWxPcHRpb24gPyBnbG9iYWxPcHRpb24uZW5hYmxlZCA6IHVuZGVmaW5lZDtcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gTWFpbiByb3V0aW5lXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIGlmIChzcmNPcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjsgLy8gTm90aGluZyB0byBkb1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzcmNPcHRpb24gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgaWYgKCFpc09iamVjdChtZXJnZVRhcmdldFtvcHRpb25dKSkge1xuICAgICAgbWVyZ2VUYXJnZXRbb3B0aW9uXSA9IHt9O1xuICAgIH1cbiAgICBtZXJnZVRhcmdldFtvcHRpb25dLmVuYWJsZWQgPSBzcmNPcHRpb247XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChzcmNPcHRpb24gPT09IG51bGwgJiYgIWlzT2JqZWN0KG1lcmdlVGFyZ2V0W29wdGlvbl0pKSB7XG4gICAgLy8gSWYgcG9zc2libGUsIGV4cGxpY2l0IGNvcHkgZnJvbSBnbG9iYWxzXG4gICAgaWYgKGlzUHJlc2VudChnbG9iYWxPcHRpb24pKSB7XG4gICAgICBtZXJnZVRhcmdldFtvcHRpb25dID0gX09iamVjdCRjcmVhdGUkMShnbG9iYWxPcHRpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG9cbiAgICB9XG4gIH1cblxuICBpZiAoIWlzT2JqZWN0KHNyY09wdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy9cbiAgLy8gRW5zdXJlIHRoYXQgJ2VuYWJsZWQnIGlzIHByb3Blcmx5IHNldC4gSXQgaXMgcmVxdWlyZWQgaW50ZXJuYWxseVxuICAvLyBOb3RlIHRoYXQgdGhlIHZhbHVlIGZyb20gb3B0aW9ucyB3aWxsIGFsd2F5cyBvdmVyd3JpdGUgdGhlIGV4aXN0aW5nIHZhbHVlXG4gIC8vXG4gIHZhciBlbmFibGVkID0gdHJ1ZTsgLy8gZGVmYXVsdCB2YWx1ZVxuICBpZiAoc3JjT3B0aW9uLmVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuYWJsZWQgPSBzcmNPcHRpb24uZW5hYmxlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUYWtlIGZyb20gZ2xvYmFscywgaWYgcHJlc2VudFxuICAgIGlmIChnbG9iYWxFbmFibGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuYWJsZWQgPSBnbG9iYWxPcHRpb24uZW5hYmxlZDtcbiAgICB9XG4gIH1cbiAgZG9NZXJnZShtZXJnZVRhcmdldCwgb3B0aW9ucywgb3B0aW9uKTtcbiAgbWVyZ2VUYXJnZXRbb3B0aW9uXS5lbmFibGVkID0gZW5hYmxlZDtcbn1cbi8qXHJcbiAqIEVhc2luZyBGdW5jdGlvbnMuXHJcbiAqIE9ubHkgY29uc2lkZXJpbmcgdGhlIHQgdmFsdWUgZm9yIHRoZSByYW5nZSBbMCwgMV0gPT4gWzAsIDFdLlxyXG4gKlxyXG4gKiBJbnNwaXJhdGlvbjogZnJvbSBodHRwOi8vZ2l6bWEuY29tL2Vhc2luZy9cclxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZ3JlLzE2NTAyOTRcclxuICovXG52YXIgZWFzaW5nRnVuY3Rpb25zID0ge1xuICAvKipcclxuICAgKiBQcm92aWRlcyBubyBlYXNpbmcgYW5kIG5vIGFjY2VsZXJhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGxpbmVhcjogZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgICByZXR1cm4gdDtcbiAgfSxcbiAgLyoqXHJcbiAgICogQWNjZWxlcmF0ZSBmcm9tIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlSW5RdWFkOiBmdW5jdGlvbiBlYXNlSW5RdWFkKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG4gIH0sXG4gIC8qKlxyXG4gICAqIERlY2VsZXJhdGUgdG8gemVybyB2ZWxvY2l0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VPdXRRdWFkOiBmdW5jdGlvbiBlYXNlT3V0UXVhZCh0KSB7XG4gICAgcmV0dXJuIHQgKiAoMiAtIHQpO1xuICB9LFxuICAvKipcclxuICAgKiBBY2NlbGVyYXRlIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VJbk91dFF1YWQ6IGZ1bmN0aW9uIGVhc2VJbk91dFF1YWQodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQ7XG4gIH0sXG4gIC8qKlxyXG4gICAqIEFjY2VsZXJhdGUgZnJvbSB6ZXJvIHZlbG9jaXR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluQ3ViaWM6IGZ1bmN0aW9uIGVhc2VJbkN1YmljKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0O1xuICB9LFxuICAvKipcclxuICAgKiBEZWNlbGVyYXRlIHRvIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlT3V0Q3ViaWM6IGZ1bmN0aW9uIGVhc2VPdXRDdWJpYyh0KSB7XG4gICAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbiAgfSxcbiAgLyoqXHJcbiAgICogQWNjZWxlcmF0ZSB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlSW5PdXRDdWJpYzogZnVuY3Rpb24gZWFzZUluT3V0Q3ViaWModCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gNCAqIHQgKiB0ICogdCA6ICh0IC0gMSkgKiAoMiAqIHQgLSAyKSAqICgyICogdCAtIDIpICsgMTtcbiAgfSxcbiAgLyoqXHJcbiAgICogQWNjZWxlcmF0ZSBmcm9tIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlSW5RdWFydDogZnVuY3Rpb24gZWFzZUluUXVhcnQodCkge1xuICAgIHJldHVybiB0ICogdCAqIHQgKiB0O1xuICB9LFxuICAvKipcclxuICAgKiBEZWNlbGVyYXRlIHRvIHplcm8gdmVsb2NpdHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gdCAtIFRpbWUuXHJcbiAgICogQHJldHVybnMgVmFsdWUgYXQgdGltZSB0LlxyXG4gICAqL1xuICBlYXNlT3V0UXVhcnQ6IGZ1bmN0aW9uIGVhc2VPdXRRdWFydCh0KSB7XG4gICAgcmV0dXJuIDEgLSAtLXQgKiB0ICogdCAqIHQ7XG4gIH0sXG4gIC8qKlxyXG4gICAqIEFjY2VsZXJhdGUgdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluT3V0UXVhcnQ6IGZ1bmN0aW9uIGVhc2VJbk91dFF1YXJ0KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDggKiB0ICogdCAqIHQgKiB0IDogMSAtIDggKiAtLXQgKiB0ICogdCAqIHQ7XG4gIH0sXG4gIC8qKlxyXG4gICAqIEFjY2VsZXJhdGUgZnJvbSB6ZXJvIHZlbG9jaXR5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluUXVpbnQ6IGZ1bmN0aW9uIGVhc2VJblF1aW50KHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG4gIH0sXG4gIC8qKlxyXG4gICAqIERlY2VsZXJhdGUgdG8gemVybyB2ZWxvY2l0eS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB0IC0gVGltZS5cclxuICAgKiBAcmV0dXJucyBWYWx1ZSBhdCB0aW1lIHQuXHJcbiAgICovXG4gIGVhc2VPdXRRdWludDogZnVuY3Rpb24gZWFzZU91dFF1aW50KHQpIHtcbiAgICByZXR1cm4gMSArIC0tdCAqIHQgKiB0ICogdCAqIHQ7XG4gIH0sXG4gIC8qKlxyXG4gICAqIEFjY2VsZXJhdGUgdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHQgLSBUaW1lLlxyXG4gICAqIEByZXR1cm5zIFZhbHVlIGF0IHRpbWUgdC5cclxuICAgKi9cbiAgZWFzZUluT3V0UXVpbnQ6IGZ1bmN0aW9uIGVhc2VJbk91dFF1aW50KHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDE2ICogdCAqIHQgKiB0ICogdCAqIHQgOiAxICsgMTYgKiAtLXQgKiB0ICogdCAqIHQgKiB0O1xuICB9XG59O1xuLy8gQFRPRE86IFRoaXMgZG9lc24ndCB3b3JrIHByb3Blcmx5LlxuLy8gSXQgd29ya3Mgb25seSBmb3Igc2luZ2xlIHByb3BlcnR5IG9iamVjdHMsXG4vLyBvdGhlcndpc2UgaXQgY29tYmluZXMgYWxsIG9mIHRoZSB0eXBlcyBpbiBhIHVuaW9uLlxuLy8gZXhwb3J0IGZ1bmN0aW9uIHRvcE1vc3Q8SzEgZXh0ZW5kcyBzdHJpbmcsIFYxPiAoXG4vLyAgIHBpbGU6IFJlY29yZDxLMSwgdW5kZWZpbmVkIHwgVjE+W10sXG4vLyAgIGFjY2Vzc29yczogSzEgfCBbSzFdXG4vLyApOiB1bmRlZmluZWQgfCBWMVxuLy8gZXhwb3J0IGZ1bmN0aW9uIHRvcE1vc3Q8SzEgZXh0ZW5kcyBzdHJpbmcsIEsyIGV4dGVuZHMgc3RyaW5nLCBWMSwgVjI+IChcbi8vICAgcGlsZTogUmVjb3JkPEsxLCB1bmRlZmluZWQgfCBWMSB8IFJlY29yZDxLMiwgdW5kZWZpbmVkIHwgVjI+PltdLFxuLy8gICBhY2Nlc3NvcnM6IFtLMSwgSzJdXG4vLyApOiB1bmRlZmluZWQgfCBWMSB8IFYyXG4vLyBleHBvcnQgZnVuY3Rpb24gdG9wTW9zdDxLMSBleHRlbmRzIHN0cmluZywgSzIgZXh0ZW5kcyBzdHJpbmcsIEszIGV4dGVuZHMgc3RyaW5nLCBWMSwgVjIsIFYzPiAoXG4vLyAgIHBpbGU6IFJlY29yZDxLMSwgdW5kZWZpbmVkIHwgVjEgfCBSZWNvcmQ8SzIsIHVuZGVmaW5lZCB8IFYyIHwgUmVjb3JkPEszLCB1bmRlZmluZWQgfCBWMz4+PltdLFxuLy8gICBhY2Nlc3NvcnM6IFtLMSwgSzIsIEszXVxuLy8gKTogdW5kZWZpbmVkIHwgVjEgfCBWMiB8IFYzXG4vKipcclxuICogR2V0IHRoZSB0b3AgbW9zdCBwcm9wZXJ0eSB2YWx1ZSBmcm9tIGEgcGlsZSBvZiBvYmplY3RzLlxyXG4gKlxyXG4gKiBAcGFyYW0gcGlsZSAtIEFycmF5IG9mIG9iamVjdHMsIG5vIHJlcXVpcmVkIGZvcm1hdC5cclxuICogQHBhcmFtIGFjY2Vzc29ycyAtIEFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxyXG4gKiBGb3IgZXhhbXBsZSBgb2JqZWN0Wydmb28nXVsnYmFyJ11gIOKGkiBgWydmb28nLCAnYmFyJ11gLlxyXG4gKiBAcmV0dXJucyBWYWx1ZSBvZiB0aGUgcHJvcGVydHkgd2l0aCBnaXZlbiBhY2Nlc3NvcnMgcGF0aCBmcm9tIHRoZSBmaXJzdCBwaWxlIGl0ZW0gd2hlcmUgaXQncyBub3QgdW5kZWZpbmVkLlxyXG4gKi9cbmZ1bmN0aW9uIHRvcE1vc3QocGlsZSwgYWNjZXNzb3JzKSB7XG4gIHZhciBjYW5kaWRhdGU7XG4gIGlmICghX0FycmF5JGlzQXJyYXkoYWNjZXNzb3JzKSkge1xuICAgIGFjY2Vzc29ycyA9IFthY2Nlc3NvcnNdO1xuICB9XG4gIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNihwaWxlKSxcbiAgICBfc3RlcDM7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBtZW1iZXIgPSBfc3RlcDMudmFsdWU7XG4gICAgICBpZiAobWVtYmVyKSB7XG4gICAgICAgIGNhbmRpZGF0ZSA9IG1lbWJlclthY2Nlc3NvcnNbMF1dO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFjY2Vzc29ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChjYW5kaWRhdGUpIHtcbiAgICAgICAgICAgIGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZVthY2Nlc3NvcnNbaV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IzLmYoKTtcbiAgfVxuICByZXR1cm4gY2FuZGlkYXRlO1xufVxudmFyIGh0bWxDb2xvcnMgPSB7XG4gIGJsYWNrOiBcIiMwMDAwMDBcIixcbiAgbmF2eTogXCIjMDAwMDgwXCIsXG4gIGRhcmtibHVlOiBcIiMwMDAwOEJcIixcbiAgbWVkaXVtYmx1ZTogXCIjMDAwMENEXCIsXG4gIGJsdWU6IFwiIzAwMDBGRlwiLFxuICBkYXJrZ3JlZW46IFwiIzAwNjQwMFwiLFxuICBncmVlbjogXCIjMDA4MDAwXCIsXG4gIHRlYWw6IFwiIzAwODA4MFwiLFxuICBkYXJrY3lhbjogXCIjMDA4QjhCXCIsXG4gIGRlZXBza3libHVlOiBcIiMwMEJGRkZcIixcbiAgZGFya3R1cnF1b2lzZTogXCIjMDBDRUQxXCIsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiBcIiMwMEZBOUFcIixcbiAgbGltZTogXCIjMDBGRjAwXCIsXG4gIHNwcmluZ2dyZWVuOiBcIiMwMEZGN0ZcIixcbiAgYXF1YTogXCIjMDBGRkZGXCIsXG4gIGN5YW46IFwiIzAwRkZGRlwiLFxuICBtaWRuaWdodGJsdWU6IFwiIzE5MTk3MFwiLFxuICBkb2RnZXJibHVlOiBcIiMxRTkwRkZcIixcbiAgbGlnaHRzZWFncmVlbjogXCIjMjBCMkFBXCIsXG4gIGZvcmVzdGdyZWVuOiBcIiMyMjhCMjJcIixcbiAgc2VhZ3JlZW46IFwiIzJFOEI1N1wiLFxuICBkYXJrc2xhdGVncmF5OiBcIiMyRjRGNEZcIixcbiAgbGltZWdyZWVuOiBcIiMzMkNEMzJcIixcbiAgbWVkaXVtc2VhZ3JlZW46IFwiIzNDQjM3MVwiLFxuICB0dXJxdW9pc2U6IFwiIzQwRTBEMFwiLFxuICByb3lhbGJsdWU6IFwiIzQxNjlFMVwiLFxuICBzdGVlbGJsdWU6IFwiIzQ2ODJCNFwiLFxuICBkYXJrc2xhdGVibHVlOiBcIiM0ODNEOEJcIixcbiAgbWVkaXVtdHVycXVvaXNlOiBcIiM0OEQxQ0NcIixcbiAgaW5kaWdvOiBcIiM0QjAwODJcIixcbiAgZGFya29saXZlZ3JlZW46IFwiIzU1NkIyRlwiLFxuICBjYWRldGJsdWU6IFwiIzVGOUVBMFwiLFxuICBjb3JuZmxvd2VyYmx1ZTogXCIjNjQ5NUVEXCIsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFwiIzY2Q0RBQVwiLFxuICBkaW1ncmF5OiBcIiM2OTY5NjlcIixcbiAgc2xhdGVibHVlOiBcIiM2QTVBQ0RcIixcbiAgb2xpdmVkcmFiOiBcIiM2QjhFMjNcIixcbiAgc2xhdGVncmF5OiBcIiM3MDgwOTBcIixcbiAgbGlnaHRzbGF0ZWdyYXk6IFwiIzc3ODg5OVwiLFxuICBtZWRpdW1zbGF0ZWJsdWU6IFwiIzdCNjhFRVwiLFxuICBsYXduZ3JlZW46IFwiIzdDRkMwMFwiLFxuICBjaGFydHJldXNlOiBcIiM3RkZGMDBcIixcbiAgYXF1YW1hcmluZTogXCIjN0ZGRkQ0XCIsXG4gIG1hcm9vbjogXCIjODAwMDAwXCIsXG4gIHB1cnBsZTogXCIjODAwMDgwXCIsXG4gIG9saXZlOiBcIiM4MDgwMDBcIixcbiAgZ3JheTogXCIjODA4MDgwXCIsXG4gIHNreWJsdWU6IFwiIzg3Q0VFQlwiLFxuICBsaWdodHNreWJsdWU6IFwiIzg3Q0VGQVwiLFxuICBibHVldmlvbGV0OiBcIiM4QTJCRTJcIixcbiAgZGFya3JlZDogXCIjOEIwMDAwXCIsXG4gIGRhcmttYWdlbnRhOiBcIiM4QjAwOEJcIixcbiAgc2FkZGxlYnJvd246IFwiIzhCNDUxM1wiLFxuICBkYXJrc2VhZ3JlZW46IFwiIzhGQkM4RlwiLFxuICBsaWdodGdyZWVuOiBcIiM5MEVFOTBcIixcbiAgbWVkaXVtcHVycGxlOiBcIiM5MzcwRDhcIixcbiAgZGFya3Zpb2xldDogXCIjOTQwMEQzXCIsXG4gIHBhbGVncmVlbjogXCIjOThGQjk4XCIsXG4gIGRhcmtvcmNoaWQ6IFwiIzk5MzJDQ1wiLFxuICB5ZWxsb3dncmVlbjogXCIjOUFDRDMyXCIsXG4gIHNpZW5uYTogXCIjQTA1MjJEXCIsXG4gIGJyb3duOiBcIiNBNTJBMkFcIixcbiAgZGFya2dyYXk6IFwiI0E5QTlBOVwiLFxuICBsaWdodGJsdWU6IFwiI0FERDhFNlwiLFxuICBncmVlbnllbGxvdzogXCIjQURGRjJGXCIsXG4gIHBhbGV0dXJxdW9pc2U6IFwiI0FGRUVFRVwiLFxuICBsaWdodHN0ZWVsYmx1ZTogXCIjQjBDNERFXCIsXG4gIHBvd2RlcmJsdWU6IFwiI0IwRTBFNlwiLFxuICBmaXJlYnJpY2s6IFwiI0IyMjIyMlwiLFxuICBkYXJrZ29sZGVucm9kOiBcIiNCODg2MEJcIixcbiAgbWVkaXVtb3JjaGlkOiBcIiNCQTU1RDNcIixcbiAgcm9zeWJyb3duOiBcIiNCQzhGOEZcIixcbiAgZGFya2toYWtpOiBcIiNCREI3NkJcIixcbiAgc2lsdmVyOiBcIiNDMEMwQzBcIixcbiAgbWVkaXVtdmlvbGV0cmVkOiBcIiNDNzE1ODVcIixcbiAgaW5kaWFucmVkOiBcIiNDRDVDNUNcIixcbiAgcGVydTogXCIjQ0Q4NTNGXCIsXG4gIGNob2NvbGF0ZTogXCIjRDI2OTFFXCIsXG4gIHRhbjogXCIjRDJCNDhDXCIsXG4gIGxpZ2h0Z3JleTogXCIjRDNEM0QzXCIsXG4gIHBhbGV2aW9sZXRyZWQ6IFwiI0Q4NzA5M1wiLFxuICB0aGlzdGxlOiBcIiNEOEJGRDhcIixcbiAgb3JjaGlkOiBcIiNEQTcwRDZcIixcbiAgZ29sZGVucm9kOiBcIiNEQUE1MjBcIixcbiAgY3JpbXNvbjogXCIjREMxNDNDXCIsXG4gIGdhaW5zYm9ybzogXCIjRENEQ0RDXCIsXG4gIHBsdW06IFwiI0REQTBERFwiLFxuICBidXJseXdvb2Q6IFwiI0RFQjg4N1wiLFxuICBsaWdodGN5YW46IFwiI0UwRkZGRlwiLFxuICBsYXZlbmRlcjogXCIjRTZFNkZBXCIsXG4gIGRhcmtzYWxtb246IFwiI0U5OTY3QVwiLFxuICB2aW9sZXQ6IFwiI0VFODJFRVwiLFxuICBwYWxlZ29sZGVucm9kOiBcIiNFRUU4QUFcIixcbiAgbGlnaHRjb3JhbDogXCIjRjA4MDgwXCIsXG4gIGtoYWtpOiBcIiNGMEU2OENcIixcbiAgYWxpY2VibHVlOiBcIiNGMEY4RkZcIixcbiAgaG9uZXlkZXc6IFwiI0YwRkZGMFwiLFxuICBhenVyZTogXCIjRjBGRkZGXCIsXG4gIHNhbmR5YnJvd246IFwiI0Y0QTQ2MFwiLFxuICB3aGVhdDogXCIjRjVERUIzXCIsXG4gIGJlaWdlOiBcIiNGNUY1RENcIixcbiAgd2hpdGVzbW9rZTogXCIjRjVGNUY1XCIsXG4gIG1pbnRjcmVhbTogXCIjRjVGRkZBXCIsXG4gIGdob3N0d2hpdGU6IFwiI0Y4RjhGRlwiLFxuICBzYWxtb246IFwiI0ZBODA3MlwiLFxuICBhbnRpcXVld2hpdGU6IFwiI0ZBRUJEN1wiLFxuICBsaW5lbjogXCIjRkFGMEU2XCIsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBcIiNGQUZBRDJcIixcbiAgb2xkbGFjZTogXCIjRkRGNUU2XCIsXG4gIHJlZDogXCIjRkYwMDAwXCIsXG4gIGZ1Y2hzaWE6IFwiI0ZGMDBGRlwiLFxuICBtYWdlbnRhOiBcIiNGRjAwRkZcIixcbiAgZGVlcHBpbms6IFwiI0ZGMTQ5M1wiLFxuICBvcmFuZ2VyZWQ6IFwiI0ZGNDUwMFwiLFxuICB0b21hdG86IFwiI0ZGNjM0N1wiLFxuICBob3RwaW5rOiBcIiNGRjY5QjRcIixcbiAgY29yYWw6IFwiI0ZGN0Y1MFwiLFxuICBkYXJrb3JhbmdlOiBcIiNGRjhDMDBcIixcbiAgbGlnaHRzYWxtb246IFwiI0ZGQTA3QVwiLFxuICBvcmFuZ2U6IFwiI0ZGQTUwMFwiLFxuICBsaWdodHBpbms6IFwiI0ZGQjZDMVwiLFxuICBwaW5rOiBcIiNGRkMwQ0JcIixcbiAgZ29sZDogXCIjRkZENzAwXCIsXG4gIHBlYWNocHVmZjogXCIjRkZEQUI5XCIsXG4gIG5hdmFqb3doaXRlOiBcIiNGRkRFQURcIixcbiAgbW9jY2FzaW46IFwiI0ZGRTRCNVwiLFxuICBiaXNxdWU6IFwiI0ZGRTRDNFwiLFxuICBtaXN0eXJvc2U6IFwiI0ZGRTRFMVwiLFxuICBibGFuY2hlZGFsbW9uZDogXCIjRkZFQkNEXCIsXG4gIHBhcGF5YXdoaXA6IFwiI0ZGRUZENVwiLFxuICBsYXZlbmRlcmJsdXNoOiBcIiNGRkYwRjVcIixcbiAgc2Vhc2hlbGw6IFwiI0ZGRjVFRVwiLFxuICBjb3Juc2lsazogXCIjRkZGOERDXCIsXG4gIGxlbW9uY2hpZmZvbjogXCIjRkZGQUNEXCIsXG4gIGZsb3JhbHdoaXRlOiBcIiNGRkZBRjBcIixcbiAgc25vdzogXCIjRkZGQUZBXCIsXG4gIHllbGxvdzogXCIjRkZGRjAwXCIsXG4gIGxpZ2h0eWVsbG93OiBcIiNGRkZGRTBcIixcbiAgaXZvcnk6IFwiI0ZGRkZGMFwiLFxuICB3aGl0ZTogXCIjRkZGRkZGXCJcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IFtwaXhlbFJhdGlvPTFdXG4gKi9cbnZhciBDb2xvclBpY2tlciQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcGl4ZWxSYXRpbz0xXVxuICAgKi9cbiAgZnVuY3Rpb24gQ29sb3JQaWNrZXIoKSB7XG4gICAgdmFyIHBpeGVsUmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbG9yUGlja2VyKTtcbiAgICB0aGlzLnBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIHRoaXMuZ2VuZXJhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5jZW50ZXJDb29yZGluYXRlcyA9IHtcbiAgICAgIHg6IDI4OSAvIDIsXG4gICAgICB5OiAyODkgLyAyXG4gICAgfTtcbiAgICB0aGlzLnIgPSAyODkgKiAwLjQ5O1xuICAgIHRoaXMuY29sb3IgPSB7XG4gICAgICByOiAyNTUsXG4gICAgICBnOiAyNTUsXG4gICAgICBiOiAyNTUsXG4gICAgICBhOiAxLjBcbiAgICB9O1xuICAgIHRoaXMuaHVlQ2lyY2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5pdGlhbENvbG9yID0ge1xuICAgICAgcjogMjU1LFxuICAgICAgZzogMjU1LFxuICAgICAgYjogMjU1LFxuICAgICAgYTogMS4wXG4gICAgfTtcbiAgICB0aGlzLnByZXZpb3VzQ29sb3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG5cbiAgICAvLyBib3VuZCBieVxuICAgIHRoaXMudXBkYXRlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICB0aGlzLmNsb3NlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGNyZWF0ZSBhbGwgRE9NIGVsZW1lbnRzXG4gICAgdGhpcy5fY3JlYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogdGhpcyBpbnNlcnRzIHRoZSBjb2xvclBpY2tlciBpbnRvIGEgZGl2IGZyb20gdGhlIERPTVxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lclxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKENvbG9yUGlja2VyLCBbe1xuICAgIGtleTogXCJpbnNlcnRUb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbnNlcnRUbyhjb250YWluZXIpIHtcbiAgICAgIGlmICh0aGlzLmhhbW1lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5oYW1tZXIgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZnJhbWUpO1xuICAgICAgdGhpcy5fYmluZEhhbW1lcigpO1xuICAgICAgdGhpcy5fc2V0U2l6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZCBvbiBhcHBseSBhbmQgc2F2ZS4gQmluZCBpdCB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VXBkYXRlQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VXBkYXRlQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiBhdHRlbXB0ZWQgdG8gc2V0IGFzIGNvbG9yUGlja2VyIHVwZGF0ZSBjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvbi5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhlIGNhbGxiYWNrIGlzIGV4ZWN1dGVkIG9uIGFwcGx5IGFuZCBzYXZlLiBCaW5kIGl0IHRvIHRoZSBhcHBsaWNhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRDbG9zZUNhbGxiYWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENsb3NlQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLmNsb3NlQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIGF0dGVtcHRlZCB0byBzZXQgYXMgY29sb3JQaWNrZXIgY2xvc2luZyBjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvbi5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzQ29sb3JTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzQ29sb3JTdHJpbmcoY29sb3IpIHtcbiAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGh0bWxDb2xvcnNbY29sb3JdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29sb3Igb2YgdGhlIGNvbG9yUGlja2VyXG4gICAgICogU3VwcG9ydGVkIGZvcm1hdHM6XG4gICAgICogJ3JlZCcgICAgICAgICAgICAgICAgICAgLS0+IEhUTUwgY29sb3Igc3RyaW5nXG4gICAgICogJyNmZmZmZmYnICAgICAgICAgICAgICAgLS0+IGhleCBzdHJpbmdcbiAgICAgKiAncmdiKDI1NSwyNTUsMjU1KScgICAgICAtLT4gcmdiIHN0cmluZ1xuICAgICAqICdyZ2JhKDI1NSwyNTUsMjU1LDEuMCknIC0tPiByZ2JhIHN0cmluZ1xuICAgICAqIHtyOjI1NSxnOjI1NSxiOjI1NX0gICAgIC0tPiByZ2Igb2JqZWN0XG4gICAgICoge3I6MjU1LGc6MjU1LGI6MjU1LGE6MS4wfSAtLT4gcmdiYSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgb2JqZWN0fSBjb2xvclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NldEluaXRpYWw9dHJ1ZV1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb2xvcihjb2xvcikge1xuICAgICAgdmFyIHNldEluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICBpZiAoY29sb3IgPT09IFwibm9uZVwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByZ2JhO1xuXG4gICAgICAvLyBpZiBhIGh0bWwgY29sb3Igc2hvcnRoYW5kIGlzIHVzZWQsIGNvbnZlcnQgdG8gaGV4XG4gICAgICB2YXIgaHRtbENvbG9yID0gdGhpcy5faXNDb2xvclN0cmluZyhjb2xvcik7XG4gICAgICBpZiAoaHRtbENvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29sb3IgPSBodG1sQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGZvcm1hdFxuICAgICAgaWYgKGlzU3RyaW5nKGNvbG9yKSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNWYWxpZFJHQihjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgcmdiYUFycmF5ID0gY29sb3Iuc3Vic3RyKDQpLnN1YnN0cigwLCBjb2xvci5sZW5ndGggLSA1KS5zcGxpdChcIixcIik7XG4gICAgICAgICAgcmdiYSA9IHtcbiAgICAgICAgICAgIHI6IHJnYmFBcnJheVswXSxcbiAgICAgICAgICAgIGc6IHJnYmFBcnJheVsxXSxcbiAgICAgICAgICAgIGI6IHJnYmFBcnJheVsyXSxcbiAgICAgICAgICAgIGE6IDEuMFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNWYWxpZFJHQkEoY29sb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgdmFyIF9yZ2JhQXJyYXkgPSBjb2xvci5zdWJzdHIoNSkuc3Vic3RyKDAsIGNvbG9yLmxlbmd0aCAtIDYpLnNwbGl0KFwiLFwiKTtcbiAgICAgICAgICByZ2JhID0ge1xuICAgICAgICAgICAgcjogX3JnYmFBcnJheVswXSxcbiAgICAgICAgICAgIGc6IF9yZ2JhQXJyYXlbMV0sXG4gICAgICAgICAgICBiOiBfcmdiYUFycmF5WzJdLFxuICAgICAgICAgICAgYTogX3JnYmFBcnJheVszXVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNWYWxpZEhleChjb2xvcikgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgcmdiT2JqID0gaGV4VG9SR0IoY29sb3IpO1xuICAgICAgICAgIHJnYmEgPSB7XG4gICAgICAgICAgICByOiByZ2JPYmoucixcbiAgICAgICAgICAgIGc6IHJnYk9iai5nLFxuICAgICAgICAgICAgYjogcmdiT2JqLmIsXG4gICAgICAgICAgICBhOiAxLjBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29sb3IgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICBpZiAoY29sb3IuciAhPT0gdW5kZWZpbmVkICYmIGNvbG9yLmcgIT09IHVuZGVmaW5lZCAmJiBjb2xvci5iICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGNvbG9yLmEgIT09IHVuZGVmaW5lZCA/IGNvbG9yLmEgOiBcIjEuMFwiO1xuICAgICAgICAgICAgcmdiYSA9IHtcbiAgICAgICAgICAgICAgcjogY29sb3IucixcbiAgICAgICAgICAgICAgZzogY29sb3IuZyxcbiAgICAgICAgICAgICAgYjogY29sb3IuYixcbiAgICAgICAgICAgICAgYTogYWxwaGFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBjb2xvclxuICAgICAgaWYgKHJnYmEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvbG9yIHBhc3NlZCB0byB0aGUgY29sb3JQaWNrZXIuIFN1cHBvcnRlZCBhcmUgc3RyaW5nczogcmdiLCBoZXgsIHJnYmEuIE9iamVjdDogcmdiICh7cjpyLGc6ZyxiOmIsW2E6YV19KS4gU3VwcGxpZWQ6IFwiICsgX0pTT04kc3RyaW5naWZ5KGNvbG9yKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRDb2xvcihyZ2JhLCBzZXRJbml0aWFsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0aGlzIHNob3dzIHRoZSBjb2xvciBwaWNrZXIuXG4gICAgICogVGhlIGh1ZSBjaXJjbGUgaXMgY29uc3RydWN0ZWQgb25jZSBhbmQgc3RvcmVkLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNob3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIGlmICh0aGlzLmNsb3NlQ2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNsb3NlQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy5jbG9zZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICB0aGlzLl9nZW5lcmF0ZUh1ZUNpcmNsZSgpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBQUklWQVRFIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbiAgICAvKipcbiAgICAgKiBIaWRlIHRoZSBwaWNrZXIuIElzIGNhbGxlZCBieSB0aGUgY2FuY2VsIGJ1dHRvbi5cbiAgICAgKiBPcHRpb25hbCBib29sZWFuIHRvIHN0b3JlIHRoZSBwcmV2aW91cyBjb2xvciBmb3IgZWFzeSBhY2Nlc3MgbGF0ZXIgb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzdG9yZVByZXZpb3VzPXRydWVdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfaGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGlkZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIHN0b3JlUHJldmlvdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICAvLyBzdG9yZSB0aGUgcHJldmlvdXMgY29sb3IgZm9yIG5leHQgdGltZTtcbiAgICAgIGlmIChzdG9yZVByZXZpb3VzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNDb2xvciA9IF9PYmplY3QkYXNzaWduKHt9LCB0aGlzLmNvbG9yKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmFwcGxpZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDYWxsYmFjayh0aGlzLmluaXRpYWxDb2xvcik7XG4gICAgICB9XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuICAgICAgLy8gY2FsbCB0aGUgY2xvc2luZyBjYWxsYmFjaywgcmVzdG9yaW5nIHRoZSBvbmNsaWNrIG1ldGhvZC5cbiAgICAgIC8vIHRoaXMgaXMgaW4gYSBzZXRUaW1lb3V0IGJlY2F1c2UgaXQgd2lsbCB0cmlnZ2VyIHRoZSBzaG93IGFnYWluIGJlZm9yZSB0aGUgY2xpY2sgaXMgZG9uZS5cbiAgICAgIF9zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzMi5jbG9zZUNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBfdGhpczIuY2xvc2VDYWxsYmFjaygpO1xuICAgICAgICAgIF90aGlzMi5jbG9zZUNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBib3VuZCB0byB0aGUgc2F2ZSBidXR0b24uIFNhdmVzIGFuZCBoaWRlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NhdmUoKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMuY29sb3IpO1xuICAgICAgdGhpcy5hcHBsaWVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9oaWRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQm91bmQgdG8gYXBwbHkgYnV0dG9uLiBTYXZlcyBidXQgZG9lcyBub3QgY2xvc2UuIElzIHVuZG9uZSBieSB0aGUgY2FuY2VsIGJ1dHRvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBseSgpIHtcbiAgICAgIHRoaXMuYXBwbGllZCA9IHRydWU7XG4gICAgICB0aGlzLnVwZGF0ZUNhbGxiYWNrKHRoaXMuY29sb3IpO1xuICAgICAgdGhpcy5fdXBkYXRlUGlja2VyKHRoaXMuY29sb3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGxvYWQgdGhlIGNvbG9yIGZyb20gdGhlIHByZXZpb3VzIHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9sb2FkTGFzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbG9hZExhc3QoKSB7XG4gICAgICBpZiAodGhpcy5wcmV2aW91c0NvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5zZXRDb2xvcih0aGlzLnByZXZpb3VzQ29sb3IsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFsZXJ0KFwiVGhlcmUgaXMgbm8gbGFzdCBjb2xvciB0byBsb2FkLi4uXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgY29sb3IsIHBsYWNlIHRoZSBwaWNrZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZ2JhXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2V0SW5pdGlhbD10cnVlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldENvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRDb2xvcihyZ2JhKSB7XG4gICAgICB2YXIgc2V0SW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIC8vIHN0b3JlIHRoZSBpbml0aWFsIGNvbG9yXG4gICAgICBpZiAoc2V0SW5pdGlhbCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmluaXRpYWxDb2xvciA9IF9PYmplY3QkYXNzaWduKHt9LCByZ2JhKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29sb3IgPSByZ2JhO1xuICAgICAgdmFyIGhzdiA9IFJHQlRvSFNWKHJnYmEuciwgcmdiYS5nLCByZ2JhLmIpO1xuICAgICAgdmFyIGFuZ2xlQ29udmVydCA9IDIgKiBNYXRoLlBJO1xuICAgICAgdmFyIHJhZGl1cyA9IHRoaXMuciAqIGhzdi5zO1xuICAgICAgdmFyIHggPSB0aGlzLmNlbnRlckNvb3JkaW5hdGVzLnggKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZUNvbnZlcnQgKiBoc3YuaCk7XG4gICAgICB2YXIgeSA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSArIHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlQ29udmVydCAqIGhzdi5oKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS5sZWZ0ID0geCAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRXaWR0aCArIFwicHhcIjtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS50b3AgPSB5IC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudEhlaWdodCArIFwicHhcIjtcbiAgICAgIHRoaXMuX3VwZGF0ZVBpY2tlcihyZ2JhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBib3VuZCB0byBvcGFjaXR5IGNvbnRyb2xcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldE9wYWNpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldE9wYWNpdHkodmFsdWUpIHtcbiAgICAgIHRoaXMuY29sb3IuYSA9IHZhbHVlIC8gMTAwO1xuICAgICAgdGhpcy5fdXBkYXRlUGlja2VyKHRoaXMuY29sb3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGJvdW5kIHRvIGJyaWdodG5lc3MgY29udHJvbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfc2V0QnJpZ2h0bmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0QnJpZ2h0bmVzcyh2YWx1ZSkge1xuICAgICAgdmFyIGhzdiA9IFJHQlRvSFNWKHRoaXMuY29sb3IuciwgdGhpcy5jb2xvci5nLCB0aGlzLmNvbG9yLmIpO1xuICAgICAgaHN2LnYgPSB2YWx1ZSAvIDEwMDtcbiAgICAgIHZhciByZ2JhID0gSFNWVG9SR0IoaHN2LmgsIGhzdi5zLCBoc3Yudik7XG4gICAgICByZ2JhW1wiYVwiXSA9IHRoaXMuY29sb3IuYTtcbiAgICAgIHRoaXMuY29sb3IgPSByZ2JhO1xuICAgICAgdGhpcy5fdXBkYXRlUGlja2VyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBjb2xvciBwaWNrZXIuIEEgYmxhY2sgY2lyY2xlIG92ZXJsYXlzIHRoZSBodWUgY2lyY2xlIHRvIG1pbWljIHRoZSBicmlnaHRuZXNzIGRlY3JlYXNpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmdiYVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVBpY2tlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlUGlja2VyKCkge1xuICAgICAgdmFyIHJnYmEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuY29sb3I7XG4gICAgICB2YXIgaHN2ID0gUkdCVG9IU1YocmdiYS5yLCByZ2JhLmcsIHJnYmEuYik7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBpZiAodGhpcy5waXhlbFJhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIChjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxKTtcbiAgICAgIH1cbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuXG4gICAgICAvLyBjbGVhciB0aGUgY2FudmFzXG4gICAgICB2YXIgdyA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICB2YXIgaCA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEodGhpcy5odWVDaXJjbGUsIDAsIDApO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYSgwLDAsMCxcIiArICgxIC0gaHN2LnYpICsgXCIpXCI7XG4gICAgICBjdHguY2lyY2xlKHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCwgdGhpcy5jZW50ZXJDb29yZGluYXRlcy55LCB0aGlzLnIpO1xuICAgICAgX2ZpbGxJbnN0YW5jZVByb3BlcnR5KGN0eCkuY2FsbChjdHgpO1xuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UudmFsdWUgPSAxMDAgKiBoc3YudjtcbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlLnZhbHVlID0gMTAwICogcmdiYS5hO1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKFwiICsgdGhpcy5pbml0aWFsQ29sb3IuciArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuZyArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuYiArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuYSArIFwiKVwiO1xuICAgICAgdGhpcy5uZXdDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInJnYmEoXCIgKyB0aGlzLmNvbG9yLnIgKyBcIixcIiArIHRoaXMuY29sb3IuZyArIFwiLFwiICsgdGhpcy5jb2xvci5iICsgXCIsXCIgKyB0aGlzLmNvbG9yLmEgKyBcIilcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1c2VkIGJ5IGNyZWF0ZSB0byBzZXQgdGhlIHNpemUgb2YgdGhlIGNhbnZhcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFNpemUoKSB7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyQ2FudmFzLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy53aWR0aCA9IDI4OSAqIHRoaXMucGl4ZWxSYXRpbztcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJDYW52YXMuaGVpZ2h0ID0gMjg5ICogdGhpcy5waXhlbFJhdGlvO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhbGwgZG9tIGVsZW1lbnRzXG4gICAgICogVE9ETzogY2xlYW51cCwgbG90cyBvZiBzaW1pbGFyIGRvbSBlbGVtZW50c1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGUoKSB7XG4gICAgICB2YXIgX2NvbnRleHQxMiwgX2NvbnRleHQxMywgX2NvbnRleHQxNCwgX2NvbnRleHQxNTtcbiAgICAgIHRoaXMuZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5mcmFtZS5jbGFzc05hbWUgPSBcInZpcy1jb2xvci1waWNrZXJcIjtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGFzc05hbWUgPSBcInZpcy1zZWxlY3RvclwiO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckRpdi5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3IpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyRGl2LmFwcGVuZENoaWxkKHRoaXMuY29sb3JQaWNrZXJDYW52YXMpO1xuICAgICAgaWYgKCF0aGlzLmNvbG9yUGlja2VyQ2FudmFzLmdldENvbnRleHQpIHtcbiAgICAgICAgdmFyIG5vQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkRJVlwiKTtcbiAgICAgICAgbm9DYW52YXMuc3R5bGUuY29sb3IgPSBcInJlZFwiO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5mb250V2VpZ2h0ID0gXCJib2xkXCI7XG4gICAgICAgIG5vQ2FudmFzLnN0eWxlLnBhZGRpbmcgPSBcIjEwcHhcIjtcbiAgICAgICAgbm9DYW52YXMuaW5uZXJUZXh0ID0gXCJFcnJvcjogeW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgSFRNTCBjYW52YXNcIjtcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5hcHBlbmRDaGlsZChub0NhbnZhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIHRoaXMucGl4ZWxSYXRpbyA9ICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIChjdHgud2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8IGN0eC5vQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxKTtcbiAgICAgICAgdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIikuc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29sb3JQaWNrZXJEaXYuY2xhc3NOYW1lID0gXCJ2aXMtY29sb3JcIjtcbiAgICAgIHRoaXMub3BhY2l0eURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLm9wYWNpdHlEaXYuY2xhc3NOYW1lID0gXCJ2aXMtb3BhY2l0eVwiO1xuICAgICAgdGhpcy5icmlnaHRuZXNzRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc0Rpdi5jbGFzc05hbWUgPSBcInZpcy1icmlnaHRuZXNzXCI7XG4gICAgICB0aGlzLmFycm93RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuYXJyb3dEaXYuY2xhc3NOYW1lID0gXCJ2aXMtYXJyb3dcIjtcbiAgICAgIHRoaXMub3BhY2l0eVJhbmdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UudHlwZSA9IFwicmFuZ2VcIjsgLy8gTm90IHN1cHBvcnRlZCBvbiBJRTlcbiAgICAgICAgdGhpcy5vcGFjaXR5UmFuZ2UubWluID0gXCIwXCI7XG4gICAgICAgIHRoaXMub3BhY2l0eVJhbmdlLm1heCA9IFwiMTAwXCI7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gVE9ETzogQWRkIHNvbWUgZXJyb3IgaGFuZGxpbmcuXG4gICAgICB9XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS52YWx1ZSA9IFwiMTAwXCI7XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS5jbGFzc05hbWUgPSBcInZpcy1yYW5nZVwiO1xuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS50eXBlID0gXCJyYW5nZVwiOyAvLyBOb3Qgc3VwcG9ydGVkIG9uIElFOVxuICAgICAgICB0aGlzLmJyaWdodG5lc3NSYW5nZS5taW4gPSBcIjBcIjtcbiAgICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2UubWF4ID0gXCIxMDBcIjtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBUT0RPOiBBZGQgc29tZSBlcnJvciBoYW5kbGluZy5cbiAgICAgIH1cbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLnZhbHVlID0gXCIxMDBcIjtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLmNsYXNzTmFtZSA9IFwidmlzLXJhbmdlXCI7XG4gICAgICB0aGlzLm9wYWNpdHlEaXYuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5UmFuZ2UpO1xuICAgICAgdGhpcy5icmlnaHRuZXNzRGl2LmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc1JhbmdlKTtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICB0aGlzLm9wYWNpdHlSYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3NldE9wYWNpdHkodGhpcy52YWx1ZSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5vcGFjaXR5UmFuZ2Uub25pbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3NldE9wYWNpdHkodGhpcy52YWx1ZSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5icmlnaHRuZXNzUmFuZ2Uub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLl9zZXRCcmlnaHRuZXNzKHRoaXMudmFsdWUpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc1JhbmdlLm9uaW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLl9zZXRCcmlnaHRuZXNzKHRoaXMudmFsdWUpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc0xhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuYnJpZ2h0bmVzc0xhYmVsLmNsYXNzTmFtZSA9IFwidmlzLWxhYmVsIHZpcy1icmlnaHRuZXNzXCI7XG4gICAgICB0aGlzLmJyaWdodG5lc3NMYWJlbC5pbm5lclRleHQgPSBcImJyaWdodG5lc3M6XCI7XG4gICAgICB0aGlzLm9wYWNpdHlMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLm9wYWNpdHlMYWJlbC5jbGFzc05hbWUgPSBcInZpcy1sYWJlbCB2aXMtb3BhY2l0eVwiO1xuICAgICAgdGhpcy5vcGFjaXR5TGFiZWwuaW5uZXJUZXh0ID0gXCJvcGFjaXR5OlwiO1xuICAgICAgdGhpcy5uZXdDb2xvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLm5ld0NvbG9yRGl2LmNsYXNzTmFtZSA9IFwidmlzLW5ldy1jb2xvclwiO1xuICAgICAgdGhpcy5uZXdDb2xvckRpdi5pbm5lclRleHQgPSBcIm5ld1wiO1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuY2xhc3NOYW1lID0gXCJ2aXMtaW5pdGlhbC1jb2xvclwiO1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuaW5uZXJUZXh0ID0gXCJpbml0aWFsXCI7XG4gICAgICB0aGlzLmNhbmNlbEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmNhbmNlbEJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gdmlzLWNhbmNlbFwiO1xuICAgICAgdGhpcy5jYW5jZWxCdXR0b24uaW5uZXJUZXh0ID0gXCJjYW5jZWxcIjtcbiAgICAgIHRoaXMuY2FuY2VsQnV0dG9uLm9uY2xpY2sgPSBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDEyID0gdGhpcy5faGlkZSkuY2FsbChfY29udGV4dDEyLCB0aGlzLCBmYWxzZSk7XG4gICAgICB0aGlzLmFwcGx5QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuYXBwbHlCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1hcHBseVwiO1xuICAgICAgdGhpcy5hcHBseUJ1dHRvbi5pbm5lclRleHQgPSBcImFwcGx5XCI7XG4gICAgICB0aGlzLmFwcGx5QnV0dG9uLm9uY2xpY2sgPSBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDEzID0gdGhpcy5fYXBwbHkpLmNhbGwoX2NvbnRleHQxMywgdGhpcyk7XG4gICAgICB0aGlzLnNhdmVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5zYXZlQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWJ1dHRvbiB2aXMtc2F2ZVwiO1xuICAgICAgdGhpcy5zYXZlQnV0dG9uLmlubmVyVGV4dCA9IFwic2F2ZVwiO1xuICAgICAgdGhpcy5zYXZlQnV0dG9uLm9uY2xpY2sgPSBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDE0ID0gdGhpcy5fc2F2ZSkuY2FsbChfY29udGV4dDE0LCB0aGlzKTtcbiAgICAgIHRoaXMubG9hZEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmxvYWRCdXR0b24uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1sb2FkXCI7XG4gICAgICB0aGlzLmxvYWRCdXR0b24uaW5uZXJUZXh0ID0gXCJsb2FkIGxhc3RcIjtcbiAgICAgIHRoaXMubG9hZEJ1dHRvbi5vbmNsaWNrID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxNSA9IHRoaXMuX2xvYWRMYXN0KS5jYWxsKF9jb250ZXh0MTUsIHRoaXMpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNvbG9yUGlja2VyRGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5hcnJvd0Rpdik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYnJpZ2h0bmVzc0xhYmVsKTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5icmlnaHRuZXNzRGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5vcGFjaXR5TGFiZWwpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm9wYWNpdHlEaXYpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm5ld0NvbG9yRGl2KTtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5pbml0aWFsQ29sb3JEaXYpO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmNhbmNlbEJ1dHRvbik7XG4gICAgICB0aGlzLmZyYW1lLmFwcGVuZENoaWxkKHRoaXMuYXBwbHlCdXR0b24pO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLnNhdmVCdXR0b24pO1xuICAgICAgdGhpcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLmxvYWRCdXR0b24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGJpbmQgaGFtbWVyIHRvIHRoZSBjb2xvciBwaWNrZXJcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2JpbmRIYW1tZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRIYW1tZXIoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHRoaXMuZHJhZyA9IHt9O1xuICAgICAgdGhpcy5waW5jaCA9IHt9O1xuICAgICAgdGhpcy5oYW1tZXIgPSBuZXcgSGFtbWVyJDEodGhpcy5jb2xvclBpY2tlckNhbnZhcyk7XG4gICAgICB0aGlzLmhhbW1lci5nZXQoXCJwaW5jaFwiKS5zZXQoe1xuICAgICAgICBlbmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJoYW1tZXIuaW5wdXRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5pc0ZpcnN0KSB7XG4gICAgICAgICAgX3RoaXMzLl9tb3ZlU2VsZWN0b3IoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwidGFwXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwicGFuc3RhcnRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5fbW92ZVNlbGVjdG9yKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJwYW5tb3ZlXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwicGFuZW5kXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuX21vdmVTZWxlY3RvcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSB0aGUgaHVlIGNpcmNsZS4gVGhpcyBpcyByZWxhdGl2ZWx5IGhlYXZ5ICgyMDBtcykgYW5kIGlzIGRvbmUgb25seSBvbmNlIG9uIHRoZSBmaXJzdCB0aW1lIGl0IGlzIHNob3duLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2VuZXJhdGVIdWVDaXJjbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlSHVlQ2lyY2xlKCkge1xuICAgICAgaWYgKHRoaXMuZ2VuZXJhdGVkID09PSBmYWxzZSkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIGlmICh0aGlzLnBpeGVsUmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBpeGVsUmF0aW8gPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyAoY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLnBpeGVsUmF0aW8sIDAsIDAsIHRoaXMucGl4ZWxSYXRpbywgMCwgMCk7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGNhbnZhc1xuICAgICAgICB2YXIgdyA9IHRoaXMuY29sb3JQaWNrZXJDYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBoID0gdGhpcy5jb2xvclBpY2tlckNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG5cbiAgICAgICAgLy8gZHJhdyBodWUgY2lyY2xlXG4gICAgICAgIHZhciB4LCB5LCBodWUsIHNhdDtcbiAgICAgICAgdGhpcy5jZW50ZXJDb29yZGluYXRlcyA9IHtcbiAgICAgICAgICB4OiB3ICogMC41LFxuICAgICAgICAgIHk6IGggKiAwLjVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yID0gMC40OSAqIHc7XG4gICAgICAgIHZhciBhbmdsZUNvbnZlcnQgPSAyICogTWF0aC5QSSAvIDM2MDtcbiAgICAgICAgdmFyIGhmYWMgPSAxIC8gMzYwO1xuICAgICAgICB2YXIgc2ZhYyA9IDEgLyB0aGlzLnI7XG4gICAgICAgIHZhciByZ2I7XG4gICAgICAgIGZvciAoaHVlID0gMDsgaHVlIDwgMzYwOyBodWUrKykge1xuICAgICAgICAgIGZvciAoc2F0ID0gMDsgc2F0IDwgdGhpcy5yOyBzYXQrKykge1xuICAgICAgICAgICAgeCA9IHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueCArIHNhdCAqIE1hdGguc2luKGFuZ2xlQ29udmVydCAqIGh1ZSk7XG4gICAgICAgICAgICB5ID0gdGhpcy5jZW50ZXJDb29yZGluYXRlcy55ICsgc2F0ICogTWF0aC5jb3MoYW5nbGVDb252ZXJ0ICogaHVlKTtcbiAgICAgICAgICAgIHJnYiA9IEhTVlRvUkdCKGh1ZSAqIGhmYWMsIHNhdCAqIHNmYWMsIDEpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiKFwiICsgcmdiLnIgKyBcIixcIiArIHJnYi5nICsgXCIsXCIgKyByZ2IuYiArIFwiKVwiO1xuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHggLSAwLjUsIHkgLSAwLjUsIDIsIDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJnYmEoMCwwLDAsMSlcIjtcbiAgICAgICAgY3R4LmNpcmNsZSh0aGlzLmNlbnRlckNvb3JkaW5hdGVzLngsIHRoaXMuY2VudGVyQ29vcmRpbmF0ZXMueSwgdGhpcy5yKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB0aGlzLmh1ZUNpcmNsZSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdywgaCk7XG4gICAgICB9XG4gICAgICB0aGlzLmdlbmVyYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbW92ZSB0aGUgc2VsZWN0b3IuIFRoaXMgaXMgY2FsbGVkIGJ5IGhhbW1lciBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9tb3ZlU2VsZWN0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVTZWxlY3RvcihldmVudCkge1xuICAgICAgdmFyIHJlY3QgPSB0aGlzLmNvbG9yUGlja2VyRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGxlZnQgPSBldmVudC5jZW50ZXIueCAtIHJlY3QubGVmdDtcbiAgICAgIHZhciB0b3AgPSBldmVudC5jZW50ZXIueSAtIHJlY3QudG9wO1xuICAgICAgdmFyIGNlbnRlclkgPSAwLjUgKiB0aGlzLmNvbG9yUGlja2VyRGl2LmNsaWVudEhlaWdodDtcbiAgICAgIHZhciBjZW50ZXJYID0gMC41ICogdGhpcy5jb2xvclBpY2tlckRpdi5jbGllbnRXaWR0aDtcbiAgICAgIHZhciB4ID0gbGVmdCAtIGNlbnRlclg7XG4gICAgICB2YXIgeSA9IHRvcCAtIGNlbnRlclk7XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHgsIHkpO1xuICAgICAgdmFyIHJhZGl1cyA9IDAuOTggKiBNYXRoLm1pbihNYXRoLnNxcnQoeCAqIHggKyB5ICogeSksIGNlbnRlclgpO1xuICAgICAgdmFyIG5ld1RvcCA9IE1hdGguY29zKGFuZ2xlKSAqIHJhZGl1cyArIGNlbnRlclk7XG4gICAgICB2YXIgbmV3TGVmdCA9IE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyArIGNlbnRlclg7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyU2VsZWN0b3Iuc3R5bGUudG9wID0gbmV3VG9wIC0gMC41ICogdGhpcy5jb2xvclBpY2tlclNlbGVjdG9yLmNsaWVudEhlaWdodCArIFwicHhcIjtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5zdHlsZS5sZWZ0ID0gbmV3TGVmdCAtIDAuNSAqIHRoaXMuY29sb3JQaWNrZXJTZWxlY3Rvci5jbGllbnRXaWR0aCArIFwicHhcIjtcblxuICAgICAgLy8gc2V0IGNvbG9yXG4gICAgICB2YXIgaCA9IGFuZ2xlIC8gKDIgKiBNYXRoLlBJKTtcbiAgICAgIGggPSBoIDwgMCA/IGggKyAxIDogaDtcbiAgICAgIHZhciBzID0gcmFkaXVzIC8gdGhpcy5yO1xuICAgICAgdmFyIGhzdiA9IFJHQlRvSFNWKHRoaXMuY29sb3IuciwgdGhpcy5jb2xvci5nLCB0aGlzLmNvbG9yLmIpO1xuICAgICAgaHN2LmggPSBoO1xuICAgICAgaHN2LnMgPSBzO1xuICAgICAgdmFyIHJnYmEgPSBIU1ZUb1JHQihoc3YuaCwgaHN2LnMsIGhzdi52KTtcbiAgICAgIHJnYmFbXCJhXCJdID0gdGhpcy5jb2xvci5hO1xuICAgICAgdGhpcy5jb2xvciA9IHJnYmE7XG5cbiAgICAgIC8vIHVwZGF0ZSBwcmV2aWV3c1xuICAgICAgdGhpcy5pbml0aWFsQ29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJyZ2JhKFwiICsgdGhpcy5pbml0aWFsQ29sb3IuciArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuZyArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuYiArIFwiLFwiICsgdGhpcy5pbml0aWFsQ29sb3IuYSArIFwiKVwiO1xuICAgICAgdGhpcy5uZXdDb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcInJnYmEoXCIgKyB0aGlzLmNvbG9yLnIgKyBcIixcIiArIHRoaXMuY29sb3IuZyArIFwiLFwiICsgdGhpcy5jb2xvci5iICsgXCIsXCIgKyB0aGlzLmNvbG9yLmEgKyBcIilcIjtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbG9yUGlja2VyO1xufSgpO1xuXG4vKipcbiAqIFdyYXAgZ2l2ZW4gdGV4dCAobGFzdCBhcmd1bWVudCkgaW4gSFRNTCBlbGVtZW50cyAoYWxsIHByZWNlZGluZyBhcmd1bWVudHMpLlxuICpcbiAqIEBwYXJhbSB7Li4uYW55fSByZXN0IC0gTGlzdCBvZiB0YWcgbmFtZXMgZm9sbG93ZWQgYnkgaW5uZXIgdGV4dC5cbiAqIEByZXR1cm5zIEFuIGVsZW1lbnQgb3IgYSB0ZXh0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIHdyYXBJblRhZygpIHtcbiAgZm9yICh2YXIgX2xlbjUgPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW41KSwgX2tleTUgPSAwOyBfa2V5NSA8IF9sZW41OyBfa2V5NSsrKSB7XG4gICAgcmVzdFtfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICB9XG4gIGlmIChyZXN0Lmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMuXCIpO1xuICB9IGVsc2UgaWYgKHJlc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJlc3RbMF0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChyZXN0WzBdKTtcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKHdyYXBJblRhZy5hcHBseSh2b2lkIDAsIF90b0NvbnN1bWFibGVBcnJheShfc2xpY2VJbnN0YW5jZVByb3BlcnR5KHJlc3QpLmNhbGwocmVzdCwgMSkpKSk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgd2F5IHRoaXMgd29ya3MgaXMgZm9yIGFsbCBwcm9wZXJ0aWVzIG9mIHRoaXMucG9zc2libGUgb3B0aW9ucywgeW91IGNhbiBzdXBwbHkgdGhlIHByb3BlcnR5IG5hbWUgaW4gYW55IGZvcm0gdG8gbGlzdCB0aGUgb3B0aW9ucy5cbiAqIEJvb2xlYW4gb3B0aW9ucyBhcmUgcmVjb2duaXNlZCBhcyBCb29sZWFuXG4gKiBOdW1iZXIgb3B0aW9ucyBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogW2RlZmF1bHQgdmFsdWUsIG1pbiB2YWx1ZSwgbWF4IHZhbHVlLCBzdGVwc2l6ZV1cbiAqIENvbG9ycyBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogWydjb2xvcicsICcjZmZmZmZmJ11cbiAqIFN0cmluZ3Mgd2l0aCBzaG91bGQgYmUgd3JpdHRlbiBhcyBhcnJheTogW29wdGlvbjEsIG9wdGlvbjIsIG9wdGlvbjMsIC4uXVxuICpcbiAqIFRoZSBvcHRpb25zIGFyZSBtYXRjaGVkIHdpdGggdGhlaXIgY291bnRlcnBhcnRzIGluIGVhY2ggb2YgdGhlIG1vZHVsZXMgYW5kIHRoZSB2YWx1ZXMgdXNlZCBpbiB0aGUgY29uZmlndXJhdGlvbiBhcmVcbiAqL1xudmFyIENvbmZpZ3VyYXRvciQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRNb2R1bGUgICAgICAgIHwgdGhlIGxvY2F0aW9uIHdoZXJlIHBhcmVudE1vZHVsZS5zZXRPcHRpb25zKCkgY2FuIGJlIGNhbGxlZFxuICAgKiBAcGFyYW0ge29iamVjdH0gZGVmYXVsdENvbnRhaW5lciAgICB8IHRoZSBkZWZhdWx0IGNvbnRhaW5lciBvZiB0aGUgbW9kdWxlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWd1cmVPcHRpb25zICAgIHwgdGhlIGZ1bGx5IGNvbmZpZ3VyZWQgYW5kIHByZWRlZmluZWQgb3B0aW9ucyBzZXQgZm91bmQgaW4gYWxsT3B0aW9ucy5qc1xuICAgKiBAcGFyYW0ge251bWJlcn0gcGl4ZWxSYXRpbyAgICAgICAgICB8IGNhbnZhcyBwaXhlbCByYXRpb1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoaWRlT3B0aW9uICAgICAgICB8IGN1c3RvbSBsb2dpYyB0byBkeW5hbWljYWxseSBoaWRlIG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIENvbmZpZ3VyYXRvcihwYXJlbnRNb2R1bGUsIGRlZmF1bHRDb250YWluZXIsIGNvbmZpZ3VyZU9wdGlvbnMpIHtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogMTtcbiAgICB2YXIgaGlkZU9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbmZpZ3VyYXRvcik7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRNb2R1bGU7XG4gICAgdGhpcy5jaGFuZ2VkT3B0aW9ucyA9IFtdO1xuICAgIHRoaXMuY29udGFpbmVyID0gZGVmYXVsdENvbnRhaW5lcjtcbiAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBmYWxzZTtcbiAgICB0aGlzLmhpZGVPcHRpb24gPSBoaWRlT3B0aW9uO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBvcHVwQ291bnRlciA9IDA7XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgZmlsdGVyOiB0cnVlLFxuICAgICAgY29udGFpbmVyOiB1bmRlZmluZWQsXG4gICAgICBzaG93QnV0dG9uOiB0cnVlXG4gICAgfTtcbiAgICBfT2JqZWN0JGFzc2lnbih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMuY29uZmlndXJlT3B0aW9ucyA9IGNvbmZpZ3VyZU9wdGlvbnM7XG4gICAgdGhpcy5tb2R1bGVPcHRpb25zID0ge307XG4gICAgdGhpcy5kb21FbGVtZW50cyA9IFtdO1xuICAgIHRoaXMucG9wdXBEaXYgPSB7fTtcbiAgICB0aGlzLnBvcHVwTGltaXQgPSA1O1xuICAgIHRoaXMucG9wdXBIaXN0b3J5ID0ge307XG4gICAgdGhpcy5jb2xvclBpY2tlciA9IG5ldyBDb2xvclBpY2tlciQxKHBpeGVsUmF0aW8pO1xuICAgIHRoaXMud3JhcHBlciA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiByZWZyZXNoIGFsbCBvcHRpb25zLlxuICAgKiBCZWNhdXNlIGFsbCBtb2R1bGVzIHBhcnNlIHRoZWlyIG9wdGlvbnMgYnkgdGhlbXNlbHZlcywgd2UganVzdCB1c2UgdGhlaXIgb3B0aW9ucy4gV2UgY29weSB0aGVtIGhlcmUuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoQ29uZmlndXJhdG9yLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByZXNldCB0aGUgcG9wdXAgaGlzdG9yeSBiZWNhdXNlIHRoZSBpbmRpY2VzIG1heSBoYXZlIGJlZW4gY2hhbmdlZC5cbiAgICAgICAgdGhpcy5wb3B1cEhpc3RvcnkgPSB7fTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlUG9wdXAoKTtcbiAgICAgICAgdmFyIGVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gb3B0aW9ucztcbiAgICAgICAgfSBlbHNlIGlmIChfQXJyYXkkaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zLmpvaW4oKTtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdGlvbnMpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvbnMgY2Fubm90IGJlIG51bGxcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmNvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfZmlsdGVySW5zdGFuY2VQcm9wZXJ0eShvcHRpb25zKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmlsdGVyID0gX2ZpbHRlckluc3RhbmNlUHJvcGVydHkob3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLnNob3dCdXR0b24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNob3dCdXR0b24gPSBvcHRpb25zLnNob3dCdXR0b247XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZW5hYmxlZCA9IG9wdGlvbnMuZW5hYmxlZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZpbHRlciA9IHRydWU7XG4gICAgICAgICAgZW5hYmxlZCA9IG9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5maWx0ZXIgPSBvcHRpb25zO1xuICAgICAgICAgIGVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfZmlsdGVySW5zdGFuY2VQcm9wZXJ0eSh0aGlzLm9wdGlvbnMpID09PSBmYWxzZSkge1xuICAgICAgICAgIGVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG1vZHVsZU9wdGlvbnNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRNb2R1bGVPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1vZHVsZU9wdGlvbnMobW9kdWxlT3B0aW9ucykge1xuICAgICAgdGhpcy5tb2R1bGVPcHRpb25zID0gbW9kdWxlT3B0aW9ucztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRhaW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5jb250YWluZXIgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NyZWF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbGwgRE9NIGVsZW1lbnRzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZSgpIHtcbiAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgICB0aGlzLmNoYW5nZWRPcHRpb25zID0gW107XG4gICAgICB2YXIgZmlsdGVyID0gX2ZpbHRlckluc3RhbmNlUHJvcGVydHkodGhpcy5vcHRpb25zKTtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciBzaG93ID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBfb3B0aW9uIGluIHRoaXMuY29uZmlndXJlT3B0aW9ucykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuY29uZmlndXJlT3B0aW9ucywgX29wdGlvbikpIHtcbiAgICAgICAgICB0aGlzLmFsbG93Q3JlYXRpb24gPSBmYWxzZTtcbiAgICAgICAgICBzaG93ID0gZmFsc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgc2hvdyA9IGZpbHRlcihfb3B0aW9uLCBbXSk7XG4gICAgICAgICAgICBzaG93ID0gc2hvdyB8fCB0aGlzLl9oYW5kbGVPYmplY3QodGhpcy5jb25maWd1cmVPcHRpb25zW19vcHRpb25dLCBbX29wdGlvbl0sIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmlsdGVyID09PSB0cnVlIHx8IF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eShmaWx0ZXIpLmNhbGwoZmlsdGVyLCBfb3B0aW9uKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHNob3cgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2hvdyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIGxpbmVicmVhayBiZXR3ZWVuIGNhdGVnb3JpZXNcbiAgICAgICAgICAgIGlmIChjb3VudGVyID4gMCkge1xuICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhIGhlYWRlciBmb3IgdGhlIGNhdGVnb3J5XG4gICAgICAgICAgICB0aGlzLl9tYWtlSGVhZGVyKF9vcHRpb24pO1xuXG4gICAgICAgICAgICAvLyBnZXQgdGhlIHN1YiBvcHRpb25zXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVPYmplY3QodGhpcy5jb25maWd1cmVPcHRpb25zW19vcHRpb25dLCBbX29wdGlvbl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX21ha2VCdXR0b24oKTtcbiAgICAgIHRoaXMuX3B1c2goKTtcbiAgICAgIC8vfiB0aGlzLmNvbG9yUGlja2VyLmluc2VydFRvKHRoaXMuY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkcmF3IGFsbCBET00gZWxlbWVudHMgb24gdGhlIHNjcmVlblxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHVzaCgpIHtcbiAgICAgIHRoaXMud3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLndyYXBwZXIuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbi13cmFwcGVyXCI7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRvbUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmRvbUVsZW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Nob3dQb3B1cElmTmVlZGVkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZGVsZXRlIGFsbCBET00gZWxlbWVudHNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NsZWFuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kb21FbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndyYXBwZXIucmVtb3ZlQ2hpbGQodGhpcy5kb21FbGVtZW50c1tpXSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy53cmFwcGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy53cmFwcGVyKTtcbiAgICAgICAgdGhpcy53cmFwcGVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdGhpcy5kb21FbGVtZW50cyA9IFtdO1xuICAgICAgdGhpcy5fcmVtb3ZlUG9wdXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIGFjdHVhbE9wdGlvbnMgaWYgaXQgZXhpc3RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmFsdWUocGF0aCkge1xuICAgICAgdmFyIGJhc2UgPSB0aGlzLm1vZHVsZU9wdGlvbnM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGJhc2VbcGF0aFtpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGJhc2UgPSBiYXNlW3BhdGhbaV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFsbCBvcHRpb24gZWxlbWVudHMgYXJlIHdyYXBwZWQgaW4gYW4gaXRlbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheS48RWxlbWVudD59IGRvbUVsZW1lbnRzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlSXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUl0ZW0ocGF0aCkge1xuICAgICAgaWYgKHRoaXMuYWxsb3dDcmVhdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGl0ZW0uY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWl0ZW0gdmlzLWNvbmZpZy1zXCIgKyBwYXRoLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgX2xlbjYgPSBhcmd1bWVudHMubGVuZ3RoLCBkb21FbGVtZW50cyA9IG5ldyBBcnJheShfbGVuNiA+IDEgPyBfbGVuNiAtIDEgOiAwKSwgX2tleTYgPSAxOyBfa2V5NiA8IF9sZW42OyBfa2V5NisrKSB7XG4gICAgICAgICAgZG9tRWxlbWVudHNbX2tleTYgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgICAgIH1cbiAgICAgICAgX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KGRvbUVsZW1lbnRzKS5jYWxsKGRvbUVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLnB1c2goaXRlbSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRvbUVsZW1lbnRzLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGhlYWRlciBmb3IgbWFqb3Igc3ViamVjdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZUhlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUhlYWRlcihuYW1lKSB7XG4gICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctaGVhZGVyXCI7XG4gICAgICBkaXYuaW5uZXJUZXh0ID0gbmFtZTtcbiAgICAgIHRoaXMuX21ha2VJdGVtKFtdLCBkaXYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1ha2UgYSBsYWJlbCwgaWYgaXQgaXMgYW4gb2JqZWN0IGxhYmVsLCBpdCBnZXRzIGRpZmZlcmVudCBzdHlsaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqZWN0TGFiZWxcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZUxhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlTGFiZWwobmFtZSwgcGF0aCkge1xuICAgICAgdmFyIG9iamVjdExhYmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1sYWJlbCB2aXMtY29uZmlnLXNcIiArIHBhdGgubGVuZ3RoO1xuICAgICAgaWYgKG9iamVjdExhYmVsID09PSB0cnVlKSB7XG4gICAgICAgIHdoaWxlIChkaXYuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGRpdi5yZW1vdmVDaGlsZChkaXYuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKHdyYXBJblRhZyhcImlcIiwgXCJiXCIsIG5hbWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpdi5pbm5lclRleHQgPSBuYW1lICsgXCI6XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGl2O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1ha2UgYSBkcm9wZG93biBsaXN0IGZvciBtdWx0aXBsZSBwb3NzaWJsZSBzdHJpbmcgb3B0b2luc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZURyb3Bkb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlRHJvcGRvd24oYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7XG4gICAgICBzZWxlY3QuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXNlbGVjdFwiO1xuICAgICAgdmFyIHNlbGVjdGVkVmFsdWUgPSAwO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eShhcnIpLmNhbGwoYXJyLCB2YWx1ZSkgIT09IC0xKSB7XG4gICAgICAgICAgc2VsZWN0ZWRWYWx1ZSA9IF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eShhcnIpLmNhbGwoYXJyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfb3B0aW9uMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICAgIF9vcHRpb24yLnZhbHVlID0gYXJyW2ldO1xuICAgICAgICBpZiAoaSA9PT0gc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICAgIF9vcHRpb24yLnNlbGVjdGVkID0gXCJzZWxlY3RlZFwiO1xuICAgICAgICB9XG4gICAgICAgIF9vcHRpb24yLmlubmVyVGV4dCA9IGFycltpXTtcbiAgICAgICAgc2VsZWN0LmFwcGVuZENoaWxkKF9vcHRpb24yKTtcbiAgICAgIH1cbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICBzZWxlY3Qub25jaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLl91cGRhdGUodGhpcy52YWx1ZSwgcGF0aCk7XG4gICAgICB9O1xuICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aCk7XG4gICAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgc2VsZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtYWtlIGEgcmFuZ2Ugb2JqZWN0IGZvciBudW1lcmljIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGFyclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZVJhbmdlKGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBhcnJbMF07XG4gICAgICB2YXIgbWluID0gYXJyWzFdO1xuICAgICAgdmFyIG1heCA9IGFyclsyXTtcbiAgICAgIHZhciBzdGVwID0gYXJyWzNdO1xuICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgcmFuZ2UuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLXJhbmdlXCI7XG4gICAgICB0cnkge1xuICAgICAgICByYW5nZS50eXBlID0gXCJyYW5nZVwiOyAvLyBub3Qgc3VwcG9ydGVkIG9uIElFOVxuICAgICAgICByYW5nZS5taW4gPSBtaW47XG4gICAgICAgIHJhbmdlLm1heCA9IG1heDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBUT0RPOiBBZGQgc29tZSBlcnJvciBoYW5kbGluZy5cbiAgICAgIH1cbiAgICAgIHJhbmdlLnN0ZXAgPSBzdGVwO1xuXG4gICAgICAvLyBzZXQgdXAgdGhlIHBvcHVwIHNldHRpbmdzIGluIGNhc2UgdGhleSBhcmUgbmVlZGVkLlxuICAgICAgdmFyIHBvcHVwU3RyaW5nID0gXCJcIjtcbiAgICAgIHZhciBwb3B1cFZhbHVlID0gMDtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBmYWN0b3IgPSAxLjI7XG4gICAgICAgIGlmICh2YWx1ZSA8IDAgJiYgdmFsdWUgKiBmYWN0b3IgPCBtaW4pIHtcbiAgICAgICAgICByYW5nZS5taW4gPSBNYXRoLmNlaWwodmFsdWUgKiBmYWN0b3IpO1xuICAgICAgICAgIHBvcHVwVmFsdWUgPSByYW5nZS5taW47XG4gICAgICAgICAgcG9wdXBTdHJpbmcgPSBcInJhbmdlIGluY3JlYXNlZFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIC8gZmFjdG9yIDwgbWluKSB7XG4gICAgICAgICAgcmFuZ2UubWluID0gTWF0aC5jZWlsKHZhbHVlIC8gZmFjdG9yKTtcbiAgICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWluO1xuICAgICAgICAgIHBvcHVwU3RyaW5nID0gXCJyYW5nZSBpbmNyZWFzZWRcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgKiBmYWN0b3IgPiBtYXggJiYgbWF4ICE9PSAxKSB7XG4gICAgICAgICAgcmFuZ2UubWF4ID0gTWF0aC5jZWlsKHZhbHVlICogZmFjdG9yKTtcbiAgICAgICAgICBwb3B1cFZhbHVlID0gcmFuZ2UubWF4O1xuICAgICAgICAgIHBvcHVwU3RyaW5nID0gXCJyYW5nZSBpbmNyZWFzZWRcIjtcbiAgICAgICAgfVxuICAgICAgICByYW5nZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UudmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICBpbnB1dC5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctcmFuZ2VpbnB1dFwiO1xuICAgICAgaW5wdXQudmFsdWUgPSByYW5nZS52YWx1ZTtcbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICByYW5nZS5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5wdXQudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBtZS5fdXBkYXRlKE51bWJlcih0aGlzLnZhbHVlKSwgcGF0aCk7XG4gICAgICB9O1xuICAgICAgcmFuZ2Uub25pbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5wdXQudmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgfTtcbiAgICAgIHZhciBsYWJlbCA9IHRoaXMuX21ha2VMYWJlbChwYXRoW3BhdGgubGVuZ3RoIC0gMV0sIHBhdGgpO1xuICAgICAgdmFyIGl0ZW1JbmRleCA9IHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCByYW5nZSwgaW5wdXQpO1xuXG4gICAgICAvLyBpZiBhIHBvcHVwIGlzIG5lZWRlZCBBTkQgaXQgaGFzIG5vdCBiZWVuIHNob3duIGZvciB0aGlzIHZhbHVlLCBzaG93IGl0LlxuICAgICAgaWYgKHBvcHVwU3RyaW5nICE9PSBcIlwiICYmIHRoaXMucG9wdXBIaXN0b3J5W2l0ZW1JbmRleF0gIT09IHBvcHVwVmFsdWUpIHtcbiAgICAgICAgdGhpcy5wb3B1cEhpc3RvcnlbaXRlbUluZGV4XSA9IHBvcHVwVmFsdWU7XG4gICAgICAgIHRoaXMuX3NldHVwUG9wdXAocG9wdXBTdHJpbmcsIGl0ZW1JbmRleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWFrZSBhIGJ1dHRvbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VCdXR0b24oKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hvd0J1dHRvbiA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgZ2VuZXJhdGVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uXCI7XG4gICAgICAgIGdlbmVyYXRlQnV0dG9uLmlubmVyVGV4dCA9IFwiZ2VuZXJhdGUgb3B0aW9uc1wiO1xuICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNC5fcHJpbnRPcHRpb25zKCk7XG4gICAgICAgIH07XG4gICAgICAgIGdlbmVyYXRlQnV0dG9uLm9ubW91c2VvdmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGdlbmVyYXRlQnV0dG9uLmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy1idXR0b24gaG92ZXJcIjtcbiAgICAgICAgfTtcbiAgICAgICAgZ2VuZXJhdGVCdXR0b24ub25tb3VzZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBnZW5lcmF0ZUJ1dHRvbi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctYnV0dG9uXCI7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub3B0aW9uc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMub3B0aW9uc0NvbnRhaW5lci5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctb3B0aW9uLWNvbnRhaW5lclwiO1xuICAgICAgICB0aGlzLmRvbUVsZW1lbnRzLnB1c2godGhpcy5vcHRpb25zQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5kb21FbGVtZW50cy5wdXNoKGdlbmVyYXRlQnV0dG9uKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcmVwYXJlIHRoZSBwb3B1cFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldHVwUG9wdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwUG9wdXAoc3RyaW5nLCBpbmRleCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5pbml0aWFsaXplZCA9PT0gdHJ1ZSAmJiB0aGlzLmFsbG93Q3JlYXRpb24gPT09IHRydWUgJiYgdGhpcy5wb3B1cENvdW50ZXIgPCB0aGlzLnBvcHVwTGltaXQpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRpdi5pZCA9IFwidmlzLWNvbmZpZ3VyYXRpb24tcG9wdXBcIjtcbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24tcG9wdXBcIjtcbiAgICAgICAgZGl2LmlubmVyVGV4dCA9IHN0cmluZztcbiAgICAgICAgZGl2Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM1Ll9yZW1vdmVQb3B1cCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBvcHVwQ291bnRlciArPSAxO1xuICAgICAgICB0aGlzLnBvcHVwRGl2ID0ge1xuICAgICAgICAgIGh0bWw6IGRpdixcbiAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgdGhlIHBvcHVwIGZyb20gdGhlIGRvbVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcmVtb3ZlUG9wdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbW92ZVBvcHVwKCkge1xuICAgICAgaWYgKHRoaXMucG9wdXBEaXYuaHRtbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucG9wdXBEaXYuaHRtbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wdXBEaXYuaHRtbCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnBvcHVwRGl2LmhpZGVUaW1lb3V0KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucG9wdXBEaXYuZGVsZXRlVGltZW91dCk7XG4gICAgICAgIHRoaXMucG9wdXBEaXYgPSB7fTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBwb3B1cCBpZiBpdCBpcyBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zaG93UG9wdXBJZk5lZWRlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvd1BvcHVwSWZOZWVkZWQoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICAgIGlmICh0aGlzLnBvcHVwRGl2Lmh0bWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgY29ycmVzcG9uZGluZ0VsZW1lbnQgPSB0aGlzLmRvbUVsZW1lbnRzW3RoaXMucG9wdXBEaXYuaW5kZXhdO1xuICAgICAgICB2YXIgcmVjdCA9IGNvcnJlc3BvbmRpbmdFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnBvcHVwRGl2Lmh0bWwuc3R5bGUubGVmdCA9IHJlY3QubGVmdCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5wb3B1cERpdi5odG1sLnN0eWxlLnRvcCA9IHJlY3QudG9wIC0gMzAgKyBcInB4XCI7IC8vIDMwIGlzIHRoZSBoZWlnaHQ7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wb3B1cERpdi5odG1sKTtcbiAgICAgICAgdGhpcy5wb3B1cERpdi5oaWRlVGltZW91dCA9IF9zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczYucG9wdXBEaXYuaHRtbC5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgfSwgMTUwMCk7XG4gICAgICAgIHRoaXMucG9wdXBEaXYuZGVsZXRlVGltZW91dCA9IF9zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczYuX3JlbW92ZVBvcHVwKCk7XG4gICAgICAgIH0sIDE4MDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1ha2UgYSBjaGVja2JveCBmb3IgYm9vbGVhbiBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZmF1bHRWYWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX21ha2VDaGVja2JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZUNoZWNrYm94KGRlZmF1bHRWYWx1ZSwgdmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgIGNoZWNrYm94LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICBjaGVja2JveC5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctY2hlY2tib3hcIjtcbiAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWU7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjaGVja2JveC5jaGVja2VkID0gdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgaWYgKF90eXBlb2YoZGVmYXVsdFZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBkZWZhdWx0VmFsdWUuZW5hYmxlZCkge1xuICAgICAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgIGNoZWNrYm94Lm9uY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBtZS5fdXBkYXRlKHRoaXMuY2hlY2tlZCwgcGF0aCk7XG4gICAgICB9O1xuICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aCk7XG4gICAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgY2hlY2tib3gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1ha2UgYSB0ZXh0IGlucHV0IGZpZWxkIGZvciBzdHJpbmcgb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWZhdWx0VmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlVGV4dElucHV0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlVGV4dElucHV0KGRlZmF1bHRWYWx1ZSwgdmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBjaGVja2JveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgIGNoZWNrYm94LnR5cGUgPSBcInRleHRcIjtcbiAgICAgIGNoZWNrYm94LmNsYXNzTmFtZSA9IFwidmlzLWNvbmZpZ3VyYXRpb24gdmlzLWNvbmZpZy10ZXh0XCI7XG4gICAgICBjaGVja2JveC52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHZhbHVlICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICBjaGVja2JveC5vbmNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbWUuX3VwZGF0ZSh0aGlzLnZhbHVlLCBwYXRoKTtcbiAgICAgIH07XG4gICAgICB2YXIgbGFiZWwgPSB0aGlzLl9tYWtlTGFiZWwocGF0aFtwYXRoLmxlbmd0aCAtIDFdLCBwYXRoKTtcbiAgICAgIHRoaXMuX21ha2VJdGVtKHBhdGgsIGxhYmVsLCBjaGVja2JveCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWFrZSBhIGNvbG9yIGZpZWxkIHdpdGggYSBjb2xvciBwaWNrZXIgZm9yIGNvbG9yIGZpZWxkc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYXJyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfbWFrZUNvbG9yRmllbGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VDb2xvckZpZWxkKGFyciwgdmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgICAgdmFyIGRlZmF1bHRDb2xvciA9IGFyclsxXTtcbiAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbG9yIDogdmFsdWU7XG4gICAgICBpZiAodmFsdWUgIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGRpdi5jbGFzc05hbWUgPSBcInZpcy1jb25maWd1cmF0aW9uIHZpcy1jb25maWctY29sb3JCbG9ja1wiO1xuICAgICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXYuY2xhc3NOYW1lID0gXCJ2aXMtY29uZmlndXJhdGlvbiB2aXMtY29uZmlnLWNvbG9yQmxvY2sgbm9uZVwiO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdENvbG9yIDogdmFsdWU7XG4gICAgICBkaXYub25jbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM3Ll9zaG93Q29sb3JQaWNrZXIodmFsdWUsIGRpdiwgcGF0aCk7XG4gICAgICB9O1xuICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHBhdGhbcGF0aC5sZW5ndGggLSAxXSwgcGF0aCk7XG4gICAgICB0aGlzLl9tYWtlSXRlbShwYXRoLCBsYWJlbCwgZGl2KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1c2VkIGJ5IHRoZSBjb2xvciBidXR0b25zIHRvIGNhbGwgdGhlIGNvbG9yIHBpY2tlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRpdlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Nob3dDb2xvclBpY2tlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvd0NvbG9yUGlja2VyKHZhbHVlLCBkaXYsIHBhdGgpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuICAgICAgLy8gY2xlYXIgdGhlIGNhbGxiYWNrIGZyb20gdGhpcyBkaXZcbiAgICAgIGRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKCkge307XG4gICAgICB0aGlzLmNvbG9yUGlja2VyLmluc2VydFRvKGRpdik7XG4gICAgICB0aGlzLmNvbG9yUGlja2VyLnNob3coKTtcbiAgICAgIHRoaXMuY29sb3JQaWNrZXIuc2V0Q29sb3IodmFsdWUpO1xuICAgICAgdGhpcy5jb2xvclBpY2tlci5zZXRVcGRhdGVDYWxsYmFjayhmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgdmFyIGNvbG9yU3RyaW5nID0gXCJyZ2JhKFwiICsgY29sb3IuciArIFwiLFwiICsgY29sb3IuZyArIFwiLFwiICsgY29sb3IuYiArIFwiLFwiICsgY29sb3IuYSArIFwiKVwiO1xuICAgICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3JTdHJpbmc7XG4gICAgICAgIF90aGlzOC5fdXBkYXRlKGNvbG9yU3RyaW5nLCBwYXRoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBvbiBjbG9zZSBvZiB0aGUgY29sb3JwaWNrZXIsIHJlc3RvcmUgdGhlIGNhbGxiYWNrLlxuICAgICAgdGhpcy5jb2xvclBpY2tlci5zZXRDbG9zZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZGl2Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM4Ll9zaG93Q29sb3JQaWNrZXIodmFsdWUsIGRpdiwgcGF0aCk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwYXJzZSBhbiBvYmplY3QgYW5kIGRyYXcgdGhlIGNvcnJlY3QgaXRlbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGF0aD1bXV0gICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoZWNrT25seT1mYWxzZV1cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZU9iamVjdChvYmopIHtcbiAgICAgIHZhciBwYXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICAgIHZhciBjaGVja09ubHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgdmFyIHNob3cgPSBmYWxzZTtcbiAgICAgIHZhciBmaWx0ZXIgPSBfZmlsdGVySW5zdGFuY2VQcm9wZXJ0eSh0aGlzLm9wdGlvbnMpO1xuICAgICAgdmFyIHZpc2libGVJblNldCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgc3ViT2JqIGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgc3ViT2JqKSkge1xuICAgICAgICAgIHNob3cgPSB0cnVlO1xuICAgICAgICAgIHZhciBpdGVtID0gb2JqW3N1Yk9ial07XG4gICAgICAgICAgdmFyIG5ld1BhdGggPSBjb3B5QW5kRXh0ZW5kQXJyYXkocGF0aCwgc3ViT2JqKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBzaG93ID0gZmlsdGVyKHN1Yk9iaiwgcGF0aCk7XG5cbiAgICAgICAgICAgIC8vIGlmIG5lZWRlZCB3ZSBtdXN0IGdvIGRlZXBlciBpbnRvIHRoZSBvYmplY3QuXG4gICAgICAgICAgICBpZiAoc2hvdyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgaWYgKCFfQXJyYXkkaXNBcnJheShpdGVtKSAmJiB0eXBlb2YgaXRlbSAhPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgaXRlbSAhPT0gXCJib29sZWFuXCIgJiYgaXRlbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWxsb3dDcmVhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNob3cgPSB0aGlzLl9oYW5kbGVPYmplY3QoaXRlbSwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxvd0NyZWF0aW9uID0gY2hlY2tPbmx5ID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2hvdyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZpc2libGVJblNldCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9nZXRWYWx1ZShuZXdQYXRoKTtcbiAgICAgICAgICAgIGlmIChfQXJyYXkkaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVBcnJheShpdGVtLCB2YWx1ZSwgbmV3UGF0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX21ha2VUZXh0SW5wdXQoaXRlbSwgdmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fbWFrZUNoZWNrYm94KGl0ZW0sIHZhbHVlLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBza2lwIHRoZSBvcHRpb25zIHRoYXQgYXJlIG5vdCBlbmFibGVkXG4gICAgICAgICAgICAgIGlmICghdGhpcy5oaWRlT3B0aW9uKHBhdGgsIHN1Yk9iaiwgdGhpcy5tb2R1bGVPcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxseSBjb2xsYXBzZSBvcHRpb25zIHdpdGggYW4gZGlzYWJsZWQgZW5hYmxlZCBvcHRpb24uXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uZW5hYmxlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZW5hYmxlZFBhdGggPSBjb3B5QW5kRXh0ZW5kQXJyYXkobmV3UGF0aCwgXCJlbmFibGVkXCIpO1xuICAgICAgICAgICAgICAgICAgdmFyIGVuYWJsZWRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlKGVuYWJsZWRQYXRoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVkVmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHN1Yk9iaiwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VJdGVtKG5ld1BhdGgsIGxhYmVsKTtcbiAgICAgICAgICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgpIHx8IHZpc2libGVJblNldDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ha2VDaGVja2JveChpdGVtLCBlbmFibGVkVmFsdWUsIG5ld1BhdGgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2xhYmVsID0gdGhpcy5fbWFrZUxhYmVsKHN1Yk9iaiwgbmV3UGF0aCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9tYWtlSXRlbShuZXdQYXRoLCBfbGFiZWwpO1xuICAgICAgICAgICAgICAgICAgdmlzaWJsZUluU2V0ID0gdGhpcy5faGFuZGxlT2JqZWN0KGl0ZW0sIG5ld1BhdGgpIHx8IHZpc2libGVJblNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJkb250IGtub3cgaG93IHRvIGhhbmRsZVwiLCBpdGVtLCBzdWJPYmosIG5ld1BhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZpc2libGVJblNldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgdGhlIGFycmF5IHR5cGUgb2Ygb3B0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXRoICAgIHwgd2hlcmUgdG8gbG9vayBmb3IgdGhlIGFjdHVhbCBvcHRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9oYW5kbGVBcnJheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQXJyYXkoYXJyLCB2YWx1ZSwgcGF0aCkge1xuICAgICAgaWYgKHR5cGVvZiBhcnJbMF0gPT09IFwic3RyaW5nXCIgJiYgYXJyWzBdID09PSBcImNvbG9yXCIpIHtcbiAgICAgICAgdGhpcy5fbWFrZUNvbG9yRmllbGQoYXJyLCB2YWx1ZSwgcGF0aCk7XG4gICAgICAgIGlmIChhcnJbMV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VkT3B0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJyWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRoaXMuX21ha2VEcm9wZG93bihhcnIsIHZhbHVlLCBwYXRoKTtcbiAgICAgICAgaWYgKGFyclswXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICB0aGlzLmNoYW5nZWRPcHRpb25zLnB1c2goe1xuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcnJbMF0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhpcy5fbWFrZVJhbmdlKGFyciwgdmFsdWUsIHBhdGgpO1xuICAgICAgICBpZiAoYXJyWzBdICE9PSB2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuY2hhbmdlZE9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlcih2YWx1ZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNhbGxlZCB0byB1cGRhdGUgdGhlIG5ldHdvcmsgd2l0aCB0aGUgbmV3IHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUodmFsdWUsIHBhdGgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5fY29uc3RydWN0T3B0aW9ucyh2YWx1ZSwgcGF0aCk7XG4gICAgICBpZiAodGhpcy5wYXJlbnQuYm9keSAmJiB0aGlzLnBhcmVudC5ib2R5LmVtaXR0ZXIgJiYgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyLmVtaXQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuYm9keS5lbWl0dGVyLmVtaXQoXCJjb25maWdDaGFuZ2VcIiwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucGFyZW50LnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8IGJvb2xlYW59IHZhbHVlXG4gICAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gcGF0aFxuICAgICAqIEBwYXJhbSB7e319IG9wdGlvbnNPYmpcbiAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY29uc3RydWN0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29uc3RydWN0T3B0aW9ucyh2YWx1ZSwgcGF0aCkge1xuICAgICAgdmFyIG9wdGlvbnNPYmogPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIHBvaW50ZXIgPSBvcHRpb25zT2JqO1xuXG4gICAgICAvLyB3aGVuIGRyb3Bkb3duIGJveGVzIGNhbiBiZSBzdHJpbmcgb3IgYm9vbGVhbiwgd2UgdHlwZWNhc3QgaXQgaW50byBjb3JyZWN0IHR5cGVzXG4gICAgICB2YWx1ZSA9IHZhbHVlID09PSBcInRydWVcIiA/IHRydWUgOiB2YWx1ZTtcbiAgICAgIHZhbHVlID0gdmFsdWUgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDogdmFsdWU7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhdGhbaV0gIT09IFwiZ2xvYmFsXCIpIHtcbiAgICAgICAgICBpZiAocG9pbnRlcltwYXRoW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwb2ludGVyW3BhdGhbaV1dID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpICE9PSBwYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyW3BhdGhbaV1dO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb2ludGVyW3BhdGhbaV1dID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9uc09iajtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9wcmludE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ByaW50T3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgICB3aGlsZSAodGhpcy5vcHRpb25zQ29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMub3B0aW9uc0NvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub3B0aW9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZCh3cmFwSW5UYWcoXCJwcmVcIiwgXCJjb25zdCBvcHRpb25zID0gXCIgKyBfSlNPTiRzdHJpbmdpZnkob3B0aW9ucywgbnVsbCwgMikpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt7fX0gb3B0aW9uc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hhbmdlZE9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fY29uc3RydWN0T3B0aW9ucyh0aGlzLmNoYW5nZWRPcHRpb25zW2ldLnZhbHVlLCB0aGlzLmNoYW5nZWRPcHRpb25zW2ldLnBhdGgsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDb25maWd1cmF0b3I7XG59KCk7XG5cbi8qKlxuICogUG9wdXAgaXMgYSBjbGFzcyB0byBjcmVhdGUgYSBwb3B1cCB3aW5kb3cgd2l0aCBzb21lIHRleHRcbiAqL1xudmFyIFBvcHVwJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgICAgICAgVGhlIGNvbnRhaW5lciBvYmplY3QuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgb3ZlcmZsb3dNZXRob2QgIEhvdyB0aGUgcG9wdXAgc2hvdWxkIGFjdCB0byBvdmVyZmxvd2luZyAoJ2ZsaXAnIG9yICdjYXAnKVxuICAgKi9cbiAgZnVuY3Rpb24gUG9wdXAoY29udGFpbmVyLCBvdmVyZmxvd01ldGhvZCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3B1cCk7XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5vdmVyZmxvd01ldGhvZCA9IG92ZXJmbG93TWV0aG9kIHx8IFwiY2FwXCI7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMucGFkZGluZyA9IDU7XG4gICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcblxuICAgIC8vIGNyZWF0ZSB0aGUgZnJhbWVcbiAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmZyYW1lLmNsYXNzTmFtZSA9IFwidmlzLXRvb2x0aXBcIjtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmZyYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0geCAgIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIHBvcHVwIHdpbmRvd1xuICAgKiBAcGFyYW0ge251bWJlcn0geSAgIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSBwb3B1cCB3aW5kb3dcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhQb3B1cCwgW3tcbiAgICBrZXk6IFwic2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb24oeCwgeSkge1xuICAgICAgdGhpcy54ID0gX3BhcnNlSW50JDEoeCk7XG4gICAgICB0aGlzLnkgPSBfcGFyc2VJbnQkMSh5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNvbnRlbnQgZm9yIHRoZSBwb3B1cCB3aW5kb3cuIFRoaXMgY2FuIGJlIEhUTUwgY29kZSBvciB0ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCBFbGVtZW50fSBjb250ZW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUZXh0KGNvbnRlbnQpIHtcbiAgICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICB3aGlsZSAodGhpcy5mcmFtZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgdGhpcy5mcmFtZS5yZW1vdmVDaGlsZCh0aGlzLmZyYW1lLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdHJpbmcgY29udGFpbmluZyBsaXRlcmFsIHRleHQsIGVsZW1lbnQgaGFzIHRvIGJlIHVzZWQgZm9yIEhUTUwgZHVlIHRvXG4gICAgICAgIC8vIFhTUyByaXNrcyBhc3NvY2lhdGVkIHdpdGggaW5uZXJIVE1MIChpLmUuIHByZXZlbnQgWFNTIGJ5IGFjY2lkZW50KS5cbiAgICAgICAgdGhpcy5mcmFtZS5pbm5lclRleHQgPSBjb250ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIHBvcHVwIHdpbmRvd1xuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZG9TaG93XSAgICBTaG93IG9yIGhpZGUgdGhlIHdpbmRvd1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNob3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdyhkb1Nob3cpIHtcbiAgICAgIGlmIChkb1Nob3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkb1Nob3cgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRvU2hvdyA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5mcmFtZS5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZnJhbWUuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBtYXhIZWlnaHQgPSB0aGlzLmZyYW1lLnBhcmVudE5vZGUuY2xpZW50SGVpZ2h0O1xuICAgICAgICB2YXIgbWF4V2lkdGggPSB0aGlzLmZyYW1lLnBhcmVudE5vZGUuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBsZWZ0ID0gMCxcbiAgICAgICAgICB0b3AgPSAwO1xuICAgICAgICBpZiAodGhpcy5vdmVyZmxvd01ldGhvZCA9PSBcImZsaXBcIikge1xuICAgICAgICAgIHZhciBpc0xlZnQgPSBmYWxzZSxcbiAgICAgICAgICAgIGlzVG9wID0gdHJ1ZTsgLy8gV2hlcmUgYXJvdW5kIHRoZSBwb3NpdGlvbiBpdCdzIGxvY2F0ZWRcblxuICAgICAgICAgIGlmICh0aGlzLnkgLSBoZWlnaHQgPCB0aGlzLnBhZGRpbmcpIHtcbiAgICAgICAgICAgIGlzVG9wID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnggKyB3aWR0aCA+IG1heFdpZHRoIC0gdGhpcy5wYWRkaW5nKSB7XG4gICAgICAgICAgICBpc0xlZnQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNMZWZ0KSB7XG4gICAgICAgICAgICBsZWZ0ID0gdGhpcy54IC0gd2lkdGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSB0aGlzLng7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1RvcCkge1xuICAgICAgICAgICAgdG9wID0gdGhpcy55IC0gaGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3AgPSB0aGlzLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvcCA9IHRoaXMueSAtIGhlaWdodDtcbiAgICAgICAgICBpZiAodG9wICsgaGVpZ2h0ICsgdGhpcy5wYWRkaW5nID4gbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICB0b3AgPSBtYXhIZWlnaHQgLSBoZWlnaHQgLSB0aGlzLnBhZGRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b3AgPCB0aGlzLnBhZGRpbmcpIHtcbiAgICAgICAgICAgIHRvcCA9IHRoaXMucGFkZGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVmdCA9IHRoaXMueDtcbiAgICAgICAgICBpZiAobGVmdCArIHdpZHRoICsgdGhpcy5wYWRkaW5nID4gbWF4V2lkdGgpIHtcbiAgICAgICAgICAgIGxlZnQgPSBtYXhXaWR0aCAtIHdpZHRoIC0gdGhpcy5wYWRkaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGVmdCA8IHRoaXMucGFkZGluZykge1xuICAgICAgICAgICAgbGVmdCA9IHRoaXMucGFkZGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZnJhbWUuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICAgICAgICB0aGlzLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGlkZSB0aGUgcG9wdXAgd2luZG93XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS5sZWZ0ID0gXCIwXCI7XG4gICAgICB0aGlzLmZyYW1lLnN0eWxlLnRvcCA9IFwiMFwiO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIHBvcHVwIHdpbmRvd1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZyYW1lKTsgLy8gUmVtb3ZlIGVsZW1lbnQgZnJvbSBET01cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBvcHVwO1xufSgpO1xudmFyIGVycm9yRm91bmQgPSBmYWxzZTtcbnZhciBhbGxPcHRpb25zJDE7XG52YXIgVkFMSURBVE9SX1BSSU5UX1NUWUxFJDEgPSBcImJhY2tncm91bmQ6ICNGRmVlZWU7IGNvbG9yOiAjZGQwMDAwXCI7XG5cbi8qKlxuICogIFVzZWQgdG8gdmFsaWRhdGUgb3B0aW9ucy5cbiAqL1xudmFyIFZhbGlkYXRvciQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVmFsaWRhdG9yKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWYWxpZGF0b3IpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhWYWxpZGF0b3IsIG51bGwsIFt7XG4gICAga2V5OiBcInZhbGlkYXRlXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogTWFpbiBmdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJlZmVyZW5jZU9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc3ViT2JqZWN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHN1Yk9iamVjdCkge1xuICAgICAgZXJyb3JGb3VuZCA9IGZhbHNlO1xuICAgICAgYWxsT3B0aW9ucyQxID0gcmVmZXJlbmNlT3B0aW9ucztcbiAgICAgIHZhciB1c2VkT3B0aW9ucyA9IHJlZmVyZW5jZU9wdGlvbnM7XG4gICAgICBpZiAoc3ViT2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXNlZE9wdGlvbnMgPSByZWZlcmVuY2VPcHRpb25zW3N1Yk9iamVjdF07XG4gICAgICB9XG4gICAgICBWYWxpZGF0b3IucGFyc2Uob3B0aW9ucywgdXNlZE9wdGlvbnMsIFtdKTtcbiAgICAgIHJldHVybiBlcnJvckZvdW5kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpbGwgdHJhdmVyc2UgYW4gb2JqZWN0IHJlY3Vyc2l2ZWx5IGFuZCBjaGVjayBldmVyeSB2YWx1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcmVmZXJlbmNlT3B0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKSB7XG4gICAgICBmb3IgKHZhciBfb3B0aW9uMyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgX29wdGlvbjMpKSB7XG4gICAgICAgICAgVmFsaWRhdG9yLmNoZWNrKF9vcHRpb24zLCBvcHRpb25zLCByZWZlcmVuY2VPcHRpb25zLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGV2ZXJ5IHZhbHVlLiBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0LCBjYWxsIHRoZSBwYXJzZSBmdW5jdGlvbiBvbiB0aGF0IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSByZWZlcmVuY2VPcHRpb25zXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGF0aCAgICB8IHdoZXJlIHRvIGxvb2sgZm9yIHRoZSBhY3R1YWwgb3B0aW9uXG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNoZWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCkge1xuICAgICAgaWYgKHJlZmVyZW5jZU9wdGlvbnNbb3B0aW9uXSA9PT0gdW5kZWZpbmVkICYmIHJlZmVyZW5jZU9wdGlvbnMuX19hbnlfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIFZhbGlkYXRvci5nZXRTdWdnZXN0aW9uKG9wdGlvbiwgcmVmZXJlbmNlT3B0aW9ucywgcGF0aCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciByZWZlcmVuY2VPcHRpb24gPSBvcHRpb247XG4gICAgICB2YXIgaXNfb2JqZWN0ID0gdHJ1ZTtcbiAgICAgIGlmIChyZWZlcmVuY2VPcHRpb25zW29wdGlvbl0gPT09IHVuZGVmaW5lZCAmJiByZWZlcmVuY2VPcHRpb25zLl9fYW55X18gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBOT1RFOiBUaGlzIG9ubHkgdHJpZ2dlcnMgaWYgdGhlIF9fYW55X18gaXMgaW4gdGhlIHRvcCBsZXZlbCBvZiB0aGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICAgIC8vICAgICAgIFRIQVQnUyBBIFJFQUxMWSBCQUQgUExBQ0UgVE8gQUxMT1cgSVQhISEhXG4gICAgICAgIC8vIFRPRE86IEV4YW1pbmUgaWYgbmVlZGVkLCByZW1vdmUgaWYgcG9zc2libGVcblxuICAgICAgICAvLyBfX2FueV9fIGlzIGEgd2lsZGNhcmQuIEFueSB2YWx1ZSBpcyBhY2NlcHRlZCBhbmQgd2lsbCBiZSBmdXJ0aGVyIGFuYWx5c2VkIGJ5IHJlZmVyZW5jZS5cbiAgICAgICAgcmVmZXJlbmNlT3B0aW9uID0gXCJfX2FueV9fXCI7XG5cbiAgICAgICAgLy8gaWYgdGhlIGFueS1zdWJncm91cCBpcyBub3QgYSBwcmVkZWZpbmVkIG9iamVjdCBpbiB0aGUgY29uZmlndXJhdG9yLFxuICAgICAgICAvLyB3ZSBkbyBub3QgbG9vayBkZWVwZXIgaW50byB0aGUgb2JqZWN0LlxuICAgICAgICBpc19vYmplY3QgPSBWYWxpZGF0b3IuZ2V0VHlwZShvcHRpb25zW29wdGlvbl0pID09PSBcIm9iamVjdFwiO1xuICAgICAgfVxuICAgICAgdmFyIHJlZk9wdGlvbk9iaiA9IHJlZmVyZW5jZU9wdGlvbnNbcmVmZXJlbmNlT3B0aW9uXTtcbiAgICAgIGlmIChpc19vYmplY3QgJiYgcmVmT3B0aW9uT2JqLl9fdHlwZV9fICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVmT3B0aW9uT2JqID0gcmVmT3B0aW9uT2JqLl9fdHlwZV9fO1xuICAgICAgfVxuICAgICAgVmFsaWRhdG9yLmNoZWNrRmllbGRzKG9wdGlvbiwgb3B0aW9ucywgcmVmZXJlbmNlT3B0aW9ucywgcmVmZXJlbmNlT3B0aW9uLCByZWZPcHRpb25PYmosIHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9ICBvcHRpb24gICAgICAgICAgIHwgdGhlIG9wdGlvbiBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgb3B0aW9ucyAgICAgICAgICB8IFRoZSBzdXBwbGllZCBvcHRpb25zIG9iamVjdFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgcmVmZXJlbmNlT3B0aW9ucyB8IFRoZSByZWZlcmVuY2Ugb3B0aW9ucyBjb250YWluaW5nIGFsbCBvcHRpb25zIGFuZCB0aGVpciBhbGxvd2VkIGZvcm1hdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIHJlZmVyZW5jZU9wdGlvbiAgfCBVc3VhbGx5IHRoaXMgaXMgdGhlIHNhbWUgYXMgb3B0aW9uLCBleGNlcHQgd2hlbiBoYW5kbGluZyBhbiBfX2FueV9fIHRhZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gIHJlZk9wdGlvbk9iaiAgICAgfCBUaGlzIGlzIHRoZSB0eXBlIG9iamVjdCBmcm9tIHRoZSByZWZlcmVuY2Ugb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgcGF0aCAgICAgICAgICAgICB8IHdoZXJlIGluIHRoZSBvYmplY3QgaXMgdGhlIG9wdGlvblxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjaGVja0ZpZWxkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0ZpZWxkcyhvcHRpb24sIG9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbnMsIHJlZmVyZW5jZU9wdGlvbiwgcmVmT3B0aW9uT2JqLCBwYXRoKSB7XG4gICAgICB2YXIgbG9nID0gZnVuY3Rpb24gbG9nKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIiVjXCIgKyBtZXNzYWdlICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKSwgVkFMSURBVE9SX1BSSU5UX1NUWUxFJDEpO1xuICAgICAgfTtcbiAgICAgIHZhciBvcHRpb25UeXBlID0gVmFsaWRhdG9yLmdldFR5cGUob3B0aW9uc1tvcHRpb25dKTtcbiAgICAgIHZhciByZWZPcHRpb25UeXBlID0gcmVmT3B0aW9uT2JqW29wdGlvblR5cGVdO1xuICAgICAgaWYgKHJlZk9wdGlvblR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBpZiB0aGUgdHlwZSBpcyBjb3JyZWN0LCB3ZSBjaGVjayBpZiBpdCBpcyBzdXBwb3NlZCB0byBiZSBvbmUgb2YgYSBmZXcgc2VsZWN0IHZhbHVlc1xuICAgICAgICBpZiAoVmFsaWRhdG9yLmdldFR5cGUocmVmT3B0aW9uVHlwZSkgPT09IFwiYXJyYXlcIiAmJiBfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkocmVmT3B0aW9uVHlwZSkuY2FsbChyZWZPcHRpb25UeXBlLCBvcHRpb25zW29wdGlvbl0pID09PSAtMSkge1xuICAgICAgICAgIGxvZygnSW52YWxpZCBvcHRpb24gZGV0ZWN0ZWQgaW4gXCInICsgb3B0aW9uICsgJ1wiLicgKyBcIiBBbGxvd2VkIHZhbHVlcyBhcmU6XCIgKyBWYWxpZGF0b3IucHJpbnQocmVmT3B0aW9uVHlwZSkgKyAnIG5vdCBcIicgKyBvcHRpb25zW29wdGlvbl0gKyAnXCIuICcpO1xuICAgICAgICAgIGVycm9yRm91bmQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvblR5cGUgPT09IFwib2JqZWN0XCIgJiYgcmVmZXJlbmNlT3B0aW9uICE9PSBcIl9fYW55X19cIikge1xuICAgICAgICAgIHBhdGggPSBjb3B5QW5kRXh0ZW5kQXJyYXkocGF0aCwgb3B0aW9uKTtcbiAgICAgICAgICBWYWxpZGF0b3IucGFyc2Uob3B0aW9uc1tvcHRpb25dLCByZWZlcmVuY2VPcHRpb25zW3JlZmVyZW5jZU9wdGlvbl0sIHBhdGgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlZk9wdGlvbk9ialtcImFueVwiXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHR5cGUgb2YgdGhlIGZpZWxkIGlzIGluY29ycmVjdCBhbmQgdGhlIGZpZWxkIGNhbm5vdCBiZSBhbnlcbiAgICAgICAgbG9nKCdJbnZhbGlkIHR5cGUgcmVjZWl2ZWQgZm9yIFwiJyArIG9wdGlvbiArICdcIi4gRXhwZWN0ZWQ6ICcgKyBWYWxpZGF0b3IucHJpbnQoX09iamVjdCRrZXlzKHJlZk9wdGlvbk9iaikpICsgXCIuIFJlY2VpdmVkIFtcIiArIG9wdGlvblR5cGUgKyAnXSBcIicgKyBvcHRpb25zW29wdGlvbl0gKyAnXCInKTtcbiAgICAgICAgZXJyb3JGb3VuZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdCB8IGJvb2xlYW4gfCBudW1iZXIgfCBzdHJpbmcgfCBBcnJheS48bnVtYmVyPiB8IERhdGUgfCBOb2RlIHwgTW9tZW50IHwgdW5kZWZpbmVkIHwgbnVsbH0gb2JqZWN0XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUeXBlKG9iamVjdCkge1xuICAgICAgdmFyIHR5cGUgPSBfdHlwZW9mKG9iamVjdCk7XG4gICAgICBpZiAodHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAob2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBCb29sZWFuKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9BcnJheSRpc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIFwiZGF0ZVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3Qubm9kZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBcImRvbVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QuX2lzQU1vbWVudE9iamVjdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybiBcIm1vbWVudFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIm9iamVjdFwiO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gXCJib29sZWFuXCI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHBhdGhcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3VnZ2VzdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdWdnZXN0aW9uKG9wdGlvbiwgb3B0aW9ucywgcGF0aCkge1xuICAgICAgdmFyIGxvY2FsU2VhcmNoID0gVmFsaWRhdG9yLmZpbmRJbk9wdGlvbnMob3B0aW9uLCBvcHRpb25zLCBwYXRoLCBmYWxzZSk7XG4gICAgICB2YXIgZ2xvYmFsU2VhcmNoID0gVmFsaWRhdG9yLmZpbmRJbk9wdGlvbnMob3B0aW9uLCBhbGxPcHRpb25zJDEsIFtdLCB0cnVlKTtcbiAgICAgIHZhciBsb2NhbFNlYXJjaFRocmVzaG9sZCA9IDg7XG4gICAgICB2YXIgZ2xvYmFsU2VhcmNoVGhyZXNob2xkID0gNDtcbiAgICAgIHZhciBtc2c7XG4gICAgICBpZiAobG9jYWxTZWFyY2guaW5kZXhNYXRjaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1zZyA9IFwiIGluIFwiICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24obG9jYWxTZWFyY2gucGF0aCwgb3B0aW9uLCBcIlwiKSArICdQZXJoYXBzIGl0IHdhcyBpbmNvbXBsZXRlPyBEaWQgeW91IG1lYW46IFwiJyArIGxvY2FsU2VhcmNoLmluZGV4TWF0Y2ggKyAnXCI/XFxuXFxuJztcbiAgICAgIH0gZWxzZSBpZiAoZ2xvYmFsU2VhcmNoLmRpc3RhbmNlIDw9IGdsb2JhbFNlYXJjaFRocmVzaG9sZCAmJiBsb2NhbFNlYXJjaC5kaXN0YW5jZSA+IGdsb2JhbFNlYXJjaC5kaXN0YW5jZSkge1xuICAgICAgICBtc2cgPSBcIiBpbiBcIiArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGxvY2FsU2VhcmNoLnBhdGgsIG9wdGlvbiwgXCJcIikgKyBcIlBlcmhhcHMgaXQgd2FzIG1pc3BsYWNlZD8gTWF0Y2hpbmcgb3B0aW9uIGZvdW5kIGF0OiBcIiArIFZhbGlkYXRvci5wcmludExvY2F0aW9uKGdsb2JhbFNlYXJjaC5wYXRoLCBnbG9iYWxTZWFyY2guY2xvc2VzdE1hdGNoLCBcIlwiKTtcbiAgICAgIH0gZWxzZSBpZiAobG9jYWxTZWFyY2guZGlzdGFuY2UgPD0gbG9jYWxTZWFyY2hUaHJlc2hvbGQpIHtcbiAgICAgICAgbXNnID0gJy4gRGlkIHlvdSBtZWFuIFwiJyArIGxvY2FsU2VhcmNoLmNsb3Nlc3RNYXRjaCArICdcIj8nICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24obG9jYWxTZWFyY2gucGF0aCwgb3B0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1zZyA9IFwiLiBEaWQgeW91IG1lYW4gb25lIG9mIHRoZXNlOiBcIiArIFZhbGlkYXRvci5wcmludChfT2JqZWN0JGtleXMob3B0aW9ucykpICsgVmFsaWRhdG9yLnByaW50TG9jYXRpb24ocGF0aCwgb3B0aW9uKTtcbiAgICAgIH1cbiAgICAgIGNvbnNvbGUuZXJyb3IoJyVjVW5rbm93biBvcHRpb24gZGV0ZWN0ZWQ6IFwiJyArIG9wdGlvbiArICdcIicgKyBtc2csIFZBTElEQVRPUl9QUklOVF9TVFlMRSQxKTtcbiAgICAgIGVycm9yRm91bmQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRyYXZlcnNlIHRoZSBvcHRpb25zIGluIHNlYXJjaCBmb3IgYSBtYXRjaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggICAgfCB3aGVyZSB0byBsb29rIGZvciB0aGUgYWN0dWFsIG9wdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlY3Vyc2l2ZT1mYWxzZV1cbiAgICAgKiBAcmV0dXJucyB7e2Nsb3Nlc3RNYXRjaDogc3RyaW5nLCBwYXRoOiBBcnJheSwgZGlzdGFuY2U6IG51bWJlcn19XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZpbmRJbk9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZEluT3B0aW9ucyhvcHRpb24sIG9wdGlvbnMsIHBhdGgpIHtcbiAgICAgIHZhciByZWN1cnNpdmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICAgICAgdmFyIG1pbiA9IDFlOTtcbiAgICAgIHZhciBjbG9zZXN0TWF0Y2ggPSBcIlwiO1xuICAgICAgdmFyIGNsb3Nlc3RNYXRjaFBhdGggPSBbXTtcbiAgICAgIHZhciBsb3dlckNhc2VPcHRpb24gPSBvcHRpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBpbmRleE1hdGNoID0gdW5kZWZpbmVkO1xuICAgICAgZm9yICh2YXIgb3AgaW4gb3B0aW9ucykge1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSB2b2lkIDA7XG4gICAgICAgIGlmIChvcHRpb25zW29wXS5fX3R5cGVfXyAhPT0gdW5kZWZpbmVkICYmIHJlY3Vyc2l2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBWYWxpZGF0b3IuZmluZEluT3B0aW9ucyhvcHRpb24sIG9wdGlvbnNbb3BdLCBjb3B5QW5kRXh0ZW5kQXJyYXkocGF0aCwgb3ApKTtcbiAgICAgICAgICBpZiAobWluID4gcmVzdWx0LmRpc3RhbmNlKSB7XG4gICAgICAgICAgICBjbG9zZXN0TWF0Y2ggPSByZXN1bHQuY2xvc2VzdE1hdGNoO1xuICAgICAgICAgICAgY2xvc2VzdE1hdGNoUGF0aCA9IHJlc3VsdC5wYXRoO1xuICAgICAgICAgICAgbWluID0gcmVzdWx0LmRpc3RhbmNlO1xuICAgICAgICAgICAgaW5kZXhNYXRjaCA9IHJlc3VsdC5pbmRleE1hdGNoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQxNjtcbiAgICAgICAgICBpZiAoX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MTYgPSBvcC50b0xvd2VyQ2FzZSgpKS5jYWxsKF9jb250ZXh0MTYsIGxvd2VyQ2FzZU9wdGlvbikgIT09IC0xKSB7XG4gICAgICAgICAgICBpbmRleE1hdGNoID0gb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpc3RhbmNlID0gVmFsaWRhdG9yLmxldmVuc2h0ZWluRGlzdGFuY2Uob3B0aW9uLCBvcCk7XG4gICAgICAgICAgaWYgKG1pbiA+IGRpc3RhbmNlKSB7XG4gICAgICAgICAgICBjbG9zZXN0TWF0Y2ggPSBvcDtcbiAgICAgICAgICAgIGNsb3Nlc3RNYXRjaFBhdGggPSBjb3B5QXJyYXkocGF0aCk7XG4gICAgICAgICAgICBtaW4gPSBkaXN0YW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNsb3Nlc3RNYXRjaDogY2xvc2VzdE1hdGNoLFxuICAgICAgICBwYXRoOiBjbG9zZXN0TWF0Y2hQYXRoLFxuICAgICAgICBkaXN0YW5jZTogbWluLFxuICAgICAgICBpbmRleE1hdGNoOiBpbmRleE1hdGNoXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHBhdGhcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInByaW50TG9jYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJpbnRMb2NhdGlvbihwYXRoLCBvcHRpb24pIHtcbiAgICAgIHZhciBwcmVmaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IFwiUHJvYmxlbSB2YWx1ZSBmb3VuZCBhdDogXFxuXCI7XG4gICAgICB2YXIgc3RyID0gXCJcXG5cXG5cIiArIHByZWZpeCArIFwib3B0aW9ucyA9IHtcXG5cIjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGkgKyAxOyBqKyspIHtcbiAgICAgICAgICBzdHIgKz0gXCIgIFwiO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSBwYXRoW2ldICsgXCI6IHtcXG5cIjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBwYXRoLmxlbmd0aCArIDE7IF9qKyspIHtcbiAgICAgICAgc3RyICs9IFwiICBcIjtcbiAgICAgIH1cbiAgICAgIHN0ciArPSBvcHRpb24gKyBcIlxcblwiO1xuICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgcGF0aC5sZW5ndGggKyAxOyBfaTUrKykge1xuICAgICAgICBmb3IgKHZhciBfajIgPSAwOyBfajIgPCBwYXRoLmxlbmd0aCAtIF9pNTsgX2oyKyspIHtcbiAgICAgICAgICBzdHIgKz0gXCIgIFwiO1xuICAgICAgICB9XG4gICAgICAgIHN0ciArPSBcIn1cXG5cIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHIgKyBcIlxcblxcblwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicHJpbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJpbnQob3B0aW9ucykge1xuICAgICAgcmV0dXJuIF9KU09OJHN0cmluZ2lmeShvcHRpb25zKS5yZXBsYWNlKC8oXCIpfChcXFspfChcXF0pfCgsXCJfX3R5cGVfX1wiKS9nLCBcIlwiKS5yZXBsYWNlKC8oLCkvZywgXCIsIFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQ29tcHV0ZSB0aGUgZWRpdCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gc3RyaW5nc1xuICAgICAqIGh0dHA6Ly9lbi53aWtpYm9va3Mub3JnL3dpa2kvQWxnb3JpdGhtX0ltcGxlbWVudGF0aW9uL1N0cmluZ3MvTGV2ZW5zaHRlaW5fZGlzdGFuY2UjSmF2YVNjcmlwdFxuICAgICAqXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDExIEFuZHJlaSBNYWNrZW56aWVcbiAgICAgKlxuICAgICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAgICpcbiAgICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICAgKlxuICAgICAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYlxuICAgICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fX1cbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibGV2ZW5zaHRlaW5EaXN0YW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsZXZlbnNodGVpbkRpc3RhbmNlKGEsIGIpIHtcbiAgICAgIGlmIChhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGIubGVuZ3RoO1xuICAgICAgaWYgKGIubGVuZ3RoID09PSAwKSByZXR1cm4gYS5sZW5ndGg7XG4gICAgICB2YXIgbWF0cml4ID0gW107XG5cbiAgICAgIC8vIGluY3JlbWVudCBhbG9uZyB0aGUgZmlyc3QgY29sdW1uIG9mIGVhY2ggcm93XG4gICAgICB2YXIgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPD0gYi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXRyaXhbaV0gPSBbaV07XG4gICAgICB9XG5cbiAgICAgIC8vIGluY3JlbWVudCBlYWNoIGNvbHVtbiBpbiB0aGUgZmlyc3Qgcm93XG4gICAgICB2YXIgajtcbiAgICAgIGZvciAoaiA9IDA7IGogPD0gYS5sZW5ndGg7IGorKykge1xuICAgICAgICBtYXRyaXhbMF1bal0gPSBqO1xuICAgICAgfVxuXG4gICAgICAvLyBGaWxsIGluIHRoZSByZXN0IG9mIHRoZSBtYXRyaXhcbiAgICAgIGZvciAoaSA9IDE7IGkgPD0gYi5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAxOyBqIDw9IGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAoYi5jaGFyQXQoaSAtIDEpID09IGEuY2hhckF0KGogLSAxKSkge1xuICAgICAgICAgICAgbWF0cml4W2ldW2pdID0gbWF0cml4W2kgLSAxXVtqIC0gMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IE1hdGgubWluKG1hdHJpeFtpIC0gMV1baiAtIDFdICsgMSxcbiAgICAgICAgICAgIC8vIHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgTWF0aC5taW4obWF0cml4W2ldW2ogLSAxXSArIDEsXG4gICAgICAgICAgICAvLyBpbnNlcnRpb25cbiAgICAgICAgICAgIG1hdHJpeFtpIC0gMV1bal0gKyAxKSk7IC8vIGRlbGV0aW9uXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXRyaXhbYi5sZW5ndGhdW2EubGVuZ3RoXTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFZhbGlkYXRvcjtcbn0oKTtcbnZhciBBY3RpdmF0b3IgPSBBY3RpdmF0b3IkMTtcbnZhciBDb25maWd1cmF0b3IgPSBDb25maWd1cmF0b3IkMTtcbnZhciBIYW1tZXIgPSBIYW1tZXIkMTtcbnZhciBQb3B1cCA9IFBvcHVwJDE7XG52YXIgVkFMSURBVE9SX1BSSU5UX1NUWUxFID0gVkFMSURBVE9SX1BSSU5UX1NUWUxFJDE7XG52YXIgVmFsaWRhdG9yID0gVmFsaWRhdG9yJDE7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvdHlwZS1idWlsdGlucyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuXG4vKipcbiAqIFBhcnNlIGEgdGV4dCBzb3VyY2UgY29udGFpbmluZyBkYXRhIGluIERPVCBsYW5ndWFnZSBpbnRvIGEgSlNPTiBvYmplY3QuXG4gKiBUaGUgb2JqZWN0IGNvbnRhaW5zIHR3byBsaXN0czogb25lIHdpdGggbm9kZXMgYW5kIG9uZSB3aXRoIGVkZ2VzLlxuICpcbiAqIERPVCBsYW5ndWFnZSByZWZlcmVuY2U6IGh0dHA6Ly93d3cuZ3JhcGh2aXoub3JnL2RvYy9pbmZvL2xhbmcuaHRtbFxuICpcbiAqIERPVCBsYW5ndWFnZSBhdHRyaWJ1dGVzOiBodHRwOi8vZ3JhcGh2aXoub3JnL2NvbnRlbnQvYXR0cnNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAgICAgVGV4dCBjb250YWluaW5nIGEgZ3JhcGggaW4gRE9ULW5vdGF0aW9uXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBncmFwaCAgIEFuIG9iamVjdCBjb250YWluaW5nIHR3byBwYXJhbWV0ZXJzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHtPYmplY3RbXX0gbm9kZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB7T2JqZWN0W119IGVkZ2VzXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVE9ET1xuICogPT09PVxuICpcbiAqIEZvciBsYWJlbCBoYW5kbGluZywgdGhpcyBpcyBhbiBpbmNvbXBsZXRlIGltcGxlbWVudGF0aW9uLiBGcm9tIGRvY3MgKHF1b3RlICMzMDE1KTpcbiAqXG4gKiA+IHRoZSBlc2NhcGUgc2VxdWVuY2VzIFwiXFxuXCIsIFwiXFxsXCIgYW5kIFwiXFxyXCIgZGl2aWRlIHRoZSBsYWJlbCBpbnRvIGxpbmVzLCBjZW50ZXJlZCxcbiAqID4gbGVmdC1qdXN0aWZpZWQsIGFuZCByaWdodC1qdXN0aWZpZWQsIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBTb3VyY2U6IGh0dHA6Ly93d3cuZ3JhcGh2aXoub3JnL2NvbnRlbnQvYXR0cnMja2VzY1N0cmluZ1xuICpcbiAqID4gQXMgYW5vdGhlciBhaWQgZm9yIHJlYWRhYmlsaXR5LCBkb3QgYWxsb3dzIGRvdWJsZS1xdW90ZWQgc3RyaW5ncyB0byBzcGFuIG11bHRpcGxlIHBoeXNpY2FsXG4gKiA+IGxpbmVzIHVzaW5nIHRoZSBzdGFuZGFyZCBDIGNvbnZlbnRpb24gb2YgYSBiYWNrc2xhc2ggaW1tZWRpYXRlbHkgcHJlY2VkaW5nIGEgbmV3bGluZVxuICogPiBjaGFyYWN0ZXJcbiAqID4gSW4gYWRkaXRpb24sIGRvdWJsZS1xdW90ZWQgc3RyaW5ncyBjYW4gYmUgY29uY2F0ZW5hdGVkIHVzaW5nIGEgJysnIG9wZXJhdG9yLlxuICogPiBBcyBIVE1MIHN0cmluZ3MgY2FuIGNvbnRhaW4gbmV3bGluZSBjaGFyYWN0ZXJzLCB3aGljaCBhcmUgdXNlZCBzb2xlbHkgZm9yIGZvcm1hdHRpbmcsXG4gKiA+IHRoZSBsYW5ndWFnZSBkb2VzIG5vdCBhbGxvdyBlc2NhcGVkIG5ld2xpbmVzIG9yIGNvbmNhdGVuYXRpb24gb3BlcmF0b3JzIHRvIGJlIHVzZWRcbiAqID4gd2l0aGluIHRoZW0uXG4gKlxuICogLSBDdXJyZW50bHksIG9ubHkgJ1xcXFxuJyBpcyBoYW5kbGVkXG4gKiAtIE5vdGUgdGhhdCB0ZXh0IGV4cGxpY2l0bHkgc2F5cyAnbGFiZWxzJzsgdGhlIGRvdCBwYXJzZXIgY3VycmVudGx5IGhhbmRsZXMgZXNjYXBlXG4gKiAgIHNlcXVlbmNlcyBpbiAqKmFsbCoqIHN0cmluZ3MuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRE9UKGRhdGEpIHtcbiAgZG90ID0gZGF0YTtcbiAgcmV0dXJuIHBhcnNlR3JhcGgoKTtcbn1cblxuLy8gbWFwcGluZyBvZiBhdHRyaWJ1dGVzIGZyb20gRE9UICh0aGUga2V5cykgdG8gdmlzLmpzICh0aGUgdmFsdWVzKVxudmFyIE5PREVfQVRUUl9NQVBQSU5HID0ge1xuICBmb250c2l6ZTogXCJmb250LnNpemVcIixcbiAgZm9udGNvbG9yOiBcImZvbnQuY29sb3JcIixcbiAgbGFiZWxmb250Y29sb3I6IFwiZm9udC5jb2xvclwiLFxuICBmb250bmFtZTogXCJmb250LmZhY2VcIixcbiAgY29sb3I6IFtcImNvbG9yLmJvcmRlclwiLCBcImNvbG9yLmJhY2tncm91bmRcIl0sXG4gIGZpbGxjb2xvcjogXCJjb2xvci5iYWNrZ3JvdW5kXCIsXG4gIHRvb2x0aXA6IFwidGl0bGVcIixcbiAgbGFiZWx0b29sdGlwOiBcInRpdGxlXCJcbn07XG52YXIgRURHRV9BVFRSX01BUFBJTkcgPSBfT2JqZWN0JGNyZWF0ZSQxKE5PREVfQVRUUl9NQVBQSU5HKTtcbkVER0VfQVRUUl9NQVBQSU5HLmNvbG9yID0gXCJjb2xvci5jb2xvclwiO1xuRURHRV9BVFRSX01BUFBJTkcuc3R5bGUgPSBcImRhc2hlc1wiO1xuXG4vLyB0b2tlbiB0eXBlcyBlbnVtZXJhdGlvblxudmFyIFRPS0VOVFlQRSA9IHtcbiAgTlVMTDogMCxcbiAgREVMSU1JVEVSOiAxLFxuICBJREVOVElGSUVSOiAyLFxuICBVTktOT1dOOiAzXG59O1xuXG4vLyBtYXAgd2l0aCBhbGwgZGVsaW1pdGVyc1xudmFyIERFTElNSVRFUlMgPSB7XG4gIFwie1wiOiB0cnVlLFxuICBcIn1cIjogdHJ1ZSxcbiAgXCJbXCI6IHRydWUsXG4gIFwiXVwiOiB0cnVlLFxuICBcIjtcIjogdHJ1ZSxcbiAgXCI9XCI6IHRydWUsXG4gIFwiLFwiOiB0cnVlLFxuICBcIi0+XCI6IHRydWUsXG4gIFwiLS1cIjogdHJ1ZVxufTtcbnZhciBkb3QgPSBcIlwiOyAvLyBjdXJyZW50IGRvdCBmaWxlXG52YXIgaW5kZXggPSAwOyAvLyBjdXJyZW50IGluZGV4IGluIGRvdCBmaWxlXG52YXIgYyA9IFwiXCI7IC8vIGN1cnJlbnQgdG9rZW4gY2hhcmFjdGVyIGluIGV4cHJcbnZhciB0b2tlbiA9IFwiXCI7IC8vIGN1cnJlbnQgdG9rZW5cbnZhciB0b2tlblR5cGUgPSBUT0tFTlRZUEUuTlVMTDsgLy8gdHlwZSBvZiB0aGUgdG9rZW5cblxuLyoqXG4gKiBHZXQgdGhlIGZpcnN0IGNoYXJhY3RlciBmcm9tIHRoZSBkb3QgZmlsZS5cbiAqIFRoZSBjaGFyYWN0ZXIgaXMgc3RvcmVkIGludG8gdGhlIGNoYXIgYy4gSWYgdGhlIGVuZCBvZiB0aGUgZG90IGZpbGUgaXNcbiAqIHJlYWNoZWQsIHRoZSBmdW5jdGlvbiBwdXRzIGFuIGVtcHR5IHN0cmluZyBpbiBjLlxuICovXG5mdW5jdGlvbiBmaXJzdCgpIHtcbiAgaW5kZXggPSAwO1xuICBjID0gZG90LmNoYXJBdCgwKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5leHQgY2hhcmFjdGVyIGZyb20gdGhlIGRvdCBmaWxlLlxuICogVGhlIGNoYXJhY3RlciBpcyBzdG9yZWQgaW50byB0aGUgY2hhciBjLiBJZiB0aGUgZW5kIG9mIHRoZSBkb3QgZmlsZSBpc1xuICogcmVhY2hlZCwgdGhlIGZ1bmN0aW9uIHB1dHMgYW4gZW1wdHkgc3RyaW5nIGluIGMuXG4gKi9cbmZ1bmN0aW9uIG5leHQoKSB7XG4gIGluZGV4Kys7XG4gIGMgPSBkb3QuY2hhckF0KGluZGV4KTtcbn1cblxuLyoqXG4gKiBQcmV2aWV3IHRoZSBuZXh0IGNoYXJhY3RlciBmcm9tIHRoZSBkb3QgZmlsZS5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBjTmV4dFxuICovXG5mdW5jdGlvbiBuZXh0UHJldmlldygpIHtcbiAgcmV0dXJuIGRvdC5jaGFyQXQoaW5kZXggKyAxKTtcbn1cblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgZ2l2ZW4gY2hhcmFjdGVyIGlzIGFscGhhYmV0aWMgb3IgbnVtZXJpYyAoIGEtekEtWl8wLTkuOiMgKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaXNBbHBoYU51bWVyaWNcbiAqL1xuZnVuY3Rpb24gaXNBbHBoYU51bWVyaWMoYykge1xuICB2YXIgY2hhckNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gIGlmIChjaGFyQ29kZSA8IDQ3KSB7XG4gICAgLy8gIy5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDM1IHx8IGNoYXJDb2RlID09PSA0NjtcbiAgfVxuICBpZiAoY2hhckNvZGUgPCA1OSkge1xuICAgIC8vIDAtOSBhbmQgOlxuICAgIHJldHVybiBjaGFyQ29kZSA+IDQ3O1xuICB9XG4gIGlmIChjaGFyQ29kZSA8IDkxKSB7XG4gICAgLy8gQS1aXG4gICAgcmV0dXJuIGNoYXJDb2RlID4gNjQ7XG4gIH1cbiAgaWYgKGNoYXJDb2RlIDwgOTYpIHtcbiAgICAvLyBfXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSA5NTtcbiAgfVxuICBpZiAoY2hhckNvZGUgPCAxMjMpIHtcbiAgICAvLyBhLXpcbiAgICByZXR1cm4gY2hhckNvZGUgPiA5NjtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogTWVyZ2UgYWxsIG9wdGlvbnMgb2Ygb2JqZWN0IGIgaW50byBvYmplY3QgYlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhXG4gKiBAcGFyYW0ge29iamVjdH0gYlxuICogQHJldHVybnMge29iamVjdH0gYVxuICovXG5mdW5jdGlvbiBtZXJnZSQxKGEsIGIpIHtcbiAgaWYgKCFhKSB7XG4gICAgYSA9IHt9O1xuICB9XG4gIGlmIChiKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBiKSB7XG4gICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBhW25hbWVdID0gYltuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogU2V0IGEgdmFsdWUgaW4gYW4gb2JqZWN0LCB3aGVyZSB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIG5hbWUgY2FuIGJlIGFcbiAqIHBhdGggd2l0aCBuZXN0ZWQgcGFyYW1ldGVycy4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIHZhciBvYmogPSB7YTogMn07XG4gKiAgICAgc2V0VmFsdWUob2JqLCAnYi5jJywgMyk7ICAgICAvLyBvYmogPSB7YTogMiwgYjoge2M6IDN9fVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoICBBIHBhcmFtZXRlciBuYW1lIG9yIGRvdC1zZXBhcmF0ZWQgcGFyYW1ldGVyIHBhdGgsXG4gKiAgICAgICAgICAgICAgICAgICAgICBsaWtlIFwiY29sb3IuaGlnaGxpZ2h0LmJvcmRlclwiLlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBzZXRWYWx1ZShvYmosIHBhdGgsIHZhbHVlKSB7XG4gIHZhciBrZXlzID0gcGF0aC5zcGxpdChcIi5cIik7XG4gIHZhciBvID0gb2JqO1xuICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICB2YXIga2V5ID0ga2V5cy5zaGlmdCgpO1xuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgLy8gdGhpcyBpc24ndCB0aGUgZW5kIHBvaW50XG4gICAgICBpZiAoIW9ba2V5XSkge1xuICAgICAgICBvW2tleV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIG8gPSBvW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoaXMgaXMgdGhlIGVuZCBwb2ludFxuICAgICAgb1trZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkIGEgbm9kZSB0byBhIGdyYXBoIG9iamVjdC4gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIG5vZGUgd2l0aFxuICogdGhlIHNhbWUgaWQsIHRoZWlyIGF0dHJpYnV0ZXMgd2lsbCBiZSBtZXJnZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge29iamVjdH0gbm9kZVxuICovXG5mdW5jdGlvbiBhZGROb2RlKGdyYXBoLCBub2RlKSB7XG4gIHZhciBpLCBsZW47XG4gIHZhciBjdXJyZW50ID0gbnVsbDtcblxuICAvLyBmaW5kIHJvb3QgZ3JhcGggKGluIGNhc2Ugb2Ygc3ViZ3JhcGgpXG4gIHZhciBncmFwaHMgPSBbZ3JhcGhdOyAvLyBsaXN0IHdpdGggYWxsIGdyYXBocyBmcm9tIGN1cnJlbnQgZ3JhcGggdG8gcm9vdCBncmFwaFxuICB2YXIgcm9vdCA9IGdyYXBoO1xuICB3aGlsZSAocm9vdC5wYXJlbnQpIHtcbiAgICBncmFwaHMucHVzaChyb290LnBhcmVudCk7XG4gICAgcm9vdCA9IHJvb3QucGFyZW50O1xuICB9XG5cbiAgLy8gZmluZCBleGlzdGluZyBub2RlIChhdCByb290IGxldmVsKSBieSBpdHMgaWRcbiAgaWYgKHJvb3Qubm9kZXMpIHtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSByb290Lm5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAobm9kZS5pZCA9PT0gcm9vdC5ub2Rlc1tpXS5pZCkge1xuICAgICAgICBjdXJyZW50ID0gcm9vdC5ub2Rlc1tpXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghY3VycmVudCkge1xuICAgIC8vIHRoaXMgaXMgYSBuZXcgbm9kZVxuICAgIGN1cnJlbnQgPSB7XG4gICAgICBpZDogbm9kZS5pZFxuICAgIH07XG4gICAgaWYgKGdyYXBoLm5vZGUpIHtcbiAgICAgIC8vIGNsb25lIGRlZmF1bHQgYXR0cmlidXRlc1xuICAgICAgY3VycmVudC5hdHRyID0gbWVyZ2UkMShjdXJyZW50LmF0dHIsIGdyYXBoLm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCBub2RlIHRvIHRoaXMgKHN1YilncmFwaCBhbmQgYWxsIGl0cyBwYXJlbnQgZ3JhcGhzXG4gIGZvciAoaSA9IGdyYXBocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBfY29udGV4dDtcbiAgICB2YXIgZyA9IGdyYXBoc1tpXTtcbiAgICBpZiAoIWcubm9kZXMpIHtcbiAgICAgIGcubm9kZXMgPSBbXTtcbiAgICB9XG4gICAgaWYgKF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dCA9IGcubm9kZXMpLmNhbGwoX2NvbnRleHQsIGN1cnJlbnQpID09PSAtMSkge1xuICAgICAgZy5ub2Rlcy5wdXNoKGN1cnJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIG1lcmdlIGF0dHJpYnV0ZXNcbiAgaWYgKG5vZGUuYXR0cikge1xuICAgIGN1cnJlbnQuYXR0ciA9IG1lcmdlJDEoY3VycmVudC5hdHRyLCBub2RlLmF0dHIpO1xuICB9XG59XG5cbi8qKlxuICogQWRkIGFuIGVkZ2UgdG8gYSBncmFwaCBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ3JhcGhcbiAqIEBwYXJhbSB7b2JqZWN0fSBlZGdlXG4gKi9cbmZ1bmN0aW9uIGFkZEVkZ2UoZ3JhcGgsIGVkZ2UpIHtcbiAgaWYgKCFncmFwaC5lZGdlcykge1xuICAgIGdyYXBoLmVkZ2VzID0gW107XG4gIH1cbiAgZ3JhcGguZWRnZXMucHVzaChlZGdlKTtcbiAgaWYgKGdyYXBoLmVkZ2UpIHtcbiAgICB2YXIgYXR0ciA9IG1lcmdlJDEoe30sIGdyYXBoLmVkZ2UpOyAvLyBjbG9uZSBkZWZhdWx0IGF0dHJpYnV0ZXNcbiAgICBlZGdlLmF0dHIgPSBtZXJnZSQxKGF0dHIsIGVkZ2UuYXR0cik7IC8vIG1lcmdlIGF0dHJpYnV0ZXNcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBlZGdlIHRvIGEgZ3JhcGggb2JqZWN0XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlciB8IG9iamVjdH0gZnJvbVxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBvYmplY3R9IHRvXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtvYmplY3QgfCBudWxsfSBhdHRyXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBlZGdlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVkZ2UoZ3JhcGgsIGZyb20sIHRvLCB0eXBlLCBhdHRyKSB7XG4gIHZhciBlZGdlID0ge1xuICAgIGZyb206IGZyb20sXG4gICAgdG86IHRvLFxuICAgIHR5cGU6IHR5cGVcbiAgfTtcbiAgaWYgKGdyYXBoLmVkZ2UpIHtcbiAgICBlZGdlLmF0dHIgPSBtZXJnZSQxKHt9LCBncmFwaC5lZGdlKTsgLy8gY2xvbmUgZGVmYXVsdCBhdHRyaWJ1dGVzXG4gIH1cblxuICBlZGdlLmF0dHIgPSBtZXJnZSQxKGVkZ2UuYXR0ciB8fCB7fSwgYXR0cik7IC8vIG1lcmdlIGF0dHJpYnV0ZXNcblxuICAvLyBNb3ZlIGFycm93cyBhdHRyaWJ1dGUgZnJvbSBhdHRyIHRvIGVkZ2UgdGVtcG9yYWxseSBjcmVhdGVkIGluXG4gIC8vIHBhcnNlQXR0cmlidXRlTGlzdCgpLlxuICBpZiAoYXR0ciAhPSBudWxsKSB7XG4gICAgaWYgKGF0dHIuaGFzT3duUHJvcGVydHkoXCJhcnJvd3NcIikgJiYgYXR0cltcImFycm93c1wiXSAhPSBudWxsKSB7XG4gICAgICBlZGdlW1wiYXJyb3dzXCJdID0ge1xuICAgICAgICB0bzoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgdHlwZTogYXR0ci5hcnJvd3MudHlwZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYXR0cltcImFycm93c1wiXSA9IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBlZGdlO1xufVxuXG4vKipcbiAqIEdldCBuZXh0IHRva2VuIGluIHRoZSBjdXJyZW50IGRvdCBmaWxlLlxuICogVGhlIHRva2VuIGFuZCB0b2tlbiB0eXBlIGFyZSBhdmFpbGFibGUgYXMgdG9rZW4gYW5kIHRva2VuVHlwZVxuICovXG5mdW5jdGlvbiBnZXRUb2tlbigpIHtcbiAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLk5VTEw7XG4gIHRva2VuID0gXCJcIjtcblxuICAvLyBza2lwIG92ZXIgd2hpdGVzcGFjZXNcbiAgd2hpbGUgKGMgPT09IFwiIFwiIHx8IGMgPT09IFwiXFx0XCIgfHwgYyA9PT0gXCJcXG5cIiB8fCBjID09PSBcIlxcclwiKSB7XG4gICAgLy8gc3BhY2UsIHRhYiwgZW50ZXJcbiAgICBuZXh0KCk7XG4gIH1cbiAgZG8ge1xuICAgIHZhciBpc0NvbW1lbnQgPSBmYWxzZTtcblxuICAgIC8vIHNraXAgY29tbWVudFxuICAgIGlmIChjID09PSBcIiNcIikge1xuICAgICAgLy8gZmluZCB0aGUgcHJldmlvdXMgbm9uLXNwYWNlIGNoYXJhY3RlclxuICAgICAgdmFyIGkgPSBpbmRleCAtIDE7XG4gICAgICB3aGlsZSAoZG90LmNoYXJBdChpKSA9PT0gXCIgXCIgfHwgZG90LmNoYXJBdChpKSA9PT0gXCJcXHRcIikge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBpZiAoZG90LmNoYXJBdChpKSA9PT0gXCJcXG5cIiB8fCBkb3QuY2hhckF0KGkpID09PSBcIlwiKSB7XG4gICAgICAgIC8vIHRoZSAjIGlzIGF0IHRoZSBzdGFydCBvZiBhIGxpbmUsIHRoaXMgaXMgaW5kZWVkIGEgbGluZSBjb21tZW50XG4gICAgICAgIHdoaWxlIChjICE9IFwiXCIgJiYgYyAhPSBcIlxcblwiKSB7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlzQ29tbWVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjID09PSBcIi9cIiAmJiBuZXh0UHJldmlldygpID09PSBcIi9cIikge1xuICAgICAgLy8gc2tpcCBsaW5lIGNvbW1lbnRcbiAgICAgIHdoaWxlIChjICE9IFwiXCIgJiYgYyAhPSBcIlxcblwiKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICAgIGlzQ29tbWVudCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjID09PSBcIi9cIiAmJiBuZXh0UHJldmlldygpID09PSBcIipcIikge1xuICAgICAgLy8gc2tpcCBibG9jayBjb21tZW50XG4gICAgICB3aGlsZSAoYyAhPSBcIlwiKSB7XG4gICAgICAgIGlmIChjID09PSBcIipcIiAmJiBuZXh0UHJldmlldygpID09PSBcIi9cIikge1xuICAgICAgICAgIC8vIGVuZCBvZiBibG9jayBjb21tZW50IGZvdW5kLiBza2lwIHRoZXNlIGxhc3QgdHdvIGNoYXJhY3RlcnNcbiAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaXNDb21tZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBza2lwIG92ZXIgd2hpdGVzcGFjZXNcbiAgICB3aGlsZSAoYyA9PT0gXCIgXCIgfHwgYyA9PT0gXCJcXHRcIiB8fCBjID09PSBcIlxcblwiIHx8IGMgPT09IFwiXFxyXCIpIHtcbiAgICAgIC8vIHNwYWNlLCB0YWIsIGVudGVyXG4gICAgICBuZXh0KCk7XG4gICAgfVxuICB9IHdoaWxlIChpc0NvbW1lbnQpO1xuXG4gIC8vIGNoZWNrIGZvciBlbmQgb2YgZG90IGZpbGVcbiAgaWYgKGMgPT09IFwiXCIpIHtcbiAgICAvLyB0b2tlbiBpcyBzdGlsbCBlbXB0eVxuICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gY2hlY2sgZm9yIGRlbGltaXRlcnMgY29uc2lzdGluZyBvZiAyIGNoYXJhY3RlcnNcbiAgdmFyIGMyID0gYyArIG5leHRQcmV2aWV3KCk7XG4gIGlmIChERUxJTUlURVJTW2MyXSkge1xuICAgIHRva2VuVHlwZSA9IFRPS0VOVFlQRS5ERUxJTUlURVI7XG4gICAgdG9rZW4gPSBjMjtcbiAgICBuZXh0KCk7XG4gICAgbmV4dCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBkZWxpbWl0ZXJzIGNvbnNpc3Rpbmcgb2YgMSBjaGFyYWN0ZXJcbiAgaWYgKERFTElNSVRFUlNbY10pIHtcbiAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuREVMSU1JVEVSO1xuICAgIHRva2VuID0gYztcbiAgICBuZXh0KCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gY2hlY2sgZm9yIGFuIGlkZW50aWZpZXIgKG51bWJlciBvciBzdHJpbmcpXG4gIC8vIFRPRE86IG1vcmUgcHJlY2lzZSBwYXJzaW5nIG9mIG51bWJlcnMvc3RyaW5ncyAoYW5kIHRoZSBwb3J0IHNlcGFyYXRvciAnOicpXG4gIGlmIChpc0FscGhhTnVtZXJpYyhjKSB8fCBjID09PSBcIi1cIikge1xuICAgIHRva2VuICs9IGM7XG4gICAgbmV4dCgpO1xuICAgIHdoaWxlIChpc0FscGhhTnVtZXJpYyhjKSkge1xuICAgICAgdG9rZW4gKz0gYztcbiAgICAgIG5leHQoKTtcbiAgICB9XG4gICAgaWYgKHRva2VuID09PSBcImZhbHNlXCIpIHtcbiAgICAgIHRva2VuID0gZmFsc2U7IC8vIGNvbnZlcnQgdG8gYm9vbGVhblxuICAgIH0gZWxzZSBpZiAodG9rZW4gPT09IFwidHJ1ZVwiKSB7XG4gICAgICB0b2tlbiA9IHRydWU7IC8vIGNvbnZlcnQgdG8gYm9vbGVhblxuICAgIH0gZWxzZSBpZiAoIWlzTmFOKE51bWJlcih0b2tlbikpKSB7XG4gICAgICB0b2tlbiA9IE51bWJlcih0b2tlbik7IC8vIGNvbnZlcnQgdG8gbnVtYmVyXG4gICAgfVxuXG4gICAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLklERU5USUZJRVI7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gY2hlY2sgZm9yIGEgc3RyaW5nIGVuY2xvc2VkIGJ5IGRvdWJsZSBxdW90ZXNcbiAgaWYgKGMgPT09ICdcIicpIHtcbiAgICBuZXh0KCk7XG4gICAgd2hpbGUgKGMgIT0gXCJcIiAmJiAoYyAhPSAnXCInIHx8IGMgPT09ICdcIicgJiYgbmV4dFByZXZpZXcoKSA9PT0gJ1wiJykpIHtcbiAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgIC8vIHNraXAgdGhlIGVzY2FwZSBjaGFyYWN0ZXJcbiAgICAgICAgdG9rZW4gKz0gYztcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfSBlbHNlIGlmIChjID09PSBcIlxcXFxcIiAmJiBuZXh0UHJldmlldygpID09PSBcIm5cIikge1xuICAgICAgICAvLyBIb25vciBhIG5ld2xpbmUgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgIHRva2VuICs9IFwiXFxuXCI7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2VuICs9IGM7XG4gICAgICB9XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICAgIGlmIChjICE9ICdcIicpIHtcbiAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKCdFbmQgb2Ygc3RyaW5nIFwiIGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIG5leHQoKTtcbiAgICB0b2tlblR5cGUgPSBUT0tFTlRZUEUuSURFTlRJRklFUjtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzb21ldGhpbmcgdW5rbm93biBpcyBmb3VuZCwgd3JvbmcgY2hhcmFjdGVycywgYSBzeW50YXggZXJyb3JcbiAgdG9rZW5UeXBlID0gVE9LRU5UWVBFLlVOS05PV047XG4gIHdoaWxlIChjICE9IFwiXCIpIHtcbiAgICB0b2tlbiArPSBjO1xuICAgIG5leHQoKTtcbiAgfVxuICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1N5bnRheCBlcnJvciBpbiBwYXJ0IFwiJyArIGNob3AodG9rZW4sIDMwKSArICdcIicpO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgZ3JhcGguXG4gKlxuICogQHJldHVybnMge29iamVjdH0gZ3JhcGhcbiAqL1xuZnVuY3Rpb24gcGFyc2VHcmFwaCgpIHtcbiAgdmFyIGdyYXBoID0ge307XG4gIGZpcnN0KCk7XG4gIGdldFRva2VuKCk7XG5cbiAgLy8gb3B0aW9uYWwgc3RyaWN0IGtleXdvcmRcbiAgaWYgKHRva2VuID09PSBcInN0cmljdFwiKSB7XG4gICAgZ3JhcGguc3RyaWN0ID0gdHJ1ZTtcbiAgICBnZXRUb2tlbigpO1xuICB9XG5cbiAgLy8gZ3JhcGggb3IgZGlncmFwaCBrZXl3b3JkXG4gIGlmICh0b2tlbiA9PT0gXCJncmFwaFwiIHx8IHRva2VuID09PSBcImRpZ3JhcGhcIikge1xuICAgIGdyYXBoLnR5cGUgPSB0b2tlbjtcbiAgICBnZXRUb2tlbigpO1xuICB9XG5cbiAgLy8gb3B0aW9uYWwgZ3JhcGggaWRcbiAgaWYgKHRva2VuVHlwZSA9PT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICBncmFwaC5pZCA9IHRva2VuO1xuICAgIGdldFRva2VuKCk7XG4gIH1cblxuICAvLyBvcGVuIGFuZ2xlIGJyYWNrZXRcbiAgaWYgKHRva2VuICE9IFwie1wiKSB7XG4gICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJBbmdsZSBicmFja2V0IHsgZXhwZWN0ZWRcIik7XG4gIH1cbiAgZ2V0VG9rZW4oKTtcblxuICAvLyBzdGF0ZW1lbnRzXG4gIHBhcnNlU3RhdGVtZW50cyhncmFwaCk7XG5cbiAgLy8gY2xvc2UgYW5nbGUgYnJhY2tldFxuICBpZiAodG9rZW4gIT0gXCJ9XCIpIHtcbiAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkFuZ2xlIGJyYWNrZXQgfSBleHBlY3RlZFwiKTtcbiAgfVxuICBnZXRUb2tlbigpO1xuXG4gIC8vIGVuZCBvZiBmaWxlXG4gIGlmICh0b2tlbiAhPT0gXCJcIikge1xuICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiRW5kIG9mIGZpbGUgZXhwZWN0ZWRcIik7XG4gIH1cbiAgZ2V0VG9rZW4oKTtcblxuICAvLyByZW1vdmUgdGVtcG9yYXJ5IGRlZmF1bHQgb3B0aW9uc1xuICBkZWxldGUgZ3JhcGgubm9kZTtcbiAgZGVsZXRlIGdyYXBoLmVkZ2U7XG4gIGRlbGV0ZSBncmFwaC5ncmFwaDtcbiAgcmV0dXJuIGdyYXBoO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCB3aXRoIHN0YXRlbWVudHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU3RhdGVtZW50cyhncmFwaCkge1xuICB3aGlsZSAodG9rZW4gIT09IFwiXCIgJiYgdG9rZW4gIT0gXCJ9XCIpIHtcbiAgICBwYXJzZVN0YXRlbWVudChncmFwaCk7XG4gICAgaWYgKHRva2VuID09PSBcIjtcIikge1xuICAgICAgZ2V0VG9rZW4oKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHNpbmdsZSBzdGF0ZW1lbnQuIENhbiBiZSBhIGFuIGF0dHJpYnV0ZSBzdGF0ZW1lbnQsIG5vZGVcbiAqIHN0YXRlbWVudCwgYSBzZXJpZXMgb2Ygbm9kZSBzdGF0ZW1lbnRzIGFuZCBlZGdlIHN0YXRlbWVudHMsIG9yIGFcbiAqIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZ3JhcGhcbiAqL1xuZnVuY3Rpb24gcGFyc2VTdGF0ZW1lbnQoZ3JhcGgpIHtcbiAgLy8gcGFyc2Ugc3ViZ3JhcGhcbiAgdmFyIHN1YmdyYXBoID0gcGFyc2VTdWJncmFwaChncmFwaCk7XG4gIGlmIChzdWJncmFwaCkge1xuICAgIC8vIGVkZ2Ugc3RhdGVtZW50c1xuICAgIHBhcnNlRWRnZShncmFwaCwgc3ViZ3JhcGgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHBhcnNlIGFuIGF0dHJpYnV0ZSBzdGF0ZW1lbnRcbiAgdmFyIGF0dHIgPSBwYXJzZUF0dHJpYnV0ZVN0YXRlbWVudChncmFwaCk7XG4gIGlmIChhdHRyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gcGFyc2Ugbm9kZVxuICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJJZGVudGlmaWVyIGV4cGVjdGVkXCIpO1xuICB9XG4gIHZhciBpZCA9IHRva2VuOyAvLyBpZCBjYW4gYmUgYSBzdHJpbmcgb3IgYSBudW1iZXJcbiAgZ2V0VG9rZW4oKTtcbiAgaWYgKHRva2VuID09PSBcIj1cIikge1xuICAgIC8vIGlkIHN0YXRlbWVudFxuICAgIGdldFRva2VuKCk7XG4gICAgaWYgKHRva2VuVHlwZSAhPSBUT0tFTlRZUEUuSURFTlRJRklFUikge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJJZGVudGlmaWVyIGV4cGVjdGVkXCIpO1xuICAgIH1cbiAgICBncmFwaFtpZF0gPSB0b2tlbjtcbiAgICBnZXRUb2tlbigpO1xuICAgIC8vIFRPRE86IGltcGxlbWVudCBjb21tYSBzZXBhcmF0ZWQgbGlzdCB3aXRoIFwiYV9saXN0OiBJRD1JRCBbJywnXSBbYV9saXN0XSBcIlxuICB9IGVsc2Uge1xuICAgIHBhcnNlTm9kZVN0YXRlbWVudChncmFwaCwgaWQpO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYSBzdWJncmFwaFxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBncmFwaCAgICBwYXJlbnQgZ3JhcGggb2JqZWN0XG4gKiBAcmV0dXJucyB7b2JqZWN0IHwgbnVsbH0gc3ViZ3JhcGhcbiAqL1xuZnVuY3Rpb24gcGFyc2VTdWJncmFwaChncmFwaCkge1xuICB2YXIgc3ViZ3JhcGggPSBudWxsO1xuXG4gIC8vIG9wdGlvbmFsIHN1YmdyYXBoIGtleXdvcmRcbiAgaWYgKHRva2VuID09PSBcInN1YmdyYXBoXCIpIHtcbiAgICBzdWJncmFwaCA9IHt9O1xuICAgIHN1YmdyYXBoLnR5cGUgPSBcInN1YmdyYXBoXCI7XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIC8vIG9wdGlvbmFsIGdyYXBoIGlkXG4gICAgaWYgKHRva2VuVHlwZSA9PT0gVE9LRU5UWVBFLklERU5USUZJRVIpIHtcbiAgICAgIHN1YmdyYXBoLmlkID0gdG9rZW47XG4gICAgICBnZXRUb2tlbigpO1xuICAgIH1cbiAgfVxuXG4gIC8vIG9wZW4gYW5nbGUgYnJhY2tldFxuICBpZiAodG9rZW4gPT09IFwie1wiKSB7XG4gICAgZ2V0VG9rZW4oKTtcbiAgICBpZiAoIXN1YmdyYXBoKSB7XG4gICAgICBzdWJncmFwaCA9IHt9O1xuICAgIH1cbiAgICBzdWJncmFwaC5wYXJlbnQgPSBncmFwaDtcbiAgICBzdWJncmFwaC5ub2RlID0gZ3JhcGgubm9kZTtcbiAgICBzdWJncmFwaC5lZGdlID0gZ3JhcGguZWRnZTtcbiAgICBzdWJncmFwaC5ncmFwaCA9IGdyYXBoLmdyYXBoO1xuXG4gICAgLy8gc3RhdGVtZW50c1xuICAgIHBhcnNlU3RhdGVtZW50cyhzdWJncmFwaCk7XG5cbiAgICAvLyBjbG9zZSBhbmdsZSBicmFja2V0XG4gICAgaWYgKHRva2VuICE9IFwifVwiKSB7XG4gICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkFuZ2xlIGJyYWNrZXQgfSBleHBlY3RlZFwiKTtcbiAgICB9XG4gICAgZ2V0VG9rZW4oKTtcblxuICAgIC8vIHJlbW92ZSB0ZW1wb3JhcnkgZGVmYXVsdCBvcHRpb25zXG4gICAgZGVsZXRlIHN1YmdyYXBoLm5vZGU7XG4gICAgZGVsZXRlIHN1YmdyYXBoLmVkZ2U7XG4gICAgZGVsZXRlIHN1YmdyYXBoLmdyYXBoO1xuICAgIGRlbGV0ZSBzdWJncmFwaC5wYXJlbnQ7XG5cbiAgICAvLyByZWdpc3RlciBhdCB0aGUgcGFyZW50IGdyYXBoXG4gICAgaWYgKCFncmFwaC5zdWJncmFwaHMpIHtcbiAgICAgIGdyYXBoLnN1YmdyYXBocyA9IFtdO1xuICAgIH1cbiAgICBncmFwaC5zdWJncmFwaHMucHVzaChzdWJncmFwaCk7XG4gIH1cbiAgcmV0dXJuIHN1YmdyYXBoO1xufVxuXG4vKipcbiAqIHBhcnNlIGFuIGF0dHJpYnV0ZSBzdGF0ZW1lbnQgbGlrZSBcIm5vZGUgW3NoYXBlPWNpcmNsZSBmb250U2l6ZT0xNl1cIi5cbiAqIEF2YWlsYWJsZSBrZXl3b3JkcyBhcmUgJ25vZGUnLCAnZWRnZScsICdncmFwaCcuXG4gKiBUaGUgcHJldmlvdXMgbGlzdCB3aXRoIGRlZmF1bHQgYXR0cmlidXRlcyB3aWxsIGJlIHJlcGxhY2VkXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgbnVsbH0ga2V5d29yZCBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBwYXJzZWQgYXR0cmlidXRlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobm9kZSwgZWRnZSwgZ3JhcGgpLCBvciBudWxsIGlmIG5vdGhpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHBhcnNlZC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VBdHRyaWJ1dGVTdGF0ZW1lbnQoZ3JhcGgpIHtcbiAgLy8gYXR0cmlidXRlIHN0YXRlbWVudHNcbiAgaWYgKHRva2VuID09PSBcIm5vZGVcIikge1xuICAgIGdldFRva2VuKCk7XG5cbiAgICAvLyBub2RlIGF0dHJpYnV0ZXNcbiAgICBncmFwaC5ub2RlID0gcGFyc2VBdHRyaWJ1dGVMaXN0KCk7XG4gICAgcmV0dXJuIFwibm9kZVwiO1xuICB9IGVsc2UgaWYgKHRva2VuID09PSBcImVkZ2VcIikge1xuICAgIGdldFRva2VuKCk7XG5cbiAgICAvLyBlZGdlIGF0dHJpYnV0ZXNcbiAgICBncmFwaC5lZGdlID0gcGFyc2VBdHRyaWJ1dGVMaXN0KCk7XG4gICAgcmV0dXJuIFwiZWRnZVwiO1xuICB9IGVsc2UgaWYgKHRva2VuID09PSBcImdyYXBoXCIpIHtcbiAgICBnZXRUb2tlbigpO1xuXG4gICAgLy8gZ3JhcGggYXR0cmlidXRlc1xuICAgIGdyYXBoLmdyYXBoID0gcGFyc2VBdHRyaWJ1dGVMaXN0KCk7XG4gICAgcmV0dXJuIFwiZ3JhcGhcIjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBwYXJzZSBhIG5vZGUgc3RhdGVtZW50XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gaWRcbiAqL1xuZnVuY3Rpb24gcGFyc2VOb2RlU3RhdGVtZW50KGdyYXBoLCBpZCkge1xuICAvLyBub2RlIHN0YXRlbWVudFxuICB2YXIgbm9kZSA9IHtcbiAgICBpZDogaWRcbiAgfTtcbiAgdmFyIGF0dHIgPSBwYXJzZUF0dHJpYnV0ZUxpc3QoKTtcbiAgaWYgKGF0dHIpIHtcbiAgICBub2RlLmF0dHIgPSBhdHRyO1xuICB9XG4gIGFkZE5vZGUoZ3JhcGgsIG5vZGUpO1xuXG4gIC8vIGVkZ2Ugc3RhdGVtZW50c1xuICBwYXJzZUVkZ2UoZ3JhcGgsIGlkKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBlZGdlIG9yIGEgc2VyaWVzIG9mIGVkZ2VzXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gZnJvbSAgICAgICAgSWQgb2YgdGhlIGZyb20gbm9kZVxuICovXG5mdW5jdGlvbiBwYXJzZUVkZ2UoZ3JhcGgsIGZyb20pIHtcbiAgd2hpbGUgKHRva2VuID09PSBcIi0+XCIgfHwgdG9rZW4gPT09IFwiLS1cIikge1xuICAgIHZhciB0bztcbiAgICB2YXIgdHlwZSA9IHRva2VuO1xuICAgIGdldFRva2VuKCk7XG4gICAgdmFyIHN1YmdyYXBoID0gcGFyc2VTdWJncmFwaChncmFwaCk7XG4gICAgaWYgKHN1YmdyYXBoKSB7XG4gICAgICB0byA9IHN1YmdyYXBoO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiSWRlbnRpZmllciBvciBzdWJncmFwaCBleHBlY3RlZFwiKTtcbiAgICAgIH1cbiAgICAgIHRvID0gdG9rZW47XG4gICAgICBhZGROb2RlKGdyYXBoLCB7XG4gICAgICAgIGlkOiB0b1xuICAgICAgfSk7XG4gICAgICBnZXRUb2tlbigpO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIGVkZ2UgYXR0cmlidXRlc1xuICAgIHZhciBhdHRyID0gcGFyc2VBdHRyaWJ1dGVMaXN0KCk7XG5cbiAgICAvLyBjcmVhdGUgZWRnZVxuICAgIHZhciBlZGdlID0gY3JlYXRlRWRnZShncmFwaCwgZnJvbSwgdG8sIHR5cGUsIGF0dHIpO1xuICAgIGFkZEVkZ2UoZ3JhcGgsIGVkZ2UpO1xuICAgIGZyb20gPSB0bztcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgc2V0IHdpdGggYXR0cmlidXRlcyxcbiAqIGZvciBleGFtcGxlIFtsYWJlbD1cIjEuMDAwXCIsIHNoYXBlPXNvbGlkXVxuICpcbiAqIEByZXR1cm5zIHtvYmplY3QgfCBudWxsfSBhdHRyXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlTGlzdCgpIHtcbiAgdmFyIGk7XG4gIHZhciBhdHRyID0gbnVsbDtcblxuICAvLyBlZGdlIHN0eWxlcyBvZiBkb3QgYW5kIHZpc1xuICB2YXIgZWRnZVN0eWxlcyA9IHtcbiAgICBkYXNoZWQ6IHRydWUsXG4gICAgc29saWQ6IGZhbHNlLFxuICAgIGRvdHRlZDogWzEsIDVdXG4gIH07XG5cbiAgLyoqXG4gICAqIERlZmluZSBhcnJvdyB0eXBlcy5cbiAgICogdmlzIGN1cnJlbnRseSBzdXBwb3J0cyB0eXBlcyBkZWZpbmVkIGluICdhcnJvd1R5cGVzJy5cbiAgICogRGV0YWlscyBvZiBhcnJvdyBzaGFwZXMgYXJlIGRlc2NyaWJlZCBpblxuICAgKiBodHRwOi8vd3d3LmdyYXBodml6Lm9yZy9jb250ZW50L2Fycm93LXNoYXBlc1xuICAgKi9cbiAgdmFyIGFycm93VHlwZXMgPSB7XG4gICAgZG90OiBcImNpcmNsZVwiLFxuICAgIGJveDogXCJib3hcIixcbiAgICBjcm93OiBcImNyb3dcIixcbiAgICBjdXJ2ZTogXCJjdXJ2ZVwiLFxuICAgIGljdXJ2ZTogXCJpbnZfY3VydmVcIixcbiAgICBub3JtYWw6IFwidHJpYW5nbGVcIixcbiAgICBpbnY6IFwiaW52X3RyaWFuZ2xlXCIsXG4gICAgZGlhbW9uZDogXCJkaWFtb25kXCIsXG4gICAgdGVlOiBcImJhclwiLFxuICAgIHZlZTogXCJ2ZWVcIlxuICB9O1xuXG4gIC8qKlxuICAgKiAnYXR0cl9saXN0JyBjb250YWlucyBhdHRyaWJ1dGVzIGZvciBjaGVja2luZyBpZiBzb21lIG9mIHRoZW0gYXJlIGFmZmVjdGVkXG4gICAqIGxhdGVyLiBGb3IgaW5zdGFuY2UsIGJvdGggb2YgJ2Fycm93aGVhZCcgYW5kICdkaXInIChlZGdlIHN0eWxlIGRlZmluZWRcbiAgICogaW4gRE9UKSBtYWtlIGNoYW5nZXMgdG8gJ2Fycm93cycgYXR0cmlidXRlIGluIHZpcy5cbiAgICovXG4gIHZhciBhdHRyX2xpc3QgPSBuZXcgQXJyYXkoKTtcbiAgdmFyIGF0dHJfbmFtZXMgPSBuZXcgQXJyYXkoKTsgLy8gdXNlZCBmb3IgY2hlY2tpbmcgdGhlIGNhc2UuXG5cbiAgLy8gcGFyc2UgYXR0cmlidXRlc1xuICB3aGlsZSAodG9rZW4gPT09IFwiW1wiKSB7XG4gICAgZ2V0VG9rZW4oKTtcbiAgICBhdHRyID0ge307XG4gICAgd2hpbGUgKHRva2VuICE9PSBcIlwiICYmIHRva2VuICE9IFwiXVwiKSB7XG4gICAgICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiQXR0cmlidXRlIG5hbWUgZXhwZWN0ZWRcIik7XG4gICAgICB9XG4gICAgICB2YXIgbmFtZSA9IHRva2VuO1xuICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgIGlmICh0b2tlbiAhPSBcIj1cIikge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkVxdWFsIHNpZ24gPSBleHBlY3RlZFwiKTtcbiAgICAgIH1cbiAgICAgIGdldFRva2VuKCk7XG4gICAgICBpZiAodG9rZW5UeXBlICE9IFRPS0VOVFlQRS5JREVOVElGSUVSKSB7XG4gICAgICAgIHRocm93IG5ld1N5bnRheEVycm9yKFwiQXR0cmlidXRlIHZhbHVlIGV4cGVjdGVkXCIpO1xuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gdG9rZW47XG5cbiAgICAgIC8vIGNvbnZlcnQgZnJvbSBkb3Qgc3R5bGUgdG8gdmlzXG4gICAgICBpZiAobmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICAgIHZhbHVlID0gZWRnZVN0eWxlc1t2YWx1ZV07XG4gICAgICB9XG4gICAgICB2YXIgYXJyb3dUeXBlO1xuICAgICAgaWYgKG5hbWUgPT09IFwiYXJyb3doZWFkXCIpIHtcbiAgICAgICAgYXJyb3dUeXBlID0gYXJyb3dUeXBlc1t2YWx1ZV07XG4gICAgICAgIG5hbWUgPSBcImFycm93c1wiO1xuICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIHR5cGU6IGFycm93VHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSBcImFycm93dGFpbFwiKSB7XG4gICAgICAgIGFycm93VHlwZSA9IGFycm93VHlwZXNbdmFsdWVdO1xuICAgICAgICBuYW1lID0gXCJhcnJvd3NcIjtcbiAgICAgICAgdmFsdWUgPSB7XG4gICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIHR5cGU6IGFycm93VHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGF0dHJfbGlzdC5wdXNoKHtcbiAgICAgICAgYXR0cjogYXR0cixcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGF0dHJfbmFtZXMucHVzaChuYW1lKTtcbiAgICAgIGdldFRva2VuKCk7XG4gICAgICBpZiAodG9rZW4gPT0gXCIsXCIpIHtcbiAgICAgICAgZ2V0VG9rZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRva2VuICE9IFwiXVwiKSB7XG4gICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcihcIkJyYWNrZXQgXSBleHBlY3RlZFwiKTtcbiAgICB9XG4gICAgZ2V0VG9rZW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcyBleHBsYWluZWQgaW4gWzFdLCBncmFwaHZpeiBoYXMgbGltaXRhdGlvbnMgZm9yIGNvbWJpbmF0aW9uIG9mXG4gICAqIGFycm93W2hlYWR8dGFpbF0gYW5kIGRpci4gSWYgYXR0cmlidXRlIGxpc3QgaW5jbHVkZXMgJ2RpcicsXG4gICAqIGZvbGxvd2luZyBjYXNlcyBqdXN0IGJlIHN1cHBvcnRlZC5cbiAgICogICAxLiBib3RoIG9yIG5vbmUgKyBhcnJvd2hlYWQsIGFycm93dGFpbFxuICAgKiAgIDIuIGZvcndhcmQgKyBhcnJvd2hlYWQgKGFycm93dGFpbCBpcyBub3QgYWZmZWR0ZWQpXG4gICAqICAgMy4gYmFjayArIGFycm93dGFpbCAoYXJyb3doZWFkIGlzIG5vdCBhZmZlY3RlZClcbiAgICogWzFdIGh0dHBzOi8vd3d3LmdyYXBodml6Lm9yZy9kb2MvaW5mby9hdHRycy5odG1sI2g6dW5kaXJfbm90ZVxuICAgKi9cbiAgaWYgKF9pbmNsdWRlc0luc3RhbmNlUHJvcGVydHkoYXR0cl9uYW1lcykuY2FsbChhdHRyX25hbWVzLCBcImRpclwiKSkge1xuICAgIHZhciBpZHggPSB7fTsgLy8gZ2V0IGluZGV4IG9mICdhcnJvd3MnIGFuZCAnZGlyJ1xuICAgIGlkeC5hcnJvd3MgPSB7fTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgYXR0cl9saXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXR0cl9saXN0W2ldLm5hbWUgPT09IFwiYXJyb3dzXCIpIHtcbiAgICAgICAgaWYgKGF0dHJfbGlzdFtpXS52YWx1ZS50byAhPSBudWxsKSB7XG4gICAgICAgICAgaWR4LmFycm93cy50byA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXR0cl9saXN0W2ldLnZhbHVlLmZyb20gIT0gbnVsbCkge1xuICAgICAgICAgIGlkeC5hcnJvd3MuZnJvbSA9IGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoXCJJbnZhbGlkIHZhbHVlIG9mIGFycm93c1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhdHRyX2xpc3RbaV0ubmFtZSA9PT0gXCJkaXJcIikge1xuICAgICAgICBpZHguZGlyID0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmaXJzdCwgYWRkIGRlZmF1bHQgYXJyb3cgc2hhcGUgaWYgaXQgaXMgbm90IGFzc2lnbmVkIHRvIGF2b2lkIGVycm9yXG4gICAgdmFyIGRpcl90eXBlID0gYXR0cl9saXN0W2lkeC5kaXJdLnZhbHVlO1xuICAgIGlmICghX2luY2x1ZGVzSW5zdGFuY2VQcm9wZXJ0eShhdHRyX25hbWVzKS5jYWxsKGF0dHJfbmFtZXMsIFwiYXJyb3dzXCIpKSB7XG4gICAgICBpZiAoZGlyX3R5cGUgPT09IFwiYm90aFwiKSB7XG4gICAgICAgIGF0dHJfbGlzdC5wdXNoKHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmRpcl0uYXR0cixcbiAgICAgICAgICBuYW1lOiBcImFycm93c1wiLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWR4LmFycm93cy50byA9IGF0dHJfbGlzdC5sZW5ndGggLSAxO1xuICAgICAgICBhdHRyX2xpc3QucHVzaCh7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5kaXJdLmF0dHIsXG4gICAgICAgICAgbmFtZTogXCJhcnJvd3NcIixcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWR4LmFycm93cy5mcm9tID0gYXR0cl9saXN0Lmxlbmd0aCAtIDE7XG4gICAgICB9IGVsc2UgaWYgKGRpcl90eXBlID09PSBcImZvcndhcmRcIikge1xuICAgICAgICBhdHRyX2xpc3QucHVzaCh7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5kaXJdLmF0dHIsXG4gICAgICAgICAgbmFtZTogXCJhcnJvd3NcIixcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlkeC5hcnJvd3MudG8gPSBhdHRyX2xpc3QubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09IFwiYmFja1wiKSB7XG4gICAgICAgIGF0dHJfbGlzdC5wdXNoKHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmRpcl0uYXR0cixcbiAgICAgICAgICBuYW1lOiBcImFycm93c1wiLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZHguYXJyb3dzLmZyb20gPSBhdHRyX2xpc3QubGVuZ3RoIC0gMTtcbiAgICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09IFwibm9uZVwiKSB7XG4gICAgICAgIGF0dHJfbGlzdC5wdXNoKHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmRpcl0uYXR0cixcbiAgICAgICAgICBuYW1lOiBcImFycm93c1wiLFxuICAgICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICAgIH0pO1xuICAgICAgICBpZHguYXJyb3dzLnRvID0gYXR0cl9saXN0Lmxlbmd0aCAtIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXdTeW50YXhFcnJvcignSW52YWxpZCBkaXIgdHlwZSBcIicgKyBkaXJfdHlwZSArICdcIicpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZnJvbV90eXBlO1xuICAgIHZhciB0b190eXBlO1xuICAgIC8vIHVwZGF0ZSAnYXJyb3dzJyBhdHRyaWJ1dGUgZnJvbSAnZGlyJy5cbiAgICBpZiAoZGlyX3R5cGUgPT09IFwiYm90aFwiKSB7XG4gICAgICAvLyBib3RoIG9mIHNoYXBlcyBvZiAnZnJvbScgYW5kICd0bycgYXJlIGdpdmVuXG4gICAgICBpZiAoaWR4LmFycm93cy50byAmJiBpZHguYXJyb3dzLmZyb20pIHtcbiAgICAgICAgdG9fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS52YWx1ZS50by50eXBlO1xuICAgICAgICBmcm9tX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGU7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfc3BsaWNlSW5zdGFuY2VQcm9wZXJ0eShhdHRyX2xpc3QpLmNhbGwoYXR0cl9saXN0LCBpZHguYXJyb3dzLmZyb20sIDEpO1xuXG4gICAgICAgIC8vIHNoYXBlIG9mICd0bycgaXMgYXNzaWduZWQgYW5kIHVzZSBkZWZhdWx0IHRvICdmcm9tJ1xuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLnRvKSB7XG4gICAgICAgIHRvX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZTtcbiAgICAgICAgZnJvbV90eXBlID0gXCJhcnJvd1wiO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy50b10gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBvbmx5IHNoYXBlIG9mICdmcm9tJyBpcyBhc3NpZ25lZCBhbmQgdXNlIGRlZmF1bHQgZm9yICd0bydcbiAgICAgIH0gZWxzZSBpZiAoaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBcImFycm93XCI7XG4gICAgICAgIGZyb21fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLnZhbHVlLmZyb20udHlwZTtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0b190eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBmcm9tX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkaXJfdHlwZSA9PT0gXCJiYWNrXCIpIHtcbiAgICAgIC8vIGdpdmVuIGJvdGggb2Ygc2hhcGVzLCBidXQgdXNlIG9ubHkgJ2Zyb20nXG4gICAgICBpZiAoaWR4LmFycm93cy50byAmJiBpZHguYXJyb3dzLmZyb20pIHtcbiAgICAgICAgdG9fdHlwZSA9IFwiXCI7XG4gICAgICAgIGZyb21fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLnZhbHVlLmZyb20udHlwZTtcbiAgICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiB0b190eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBmcm9tX3R5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZ2l2ZW4gc2hhcGUgb2YgJ3RvJywgYnV0IGRvZXMgbm90IHVzZSBpdFxuICAgICAgfSBlbHNlIGlmIChpZHguYXJyb3dzLnRvKSB7XG4gICAgICAgIHRvX3R5cGUgPSBcIlwiO1xuICAgICAgICBmcm9tX3R5cGUgPSBcImFycm93XCI7XG4gICAgICAgIGlkeC5hcnJvd3MuZnJvbSA9IGlkeC5hcnJvd3MudG87XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dID0ge1xuICAgICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MuZnJvbV0ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFzc2lnbiBnaXZlbiAnZnJvbScgc2hhcGVcbiAgICAgIH0gZWxzZSBpZiAoaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBcIlwiO1xuICAgICAgICBmcm9tX3R5cGUgPSBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGU7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5hdHRyLFxuICAgICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLmZyb21dID0ge1xuICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5hdHRyLFxuICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS5uYW1lLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiBhdHRyX2xpc3RbaWR4LmFycm93cy5mcm9tXS52YWx1ZS5mcm9tLnR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkaXJfdHlwZSA9PT0gXCJub25lXCIpIHtcbiAgICAgIHZhciBpZHhfYXJyb3c7XG4gICAgICBpZiAoaWR4LmFycm93cy50bykge1xuICAgICAgICBpZHhfYXJyb3cgPSBpZHguYXJyb3dzLnRvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWR4X2Fycm93ID0gaWR4LmFycm93cy5mcm9tO1xuICAgICAgfVxuICAgICAgYXR0cl9saXN0W2lkeF9hcnJvd10gPSB7XG4gICAgICAgIGF0dHI6IGF0dHJfbGlzdFtpZHhfYXJyb3ddLmF0dHIsXG4gICAgICAgIG5hbWU6IGF0dHJfbGlzdFtpZHhfYXJyb3ddLm5hbWUsXG4gICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZGlyX3R5cGUgPT09IFwiZm9yd2FyZFwiKSB7XG4gICAgICAvLyBnaXZlbiBib3RoIG9mIHNoYXBlcywgYnV0IHVzZSBvbmx5ICd0bydcbiAgICAgIGlmIChpZHguYXJyb3dzLnRvICYmIGlkeC5hcnJvd3MuZnJvbSkge1xuICAgICAgICB0b190eXBlID0gYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLnZhbHVlLnRvLnR5cGU7XG4gICAgICAgIGZyb21fdHlwZSA9IFwiXCI7XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGFzc2lnbiBnaXZlbiAndG8nIHNoYXBlXG4gICAgICB9IGVsc2UgaWYgKGlkeC5hcnJvd3MudG8pIHtcbiAgICAgICAgdG9fdHlwZSA9IGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXS52YWx1ZS50by50eXBlO1xuICAgICAgICBmcm9tX3R5cGUgPSBcIlwiO1xuICAgICAgICBhdHRyX2xpc3RbaWR4LmFycm93cy50b10gPSB7XG4gICAgICAgICAgYXR0cjogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLmF0dHIsXG4gICAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHRvOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IHRvX3R5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IGZyb21fdHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBnaXZlbiBzaGFwZSBvZiAnZnJvbScsIGJ1dCBkb2VzIG5vdCB1c2UgaXRcbiAgICAgIH0gZWxzZSBpZiAoaWR4LmFycm93cy5mcm9tKSB7XG4gICAgICAgIHRvX3R5cGUgPSBcImFycm93XCI7XG4gICAgICAgIGZyb21fdHlwZSA9IFwiXCI7XG4gICAgICAgIGlkeC5hcnJvd3MudG8gPSBpZHguYXJyb3dzLmZyb207XG4gICAgICAgIGF0dHJfbGlzdFtpZHguYXJyb3dzLnRvXSA9IHtcbiAgICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgICBuYW1lOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10ubmFtZSxcbiAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgdG86IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogdG9fdHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgdHlwZTogZnJvbV90eXBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dID0ge1xuICAgICAgICBhdHRyOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10uYXR0cixcbiAgICAgICAgbmFtZTogYXR0cl9saXN0W2lkeC5hcnJvd3MudG9dLm5hbWUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgdG86IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiBhdHRyX2xpc3RbaWR4LmFycm93cy50b10udmFsdWUudG8udHlwZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3U3ludGF4RXJyb3IoJ0ludmFsaWQgZGlyIHR5cGUgXCInICsgZGlyX3R5cGUgKyAnXCInKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgJ2RpcicgYXR0cmlidXRlIG5vIG5lZWQgYW55bW9yZVxuICAgIF9zcGxpY2VJbnN0YW5jZVByb3BlcnR5KGF0dHJfbGlzdCkuY2FsbChhdHRyX2xpc3QsIGlkeC5kaXIsIDEpO1xuICB9XG5cbiAgLy8gcGFyc2UgJ3BlbndpZHRoJ1xuICB2YXIgbm9mX2F0dHJfbGlzdDtcbiAgaWYgKF9pbmNsdWRlc0luc3RhbmNlUHJvcGVydHkoYXR0cl9uYW1lcykuY2FsbChhdHRyX25hbWVzLCBcInBlbndpZHRoXCIpKSB7XG4gICAgdmFyIHRtcF9hdHRyX2xpc3QgPSBbXTtcbiAgICBub2ZfYXR0cl9saXN0ID0gYXR0cl9saXN0Lmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbm9mX2F0dHJfbGlzdDsgaSsrKSB7XG4gICAgICAvLyBleGNsdWRlICd3aWR0aCcgZnJvbSBhdHRyX2xpc3QgaWYgJ3BlbndpZHRoJyBleGlzdHNcbiAgICAgIGlmIChhdHRyX2xpc3RbaV0ubmFtZSAhPT0gXCJ3aWR0aFwiKSB7XG4gICAgICAgIGlmIChhdHRyX2xpc3RbaV0ubmFtZSA9PT0gXCJwZW53aWR0aFwiKSB7XG4gICAgICAgICAgYXR0cl9saXN0W2ldLm5hbWUgPSBcIndpZHRoXCI7XG4gICAgICAgIH1cbiAgICAgICAgdG1wX2F0dHJfbGlzdC5wdXNoKGF0dHJfbGlzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGF0dHJfbGlzdCA9IHRtcF9hdHRyX2xpc3Q7XG4gIH1cbiAgbm9mX2F0dHJfbGlzdCA9IGF0dHJfbGlzdC5sZW5ndGg7XG4gIGZvciAoaSA9IDA7IGkgPCBub2ZfYXR0cl9saXN0OyBpKyspIHtcbiAgICBzZXRWYWx1ZShhdHRyX2xpc3RbaV0uYXR0ciwgYXR0cl9saXN0W2ldLm5hbWUsIGF0dHJfbGlzdFtpXS52YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGF0dHI7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc3ludGF4IGVycm9yIHdpdGggZXh0cmEgaW5mb3JtYXRpb24gb24gY3VycmVudCB0b2tlbiBhbmQgaW5kZXguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtTeW50YXhFcnJvcn0gZXJyXG4gKi9cbmZ1bmN0aW9uIG5ld1N5bnRheEVycm9yKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG5ldyBTeW50YXhFcnJvcihtZXNzYWdlICsgJywgZ290IFwiJyArIGNob3AodG9rZW4sIDMwKSArICdcIiAoY2hhciAnICsgaW5kZXggKyBcIilcIik7XG59XG5cbi8qKlxuICogQ2hvcCBvZmYgdGV4dCBhZnRlciBhIG1heGltdW0gbGVuZ3RoXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhMZW5ndGhcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNob3AodGV4dCwgbWF4TGVuZ3RoKSB7XG4gIHJldHVybiB0ZXh0Lmxlbmd0aCA8PSBtYXhMZW5ndGggPyB0ZXh0IDogdGV4dC5zdWJzdHIoMCwgMjcpICsgXCIuLi5cIjtcbn1cblxuLyoqXG4gKiBFeGVjdXRlIGEgZnVuY3Rpb24gZm4gZm9yIGVhY2ggcGFpciBvZiBlbGVtZW50cyBpbiB0d28gYXJyYXlzXG4gKlxuICogQHBhcmFtIHtBcnJheSB8ICp9IGFycmF5MVxuICogQHBhcmFtIHtBcnJheSB8ICp9IGFycmF5MlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaDIoYXJyYXkxLCBhcnJheTIsIGZuKSB7XG4gIGlmIChfQXJyYXkkaXNBcnJheShhcnJheTEpKSB7XG4gICAgX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KGFycmF5MSkuY2FsbChhcnJheTEsIGZ1bmN0aW9uIChlbGVtMSkge1xuICAgICAgaWYgKF9BcnJheSRpc0FycmF5KGFycmF5MikpIHtcbiAgICAgICAgX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KGFycmF5MikuY2FsbChhcnJheTIsIGZ1bmN0aW9uIChlbGVtMikge1xuICAgICAgICAgIGZuKGVsZW0xLCBlbGVtMik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4oZWxlbTEsIGFycmF5Mik7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKF9BcnJheSRpc0FycmF5KGFycmF5MikpIHtcbiAgICAgIF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShhcnJheTIpLmNhbGwoYXJyYXkyLCBmdW5jdGlvbiAoZWxlbTIpIHtcbiAgICAgICAgZm4oYXJyYXkxLCBlbGVtMik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4oYXJyYXkxLCBhcnJheTIpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNldCBhIG5lc3RlZCBwcm9wZXJ0eSBvbiBhbiBvYmplY3RcbiAqIFdoZW4gbmVzdGVkIG9iamVjdHMgYXJlIG1pc3NpbmcsIHRoZXkgd2lsbCBiZSBjcmVhdGVkLlxuICogRm9yIGV4YW1wbGUgc2V0UHJvcCh7fSwgJ2ZvbnQuY29sb3InLCAncmVkJykgd2lsbCByZXR1cm4ge2ZvbnQ6IHtjb2xvcjogJ3JlZCd9fVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoICAgQSBkb3Qgc2VwYXJhdGVkIHN0cmluZyBsaWtlICdmb250LmNvbG9yJ1xuICogQHBhcmFtIHsqfSB2YWx1ZSAgICAgICBWYWx1ZSBmb3IgdGhlIHByb3BlcnR5XG4gKiBAcmV0dXJucyB7b2JqZWN0fSBSZXR1cm5zIHRoZSBvcmlnaW5hbCBvYmplY3QsIGFsbG93cyBmb3IgY2hhaW5pbmcuXG4gKi9cbmZ1bmN0aW9uIHNldFByb3Aob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICB2YXIgbmFtZXMgPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgdmFyIHByb3AgPSBuYW1lcy5wb3AoKTtcblxuICAvLyB0cmF2ZXJzZSBvdmVyIHRoZSBuZXN0ZWQgb2JqZWN0c1xuICB2YXIgb2JqID0gb2JqZWN0O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lc1tpXTtcbiAgICBpZiAoIShuYW1lIGluIG9iaikpIHtcbiAgICAgIG9ialtuYW1lXSA9IHt9O1xuICAgIH1cbiAgICBvYmogPSBvYmpbbmFtZV07XG4gIH1cblxuICAvLyBzZXQgdGhlIHByb3BlcnR5IHZhbHVlXG4gIG9ialtwcm9wXSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufVxuXG4vKipcbiAqIENvbnZlcnQgYW4gb2JqZWN0IHdpdGggRE9UIGF0dHJpYnV0ZXMgdG8gdGhlaXIgdmlzLmpzIGVxdWl2YWxlbnRzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyICAgICBPYmplY3Qgd2l0aCBET1QgYXR0cmlidXRlc1xuICogQHBhcmFtIHtvYmplY3R9IG1hcHBpbmdcbiAqIEByZXR1cm5zIHtvYmplY3R9ICAgICAgICAgUmV0dXJucyBhbiBvYmplY3Qgd2l0aCB2aXMuanMgYXR0cmlidXRlc1xuICovXG5mdW5jdGlvbiBjb252ZXJ0QXR0cihhdHRyLCBtYXBwaW5nKSB7XG4gIHZhciBjb252ZXJ0ZWQgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBhdHRyKSB7XG4gICAgaWYgKGF0dHIuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIHZhciB2aXNQcm9wID0gbWFwcGluZ1twcm9wXTtcbiAgICAgIGlmIChfQXJyYXkkaXNBcnJheSh2aXNQcm9wKSkge1xuICAgICAgICBfZm9yRWFjaEluc3RhbmNlUHJvcGVydHkodmlzUHJvcCkuY2FsbCh2aXNQcm9wLCBmdW5jdGlvbiAodmlzUHJvcEkpIHtcbiAgICAgICAgICBzZXRQcm9wKGNvbnZlcnRlZCwgdmlzUHJvcEksIGF0dHJbcHJvcF0pO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZpc1Byb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc2V0UHJvcChjb252ZXJ0ZWQsIHZpc1Byb3AsIGF0dHJbcHJvcF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0UHJvcChjb252ZXJ0ZWQsIHByb3AsIGF0dHJbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29udmVydGVkO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBzdHJpbmcgY29udGFpbmluZyBhIGdyYXBoIGluIERPVCBsYW5ndWFnZSBpbnRvIGEgbWFwIGNvbnRhaW5pbmdcbiAqIHdpdGggbm9kZXMgYW5kIGVkZ2VzIGluIHRoZSBmb3JtYXQgb2YgZ3JhcGguXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgICAgICAgICBUZXh0IGNvbnRhaW5pbmcgYSBncmFwaCBpbiBET1Qtbm90YXRpb25cbiAqIEByZXR1cm5zIHtvYmplY3R9IGdyYXBoRGF0YVxuICovXG5mdW5jdGlvbiBET1RUb0dyYXBoKGRhdGEpIHtcbiAgLy8gcGFyc2UgdGhlIERPVCBmaWxlXG4gIHZhciBkb3REYXRhID0gcGFyc2VET1QoZGF0YSk7XG4gIHZhciBncmFwaERhdGEgPSB7XG4gICAgbm9kZXM6IFtdLFxuICAgIGVkZ2VzOiBbXSxcbiAgICBvcHRpb25zOiB7fVxuICB9O1xuXG4gIC8vIGNvcHkgdGhlIG5vZGVzXG4gIGlmIChkb3REYXRhLm5vZGVzKSB7XG4gICAgdmFyIF9jb250ZXh0MjtcbiAgICBfZm9yRWFjaEluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQyID0gZG90RGF0YS5ub2RlcykuY2FsbChfY29udGV4dDIsIGZ1bmN0aW9uIChkb3ROb2RlKSB7XG4gICAgICB2YXIgZ3JhcGhOb2RlID0ge1xuICAgICAgICBpZDogZG90Tm9kZS5pZCxcbiAgICAgICAgbGFiZWw6IFN0cmluZyhkb3ROb2RlLmxhYmVsIHx8IGRvdE5vZGUuaWQpXG4gICAgICB9O1xuICAgICAgbWVyZ2UkMShncmFwaE5vZGUsIGNvbnZlcnRBdHRyKGRvdE5vZGUuYXR0ciwgTk9ERV9BVFRSX01BUFBJTkcpKTtcbiAgICAgIGlmIChncmFwaE5vZGUuaW1hZ2UpIHtcbiAgICAgICAgZ3JhcGhOb2RlLnNoYXBlID0gXCJpbWFnZVwiO1xuICAgICAgfVxuICAgICAgZ3JhcGhEYXRhLm5vZGVzLnB1c2goZ3JhcGhOb2RlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGNvcHkgdGhlIGVkZ2VzXG4gIGlmIChkb3REYXRhLmVkZ2VzKSB7XG4gICAgdmFyIF9jb250ZXh0MztcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFuIGVkZ2UgaW4gRE9UIGZvcm1hdCB0byBhbiBlZGdlIHdpdGggVmlzR3JhcGggZm9ybWF0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZG90RWRnZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IGdyYXBoRWRnZVxuICAgICAqL1xuICAgIHZhciBjb252ZXJ0RWRnZSA9IGZ1bmN0aW9uIGNvbnZlcnRFZGdlKGRvdEVkZ2UpIHtcbiAgICAgIHZhciBncmFwaEVkZ2UgPSB7XG4gICAgICAgIGZyb206IGRvdEVkZ2UuZnJvbSxcbiAgICAgICAgdG86IGRvdEVkZ2UudG9cbiAgICAgIH07XG4gICAgICBtZXJnZSQxKGdyYXBoRWRnZSwgY29udmVydEF0dHIoZG90RWRnZS5hdHRyLCBFREdFX0FUVFJfTUFQUElORykpO1xuXG4gICAgICAvLyBBZGQgYXJyb3dzIGF0dHJpYnV0ZSB0byBkZWZhdWx0IHN0eWxlZCBhcnJvdy5cbiAgICAgIC8vIFRoZSByZWFzb24gd2h5IGRlZmF1bHQgc3R5bGUgaXMgbm90IGFkZGVkIGluIHBhcnNlQXR0cmlidXRlTGlzdCgpIGlzXG4gICAgICAvLyBiZWNhdXNlIG9ubHkgZGVmYXVsdCBpcyBjbGVhcmVkIGJlZm9yZSBoZXJlLlxuICAgICAgaWYgKGdyYXBoRWRnZS5hcnJvd3MgPT0gbnVsbCAmJiBkb3RFZGdlLnR5cGUgPT09IFwiLT5cIikge1xuICAgICAgICBncmFwaEVkZ2UuYXJyb3dzID0gXCJ0b1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdyYXBoRWRnZTtcbiAgICB9O1xuICAgIF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDMgPSBkb3REYXRhLmVkZ2VzKS5jYWxsKF9jb250ZXh0MywgZnVuY3Rpb24gKGRvdEVkZ2UpIHtcbiAgICAgIHZhciBmcm9tLCB0bztcbiAgICAgIGlmIChkb3RFZGdlLmZyb20gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgZnJvbSA9IGRvdEVkZ2UuZnJvbS5ub2RlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb20gPSB7XG4gICAgICAgICAgaWQ6IGRvdEVkZ2UuZnJvbVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKGRvdEVkZ2UudG8gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgdG8gPSBkb3RFZGdlLnRvLm5vZGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG8gPSB7XG4gICAgICAgICAgaWQ6IGRvdEVkZ2UudG9cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChkb3RFZGdlLmZyb20gaW5zdGFuY2VvZiBPYmplY3QgJiYgZG90RWRnZS5mcm9tLmVkZ2VzKSB7XG4gICAgICAgIHZhciBfY29udGV4dDQ7XG4gICAgICAgIF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDQgPSBkb3RFZGdlLmZyb20uZWRnZXMpLmNhbGwoX2NvbnRleHQ0LCBmdW5jdGlvbiAoc3ViRWRnZSkge1xuICAgICAgICAgIHZhciBncmFwaEVkZ2UgPSBjb252ZXJ0RWRnZShzdWJFZGdlKTtcbiAgICAgICAgICBncmFwaERhdGEuZWRnZXMucHVzaChncmFwaEVkZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZvckVhY2gyKGZyb20sIHRvLCBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFyIHN1YkVkZ2UgPSBjcmVhdGVFZGdlKGdyYXBoRGF0YSwgZnJvbS5pZCwgdG8uaWQsIGRvdEVkZ2UudHlwZSwgZG90RWRnZS5hdHRyKTtcbiAgICAgICAgdmFyIGdyYXBoRWRnZSA9IGNvbnZlcnRFZGdlKHN1YkVkZ2UpO1xuICAgICAgICBncmFwaERhdGEuZWRnZXMucHVzaChncmFwaEVkZ2UpO1xuICAgICAgfSk7XG4gICAgICBpZiAoZG90RWRnZS50byBpbnN0YW5jZW9mIE9iamVjdCAmJiBkb3RFZGdlLnRvLmVkZ2VzKSB7XG4gICAgICAgIHZhciBfY29udGV4dDU7XG4gICAgICAgIF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDUgPSBkb3RFZGdlLnRvLmVkZ2VzKS5jYWxsKF9jb250ZXh0NSwgZnVuY3Rpb24gKHN1YkVkZ2UpIHtcbiAgICAgICAgICB2YXIgZ3JhcGhFZGdlID0gY29udmVydEVkZ2Uoc3ViRWRnZSk7XG4gICAgICAgICAgZ3JhcGhEYXRhLmVkZ2VzLnB1c2goZ3JhcGhFZGdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBjb3B5IHRoZSBvcHRpb25zXG4gIGlmIChkb3REYXRhLmF0dHIpIHtcbiAgICBncmFwaERhdGEub3B0aW9ucyA9IGRvdERhdGEuYXR0cjtcbiAgfVxuICByZXR1cm4gZ3JhcGhEYXRhO1xufVxuXG4vKiBlc2xpbnQtZW5hYmxlIG5vLXZhciAqL1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuLyogZXNsaW50LWVuYWJsZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgKi9cblxudmFyIGRvdHBhcnNlciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRET1RUb0dyYXBoOiBET1RUb0dyYXBoLFxuXHRwYXJzZURPVDogcGFyc2VET1Rcbn0pO1xuXG4vKipcclxuICogQ29udmVydCBHZXBoaSB0byBWaXMuXHJcbiAqXHJcbiAqIEBwYXJhbSBnZXBoaUpTT04gLSBUaGUgcGFyc2VkIEpTT04gZGF0YSBpbiBHZXBoaSBmb3JtYXQuXHJcbiAqIEBwYXJhbSBvcHRpb25zT2JqIC0gQWRkaXRpb25hbCBvcHRpb25zLlxyXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIGRhdGEgcmVhZHkgdG8gYmUgdXNlZCBpbiBWaXMuXHJcbiAqL1xuZnVuY3Rpb24gcGFyc2VHZXBoaShnZXBoaUpTT04sIG9wdGlvbnNPYmopIHtcbiAgdmFyIF9jb250ZXh0O1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBlZGdlczoge1xuICAgICAgaW5oZXJpdENvbG9yOiBmYWxzZVxuICAgIH0sXG4gICAgbm9kZXM6IHtcbiAgICAgIGZpeGVkOiBmYWxzZSxcbiAgICAgIHBhcnNlQ29sb3I6IGZhbHNlXG4gICAgfVxuICB9O1xuICBpZiAob3B0aW9uc09iaiAhPSBudWxsKSB7XG4gICAgaWYgKG9wdGlvbnNPYmouZml4ZWQgIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5ub2Rlcy5maXhlZCA9IG9wdGlvbnNPYmouZml4ZWQ7XG4gICAgfVxuICAgIGlmIChvcHRpb25zT2JqLnBhcnNlQ29sb3IgIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5ub2Rlcy5wYXJzZUNvbG9yID0gb3B0aW9uc09iai5wYXJzZUNvbG9yO1xuICAgIH1cbiAgICBpZiAob3B0aW9uc09iai5pbmhlcml0Q29sb3IgIT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5lZGdlcy5pbmhlcml0Q29sb3IgPSBvcHRpb25zT2JqLmluaGVyaXRDb2xvcjtcbiAgICB9XG4gIH1cbiAgdmFyIGdFZGdlcyA9IGdlcGhpSlNPTi5lZGdlcztcbiAgdmFyIHZFZGdlcyA9IF9tYXBJbnN0YW5jZVByb3BlcnR5KGdFZGdlcykuY2FsbChnRWRnZXMsIGZ1bmN0aW9uIChnRWRnZSkge1xuICAgIHZhciB2RWRnZSA9IHtcbiAgICAgIGZyb206IGdFZGdlLnNvdXJjZSxcbiAgICAgIGlkOiBnRWRnZS5pZCxcbiAgICAgIHRvOiBnRWRnZS50YXJnZXRcbiAgICB9O1xuICAgIGlmIChnRWRnZS5hdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgIHZFZGdlLmF0dHJpYnV0ZXMgPSBnRWRnZS5hdHRyaWJ1dGVzO1xuICAgIH1cbiAgICBpZiAoZ0VkZ2UubGFiZWwgIT0gbnVsbCkge1xuICAgICAgdkVkZ2UubGFiZWwgPSBnRWRnZS5sYWJlbDtcbiAgICB9XG4gICAgaWYgKGdFZGdlLmF0dHJpYnV0ZXMgIT0gbnVsbCAmJiBnRWRnZS5hdHRyaWJ1dGVzLnRpdGxlICE9IG51bGwpIHtcbiAgICAgIHZFZGdlLnRpdGxlID0gZ0VkZ2UuYXR0cmlidXRlcy50aXRsZTtcbiAgICB9XG4gICAgaWYgKGdFZGdlLnR5cGUgPT09IFwiRGlyZWN0ZWRcIikge1xuICAgICAgdkVkZ2UuYXJyb3dzID0gXCJ0b1wiO1xuICAgIH1cbiAgICAvLyBlZGdlWyd2YWx1ZSddID0gZ0VkZ2UuYXR0cmlidXRlcyAhPSBudWxsID8gZ0VkZ2UuYXR0cmlidXRlcy5XZWlnaHQgOiB1bmRlZmluZWQ7XG4gICAgLy8gZWRnZVsnd2lkdGgnXSA9IGVkZ2VbJ3ZhbHVlJ10gIT0gbnVsbCA/IHVuZGVmaW5lZCA6IGVkZ2VnRWRnZS5zaXplO1xuICAgIGlmIChnRWRnZS5jb2xvciAmJiBvcHRpb25zLmVkZ2VzLmluaGVyaXRDb2xvciA9PT0gZmFsc2UpIHtcbiAgICAgIHZFZGdlLmNvbG9yID0gZ0VkZ2UuY29sb3I7XG4gICAgfVxuICAgIHJldHVybiB2RWRnZTtcbiAgfSk7XG4gIHZhciB2Tm9kZXMgPSBfbWFwSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dCA9IGdlcGhpSlNPTi5ub2RlcykuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKGdOb2RlKSB7XG4gICAgdmFyIHZOb2RlID0ge1xuICAgICAgaWQ6IGdOb2RlLmlkLFxuICAgICAgZml4ZWQ6IG9wdGlvbnMubm9kZXMuZml4ZWQgJiYgZ05vZGUueCAhPSBudWxsICYmIGdOb2RlLnkgIT0gbnVsbFxuICAgIH07XG4gICAgaWYgKGdOb2RlLmF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgdk5vZGUuYXR0cmlidXRlcyA9IGdOb2RlLmF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIGlmIChnTm9kZS5sYWJlbCAhPSBudWxsKSB7XG4gICAgICB2Tm9kZS5sYWJlbCA9IGdOb2RlLmxhYmVsO1xuICAgIH1cbiAgICBpZiAoZ05vZGUuc2l6ZSAhPSBudWxsKSB7XG4gICAgICB2Tm9kZS5zaXplID0gZ05vZGUuc2l6ZTtcbiAgICB9XG4gICAgaWYgKGdOb2RlLmF0dHJpYnV0ZXMgIT0gbnVsbCAmJiBnTm9kZS5hdHRyaWJ1dGVzLnRpdGxlICE9IG51bGwpIHtcbiAgICAgIHZOb2RlLnRpdGxlID0gZ05vZGUuYXR0cmlidXRlcy50aXRsZTtcbiAgICB9XG4gICAgaWYgKGdOb2RlLnRpdGxlICE9IG51bGwpIHtcbiAgICAgIHZOb2RlLnRpdGxlID0gZ05vZGUudGl0bGU7XG4gICAgfVxuICAgIGlmIChnTm9kZS54ICE9IG51bGwpIHtcbiAgICAgIHZOb2RlLnggPSBnTm9kZS54O1xuICAgIH1cbiAgICBpZiAoZ05vZGUueSAhPSBudWxsKSB7XG4gICAgICB2Tm9kZS55ID0gZ05vZGUueTtcbiAgICB9XG4gICAgaWYgKGdOb2RlLmNvbG9yICE9IG51bGwpIHtcbiAgICAgIGlmIChvcHRpb25zLm5vZGVzLnBhcnNlQ29sb3IgPT09IHRydWUpIHtcbiAgICAgICAgdk5vZGUuY29sb3IgPSBnTm9kZS5jb2xvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZOb2RlLmNvbG9yID0ge1xuICAgICAgICAgIGJhY2tncm91bmQ6IGdOb2RlLmNvbG9yLFxuICAgICAgICAgIGJvcmRlcjogZ05vZGUuY29sb3IsXG4gICAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBnTm9kZS5jb2xvcixcbiAgICAgICAgICAgIGJvcmRlcjogZ05vZGUuY29sb3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhvdmVyOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBnTm9kZS5jb2xvcixcbiAgICAgICAgICAgIGJvcmRlcjogZ05vZGUuY29sb3JcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2Tm9kZTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgbm9kZXM6IHZOb2RlcyxcbiAgICBlZGdlczogdkVkZ2VzXG4gIH07XG59XG5cbnZhciBnZXBoaVBhcnNlciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcblx0X19wcm90b19fOiBudWxsLFxuXHRwYXJzZUdlcGhpOiBwYXJzZUdlcGhpXG59KTtcblxuLy8gRW5nbGlzaFxudmFyIGVuID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCJDbGljayBpbiBhbiBlbXB0eSBzcGFjZSB0byBwbGFjZSBhIG5ldyBub2RlLlwiLFxuICBhZGRFZGdlOiBcIkFkZCBFZGdlXCIsXG4gIGFkZE5vZGU6IFwiQWRkIE5vZGVcIixcbiAgYmFjazogXCJCYWNrXCIsXG4gIGNsb3NlOiBcIkNsb3NlXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJDYW5ub3QgbGluayBlZGdlcyB0byBhIGNsdXN0ZXIuXCIsXG4gIGRlbDogXCJEZWxldGUgc2VsZWN0ZWRcIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcIkNsdXN0ZXJzIGNhbm5vdCBiZSBkZWxldGVkLlwiLFxuICBlZGdlRGVzY3JpcHRpb246IFwiQ2xpY2sgb24gYSBub2RlIGFuZCBkcmFnIHRoZSBlZGdlIHRvIGFub3RoZXIgbm9kZSB0byBjb25uZWN0IHRoZW0uXCIsXG4gIGVkaXQ6IFwiRWRpdFwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIkNsdXN0ZXJzIGNhbm5vdCBiZSBlZGl0ZWQuXCIsXG4gIGVkaXRFZGdlOiBcIkVkaXQgRWRnZVwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcIkNsaWNrIG9uIHRoZSBjb250cm9sIHBvaW50cyBhbmQgZHJhZyB0aGVtIHRvIGEgbm9kZSB0byBjb25uZWN0IHRvIGl0LlwiLFxuICBlZGl0Tm9kZTogXCJFZGl0IE5vZGVcIlxufTtcbi8vIEdlcm1hblxudmFyIGRlID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCJLbGlja2UgYXVmIGVpbmUgZnJlaWUgU3RlbGxlLCB1bSBlaW5lbiBuZXVlbiBLbm90ZW4genUgcGxhemllcmVuLlwiLFxuICBhZGRFZGdlOiBcIkthbnRlIGhpbnp1ZlxceEZDZ2VuXCIsXG4gIGFkZE5vZGU6IFwiS25vdGVuIGhpbnp1ZlxceEZDZ2VuXCIsXG4gIGJhY2s6IFwiWnVyXFx4RkNja1wiLFxuICBjbG9zZTogXCJTY2hsaWXDn2VuXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJFcyBpc3QgbmljaHQgbVxceEY2Z2xpY2gsIEthbnRlbiBtaXQgQ2x1c3Rlcm4genUgdmVyYmluZGVuLlwiLFxuICBkZWw6IFwiTFxceEY2c2NoZSBBdXN3YWhsXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCJDbHVzdGVyIGtcXHhGNm5uZW4gbmljaHQgZ2VsXFx4RjZzY2h0IHdlcmRlbi5cIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIktsaWNrZSBhdWYgZWluZW4gS25vdGVuIHVuZCB6aWVoZSBkaWUgS2FudGUgenUgZWluZW0gYW5kZXJlbiBLbm90ZW4sIHVtIGRpZXNlIHp1IHZlcmJpbmRlbi5cIixcbiAgZWRpdDogXCJFZGl0aWVyZW5cIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCJDbHVzdGVyIGtcXHhGNm5uZW4gbmljaHQgZWRpdGllcnQgd2VyZGVuLlwiLFxuICBlZGl0RWRnZTogXCJLYW50ZSBlZGl0aWVyZW5cIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJLbGlja2UgYXVmIGRpZSBWZXJiaW5kdW5nc3B1bmt0ZSB1bmQgemllaGUgZGllc2UgYXVmIGVpbmVuIEtub3RlbiwgdW0gc2llIHp1IHZlcmJpbmRlbi5cIixcbiAgZWRpdE5vZGU6IFwiS25vdGVuIGVkaXRpZXJlblwiXG59O1xuLy8gU3BhbmlzaFxudmFyIGVzID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCJIYWdhIGNsaWMgZW4gdW4gbHVnYXIgdmFjXFx4RURvIHBhcmEgY29sb2NhciB1biBudWV2byBub2RvLlwiLFxuICBhZGRFZGdlOiBcIkFcXHhGMWFkaXIgYXJpc3RhXCIsXG4gIGFkZE5vZGU6IFwiQVxceEYxYWRpciBub2RvXCIsXG4gIGJhY2s6IFwiQXRyXFx4RTFzXCIsXG4gIGNsb3NlOiBcIkNlcnJhclwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwiTm8gc2UgcHVlZGUgY29uZWN0YXIgdW5hIGFyaXN0YSBhIHVuIGdydXBvLlwiLFxuICBkZWw6IFwiRWxpbWluYXIgc2VsZWNjaVxceEYzblwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwiTm8gZXMgcG9zaWJsZSBlbGltaW5hciBncnVwb3MuXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCJIYWdhIGNsaWMgZW4gdW4gbm9kbyB5IGFycmFzdHJlIGxhIGFyaXN0YSBoYWNpYSBvdHJvIG5vZG8gcGFyYSBjb25lY3Rhcmxvcy5cIixcbiAgZWRpdDogXCJFZGl0YXJcIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCJObyBlcyBwb3NpYmxlIGVkaXRhciBncnVwb3MuXCIsXG4gIGVkaXRFZGdlOiBcIkVkaXRhciBhcmlzdGFcIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJIYWdhIGNsaWMgZW4gdW4gcHVudG8gZGUgY29udHJvbCB5IGFycmFzdHJlbG8gYSB1biBub2RvIHBhcmEgY29uZWN0YXJsby5cIixcbiAgZWRpdE5vZGU6IFwiRWRpdGFyIG5vZG9cIlxufTtcbi8vSXRhbGlhbm9cbnZhciBpdCA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiQ2xpY2NhIHBlciBhZ2dpdW5nZXJlIHVuIG51b3ZvIG5vZG9cIixcbiAgYWRkRWRnZTogXCJBZ2dpdW5naSB1biB2ZXJ0aWNlXCIsXG4gIGFkZE5vZGU6IFwiQWdnaXVuZ2kgdW4gbm9kb1wiLFxuICBiYWNrOiBcIkluZGlldHJvXCIsXG4gIGNsb3NlOiBcIkNoaXVkZXJlXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJOb24gc2kgcG9zc29ubyBjb2xsZWdhcmUgdmVydGljaSBhZCB1biBjbHVzdGVyXCIsXG4gIGRlbDogXCJDYW5jZWxsYSBsYSBzZWxlemlvbmVcIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcIkkgY2x1c3RlciBub24gcG9zc29ubyBlc3NlcmUgY2FuY2VsbGF0aVwiLFxuICBlZGdlRGVzY3JpcHRpb246IFwiQ2xpY2NhIHN1IHVuIG5vZG8gZSB0cmFzY2luYWxvIGFkIHVuIGFsdHJvIG5vZG8gcGVyIGNvbm5ldHRlcmxpLlwiLFxuICBlZGl0OiBcIk1vZGlmaWNhXCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwiSSBjbHVzdGVycyBub24gcG9zc29ubyBlc3NlcmUgbW9kaWZpY2F0aS5cIixcbiAgZWRpdEVkZ2U6IFwiTW9kaWZpY2EgaWwgdmVydGljZVwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcIkNsaWNjYSBzdWkgUHVudGkgZGkgY29udHJvbGxvIGUgdHJhc2NpbmFsaSBhZCB1biBub2RvIHBlciBjb25uZXR0ZXJsaS5cIixcbiAgZWRpdE5vZGU6IFwiTW9kaWZpY2EgaWwgbm9kb1wiXG59O1xuLy8gRHV0Y2hcbnZhciBubCA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiS2xpayBvcCBlZW4gbGVlZyBnZWJpZWQgb20gZWVuIG5pZXV3ZSBub2RlIHRlIG1ha2VuLlwiLFxuICBhZGRFZGdlOiBcIkxpbmsgdG9ldm9lZ2VuXCIsXG4gIGFkZE5vZGU6IFwiTm9kZSB0b2V2b2VnZW5cIixcbiAgYmFjazogXCJUZXJ1Z1wiLFxuICBjbG9zZTogXCJTbHVpdGVuXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJLYW4gZ2VlbiBsaW5rIG1ha2VuIG5hYXIgZWVuIGNsdXN0ZXIuXCIsXG4gIGRlbDogXCJTZWxlY3RpZSB2ZXJ3aWpkZXJlblwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwiQ2x1c3RlcnMga3VubmVuIG5pZXQgd29yZGVuIHZlcndpamRlcmQuXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCJLbGlrIG9wIGVlbiBub2RlIGVuIHNsZWVwIGRlIGxpbmsgbmFhciBlZW4gYW5kZXJlIG5vZGUgb20gemUgdGUgdmVyYmluZGVuLlwiLFxuICBlZGl0OiBcIldpanppZ2VuXCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwiQ2x1c3RlcnMga3VubmVuIG5pZXQgd29yZGVuIGFhbmdlcGFzdC5cIixcbiAgZWRpdEVkZ2U6IFwiTGluayB3aWp6aWdlblwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcIktsaWsgb3AgZGUgdmVyYmluZGluZ3NwdW50ZW4gZW4gc2xlZXAgemUgbmFhciBlZW4gbm9kZSBvbSBkYWFybWVlIHRlIHZlcmJpbmRlbi5cIixcbiAgZWRpdE5vZGU6IFwiTm9kZSB3aWp6aWdlblwiXG59O1xuLy8gUG9ydHVndWVzZSBCcmF6aWxcbnZhciBwdCA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiQ2xpcXVlIGVtIHVtIGVzcGHDp28gZW0gYnJhbmNvIHBhcmEgYWRpY2lvbmFyIHVtIG5vdm8gbsOzXCIsXG4gIGFkZEVkZ2U6IFwiQWRpY2lvbmFyIGFyZXN0YVwiLFxuICBhZGROb2RlOiBcIkFkaWNpb25hciBuw7NcIixcbiAgYmFjazogXCJWb2x0YXJcIixcbiAgY2xvc2U6IFwiRmVjaGFyXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJOw6NvIGZvaSBwb3Nzw612ZWwgbGlua2FyIGFyZXN0YXMgYSB1bSBjbHVzdGVyLlwiLFxuICBkZWw6IFwiUmVtb3ZlciBzZWxlY2lvbmFkb1wiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwiQ2x1c3RlcnMgbsOjbyBwdWRlcmFtIHNlciByZW1vdmlkb3MuXCIsXG4gIGVkZ2VEZXNjcmlwdGlvbjogXCJDbGlxdWUgZW0gdW0gbsOzIGUgYXJyYXN0ZSBhIGFyZXN0YSBhdMOpIG91dHJvIG7DsyBwYXJhIGNvbmVjdMOhLWxvc1wiLFxuICBlZGl0OiBcIkVkaXRhclwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIkNsdXN0ZXJzIG7Do28gcHVkZXJhbSBzZXIgZWRpdGFkb3MuXCIsXG4gIGVkaXRFZGdlOiBcIkVkaXRhciBhcmVzdGFcIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJDbGlxdWUgbm9zIHBvbnRvcyBkZSBjb250cm9sZSBlIG9zIGFycmFzdGUgcGFyYSB1bSBuw7MgcGFyYSBjb25lY3TDoS1sb3NcIixcbiAgZWRpdE5vZGU6IFwiRWRpdGFyIG7Ds1wiXG59O1xuLy8gUnVzc2lhblxudmFyIHJ1ID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCLQmtC70LjQutC90LjRgtC1INCyINGB0LLQvtCx0L7QtNC90L7QtSDQvNC10YHRgtC+LCDRh9GC0L7QsdGLINC00L7QsdCw0LLQuNGC0Ywg0L3QvtCy0YvQuSDRg9C30LXQuy5cIixcbiAgYWRkRWRnZTogXCLQlNC+0LHQsNCy0LjRgtGMINGA0LXQsdGA0L5cIixcbiAgYWRkTm9kZTogXCLQlNC+0LHQsNCy0LjRgtGMINGD0LfQtdC7XCIsXG4gIGJhY2s6IFwi0J3QsNC30LDQtFwiLFxuICBjbG9zZTogXCLQl9Cw0LrRgNGL0LLQsNGC0YxcIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcItCd0LXQstC+0LfQvNC+0LbQvdC+INGB0L7QtdC00LjQvdC40YLRjCDRgNC10LHRgNCwINCyINC60LvQsNGB0YLQtdGALlwiLFxuICBkZWw6IFwi0KPQtNCw0LvQuNGC0Ywg0LLRi9Cx0YDQsNC90L3QvtC1XCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCLQmtC70LDRgdGC0LXRgNGLINC90LUg0LzQvtCz0YPRgiDQsdGL0YLRjCDRg9C00LDQu9C10L3Ri1wiLFxuICBlZGdlRGVzY3JpcHRpb246IFwi0JrQu9C40LrQvdC40YLQtSDQvdCwINGD0LfQtdC7INC4INC/0YDQvtGC0Y/QvdC40YLQtSDRgNC10LHRgNC+INC6INC00YDRg9Cz0L7QvNGDINGD0LfQu9GDLCDRh9GC0L7QsdGLINGB0L7QtdC00LjQvdC40YLRjCDQuNGFLlwiLFxuICBlZGl0OiBcItCg0LXQtNCw0LrRgtC40YDQvtCy0LDRgtGMXCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwi0JrQu9Cw0YHRgtC10YDRiyDQvdC10LTQvtGB0YLRg9C/0L3RiyDQtNC70Y8g0YDQtdC00LDQutGC0LjRgNC+0LLQsNC90LjRjy5cIixcbiAgZWRpdEVkZ2U6IFwi0KDQtdC00LDQutGC0LjRgNC+0LLQsNGC0Ywg0YDQtdCx0YDQvlwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcItCa0LvQuNC60L3QuNGC0LUg0L3QsCDQutC+0L3RgtGA0L7Qu9GM0L3Ri9C1INGC0L7Rh9C60Lgg0Lgg0L/QtdGA0LXRgtCw0YnQuNGC0LUg0LjRhSDQsiDRg9C30LXQuywg0YfRgtC+0LHRiyDQv9C+0LTQutC70Y7Rh9C40YLRjNGB0Y8g0Log0L3QtdC80YMuXCIsXG4gIGVkaXROb2RlOiBcItCg0LXQtNCw0LrRgtC40YDQvtCy0LDRgtGMINGD0LfQtdC7XCJcbn07XG4vLyBDaGluZXNlXG52YXIgY24gPSB7XG4gIGFkZERlc2NyaXB0aW9uOiBcIuWNleWHu+epuueZveWkhOaUvue9ruaWsOiKgueCueOAglwiLFxuICBhZGRFZGdlOiBcIua3u+WKoOi/nuaOpee6v1wiLFxuICBhZGROb2RlOiBcIua3u+WKoOiKgueCuVwiLFxuICBiYWNrOiBcIui/lOWbnlwiLFxuICBjbG9zZTogXCLpl5zplolcIixcbiAgY3JlYXRlRWRnZUVycm9yOiBcIuaXoOazleWwhui/nuaOpee6v+i/nuaOpeWIsOe+pOmbhuOAglwiLFxuICBkZWw6IFwi5Yig6Zmk6YCJ5a6aXCIsXG4gIGRlbGV0ZUNsdXN0ZXJFcnJvcjogXCLml6Dms5XliKDpmaTnvqTpm4bjgIJcIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIuWNleWHu+afkOS4quiKgueCueW5tuWwhuivpei/nuaOpee6v+aLluWKqOWIsOWPpuS4gOS4quiKgueCueS7pei/nuaOpeWug+S7rOOAglwiLFxuICBlZGl0OiBcIue8lui+kVwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIuaXoOazlee8lui+kee+pOmbhuOAglwiLFxuICBlZGl0RWRnZTogXCLnvJbovpHov57mjqXnur9cIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCLljZXlh7vmjqfliLboioLngrnlubblsIblroPku6zmi5bliLDoioLngrnkuIrov57mjqXjgIJcIixcbiAgZWRpdE5vZGU6IFwi57yW6L6R6IqC54K5XCJcbn07XG4vLyBVa3JhaW5pYW5cbnZhciB1ayA9IHtcbiAgYWRkRGVzY3JpcHRpb246IFwiS9C70ZbQutC90ZbRgtGMINC90LAg0LLRltC70YzQvdC1INC80ZbRgdGG0LUsINGJ0L7QsSDQtNC+0LTQsNGC0Lgg0L3QvtCy0LjQuSDQstGD0LfQvtC7LlwiLFxuICBhZGRFZGdlOiBcItCU0L7QtNCw0YLQuCDQutGA0LDQuVwiLFxuICBhZGROb2RlOiBcItCU0L7QtNCw0YLQuCDQstGD0LfQvtC7XCIsXG4gIGJhY2s6IFwi0J3QsNC30LDQtFwiLFxuICBjbG9zZTogXCLQl9Cw0LrRgNC40YLQuFwiLFxuICBjcmVhdGVFZGdlRXJyb3I6IFwi0J3QtSDQvNC+0LbQu9C40LLQviDQvtCxJ9GU0LTQvdCw0YLQuCDQutGA0LDRlyDQsiDQs9GA0YPQv9GDLlwiLFxuICBkZWw6IFwi0JLQuNC00LDQu9C40YLQuCDQvtCx0YDQsNC90LVcIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcItCT0YDRg9C/0Lgg0L3QtSDQvNC+0LbRg9GC0Ywg0LHRg9GC0Lgg0LLQuNC00LDQu9C10L3Rli5cIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcItCa0LvRltC60L3RltGC0Ywg0L3QsCDQstGD0LfQvtC7INGWINC/0LXRgNC10YLRj9Cz0L3RltGC0Ywg0LrRgNCw0Lkg0LTQviDRltC90YjQvtCz0L4g0LLRg9C30LvQsCwg0YnQvtCxINGX0YUg0Lcn0ZTQtNC90LDRgtC4LlwiLFxuICBlZGl0OiBcItCg0LXQtNCw0LPRg9Cy0LDRgtC4XCIsXG4gIGVkaXRDbHVzdGVyRXJyb3I6IFwi0JPRgNGD0L/QuCDQvdC10LTQvtGB0YLRg9C/0L3RliDQtNC70Y8g0YDQtdC00LDQs9GD0LLQsNC90L3Rjy5cIixcbiAgZWRpdEVkZ2U6IFwi0KDQtdC00LDQs9GD0LLQsNGC0Lgg0LrRgNCw0LlcIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCLQmtC70ZbQutC90ZbRgtGMINC90LAg0LrQvtC90YLRgNC+0LvRjNC90ZYg0YLQvtGH0LrQuCDRliDQv9C10YDQtdGC0Y/Qs9C90ZbRgtGMINGX0YUg0YMg0LLRg9C30L7Quywg0YnQvtCxINC/0ZbQtNC60LvRjtGH0LjRgtC40YHRjyDQtNC+INC90YzQvtCz0L4uXCIsXG4gIGVkaXROb2RlOiBcItCg0LXQtNCw0LPRg9Cy0LDRgtC4INCy0YPQt9C+0LtcIlxufTtcbi8vIEZyZW5jaFxudmFyIGZyID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCJDbGlxdWV6IGRhbnMgdW4gZW5kcm9pdCB2aWRlIHBvdXIgcGxhY2VyIHVuIG7Fk3VkLlwiLFxuICBhZGRFZGdlOiBcIkFqb3V0ZXIgdW4gbGllblwiLFxuICBhZGROb2RlOiBcIkFqb3V0ZXIgdW4gbsWTdWRcIixcbiAgYmFjazogXCJSZXRvdXJcIixcbiAgY2xvc2U6IFwiRmVybWVyXCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJJbXBvc3NpYmxlIGRlIGNyw6llciB1biBsaWVuIHZlcnMgdW4gY2x1c3Rlci5cIixcbiAgZGVsOiBcIkVmZmFjZXIgbGEgc8OpbGVjdGlvblwiLFxuICBkZWxldGVDbHVzdGVyRXJyb3I6IFwiTGVzIGNsdXN0ZXJzIG5lIHBldXZlbnQgcGFzIMOqdHJlIGVmZmFjw6lzLlwiLFxuICBlZGdlRGVzY3JpcHRpb246IFwiQ2xpcXVleiBzdXIgdW4gbsWTdWQgZXQgZ2xpc3NleiBsZSBsaWVuIHZlcnMgdW4gYXV0cmUgbsWTdWQgcG91ciBsZXMgY29ubmVjdGVyLlwiLFxuICBlZGl0OiBcIsOJZGl0ZXJcIixcbiAgZWRpdENsdXN0ZXJFcnJvcjogXCJMZXMgY2x1c3RlcnMgbmUgcGV1dmVudCBwYXMgw6p0cmUgw6lkaXTDqXMuXCIsXG4gIGVkaXRFZGdlOiBcIsOJZGl0ZXIgbGUgbGllblwiLFxuICBlZGl0RWRnZURlc2NyaXB0aW9uOiBcIkNsaXF1ZXogc3VyIGxlcyBwb2ludHMgZGUgY29udHLDtGxlIGV0IGdsaXNzZXotbGVzIHBvdXIgY29ubmVjdGVyIHVuIG7Fk3VkLlwiLFxuICBlZGl0Tm9kZTogXCLDiWRpdGVyIGxlIG7Fk3VkXCJcbn07XG4vLyBDemVjaFxudmFyIGNzID0ge1xuICBhZGREZXNjcmlwdGlvbjogXCJLbHVrbnV0w61tIGRvIHByw6F6ZG7DqWhvIHByb3N0b3J1IG3Fr8W+ZXRlIHDFmWlkYXQgbm92w70gdnJjaG9sLlwiLFxuICBhZGRFZGdlOiBcIlDFmWlkYXQgaHJhbnVcIixcbiAgYWRkTm9kZTogXCJQxZlpZGF0IHZyY2hvbFwiLFxuICBiYWNrOiBcIlpwxJt0XCIsXG4gIGNsb3NlOiBcIlphdsWZw610XCIsXG4gIGNyZWF0ZUVkZ2VFcnJvcjogXCJOZWx6ZSBwxZlpcG9qaXQgaHJhbnUga2Ugc2hsdWt1LlwiLFxuICBkZWw6IFwiU21hemF0IHbDvWLEm3JcIixcbiAgZGVsZXRlQ2x1c3RlckVycm9yOiBcIk5lbHplIG1hemF0IHNobHVreS5cIixcbiAgZWRnZURlc2NyaXB0aW9uOiBcIlDFmWV0YcW+ZW7DrW0geiBqZWRub2hvIHZyY2hvbHUgZG8gZHJ1aMOpaG8gbcWvxb5ldGUgc3Bvaml0IHR5dG8gdnJjaG9seSBub3ZvdSBocmFub3UuXCIsXG4gIGVkaXQ6IFwiVXByYXZpdFwiLFxuICBlZGl0Q2x1c3RlckVycm9yOiBcIk5lbHplIHVwcmF2b3ZhdCBzaGx1a3kuXCIsXG4gIGVkaXRFZGdlOiBcIlVwcmF2aXQgaHJhbnVcIixcbiAgZWRpdEVkZ2VEZXNjcmlwdGlvbjogXCJQxZlldGHFvmVuw61tIGtvbnRyb2xuw61obyB2cmNob2x1IGhyYW55IGppIG3Fr8W+ZXRlIHDFmWlwb2ppdCBrIGppbsOpbXUgdnJjaG9sdS5cIixcbiAgZWRpdE5vZGU6IFwiVXByYXZpdCB2cmNob2xcIlxufTtcblxudmFyIGxvY2FsZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0Y246IGNuLFxuXHRjczogY3MsXG5cdGRlOiBkZSxcblx0ZW46IGVuLFxuXHRlczogZXMsXG5cdGZyOiBmcixcblx0aXQ6IGl0LFxuXHRubDogbmwsXG5cdHB0OiBwdCxcblx0cnU6IHJ1LFxuXHR1azogdWtcbn0pO1xuXG4vKipcclxuICogTm9ybWFsaXplcyBsYW5ndWFnZSBjb2RlIGludG8gdGhlIGZvcm1hdCB1c2VkIGludGVybmFsbHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBsb2NhbGVzIC0gQWxsIHRoZSBhdmFpbGFibGUgbG9jYWxlcy5cclxuICogQHBhcmFtIHJhd0NvZGUgLSBUaGUgb3JpZ2luYWwgY29kZSBhcyBzdXBwbGllZCBieSB0aGUgdXNlci5cclxuICogQHJldHVybnMgTGFuZ3VhZ2UgY29kZSBpbiB0aGUgZm9ybWF0IGxhbmd1YWdlLUNPVU5UUlkgb3IgbGFuZ3VhZ2UsIGV2ZW50dWFsbHlcclxuICogZmFsbGJhY2tzIHRvIGVuLlxyXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxhbmd1YWdlQ29kZShsb2NhbGVzLCByYXdDb2RlKSB7XG4gIHRyeSB7XG4gICAgdmFyIF9yYXdDb2RlJHNwbGl0ID0gcmF3Q29kZS5zcGxpdCgvWy1fIC9dLywgMiksXG4gICAgICBfcmF3Q29kZSRzcGxpdDIgPSBfc2xpY2VkVG9BcnJheShfcmF3Q29kZSRzcGxpdCwgMiksXG4gICAgICByYXdMYW5ndWFnZSA9IF9yYXdDb2RlJHNwbGl0MlswXSxcbiAgICAgIHJhd0NvdW50cnkgPSBfcmF3Q29kZSRzcGxpdDJbMV07XG4gICAgdmFyIGxhbmd1YWdlID0gcmF3TGFuZ3VhZ2UgIT0gbnVsbCA/IHJhd0xhbmd1YWdlLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgIHZhciBjb3VudHJ5ID0gcmF3Q291bnRyeSAhPSBudWxsID8gcmF3Q291bnRyeS50b1VwcGVyQ2FzZSgpIDogbnVsbDtcbiAgICBpZiAobGFuZ3VhZ2UgJiYgY291bnRyeSkge1xuICAgICAgdmFyIGNvZGUgPSBsYW5ndWFnZSArIFwiLVwiICsgY291bnRyeTtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobG9jYWxlcywgY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2NvbnRleHQ7XG4gICAgICAgIGNvbnNvbGUud2FybihfY29uY2F0SW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dCA9IFwiVW5rbm93biB2YXJpYW50IFwiLmNvbmNhdChjb3VudHJ5LCBcIiBvZiBsYW5ndWFnZSBcIikpLmNhbGwoX2NvbnRleHQsIGxhbmd1YWdlLCBcIi5cIikpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFuZ3VhZ2UpIHtcbiAgICAgIHZhciBfY29kZSA9IGxhbmd1YWdlO1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsb2NhbGVzLCBfY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIF9jb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiVW5rbm93biBsYW5ndWFnZSBcIi5jb25jYXQobGFuZ3VhZ2UpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc29sZS53YXJuKFwiVW5rbm93biBsb2NhbGUgXCIuY29uY2F0KHJhd0NvZGUsIFwiLCBmYWxsaW5nIGJhY2sgdG8gRW5nbGlzaC5cIikpO1xuICAgIHJldHVybiBcImVuXCI7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgY29uc29sZS53YXJuKFwiVW5leHBlY3RlZCBlcnJvciB3aGlsZSBub3JtYWxpemluZyBsb2NhbGUgXCIuY29uY2F0KHJhd0NvZGUsIFwiLCBmYWxsaW5nIGJhY2sgdG8gRW5nbGlzaC5cIikpO1xuICAgIHJldHVybiBcImVuXCI7XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NvY2lhdGVzIGEgY2FudmFzIHRvIGEgZ2l2ZW4gaW1hZ2UsIGNvbnRhaW5pbmcgYSBudW1iZXIgb2YgcmVuZGVyaW5nc1xuICogb2YgdGhlIGltYWdlIGF0IHZhcmlvdXMgc2l6ZXMuXG4gKlxuICogVGhpcyB0ZWNobmlxdWUgaXMga25vd24gYXMgJ21pcG1hcHBpbmcnLlxuICpcbiAqIE5PVEU6IEltYWdlcyBjYW4gYWxzbyBiZSBvZiB0eXBlICdkYXRhOnN2Zyt4bWxgLiBUaGlzIGNvZGUgYWxzbyB3b3Jrc1xuICogICAgICAgZm9yIHN2ZywgYnV0IHRoZSBtaXBtYXBwaW5nIG1heSBub3QgYmUgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXG4gKi9cbnZhciBDYWNoZWRJbWFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBDYWNoZWRJbWFnZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FjaGVkSW1hZ2UpO1xuICAgIHRoaXMuTlVNX0lURVJBVElPTlMgPSA0OyAvLyBOdW1iZXIgb2YgaXRlbXMgaW4gdGhlIGNvb3JkaW5hdGVzIGFycmF5XG5cbiAgICB0aGlzLmltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBpbWFnZSBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgbG9hZGVkLlxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKENhY2hlZEltYWdlLCBbe1xuICAgIGtleTogXCJpbml0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICBpZiAodGhpcy5pbml0aWFsaXplZCgpKSByZXR1cm47XG4gICAgICB0aGlzLnNyYyA9IHRoaXMuaW1hZ2Uuc3JjOyAvLyBGb3Igc2FtZSBpbnRlcmZhY2Ugd2l0aCBJbWFnZVxuICAgICAgdmFyIHcgPSB0aGlzLmltYWdlLndpZHRoO1xuICAgICAgdmFyIGggPSB0aGlzLmltYWdlLmhlaWdodDtcblxuICAgICAgLy8gRWFzZSBleHRlcm5hbCBhY2Nlc3NcbiAgICAgIHRoaXMud2lkdGggPSB3O1xuICAgICAgdGhpcy5oZWlnaHQgPSBoO1xuICAgICAgdmFyIGgyID0gTWF0aC5mbG9vcihoIC8gMik7XG4gICAgICB2YXIgaDQgPSBNYXRoLmZsb29yKGggLyA0KTtcbiAgICAgIHZhciBoOCA9IE1hdGguZmxvb3IoaCAvIDgpO1xuICAgICAgdmFyIGgxNiA9IE1hdGguZmxvb3IoaCAvIDE2KTtcbiAgICAgIHZhciB3MiA9IE1hdGguZmxvb3IodyAvIDIpO1xuICAgICAgdmFyIHc0ID0gTWF0aC5mbG9vcih3IC8gNCk7XG4gICAgICB2YXIgdzggPSBNYXRoLmZsb29yKHcgLyA4KTtcbiAgICAgIHZhciB3MTYgPSBNYXRoLmZsb29yKHcgLyAxNik7XG5cbiAgICAgIC8vIE1ha2UgY2FudmFzIGFzIHNtYWxsIGFzIHBvc3NpYmxlXG4gICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IDMgKiB3NDtcbiAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGgyO1xuXG4gICAgICAvLyBDb29yZGluYXRlcyBhbmQgc2l6ZXMgb2YgaW1hZ2VzIGNvbnRhaW5lZCBpbiB0aGUgY2FudmFzXG4gICAgICAvLyBWYWx1ZXMgcGVyIHJvdzogIFt0b3AgeCwgbGVmdCB5LCB3aWR0aCwgaGVpZ2h0XVxuXG4gICAgICB0aGlzLmNvb3JkaW5hdGVzID0gW1swLCAwLCB3MiwgaDJdLCBbdzIsIDAsIHc0LCBoNF0sIFt3MiwgaDQsIHc4LCBoOF0sIFs1ICogdzgsIGg0LCB3MTYsIGgxNl1dO1xuICAgICAgdGhpcy5fZmlsbE1pcE1hcCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGluaXQoKSBoYXMgYmVlbiBjYWxsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpbml0aWFsaXplZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGVzICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkcmF3IG1haW4gaW1hZ2UgaW4gdmFyaW91cyBzaXplcyB0byB0aGUgY29udGV4dC5cbiAgICAgKlxuICAgICAqIFRoZSByYXRpb25hbGUgYmVoaW5kIHRoaXMgaXMgdG8gcmVkdWNlIGFydGVmYWN0cyBkdWUgdG8gaW50ZXJwb2xhdGlvblxuICAgICAqIGF0IGRpZmZlcmluZyB6b29tIGxldmVscy5cbiAgICAgKlxuICAgICAqIFNvdXJjZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTg3NjE0MDQvMTIyMzUzMVxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2RzIHRha2VzIHRoZSByZXNpemluZyBvdXQgb2YgdGhlIGRyYXdpbmcgbG9vcCwgaW4gb3JkZXIgdG9cbiAgICAgKiByZWR1Y2UgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuXG4gICAgICpcbiAgICAgKiBUT0RPOiBUaGUgY29kZSBhc3N1bWVzIHRoYXQgYSAyRCBjb250ZXh0IGNhbiBhbHdheXMgYmUgZ290dGVuLiBUaGlzIGlzXG4gICAgICogICAgICAgbm90IG5lY2Vzc2FyaWx5IHRydWUhIE9UT0gsIGlmIG5vdCB0cnVlIHRoZW4gdXNhZ2Ugb2YgdGhpcyBjbGFzc1xuICAgICAqICAgICAgIGlzIHNlbnNlbGVzcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbGxNaXBNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbGxNaXBNYXAoKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICAvLyBGaXJzdCB6b29tLWxldmVsIGNvbWVzIGZyb20gdGhlIGltYWdlXG4gICAgICB2YXIgdG8gPSB0aGlzLmNvb3JkaW5hdGVzWzBdO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmltYWdlLCB0b1swXSwgdG9bMV0sIHRvWzJdLCB0b1szXSk7XG5cbiAgICAgIC8vIFRoZSByZXN0IGFyZSBjb3B5IGFjdGlvbnMgaW50ZXJuYWwgdG8gdGhlIGNhbnZhcy9jb250ZXh0XG4gICAgICBmb3IgKHZhciBpdGVyYXRpb25zID0gMTsgaXRlcmF0aW9ucyA8IHRoaXMuTlVNX0lURVJBVElPTlM7IGl0ZXJhdGlvbnMrKykge1xuICAgICAgICB2YXIgZnJvbSA9IHRoaXMuY29vcmRpbmF0ZXNbaXRlcmF0aW9ucyAtIDFdO1xuICAgICAgICB2YXIgX3RvID0gdGhpcy5jb29yZGluYXRlc1tpdGVyYXRpb25zXTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmNhbnZhcywgZnJvbVswXSwgZnJvbVsxXSwgZnJvbVsyXSwgZnJvbVszXSwgX3RvWzBdLCBfdG9bMV0sIF90b1syXSwgX3RvWzNdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IHRoZSBpbWFnZSwgdXNpbmcgdGhlIG1pcG1hcCBpZiBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBNaXBNYXAgaXMgb25seSB1c2VkIGlmIHBhcmFtIGZhY3RvciA+IDI7IG90aGVyd2lzZSwgb3JpZ2luYWwgYml0bWFwXG4gICAgICogaXMgcmVzaXplZC4gVGhpcyBpcyBhbHNvIHVzZWQgdG8gc2tpcCBtaXBtYXAgdXNhZ2UsIGUuZy4gYnkgc2V0dGluZyBmYWN0b3IgPSAxXG4gICAgICpcbiAgICAgKiBDcmVkaXRzIHRvICdBbGV4IGRlIE11bGRlcicgZm9yIG9yaWdpbmFsIGltcGxlbWVudGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAgY29udGV4dCBvbiB3aGljaCB0byBkcmF3IHpvb21lZCBpbWFnZVxuICAgICAqIEBwYXJhbSB7RmxvYXR9IGZhY3RvciBzY2FsZSBmYWN0b3IgYXQgd2hpY2ggdG8gZHJhd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvcFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkcmF3SW1hZ2VBdFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdJbWFnZUF0UG9zaXRpb24oY3R4LCBmYWN0b3IsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKCkpIHJldHVybjsgLy9jYW4ndCBkcmF3IGltYWdlIHlldCBub3QgaW50aWFsaXplZFxuXG4gICAgICBpZiAoZmFjdG9yID4gMikge1xuICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggem9vbWVkIGltYWdlIHRvIHVzZVxuICAgICAgICBmYWN0b3IgKj0gMC41O1xuICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICAgIHdoaWxlIChmYWN0b3IgPiAyICYmIGl0ZXJhdGlvbnMgPCB0aGlzLk5VTV9JVEVSQVRJT05TKSB7XG4gICAgICAgICAgZmFjdG9yICo9IDAuNTtcbiAgICAgICAgICBpdGVyYXRpb25zICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZXJhdGlvbnMgPj0gdGhpcy5OVU1fSVRFUkFUSU9OUykge1xuICAgICAgICAgIGl0ZXJhdGlvbnMgPSB0aGlzLk5VTV9JVEVSQVRJT05TIC0gMTtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiaXRlcmF0aW9uczogXCIgKyBpdGVyYXRpb25zKTtcblxuICAgICAgICB2YXIgZnJvbSA9IHRoaXMuY29vcmRpbmF0ZXNbaXRlcmF0aW9uc107XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXMsIGZyb21bMF0sIGZyb21bMV0sIGZyb21bMl0sIGZyb21bM10sIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEcmF3IGltYWdlIGRpcmVjdGx5XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5pbWFnZSwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENhY2hlZEltYWdlO1xufSgpO1xuXG4vKipcbiAqIFRoaXMgY2FsbGJhY2sgaXMgYSBjYWxsYmFjayB0aGF0IGFjY2VwdHMgYW4gSW1hZ2UuXG4gKlxuICogQGNhbGxiYWNrIEltYWdlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXG4gKi9cblxuLyoqXG4gKiBUaGlzIGNsYXNzIGxvYWRzIGltYWdlcyBhbmQga2VlcHMgdGhlbSBzdG9yZWQuXG4gKlxuICogQHBhcmFtIHtJbWFnZUNhbGxiYWNrfSBjYWxsYmFja1xuICovXG52YXIgSW1hZ2VzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SW1hZ2VDYWxsYmFja30gY2FsbGJhY2tcbiAgICovXG4gIGZ1bmN0aW9uIEltYWdlcyhjYWxsYmFjaykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZXMpO1xuICAgIHRoaXMuaW1hZ2VzID0ge307XG4gICAgdGhpcy5pbWFnZUJyb2tlbiA9IHt9O1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsICAgICAgICAgICAgICAgICAgICAgIFRoZSBvcmlnaW5hbCBVcmwgdGhhdCBmYWlsZWQgdG8gbG9hZCwgaWYgdGhlIGJyb2tlbiBpbWFnZSBpcyBzdWNjZXNzZnVsbHkgbG9hZGVkIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGNhY2hlIHVzaW5nIHRoaXMgVXJsIGFzIHRoZSBrZXkgc28gdGhhdCBzdWJzZXF1ZW50IHJlcXVlc3RzIGZvciB0aGlzIFVybCB3aWxsIHJldHVybiB0aGUgYnJva2VuIGltYWdlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBicm9rZW5VcmwgICAgICAgICAgICAgICAgVXJsIHRoZSBicm9rZW4gaW1hZ2UgdG8gdHJ5IGFuZCBsb2FkXG4gICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlVG9Mb2FkQnJva2VuVXJsT24gICBUaGUgaW1hZ2Ugb2JqZWN0XG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoSW1hZ2VzLCBbe1xuICAgIGtleTogXCJfdHJ5bG9hZEJyb2tlblVybFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJ5bG9hZEJyb2tlblVybCh1cmwsIGJyb2tlblVybCwgaW1hZ2VUb0xvYWRCcm9rZW5VcmxPbikge1xuICAgICAgLy9JZiB0aGVzZSBwYXJhbWV0ZXJzIGFyZW4ndCBzcGVjaWZpZWQgdGhlbiBleGl0IHRoZSBmdW5jdGlvbiBiZWNhdXNlIG5vdGhpbmcgY29uc3RydWN0aXZlIGNhbiBiZSBkb25lXG4gICAgICBpZiAodXJsID09PSB1bmRlZmluZWQgfHwgaW1hZ2VUb0xvYWRCcm9rZW5VcmxPbiA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICBpZiAoYnJva2VuVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiTm8gYnJva2VuIHVybCBpbWFnZSBkZWZpbmVkXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vQ2xlYXIgdGhlIG9sZCBzdWJzY3JpcHRpb24gdG8gdGhlIGVycm9yIGV2ZW50IGFuZCBwdXQgYSBuZXcgaW4gcGxhY2UgdGhhdCBvbmx5IGhhbmRsZSBlcnJvcnMgaW4gbG9hZGluZyB0aGUgYnJva2VuSW1hZ2VVcmxcbiAgICAgIGltYWdlVG9Mb2FkQnJva2VuVXJsT24uaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBsb2FkIGJyb2tlbkltYWdlOlwiLCBicm9rZW5VcmwpO1xuICAgICAgICAvLyBjYWNoZSBpdGVtIHdpbGwgY29udGFpbiBlbXB0eSBpbWFnZSwgdGhpcyBzaG91bGQgYmUgT0sgZm9yIGRlZmF1bHRcbiAgICAgIH07XG5cbiAgICAgIC8vU2V0IHRoZSBzb3VyY2Ugb2YgdGhlIGltYWdlIHRvIHRoZSBicm9rZW5VcmwsIHRoaXMgaXMgYWN0dWFsbHkgd2hhdCBraWNrcyBvZmYgdGhlIGxvYWRpbmcgb2YgdGhlIGJyb2tlbiBpbWFnZVxuICAgICAgaW1hZ2VUb0xvYWRCcm9rZW5VcmxPbi5pbWFnZS5zcmMgPSBicm9rZW5Vcmw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5JbWFnZX0gaW1hZ2VUb1JlZHJhd1dpdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9yZWRyYXdXaXRoSW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZHJhd1dpdGhJbWFnZShpbWFnZVRvUmVkcmF3V2l0aCkge1xuICAgICAgaWYgKHRoaXMuY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhpbWFnZVRvUmVkcmF3V2l0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAgICAgICAgICBVcmwgb2YgdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGJyb2tlblVybCAgICBVcmwgb2YgYW4gaW1hZ2UgdG8gdXNlIGlmIHRoZSB1cmwgaW1hZ2UgaXMgbm90IGZvdW5kXG4gICAgICogQHJldHVybnMge0ltYWdlfSBpbWcgICAgICAgICAgVGhlIGltYWdlIG9iamVjdFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCh1cmwsIGJyb2tlblVybCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIC8vVHJ5IGFuZCBnZXQgdGhlIGltYWdlIGZyb20gdGhlIGNhY2hlLCBpZiBzdWNjZXNzZnVsIHRoZW4gcmV0dXJuIHRoZSBjYWNoZWQgaW1hZ2VcbiAgICAgIHZhciBjYWNoZWRJbWFnZSA9IHRoaXMuaW1hZ2VzW3VybF07XG4gICAgICBpZiAoY2FjaGVkSW1hZ2UpIHJldHVybiBjYWNoZWRJbWFnZTtcblxuICAgICAgLy9DcmVhdGUgYSBuZXcgaW1hZ2VcbiAgICAgIHZhciBpbWcgPSBuZXcgQ2FjaGVkSW1hZ2UoKTtcblxuICAgICAgLy8gTmVlZCB0byBhZGQgdG8gY2FjaGUgaGVyZSwgb3RoZXJ3aXNlIGZpbmFsIHJldHVybiB3aWxsIHNwYXduIGRpZmZlcmVudCBjb3BpZXMgb2YgdGhlIHNhbWUgaW1hZ2UsXG4gICAgICAvLyBBbHNvLCB0aGVyZSB3aWxsIGJlIG11bHRpcGxlIGxvYWRzIG9mIHRoZSBzYW1lIGltYWdlLlxuICAgICAgdGhpcy5pbWFnZXNbdXJsXSA9IGltZztcblxuICAgICAgLy9TdWJzY3JpYmUgdG8gdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIGlmIHRoZSBpbWFnZSBsb2FkcyBzdWNjZXNzZnVsbHlcbiAgICAgIGltZy5pbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFByb3Blcmx5IGluaXQgdGhlIGNhY2hlZCBpdGVtIGFuZCB0aGVuIHJlcXVlc3QgYSByZWRyYXdcbiAgICAgICAgX3RoaXMuX2ZpeEltYWdlQ29vcmRpbmF0ZXMoaW1nLmltYWdlKTtcbiAgICAgICAgaW1nLmluaXQoKTtcbiAgICAgICAgX3RoaXMuX3JlZHJhd1dpdGhJbWFnZShpbWcpO1xuICAgICAgfTtcblxuICAgICAgLy9TdWJzY3JpYmUgdG8gdGhlIGV2ZW50IHRoYXQgaXMgcmFpc2VkIGlmIHRoZSBpbWFnZSBmYWlscyB0byBsb2FkXG4gICAgICBpbWcuaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBsb2FkIGltYWdlOlwiLCB1cmwpO1xuICAgICAgICAvL1RyeSBhbmQgbG9hZCB0aGUgaW1hZ2Ugc3BlY2lmaWVkIGJ5IHRoZSBicm9rZW5VcmwgdXNpbmdcbiAgICAgICAgX3RoaXMuX3RyeWxvYWRCcm9rZW5VcmwodXJsLCBicm9rZW5VcmwsIGltZyk7XG4gICAgICB9O1xuXG4gICAgICAvL1NldCB0aGUgc291cmNlIG9mIHRoZSBpbWFnZSB0byB0aGUgdXJsLCB0aGlzIGlzIHdoYXQgYWN0dWFsbHkga2lja3Mgb2ZmIHRoZSBsb2FkaW5nIG9mIHRoZSBpbWFnZVxuICAgICAgaW1nLmltYWdlLnNyYyA9IHVybDtcblxuICAgICAgLy9SZXR1cm4gdGhlIG5ldyBpbWFnZVxuICAgICAgcmV0dXJuIGltZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJRTExIGZpeCAtLSB0aGFua3MgZHBvbmNoIVxuICAgICAqXG4gICAgICogTG9jYWwgaGVscGVyIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5JbWFnZX0gaW1hZ2VUb0NhY2hlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZml4SW1hZ2VDb29yZGluYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZml4SW1hZ2VDb29yZGluYXRlcyhpbWFnZVRvQ2FjaGUpIHtcbiAgICAgIGlmIChpbWFnZVRvQ2FjaGUud2lkdGggPT09IDApIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbWFnZVRvQ2FjaGUpO1xuICAgICAgICBpbWFnZVRvQ2FjaGUud2lkdGggPSBpbWFnZVRvQ2FjaGUub2Zmc2V0V2lkdGg7XG4gICAgICAgIGltYWdlVG9DYWNoZS5oZWlnaHQgPSBpbWFnZVRvQ2FjaGUub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGltYWdlVG9DYWNoZSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBJbWFnZXM7XG59KCk7XG5cbnZhciBpbnRlcm5hbE1ldGFkYXRhID0ge2V4cG9ydHM6IHt9fTtcblxuLy8gRkYyNi0gYnVnOiBBcnJheUJ1ZmZlcnMgYXJlIG5vbi1leHRlbnNpYmxlLCBidXQgT2JqZWN0LmlzRXh0ZW5zaWJsZSBkb2VzIG5vdCByZXBvcnQgaXRcbnZhciBmYWlscyQ5ID0gZmFpbHMkdztcblxudmFyIGFycmF5QnVmZmVyTm9uRXh0ZW5zaWJsZSA9IGZhaWxzJDkoZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyID09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaXNleHRlbnNpYmxlLCBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuICAgIGlmIChPYmplY3QuaXNFeHRlbnNpYmxlKGJ1ZmZlcikpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShidWZmZXIsICdhJywgeyB2YWx1ZTogOCB9KTtcbiAgfVxufSk7XG5cbnZhciBmYWlscyQ4ID0gZmFpbHMkdztcbnZhciBpc09iamVjdCQ2ID0gaXNPYmplY3QkajtcbnZhciBjbGFzc29mJDIgPSBjbGFzc29mUmF3JDI7XG52YXIgQVJSQVlfQlVGRkVSX05PTl9FWFRFTlNJQkxFID0gYXJyYXlCdWZmZXJOb25FeHRlbnNpYmxlO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWlzZXh0ZW5zaWJsZSAtLSBzYWZlXG52YXIgJGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGU7XG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyQxID0gZmFpbHMkOChmdW5jdGlvbiAoKSB7ICRpc0V4dGVuc2libGUoMSk7IH0pO1xuXG4vLyBgT2JqZWN0LmlzRXh0ZW5zaWJsZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5pc2V4dGVuc2libGVcbnZhciBvYmplY3RJc0V4dGVuc2libGUgPSAoRkFJTFNfT05fUFJJTUlUSVZFUyQxIHx8IEFSUkFZX0JVRkZFUl9OT05fRVhURU5TSUJMRSkgPyBmdW5jdGlvbiBpc0V4dGVuc2libGUoaXQpIHtcbiAgaWYgKCFpc09iamVjdCQ2KGl0KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoQVJSQVlfQlVGRkVSX05PTl9FWFRFTlNJQkxFICYmIGNsYXNzb2YkMihpdCkgPT09ICdBcnJheUJ1ZmZlcicpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuICRpc0V4dGVuc2libGUgPyAkaXNFeHRlbnNpYmxlKGl0KSA6IHRydWU7XG59IDogJGlzRXh0ZW5zaWJsZTtcblxudmFyIGZhaWxzJDcgPSBmYWlscyR3O1xuXG52YXIgZnJlZXppbmcgPSAhZmFpbHMkNyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaXNleHRlbnNpYmxlLCBlcy9uby1vYmplY3QtcHJldmVudGV4dGVuc2lvbnMgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5pc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7XG59KTtcblxudmFyICQkZyA9IF9leHBvcnQ7XG52YXIgdW5jdXJyeVRoaXMkNCA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgaGlkZGVuS2V5cyA9IGhpZGRlbktleXMkNjtcbnZhciBpc09iamVjdCQ1ID0gaXNPYmplY3QkajtcbnZhciBoYXNPd24kMyA9IGhhc093blByb3BlcnR5XzE7XG52YXIgZGVmaW5lUHJvcGVydHkkMiA9IG9iamVjdERlZmluZVByb3BlcnR5LmY7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IG9iamVjdEdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsO1xudmFyIGlzRXh0ZW5zaWJsZSQxID0gb2JqZWN0SXNFeHRlbnNpYmxlO1xudmFyIHVpZCA9IHVpZCQ0O1xudmFyIEZSRUVaSU5HJDEgPSBmcmVlemluZztcblxudmFyIFJFUVVJUkVEID0gZmFsc2U7XG52YXIgTUVUQURBVEEgPSB1aWQoJ21ldGEnKTtcbnZhciBpZCQxID0gMDtcblxudmFyIHNldE1ldGFkYXRhID0gZnVuY3Rpb24gKGl0KSB7XG4gIGRlZmluZVByb3BlcnR5JDIoaXQsIE1FVEFEQVRBLCB7IHZhbHVlOiB7XG4gICAgb2JqZWN0SUQ6ICdPJyArIGlkJDErKywgLy8gb2JqZWN0IElEXG4gICAgd2Vha0RhdGE6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xuXG52YXIgZmFzdEtleSQxID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgLy8gcmV0dXJuIGEgcHJpbWl0aXZlIHdpdGggcHJlZml4XG4gIGlmICghaXNPYmplY3QkNShpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzT3duJDMoaXQsIE1FVEFEQVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUkMShpdCkpIHJldHVybiAnRic7XG4gICAgLy8gbm90IG5lY2Vzc2FyeSB0byBhZGQgbWV0YWRhdGFcbiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJztcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGFkYXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBREFUQV0ub2JqZWN0SUQ7XG59O1xuXG52YXIgZ2V0V2Vha0RhdGEkMSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIGlmICghaGFzT3duJDMoaXQsIE1FVEFEQVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUkMShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGFkYXRhKGl0KTtcbiAgLy8gcmV0dXJuIHRoZSBzdG9yZSBvZiB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBREFUQV0ud2Vha0RhdGE7XG59O1xuXG4vLyBhZGQgbWV0YWRhdGEgb24gZnJlZXplLWZhbWlseSBtZXRob2RzIGNhbGxpbmdcbnZhciBvbkZyZWV6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoRlJFRVpJTkckMSAmJiBSRVFVSVJFRCAmJiBpc0V4dGVuc2libGUkMShpdCkgJiYgIWhhc093biQzKGl0LCBNRVRBREFUQSkpIHNldE1ldGFkYXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxudmFyIGVuYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgbWV0YS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG4gIFJFUVVJUkVEID0gdHJ1ZTtcbiAgdmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmY7XG4gIHZhciBzcGxpY2UgPSB1bmN1cnJ5VGhpcyQ0KFtdLnNwbGljZSk7XG4gIHZhciB0ZXN0ID0ge307XG4gIHRlc3RbTUVUQURBVEFdID0gMTtcblxuICAvLyBwcmV2ZW50IGV4cG9zaW5nIG9mIG1ldGFkYXRhIGtleVxuICBpZiAoZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0KS5sZW5ndGgpIHtcbiAgICBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSByZXN1bHQubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlc3VsdFtpXSA9PT0gTUVUQURBVEEpIHtcbiAgICAgICAgICBzcGxpY2UocmVzdWx0LCBpLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAkJGcoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xuICAgICAgZ2V0T3duUHJvcGVydHlOYW1lczogZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsTW9kdWxlLmZcbiAgICB9KTtcbiAgfVxufTtcblxudmFyIG1ldGEgPSBpbnRlcm5hbE1ldGFkYXRhLmV4cG9ydHMgPSB7XG4gIGVuYWJsZTogZW5hYmxlLFxuICBmYXN0S2V5OiBmYXN0S2V5JDEsXG4gIGdldFdlYWtEYXRhOiBnZXRXZWFrRGF0YSQxLFxuICBvbkZyZWV6ZTogb25GcmVlemVcbn07XG5cbmhpZGRlbktleXNbTUVUQURBVEFdID0gdHJ1ZTtcblxudmFyIGludGVybmFsTWV0YWRhdGFFeHBvcnRzID0gaW50ZXJuYWxNZXRhZGF0YS5leHBvcnRzO1xuXG52YXIgYmluZCQ1ID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBjYWxsJDEgPSBmdW5jdGlvbkNhbGw7XG52YXIgYW5PYmplY3QkMyA9IGFuT2JqZWN0JGQ7XG52YXIgdHJ5VG9TdHJpbmckMSA9IHRyeVRvU3RyaW5nJDY7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gaXNBcnJheUl0ZXJhdG9yTWV0aG9kJDI7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UkMiA9IGxlbmd0aE9mQXJyYXlMaWtlJGM7XG52YXIgaXNQcm90b3R5cGVPZiQ2ID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBnZXRJdGVyYXRvciA9IGdldEl0ZXJhdG9yJDI7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZCQ5O1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBpdGVyYXRvckNsb3NlJDI7XG5cbnZhciAkVHlwZUVycm9yJDMgPSBUeXBlRXJyb3I7XG5cbnZhciBSZXN1bHQgPSBmdW5jdGlvbiAoc3RvcHBlZCwgcmVzdWx0KSB7XG4gIHRoaXMuc3RvcHBlZCA9IHN0b3BwZWQ7XG4gIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xufTtcblxudmFyIFJlc3VsdFByb3RvdHlwZSA9IFJlc3VsdC5wcm90b3R5cGU7XG5cbnZhciBpdGVyYXRlJDMgPSBmdW5jdGlvbiAoaXRlcmFibGUsIHVuYm91bmRGdW5jdGlvbiwgb3B0aW9ucykge1xuICB2YXIgdGhhdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aGF0O1xuICB2YXIgQVNfRU5UUklFUyA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5BU19FTlRSSUVTKTtcbiAgdmFyIElTX1JFQ09SRCA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JU19SRUNPUkQpO1xuICB2YXIgSVNfSVRFUkFUT1IgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfSVRFUkFUT1IpO1xuICB2YXIgSU5URVJSVVBURUQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSU5URVJSVVBURUQpO1xuICB2YXIgZm4gPSBiaW5kJDUodW5ib3VuZEZ1bmN0aW9uLCB0aGF0KTtcbiAgdmFyIGl0ZXJhdG9yLCBpdGVyRm4sIGluZGV4LCBsZW5ndGgsIHJlc3VsdCwgbmV4dCwgc3RlcDtcblxuICB2YXIgc3RvcCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICBpZiAoaXRlcmF0b3IpIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICdub3JtYWwnLCBjb25kaXRpb24pO1xuICAgIHJldHVybiBuZXcgUmVzdWx0KHRydWUsIGNvbmRpdGlvbik7XG4gIH07XG5cbiAgdmFyIGNhbGxGbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChBU19FTlRSSUVTKSB7XG4gICAgICBhbk9iamVjdCQzKHZhbHVlKTtcbiAgICAgIHJldHVybiBJTlRFUlJVUFRFRCA/IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSwgc3RvcCkgOiBmbih2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgIH0gcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWUsIHN0b3ApIDogZm4odmFsdWUpO1xuICB9O1xuXG4gIGlmIChJU19SRUNPUkQpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlLml0ZXJhdG9yO1xuICB9IGVsc2UgaWYgKElTX0lURVJBVE9SKSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcbiAgfSBlbHNlIHtcbiAgICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSk7XG4gICAgaWYgKCFpdGVyRm4pIHRocm93IG5ldyAkVHlwZUVycm9yJDModHJ5VG9TdHJpbmckMShpdGVyYWJsZSkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xuICAgIC8vIG9wdGltaXNhdGlvbiBmb3IgYXJyYXkgaXRlcmF0b3JzXG4gICAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyRm4pKSB7XG4gICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UkMihpdGVyYWJsZSk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3VsdCA9IGNhbGxGbihpdGVyYWJsZVtpbmRleF0pO1xuICAgICAgICBpZiAocmVzdWx0ICYmIGlzUHJvdG90eXBlT2YkNihSZXN1bHRQcm90b3R5cGUsIHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbiAgICB9XG4gICAgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihpdGVyYWJsZSwgaXRlckZuKTtcbiAgfVxuXG4gIG5leHQgPSBJU19SRUNPUkQgPyBpdGVyYWJsZS5uZXh0IDogaXRlcmF0b3IubmV4dDtcbiAgd2hpbGUgKCEoc3RlcCA9IGNhbGwkMShuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gY2FsbEZuKHN0ZXAudmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcmVzdWx0ID09ICdvYmplY3QnICYmIHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mJDYoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbn07XG5cbnZhciBpc1Byb3RvdHlwZU9mJDUgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xuXG52YXIgJFR5cGVFcnJvciQyID0gVHlwZUVycm9yO1xuXG52YXIgYW5JbnN0YW5jZSQzID0gZnVuY3Rpb24gKGl0LCBQcm90b3R5cGUpIHtcbiAgaWYgKGlzUHJvdG90eXBlT2YkNShQcm90b3R5cGUsIGl0KSkgcmV0dXJuIGl0O1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvciQyKCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xufTtcblxudmFyICQkZiA9IF9leHBvcnQ7XG52YXIgZ2xvYmFsJDUgPSBnbG9iYWwkbjtcbnZhciBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlJDEgPSBpbnRlcm5hbE1ldGFkYXRhRXhwb3J0cztcbnZhciBmYWlscyQ2ID0gZmFpbHMkdztcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkkNjtcbnZhciBpdGVyYXRlJDIgPSBpdGVyYXRlJDM7XG52YXIgYW5JbnN0YW5jZSQyID0gYW5JbnN0YW5jZSQzO1xudmFyIGlzQ2FsbGFibGUgPSBpc0NhbGxhYmxlJGk7XG52YXIgaXNPYmplY3QkNCA9IGlzT2JqZWN0JGo7XG52YXIgaXNOdWxsT3JVbmRlZmluZWQkMiA9IGlzTnVsbE9yVW5kZWZpbmVkJDY7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBzZXRUb1N0cmluZ1RhZyQ2O1xudmFyIGRlZmluZVByb3BlcnR5JDEgPSBvYmplY3REZWZpbmVQcm9wZXJ0eS5mO1xudmFyIGZvckVhY2ggPSBhcnJheUl0ZXJhdGlvbi5mb3JFYWNoO1xudmFyIERFU0NSSVBUT1JTJDUgPSBkZXNjcmlwdG9ycztcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDIgPSBpbnRlcm5hbFN0YXRlO1xuXG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQyID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQyLnNldDtcbnZhciBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yJDIgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDIuZ2V0dGVyRm9yO1xuXG52YXIgY29sbGVjdGlvbiQzID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUsIHdyYXBwZXIsIGNvbW1vbikge1xuICB2YXIgSVNfTUFQID0gQ09OU1RSVUNUT1JfTkFNRS5pbmRleE9mKCdNYXAnKSAhPT0gLTE7XG4gIHZhciBJU19XRUFLID0gQ09OU1RSVUNUT1JfTkFNRS5pbmRleE9mKCdXZWFrJykgIT09IC0xO1xuICB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuICB2YXIgTmF0aXZlQ29uc3RydWN0b3IgPSBnbG9iYWwkNVtDT05TVFJVQ1RPUl9OQU1FXTtcbiAgdmFyIE5hdGl2ZVByb3RvdHlwZSA9IE5hdGl2ZUNvbnN0cnVjdG9yICYmIE5hdGl2ZUNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgdmFyIGV4cG9ydGVkID0ge307XG4gIHZhciBDb25zdHJ1Y3RvcjtcblxuICBpZiAoIURFU0NSSVBUT1JTJDUgfHwgIWlzQ2FsbGFibGUoTmF0aXZlQ29uc3RydWN0b3IpXG4gICAgfHwgIShJU19XRUFLIHx8IE5hdGl2ZVByb3RvdHlwZS5mb3JFYWNoICYmICFmYWlscyQ2KGZ1bmN0aW9uICgpIHsgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCkuZW50cmllcygpLm5leHQoKTsgfSkpXG4gICkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQ29uc3RydWN0b3IgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZSQxLmVuYWJsZSgpO1xuICB9IGVsc2Uge1xuICAgIENvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAodGFyZ2V0LCBpdGVyYWJsZSkge1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSQyKGFuSW5zdGFuY2UkMih0YXJnZXQsIFByb3RvdHlwZSksIHtcbiAgICAgICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcbiAgICAgICAgY29sbGVjdGlvbjogbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKClcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZCQyKGl0ZXJhYmxlKSkgaXRlcmF0ZSQyKGl0ZXJhYmxlLCB0YXJnZXRbQURERVJdLCB7IHRoYXQ6IHRhcmdldCwgQVNfRU5UUklFUzogSVNfTUFQIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIFByb3RvdHlwZSA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICAgIHZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvciQyKENPTlNUUlVDVE9SX05BTUUpO1xuXG4gICAgZm9yRWFjaChbJ2FkZCcsICdjbGVhcicsICdkZWxldGUnLCAnZm9yRWFjaCcsICdnZXQnLCAnaGFzJywgJ3NldCcsICdrZXlzJywgJ3ZhbHVlcycsICdlbnRyaWVzJ10sIGZ1bmN0aW9uIChLRVkpIHtcbiAgICAgIHZhciBJU19BRERFUiA9IEtFWSA9PT0gJ2FkZCcgfHwgS0VZID09PSAnc2V0JztcbiAgICAgIGlmIChLRVkgaW4gTmF0aXZlUHJvdG90eXBlICYmICEoSVNfV0VBSyAmJiBLRVkgPT09ICdjbGVhcicpKSB7XG4gICAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShQcm90b3R5cGUsIEtFWSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICB2YXIgY29sbGVjdGlvbiA9IGdldEludGVybmFsU3RhdGUodGhpcykuY29sbGVjdGlvbjtcbiAgICAgICAgICBpZiAoIUlTX0FEREVSICYmIElTX1dFQUsgJiYgIWlzT2JqZWN0JDQoYSkpIHJldHVybiBLRVkgPT09ICdnZXQnID8gdW5kZWZpbmVkIDogZmFsc2U7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGNvbGxlY3Rpb25bS0VZXShhID09PSAwID8gMCA6IGEsIGIpO1xuICAgICAgICAgIHJldHVybiBJU19BRERFUiA/IHRoaXMgOiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgSVNfV0VBSyB8fCBkZWZpbmVQcm9wZXJ0eSQxKFByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuY29sbGVjdGlvbi5zaXplO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUsIGZhbHNlLCB0cnVlKTtcblxuICBleHBvcnRlZFtDT05TVFJVQ1RPUl9OQU1FXSA9IENvbnN0cnVjdG9yO1xuICAkJGYoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogdHJ1ZSB9LCBleHBvcnRlZCk7XG5cbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn07XG5cbnZhciBkZWZpbmVCdWlsdEluID0gZGVmaW5lQnVpbHRJbiQ1O1xuXG52YXIgZGVmaW5lQnVpbHRJbnMkMyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy51bnNhZmUgJiYgdGFyZ2V0W2tleV0pIHRhcmdldFtrZXldID0gc3JjW2tleV07XG4gICAgZWxzZSBkZWZpbmVCdWlsdEluKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gIH0gcmV0dXJuIHRhcmdldDtcbn07XG5cbnZhciBnZXRCdWlsdEluJDEgPSBnZXRCdWlsdEluJGM7XG52YXIgZGVmaW5lQnVpbHRJbkFjY2Vzc29yJDEgPSBkZWZpbmVCdWlsdEluQWNjZXNzb3IkMztcbnZhciB3ZWxsS25vd25TeW1ib2wgPSB3ZWxsS25vd25TeW1ib2wkbTtcbnZhciBERVNDUklQVE9SUyQ0ID0gZGVzY3JpcHRvcnM7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbnZhciBzZXRTcGVjaWVzJDEgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSkge1xuICB2YXIgQ29uc3RydWN0b3IgPSBnZXRCdWlsdEluJDEoQ09OU1RSVUNUT1JfTkFNRSk7XG5cbiAgaWYgKERFU0NSSVBUT1JTJDQgJiYgQ29uc3RydWN0b3IgJiYgIUNvbnN0cnVjdG9yW1NQRUNJRVNdKSB7XG4gICAgZGVmaW5lQnVpbHRJbkFjY2Vzc29yJDEoQ29uc3RydWN0b3IsIFNQRUNJRVMsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfVxuICAgIH0pO1xuICB9XG59O1xuXG52YXIgY3JlYXRlJDQgPSBvYmplY3RDcmVhdGU7XG52YXIgZGVmaW5lQnVpbHRJbkFjY2Vzc29yID0gZGVmaW5lQnVpbHRJbkFjY2Vzc29yJDM7XG52YXIgZGVmaW5lQnVpbHRJbnMkMiA9IGRlZmluZUJ1aWx0SW5zJDM7XG52YXIgYmluZCQ0ID0gZnVuY3Rpb25CaW5kQ29udGV4dDtcbnZhciBhbkluc3RhbmNlJDEgPSBhbkluc3RhbmNlJDM7XG52YXIgaXNOdWxsT3JVbmRlZmluZWQkMSA9IGlzTnVsbE9yVW5kZWZpbmVkJDY7XG52YXIgaXRlcmF0ZSQxID0gaXRlcmF0ZSQzO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gaXRlcmF0b3JEZWZpbmU7XG52YXIgY3JlYXRlSXRlclJlc3VsdE9iamVjdCA9IGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QkMztcbnZhciBzZXRTcGVjaWVzID0gc2V0U3BlY2llcyQxO1xudmFyIERFU0NSSVBUT1JTJDMgPSBkZXNjcmlwdG9ycztcbnZhciBmYXN0S2V5ID0gaW50ZXJuYWxNZXRhZGF0YUV4cG9ydHMuZmFzdEtleTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlJDEgPSBpbnRlcm5hbFN0YXRlO1xuXG52YXIgc2V0SW50ZXJuYWxTdGF0ZSQxID0gSW50ZXJuYWxTdGF0ZU1vZHVsZSQxLnNldDtcbnZhciBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yJDEgPSBJbnRlcm5hbFN0YXRlTW9kdWxlJDEuZ2V0dGVyRm9yO1xuXG52YXIgY29sbGVjdGlvblN0cm9uZyQyID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSQxKHRoYXQsIFByb3RvdHlwZSk7XG4gICAgICBzZXRJbnRlcm5hbFN0YXRlJDEodGhhdCwge1xuICAgICAgICB0eXBlOiBDT05TVFJVQ1RPUl9OQU1FLFxuICAgICAgICBpbmRleDogY3JlYXRlJDQobnVsbCksXG4gICAgICAgIGZpcnN0OiB1bmRlZmluZWQsXG4gICAgICAgIGxhc3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgc2l6ZTogMFxuICAgICAgfSk7XG4gICAgICBpZiAoIURFU0NSSVBUT1JTJDMpIHRoYXQuc2l6ZSA9IDA7XG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkJDEoaXRlcmFibGUpKSBpdGVyYXRlJDEoaXRlcmFibGUsIHRoYXRbQURERVJdLCB7IHRoYXQ6IHRoYXQsIEFTX0VOVFJJRVM6IElTX01BUCB9KTtcbiAgICB9KTtcblxuICAgIHZhciBQcm90b3R5cGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbiAgICB2YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IkMShDT05TVFJVQ1RPUl9OQU1FKTtcblxuICAgIHZhciBkZWZpbmUgPSBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgICB2YXIgcHJldmlvdXMsIGluZGV4O1xuICAgICAgLy8gY2hhbmdlIGV4aXN0aW5nIGVudHJ5XG4gICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgZW50cnkudmFsdWUgPSB2YWx1ZTtcbiAgICAgIC8vIGNyZWF0ZSBuZXcgZW50cnlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLmxhc3QgPSBlbnRyeSA9IHtcbiAgICAgICAgICBpbmRleDogaW5kZXggPSBmYXN0S2V5KGtleSwgdHJ1ZSksXG4gICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHByZXZpb3VzOiBwcmV2aW91cyA9IHN0YXRlLmxhc3QsXG4gICAgICAgICAgbmV4dDogdW5kZWZpbmVkLFxuICAgICAgICAgIHJlbW92ZWQ6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIGlmICghc3RhdGUuZmlyc3QpIHN0YXRlLmZpcnN0ID0gZW50cnk7XG4gICAgICAgIGlmIChwcmV2aW91cykgcHJldmlvdXMubmV4dCA9IGVudHJ5O1xuICAgICAgICBpZiAoREVTQ1JJUFRPUlMkMykgc3RhdGUuc2l6ZSsrO1xuICAgICAgICBlbHNlIHRoYXQuc2l6ZSsrO1xuICAgICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHN0YXRlLmluZGV4W2luZGV4XSA9IGVudHJ5O1xuICAgICAgfSByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgdmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgIC8vIGZhc3QgY2FzZVxuICAgICAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICAgICAgdmFyIGVudHJ5O1xuICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiBzdGF0ZS5pbmRleFtpbmRleF07XG4gICAgICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgICAgIGZvciAoZW50cnkgPSBzdGF0ZS5maXJzdDsgZW50cnk7IGVudHJ5ID0gZW50cnkubmV4dCkge1xuICAgICAgICBpZiAoZW50cnkua2V5ID09PSBrZXkpIHJldHVybiBlbnRyeTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZGVmaW5lQnVpbHRJbnMkMihQcm90b3R5cGUsIHtcbiAgICAgIC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlLmNsZWFyKClgIG1ldGhvZHNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5jbGVhclxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmNsZWFyXG4gICAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgICAgdmFyIGRhdGEgPSBzdGF0ZS5pbmRleDtcbiAgICAgICAgdmFyIGVudHJ5ID0gc3RhdGUuZmlyc3Q7XG4gICAgICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgICAgIGVudHJ5LnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgIGlmIChlbnRyeS5wcmV2aW91cykgZW50cnkucHJldmlvdXMgPSBlbnRyeS5wcmV2aW91cy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGRlbGV0ZSBkYXRhW2VudHJ5LmluZGV4XTtcbiAgICAgICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZmlyc3QgPSBzdGF0ZS5sYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoREVTQ1JJUFRPUlMkMykgc3RhdGUuc2l6ZSA9IDA7XG4gICAgICAgIGVsc2UgdGhhdC5zaXplID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyBgeyBNYXAsIFNldCB9LnByb3RvdHlwZS5kZWxldGUoa2V5KWAgbWV0aG9kc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmRlbGV0ZVxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLmRlbGV0ZVxuICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGF0LCBrZXkpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGVudHJ5Lm5leHQ7XG4gICAgICAgICAgdmFyIHByZXYgPSBlbnRyeS5wcmV2aW91cztcbiAgICAgICAgICBkZWxldGUgc3RhdGUuaW5kZXhbZW50cnkuaW5kZXhdO1xuICAgICAgICAgIGVudHJ5LnJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgIGlmIChwcmV2KSBwcmV2Lm5leHQgPSBuZXh0O1xuICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnByZXZpb3VzID0gcHJldjtcbiAgICAgICAgICBpZiAoc3RhdGUuZmlyc3QgPT09IGVudHJ5KSBzdGF0ZS5maXJzdCA9IG5leHQ7XG4gICAgICAgICAgaWYgKHN0YXRlLmxhc3QgPT09IGVudHJ5KSBzdGF0ZS5sYXN0ID0gcHJldjtcbiAgICAgICAgICBpZiAoREVTQ1JJUFRPUlMkMykgc3RhdGUuc2l6ZS0tO1xuICAgICAgICAgIGVsc2UgdGhhdC5zaXplLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gYHsgTWFwLCBTZXQgfS5wcm90b3R5cGUuZm9yRWFjaChjYWxsYmFja2ZuLCB0aGlzQXJnID0gdW5kZWZpbmVkKWAgbWV0aG9kc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmZvcmVhY2hcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5mb3JlYWNoXG4gICAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZCQ0KGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5maXJzdCkge1xuICAgICAgICAgIGJvdW5kRnVuY3Rpb24oZW50cnkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBgeyBNYXAsIFNldH0ucHJvdG90eXBlLmhhcyhrZXkpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuaGFzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuaGFzXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGRlZmluZUJ1aWx0SW5zJDIoUHJvdG90eXBlLCBJU19NQVAgPyB7XG4gICAgICAvLyBgTWFwLnByb3RvdHlwZS5nZXQoa2V5KWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuZ2V0XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhpcywga2V5KTtcbiAgICAgICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnZhbHVlO1xuICAgICAgfSxcbiAgICAgIC8vIGBNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUuc2V0XG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUodGhpcywga2V5ID09PSAwID8gMCA6IGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gOiB7XG4gICAgICAvLyBgU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpYCBtZXRob2RcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5hZGRcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkZWZpbmUodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChERVNDUklQVE9SUyQzKSBkZWZpbmVCdWlsdEluQWNjZXNzb3IoUHJvdG90eXBlLCAnc2l6ZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zaXplO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCkge1xuICAgIHZhciBJVEVSQVRPUl9OQU1FID0gQ09OU1RSVUNUT1JfTkFNRSArICcgSXRlcmF0b3InO1xuICAgIHZhciBnZXRJbnRlcm5hbENvbGxlY3Rpb25TdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IkMShDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICB2YXIgZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvciQxKElURVJBVE9SX05BTUUpO1xuICAgIC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlLnsga2V5cywgdmFsdWVzLCBlbnRyaWVzLCBAQGl0ZXJhdG9yIH0oKWAgbWV0aG9kc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWFwLnByb3RvdHlwZS5lbnRyaWVzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLmtleXNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC5wcm90b3R5cGUudmFsdWVzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1tYXAucHJvdG90eXBlLUBAaXRlcmF0b3JcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXNldC5wcm90b3R5cGUuZW50cmllc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS5rZXlzXG4gICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXQucHJvdG90eXBlLnZhbHVlc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LnByb3RvdHlwZS1AQGl0ZXJhdG9yXG4gICAgZGVmaW5lSXRlcmF0b3IoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSQxKHRoaXMsIHtcbiAgICAgICAgdHlwZTogSVRFUkFUT1JfTkFNRSxcbiAgICAgICAgdGFyZ2V0OiBpdGVyYXRlZCxcbiAgICAgICAgc3RhdGU6IGdldEludGVybmFsQ29sbGVjdGlvblN0YXRlKGl0ZXJhdGVkKSxcbiAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgbGFzdDogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUodGhpcyk7XG4gICAgICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gICAgICB2YXIgZW50cnkgPSBzdGF0ZS5sYXN0O1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucmVtb3ZlZCkgZW50cnkgPSBlbnRyeS5wcmV2aW91cztcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZiAoIXN0YXRlLnRhcmdldCB8fCAhKHN0YXRlLmxhc3QgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubmV4dCA6IHN0YXRlLnN0YXRlLmZpcnN0KSkge1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gc3RlcCBieSBraW5kXG4gICAgICBpZiAoa2luZCA9PT0gJ2tleXMnKSByZXR1cm4gY3JlYXRlSXRlclJlc3VsdE9iamVjdChlbnRyeS5rZXksIGZhbHNlKTtcbiAgICAgIGlmIChraW5kID09PSAndmFsdWVzJykgcmV0dXJuIGNyZWF0ZUl0ZXJSZXN1bHRPYmplY3QoZW50cnkudmFsdWUsIGZhbHNlKTtcbiAgICAgIHJldHVybiBjcmVhdGVJdGVyUmVzdWx0T2JqZWN0KFtlbnRyeS5rZXksIGVudHJ5LnZhbHVlXSwgZmFsc2UpO1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGB7IE1hcCwgU2V0IH0ucHJvdG90eXBlW0BAc3BlY2llc11gIGFjY2Vzc29yc1xuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtZ2V0LW1hcC1AQHNwZWNpZXNcbiAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC1zZXQtQEBzcGVjaWVzXG4gICAgc2V0U3BlY2llcyhDT05TVFJVQ1RPUl9OQU1FKTtcbiAgfVxufTtcblxudmFyIGNvbGxlY3Rpb24kMiA9IGNvbGxlY3Rpb24kMztcbnZhciBjb2xsZWN0aW9uU3Ryb25nJDEgPSBjb2xsZWN0aW9uU3Ryb25nJDI7XG5cbi8vIGBNYXBgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW1hcC1vYmplY3RzXG5jb2xsZWN0aW9uJDIoJ01hcCcsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7IHJldHVybiBpbml0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpOyB9O1xufSwgY29sbGVjdGlvblN0cm9uZyQxKTtcblxudmFyIHBhdGgkZiA9IHBhdGgkdztcblxudmFyIG1hcCQyID0gcGF0aCRmLk1hcDtcblxudmFyIHBhcmVudCR2ID0gbWFwJDI7XG5cblxudmFyIG1hcCQxID0gcGFyZW50JHY7XG5cbnZhciBtYXAgPSBtYXAkMTtcblxudmFyIF9NYXAgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMobWFwKTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIGNhbiBzdG9yZSBncm91cHMgYW5kIG9wdGlvbnMgc3BlY2lmaWMgZm9yIGdyb3Vwcy5cbiAqL1xudmFyIEdyb3VwcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBHcm91cHMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdyb3Vwcyk7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuX2RlZmF1bHRJbmRleCA9IDA7XG4gICAgdGhpcy5fZ3JvdXBJbmRleCA9IDA7XG4gICAgdGhpcy5fZGVmYXVsdEdyb3VwcyA9IFt7XG4gICAgICBib3JkZXI6IFwiIzJCN0NFOVwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjOTdDMkZDXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiMyQjdDRTlcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRDJFNUZGXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiIzJCN0NFOVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNEMkU1RkZcIlxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gMDogYmx1ZVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjRkZBNTAwXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNGRkZGMDBcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0ZGQTUwMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRkZGQTNcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkZBNTAwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGRkZBM1wiXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyAxOiB5ZWxsb3dcbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0ZBMEExMFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRkI3RTgxXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGQTBBMTBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkZBRkIxXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0ZBMEExMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRkFGQjFcIlxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gMjogcmVkXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiM0MUE5MDZcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzdCRTE0MVwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjNDFBOTA2XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ExRUM3NlwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM0MUE5MDZcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjQTFFQzc2XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIDM6IGdyZWVuXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNFMTI5RjBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0VCN0RGNFwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRTEyOUYwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0YwQjNGNVwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNFMTI5RjBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRjBCM0Y1XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIDQ6IG1hZ2VudGFcbiAgICB7XG4gICAgICBib3JkZXI6IFwiIzdDMjlGMFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjQUQ4NUU0XCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM3QzI5RjBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRDNCREYwXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiIzdDMjlGMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNEM0JERjBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gNTogcHVycGxlXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNDMzdGMDBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0ZGQTgwN1wiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjQzM3RjAwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGQ0E2NlwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNDMzdGMDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkZDQTY2XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIDY6IG9yYW5nZVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjNDIyMEZCXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiM2RTZFRkRcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiIzQyMjBGQlwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM5QjlCRkRcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjNDIyMEZCXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzlCOUJGRFwiXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyA3OiBkYXJrYmx1ZVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjRkQ1QTc3XCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNGRkMwQ0JcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0ZENUE3N1wiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRkQxRDlcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkQ1QTc3XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGRDFEOVwiXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyA4OiBwaW5rXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiM0QUQ2M0FcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiI0MyRkFCQ1wiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjNEFENjNBXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0U2RkZFM1wiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM0QUQ2M0FcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRTZGRkUzXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIDk6IG1pbnRcblxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjOTkwMDAwXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNFRTAwMDBcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0JCMDAwMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRjMzMzNcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjQkIwMDAwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGMzMzM1wiXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyAxMDpicmlnaHQgcmVkXG5cbiAgICB7XG4gICAgICBib3JkZXI6IFwiI0ZGNjAwMFwiLFxuICAgICAgYmFja2dyb3VuZDogXCIjRkY2MDAwXCIsXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRjYwMDBcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjRkY2MDAwXCJcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBib3JkZXI6IFwiI0ZGNjAwMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRjYwMDBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gMTI6IHJlYWwgb3JhbmdlXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiM5N0MyRkNcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzJCN0NFOVwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRDJFNUZGXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzJCN0NFOVwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNEMkU1RkZcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMkI3Q0U5XCJcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIDEzOiBibHVlXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiMzOTk2MDVcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzI1NUMwM1wiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjMzk5NjA1XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzI1NUMwM1wiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiMzOTk2MDVcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMjU1QzAzXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIDE0OiBncmVlblxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjQjcwMDU0XCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNGRjAwN0VcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0I3MDA1NFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRjAwN0VcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjQjcwMDU0XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZGMDA3RVwiXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyAxNTogbWFnZW50YVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjQUQ4NUU0XCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiM3QzI5RjBcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0QzQkRGMFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM3QzI5RjBcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRDNCREYwXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzdDMjlGMFwiXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyAxNjogcHVycGxlXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiM0NTU3RkFcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzAwMEVBMVwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjNkU2RUZEXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzAwMEVBMVwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiM2RTZFRkRcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjMDAwRUExXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIDE3OiBkYXJrYmx1ZVxuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjRkZDMENCXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiNGRDVBNzdcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0ZGRDFEOVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiNGRDVBNzdcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkZEMUQ5XCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0ZENUE3N1wiXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyAxODogcGlua1xuICAgIHtcbiAgICAgIGJvcmRlcjogXCIjQzJGQUJDXCIsXG4gICAgICBiYWNrZ3JvdW5kOiBcIiM3NEQ2NkFcIixcbiAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICBib3JkZXI6IFwiI0U2RkZFM1wiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM3NEQ2NkFcIlxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogXCIjRTZGRkUzXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiIzc0RDY2QVwiXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyAxOTogbWludFxuXG4gICAge1xuICAgICAgYm9yZGVyOiBcIiNFRTAwMDBcIixcbiAgICAgIGJhY2tncm91bmQ6IFwiIzk5MDAwMFwiLFxuICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgIGJvcmRlcjogXCIjRkYzMzMzXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwiI0JCMDAwMFwiXG4gICAgICB9LFxuICAgICAgaG92ZXI6IHtcbiAgICAgICAgYm9yZGVyOiBcIiNGRjMzMzNcIixcbiAgICAgICAgYmFja2dyb3VuZDogXCIjQkIwMDAwXCJcbiAgICAgIH1cbiAgICB9IC8vIDIwOmJyaWdodCByZWRcbiAgICBdO1xuXG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIHVzZURlZmF1bHRHcm91cHM6IHRydWVcbiAgICB9O1xuICAgIF9PYmplY3QkYXNzaWduKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhHcm91cHMsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgb3B0aW9uRmllbGRzID0gW1widXNlRGVmYXVsdEdyb3Vwc1wiXTtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgZ3JvdXBOYW1lIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIGdyb3VwTmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkob3B0aW9uRmllbGRzKS5jYWxsKG9wdGlvbkZpZWxkcywgZ3JvdXBOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgdmFyIGdyb3VwID0gb3B0aW9uc1tncm91cE5hbWVdO1xuICAgICAgICAgICAgICB0aGlzLmFkZChncm91cE5hbWUsIGdyb3VwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgZ3JvdXBzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLl9ncm91cHMgPSBuZXcgX01hcCgpO1xuICAgICAgdGhpcy5fZ3JvdXBOYW1lcyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBncm91cCBvcHRpb25zIG9mIGEgZ3JvdXBuYW1lLlxuICAgICAqIElmIGdyb3VwbmFtZSBpcyBub3QgZm91bmQsIGEgbmV3IGdyb3VwIG1heSBiZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSAgICAgICBncm91cG5hbWUgICAgIENhbiBiZSBhIG51bWJlciwgc3RyaW5nLCBEYXRlLCBldGMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2hvdWxkQ3JlYXRlPXRydWVdIElmIHRydWUsIGNyZWF0ZSBhIG5ldyBncm91cFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBmb3VuZCBvciBjcmVhdGVkIGdyb3VwXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChncm91cG5hbWUpIHtcbiAgICAgIHZhciBzaG91bGRDcmVhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICB2YXIgZ3JvdXAgPSB0aGlzLl9ncm91cHMuZ2V0KGdyb3VwbmFtZSk7XG4gICAgICBpZiAoZ3JvdXAgPT09IHVuZGVmaW5lZCAmJiBzaG91bGRDcmVhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VEZWZhdWx0R3JvdXBzID09PSBmYWxzZSAmJiB0aGlzLl9ncm91cE5hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBjcmVhdGUgbmV3IGdyb3VwXG4gICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fZ3JvdXBJbmRleCAlIHRoaXMuX2dyb3VwTmFtZXMubGVuZ3RoO1xuICAgICAgICAgICsrdGhpcy5fZ3JvdXBJbmRleDtcbiAgICAgICAgICBncm91cCA9IHt9O1xuICAgICAgICAgIGdyb3VwLmNvbG9yID0gdGhpcy5fZ3JvdXBzLmdldCh0aGlzLl9ncm91cE5hbWVzW2luZGV4XSk7XG4gICAgICAgICAgdGhpcy5fZ3JvdXBzLnNldChncm91cG5hbWUsIGdyb3VwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjcmVhdGUgbmV3IGdyb3VwXG4gICAgICAgICAgdmFyIF9pbmRleCA9IHRoaXMuX2RlZmF1bHRJbmRleCAlIHRoaXMuX2RlZmF1bHRHcm91cHMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuX2RlZmF1bHRJbmRleCsrO1xuICAgICAgICAgIGdyb3VwID0ge307XG4gICAgICAgICAgZ3JvdXAuY29sb3IgPSB0aGlzLl9kZWZhdWx0R3JvdXBzW19pbmRleF07XG4gICAgICAgICAgdGhpcy5fZ3JvdXBzLnNldChncm91cG5hbWUsIGdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdyb3VwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBjdXN0b20gZ3JvdXAgc3R5bGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ3JvdXBOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGdyb3VwLCBhIG5ldyBncm91cCB3aWxsIGJlXG4gICAgICogY3JlYXRlZCBpZiBhIGdyb3VwIHdpdGggdGhlIHNhbWUgbmFtZSBkb2Vzbid0IGV4aXN0LCBvdGhlcndpc2UgdGhlIG9sZFxuICAgICAqIGdyb3VwcyBzdHlsZSB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZSAtIEFuIG9iamVjdCBjb250YWluaW5nIGJvcmRlckNvbG9yLCBiYWNrZ3JvdW5kQ29sb3IsXG4gICAgICogZXRjLlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBjcmVhdGVkIGdyb3VwIG9iamVjdC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGdyb3VwTmFtZSwgc3R5bGUpIHtcbiAgICAgIC8vIE9ubHkgcHVzaCBncm91cCBuYW1lIG9uY2UgdG8gcHJldmVudCBkdXBsaWNhdGVzIHdoaWNoIHdvdWxkIGNvbnN1bWUgbW9yZVxuICAgICAgLy8gUkFNIGFuZCBhbHNvIHNrZXcgdGhlIGRpc3RyaWJ1dGlvbiB0b3dhcmRzIG1vcmUgb2Z0ZW4gdXBkYXRlZCBncm91cHMsXG4gICAgICAvLyBuZWl0aGVyIG9mIHdoaWNoIGlzIGRlc2lyYWJsZS5cbiAgICAgIGlmICghdGhpcy5fZ3JvdXBzLmhhcyhncm91cE5hbWUpKSB7XG4gICAgICAgIHRoaXMuX2dyb3VwTmFtZXMucHVzaChncm91cE5hbWUpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZ3JvdXBzLnNldChncm91cE5hbWUsIHN0eWxlKTtcbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEdyb3Vwcztcbn0oKTtcblxudmFyICQkZSA9IF9leHBvcnQ7XG5cbi8vIGBOdW1iZXIuaXNOYU5gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1udW1iZXIuaXNuYW5cbiQkZSh7IHRhcmdldDogJ051bWJlcicsIHN0YXQ6IHRydWUgfSwge1xuICBpc05hTjogZnVuY3Rpb24gaXNOYU4obnVtYmVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICByZXR1cm4gbnVtYmVyICE9PSBudW1iZXI7XG4gIH1cbn0pO1xuXG52YXIgcGF0aCRlID0gcGF0aCR3O1xuXG52YXIgaXNOYW4kMiA9IHBhdGgkZS5OdW1iZXIuaXNOYU47XG5cbnZhciBwYXJlbnQkdSA9IGlzTmFuJDI7XG5cbnZhciBpc05hbiQxID0gcGFyZW50JHU7XG5cbnZhciBpc05hbiA9IGlzTmFuJDE7XG5cbnZhciBfTnVtYmVyJGlzTmFOID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGlzTmFuKTtcblxudmFyIGdsb2JhbCQ0ID0gZ2xvYmFsJG47XG5cbnZhciBnbG9iYWxJc0Zpbml0ZSA9IGdsb2JhbCQ0LmlzRmluaXRlO1xuXG4vLyBgTnVtYmVyLmlzRmluaXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbnVtYmVyLmlzZmluaXRlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tbnVtYmVyLWlzZmluaXRlIC0tIHNhZmVcbnZhciBudW1iZXJJc0Zpbml0ZSQxID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uIGlzRmluaXRlKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ251bWJlcicgJiYgZ2xvYmFsSXNGaW5pdGUoaXQpO1xufTtcblxudmFyICQkZCA9IF9leHBvcnQ7XG52YXIgbnVtYmVySXNGaW5pdGUgPSBudW1iZXJJc0Zpbml0ZSQxO1xuXG4vLyBgTnVtYmVyLmlzRmluaXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbnVtYmVyLmlzZmluaXRlXG4kJGQoeyB0YXJnZXQ6ICdOdW1iZXInLCBzdGF0OiB0cnVlIH0sIHsgaXNGaW5pdGU6IG51bWJlcklzRmluaXRlIH0pO1xuXG52YXIgcGF0aCRkID0gcGF0aCR3O1xuXG52YXIgX2lzRmluaXRlJDIgPSBwYXRoJGQuTnVtYmVyLmlzRmluaXRlO1xuXG52YXIgcGFyZW50JHQgPSBfaXNGaW5pdGUkMjtcblxudmFyIF9pc0Zpbml0ZSQxID0gcGFyZW50JHQ7XG5cbnZhciBfaXNGaW5pdGUgPSBfaXNGaW5pdGUkMTtcblxudmFyIF9OdW1iZXIkaXNGaW5pdGUgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoX2lzRmluaXRlKTtcblxudmFyICQkYyA9IF9leHBvcnQ7XG52YXIgJHNvbWUgPSBhcnJheUl0ZXJhdGlvbi5zb21lO1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QkMyA9IGFycmF5TWV0aG9kSXNTdHJpY3QkNjtcblxudmFyIFNUUklDVF9NRVRIT0QkMiA9IGFycmF5TWV0aG9kSXNTdHJpY3QkMygnc29tZScpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnNvbWVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxuJCRjKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhU1RSSUNUX01FVEhPRCQyIH0sIHtcbiAgc29tZTogZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkc29tZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJDQgPSBlbnRyeVZpcnR1YWwkaTtcblxudmFyIHNvbWUkMyA9IGVudHJ5VmlydHVhbCQ0KCdBcnJheScpLnNvbWU7XG5cbnZhciBpc1Byb3RvdHlwZU9mJDQgPSBvYmplY3RJc1Byb3RvdHlwZU9mO1xudmFyIG1ldGhvZCQ0ID0gc29tZSQzO1xuXG52YXIgQXJyYXlQcm90b3R5cGUkNCA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIHNvbWUkMiA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQuc29tZTtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSQ0IHx8IChpc1Byb3RvdHlwZU9mJDQoQXJyYXlQcm90b3R5cGUkNCwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUkNC5zb21lKSA/IG1ldGhvZCQ0IDogb3duO1xufTtcblxudmFyIHBhcmVudCRzID0gc29tZSQyO1xuXG52YXIgc29tZSQxID0gcGFyZW50JHM7XG5cbnZhciBzb21lID0gc29tZSQxO1xuXG52YXIgX3NvbWVJbnN0YW5jZVByb3BlcnR5ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHNvbWUpO1xuXG52YXIgcGF0aCRjID0gcGF0aCR3O1xuXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzJDIgPSBwYXRoJGMuT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxudmFyIHBhcmVudCRyID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzJDI7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMkMSA9IHBhcmVudCRyO1xuXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzJDE7XG5cbnZhciBfT2JqZWN0JGdldE93blByb3BlcnR5U3ltYm9scyA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpO1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDYgPSB7ZXhwb3J0czoge319O1xuXG52YXIgJCRiID0gX2V4cG9ydDtcbnZhciBmYWlscyQ1ID0gZmFpbHMkdztcbnZhciB0b0luZGV4ZWRPYmplY3QkMSA9IHRvSW5kZXhlZE9iamVjdCRhO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IG9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvci5mO1xudmFyIERFU0NSSVBUT1JTJDIgPSBkZXNjcmlwdG9ycztcblxudmFyIEZPUkNFRCQ1ID0gIURFU0NSSVBUT1JTJDIgfHwgZmFpbHMkNShmdW5jdGlvbiAoKSB7IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcigxKTsgfSk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxuJCRiKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQkNSwgc2hhbTogIURFU0NSSVBUT1JTJDIgfSwge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgcmV0dXJuIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcih0b0luZGV4ZWRPYmplY3QkMShpdCksIGtleSk7XG4gIH1cbn0pO1xuXG52YXIgcGF0aCRiID0gcGF0aCR3O1xuXG52YXIgT2JqZWN0JDMgPSBwYXRoJGIuT2JqZWN0O1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDUgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNi5leHBvcnRzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdCQzLmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KTtcbn07XG5cbmlmIChPYmplY3QkMy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iuc2hhbSkgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDUuc2hhbSA9IHRydWU7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JFeHBvcnRzID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDYuZXhwb3J0cztcblxudmFyIHBhcmVudCRxID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yRXhwb3J0cztcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ0ID0gcGFyZW50JHE7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQ0O1xuXG52YXIgX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMyk7XG5cbnZhciAkJGEgPSBfZXhwb3J0O1xudmFyIERFU0NSSVBUT1JTJDEgPSBkZXNjcmlwdG9ycztcbnZhciBvd25LZXlzJDQgPSBvd25LZXlzJDU7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gdG9JbmRleGVkT2JqZWN0JGE7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlJDEgPSBvYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgY3JlYXRlUHJvcGVydHkgPSBjcmVhdGVQcm9wZXJ0eSQ2O1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yc1xuJCRhKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgc2hhbTogIURFU0NSSVBUT1JTJDEgfSwge1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iamVjdCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XG4gICAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSQxLmY7XG4gICAgdmFyIGtleXMgPSBvd25LZXlzJDQoTyk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGtleSwgZGVzY3JpcHRvcjtcbiAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpbmRleCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBrZXkgPSBrZXlzW2luZGV4KytdKTtcbiAgICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG5cbnZhciBwYXRoJGEgPSBwYXRoJHc7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzJDIgPSBwYXRoJGEuT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XG5cbnZhciBwYXJlbnQkcCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMkMjtcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMkMSA9IHBhcmVudCRwO1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMkMTtcblxudmFyIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKTtcblxudmFyIGRlZmluZVByb3BlcnRpZXMkNCA9IHtleHBvcnRzOiB7fX07XG5cbnZhciAkJDkgPSBfZXhwb3J0O1xudmFyIERFU0NSSVBUT1JTID0gZGVzY3JpcHRvcnM7XG52YXIgZGVmaW5lUHJvcGVydGllcyQzID0gb2JqZWN0RGVmaW5lUHJvcGVydGllcy5mO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnRpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0aWVzIC0tIHNhZmVcbiQkOSh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgIT09IGRlZmluZVByb3BlcnRpZXMkMywgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgZGVmaW5lUHJvcGVydGllczogZGVmaW5lUHJvcGVydGllcyQzXG59KTtcblxudmFyIHBhdGgkOSA9IHBhdGgkdztcblxudmFyIE9iamVjdCQyID0gcGF0aCQ5Lk9iamVjdDtcblxudmFyIGRlZmluZVByb3BlcnRpZXMkMiA9IGRlZmluZVByb3BlcnRpZXMkNC5leHBvcnRzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhULCBEKSB7XG4gIHJldHVybiBPYmplY3QkMi5kZWZpbmVQcm9wZXJ0aWVzKFQsIEQpO1xufTtcblxuaWYgKE9iamVjdCQyLmRlZmluZVByb3BlcnRpZXMuc2hhbSkgZGVmaW5lUHJvcGVydGllcyQyLnNoYW0gPSB0cnVlO1xuXG52YXIgZGVmaW5lUHJvcGVydGllc0V4cG9ydHMgPSBkZWZpbmVQcm9wZXJ0aWVzJDQuZXhwb3J0cztcblxudmFyIHBhcmVudCRvID0gZGVmaW5lUHJvcGVydGllc0V4cG9ydHM7XG5cbnZhciBkZWZpbmVQcm9wZXJ0aWVzJDEgPSBwYXJlbnQkbztcblxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBkZWZpbmVQcm9wZXJ0aWVzJDE7XG5cbnZhciBfT2JqZWN0JGRlZmluZVByb3BlcnRpZXMgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZGVmaW5lUHJvcGVydGllcyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5JDk7XG5cbnZhciBfT2JqZWN0JGRlZmluZVByb3BlcnR5ID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGRlZmluZVByb3BlcnR5KTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpO1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIF9PYmplY3QkZGVmaW5lUHJvcGVydHkkMShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG52YXIgZ2xvYmFsJDMgPSBnbG9iYWwkbjtcbnZhciBmYWlscyQ0ID0gZmFpbHMkdztcbnZhciB1bmN1cnJ5VGhpcyQzID0gZnVuY3Rpb25VbmN1cnJ5VGhpcztcbnZhciB0b1N0cmluZyQxID0gdG9TdHJpbmckYTtcbnZhciB0cmltID0gc3RyaW5nVHJpbS50cmltO1xudmFyIHdoaXRlc3BhY2VzID0gd2hpdGVzcGFjZXMkMztcblxudmFyIGNoYXJBdCA9IHVuY3VycnlUaGlzJDMoJycuY2hhckF0KTtcbnZhciAkcGFyc2VGbG9hdCQxID0gZ2xvYmFsJDMucGFyc2VGbG9hdDtcbnZhciBTeW1ib2wkMSA9IGdsb2JhbCQzLlN5bWJvbDtcbnZhciBJVEVSQVRPUiA9IFN5bWJvbCQxICYmIFN5bWJvbCQxLml0ZXJhdG9yO1xudmFyIEZPUkNFRCQ0ID0gMSAvICRwYXJzZUZsb2F0JDEod2hpdGVzcGFjZXMgKyAnLTAnKSAhPT0gLUluZmluaXR5XG4gIC8vIE1TIEVkZ2UgMTgtIGJyb2tlbiB3aXRoIGJveGVkIHN5bWJvbHNcbiAgfHwgKElURVJBVE9SICYmICFmYWlscyQ0KGZ1bmN0aW9uICgpIHsgJHBhcnNlRmxvYXQkMShPYmplY3QoSVRFUkFUT1IpKTsgfSkpO1xuXG4vLyBgcGFyc2VGbG9hdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXBhcnNlZmxvYXQtc3RyaW5nXG52YXIgbnVtYmVyUGFyc2VGbG9hdCA9IEZPUkNFRCQ0ID8gZnVuY3Rpb24gcGFyc2VGbG9hdChzdHJpbmcpIHtcbiAgdmFyIHRyaW1tZWRTdHJpbmcgPSB0cmltKHRvU3RyaW5nJDEoc3RyaW5nKSk7XG4gIHZhciByZXN1bHQgPSAkcGFyc2VGbG9hdCQxKHRyaW1tZWRTdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIGNoYXJBdCh0cmltbWVkU3RyaW5nLCAwKSA9PT0gJy0nID8gLTAgOiByZXN1bHQ7XG59IDogJHBhcnNlRmxvYXQkMTtcblxudmFyICQkOCA9IF9leHBvcnQ7XG52YXIgJHBhcnNlRmxvYXQgPSBudW1iZXJQYXJzZUZsb2F0O1xuXG4vLyBgcGFyc2VGbG9hdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXBhcnNlZmxvYXQtc3RyaW5nXG4kJDgoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogcGFyc2VGbG9hdCAhPT0gJHBhcnNlRmxvYXQgfSwge1xuICBwYXJzZUZsb2F0OiAkcGFyc2VGbG9hdFxufSk7XG5cbnZhciBwYXRoJDggPSBwYXRoJHc7XG5cbnZhciBfcGFyc2VGbG9hdCQzID0gcGF0aCQ4LnBhcnNlRmxvYXQ7XG5cbnZhciBwYXJlbnQkbiA9IF9wYXJzZUZsb2F0JDM7XG5cbnZhciBfcGFyc2VGbG9hdCQyID0gcGFyZW50JG47XG5cbnZhciBfcGFyc2VGbG9hdCA9IF9wYXJzZUZsb2F0JDI7XG5cbnZhciBfcGFyc2VGbG9hdCQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKF9wYXJzZUZsb2F0KTtcblxudmFyICQkNyA9IF9leHBvcnQ7XG52YXIgZmFpbHMkMyA9IGZhaWxzJHc7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyQzID0gb2JqZWN0R2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsLmY7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSBmYWlscyQzKGZ1bmN0aW9uICgpIHsgcmV0dXJuICFPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygxKTsgfSk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4kJDcoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMgfSwge1xuICBnZXRPd25Qcm9wZXJ0eU5hbWVzOiBnZXRPd25Qcm9wZXJ0eU5hbWVzJDNcbn0pO1xuXG52YXIgcGF0aCQ3ID0gcGF0aCR3O1xuXG52YXIgT2JqZWN0JDEgPSBwYXRoJDcuT2JqZWN0O1xuXG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyQyID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gT2JqZWN0JDEuZ2V0T3duUHJvcGVydHlOYW1lcyhpdCk7XG59O1xuXG52YXIgcGFyZW50JG0gPSBnZXRPd25Qcm9wZXJ0eU5hbWVzJDI7XG5cbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzJDEgPSBwYXJlbnQkbTtcblxudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzJDE7XG5cbnZhciBfT2JqZWN0JGdldE93blByb3BlcnR5TmFtZXMgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZ2V0T3duUHJvcGVydHlOYW1lcyk7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgY29tcG9uZW50c1xuICovXG5cbi8qKlxuICogRGV0ZXJtaW5lIHZhbHVlcyB0byB1c2UgZm9yIChzdWIpb3B0aW9ucyBvZiAnY2hvc2VuJy5cbiAqXG4gKiBUaGlzIG9wdGlvbiBpcyBlaXRoZXIgYSBib29sZWFuIG9yIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgc2hvdWxkIGJlIGV4YW1pbmVkIGZ1cnRoZXIuXG4gKiBUaGUgcmVsZXZhbnQgc3RydWN0dXJlcyBhcmU6XG4gKlxuICogLSBjaG9zZW46IDxib29sZWFuIHZhbHVlPlxuICogLSBjaG9zZW46IHsgc3ViT3B0aW9uOiA8Ym9vbGVhbiBvciBmdW5jdGlvbj4gfVxuICpcbiAqIFdoZXJlIHN1Yk9wdGlvbiBpcyAnbm9kZScsICdlZGdlJyBvciAnbGFiZWwnLlxuICpcbiAqIFRoZSBpbnRlbnRpb24gb2YgdGhpcyBtZXRob2QgYXBwZWFycyB0byBiZSB0byBzZXQgYSBzcGVjaWZpYyBwcmlvcml0eSB0byB0aGUgb3B0aW9ucztcbiAqIFNpbmNlIG1vc3QgcHJvcGVydGllcyBhcmUgZWl0aGVyIGJyaWRnZWQgb3IgbWVyZ2VkIGludG8gdGhlIGxvY2FsIG9wdGlvbnMgb2JqZWN0cywgdGhlcmVcbiAqIGlzIG5vdCBtdWNoIHBvaW50IGluIGhhbmRsaW5nIHRoZW0gc2VwYXJhdGVseS5cbiAqIFRPRE86IGV4YW1pbmUgaWYgJ21vc3QnIGluIHByZXZpb3VzIHNlbnRlbmNlIGNhbiBiZSByZXBsYWNlZCB3aXRoICdhbGwnLiBJbiB0aGF0IGNhc2UsIHdlXG4gKiAgICAgICBzaG91bGQgYmUgYWJsZSB0byBnZXQgcmlkIG9mIHRoaXMgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSAgc3ViT3B0aW9uICBvcHRpb24gd2l0aGluIG9iamVjdCAnY2hvc2VuJyB0byBjb25zaWRlcjsgZWl0aGVyICdub2RlJywgJ2VkZ2UnIG9yICdsYWJlbCdcbiAqIEBwYXJhbSB7b2JqZWN0fSAgcGlsZSAgICAgICBhcnJheSBvZiBvcHRpb25zIG9iamVjdHMgdG8gY29uc2lkZXJcbiAqIEByZXR1cm5zIHtib29sZWFuIHwgRnVuY3Rpb259ICB2YWx1ZSBmb3IgcGFzc2VkIHN1Yk9wdGlvbiBvZiAnY2hvc2VuJyB0byB1c2VcbiAqL1xuZnVuY3Rpb24gY2hvb3NpZnkoc3ViT3B0aW9uLCBwaWxlKSB7XG4gIC8vIGFsbG93ZWQgdmFsdWVzIGZvciBzdWJPcHRpb25cbiAgdmFyIGFsbG93ZWQgPSBbXCJub2RlXCIsIFwiZWRnZVwiLCBcImxhYmVsXCJdO1xuICB2YXIgdmFsdWUgPSB0cnVlO1xuICB2YXIgY2hvc2VuID0gdG9wTW9zdChwaWxlLCBcImNob3NlblwiKTtcbiAgaWYgKHR5cGVvZiBjaG9zZW4gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgdmFsdWUgPSBjaG9zZW47XG4gIH0gZWxzZSBpZiAoX3R5cGVvZihjaG9zZW4pID09PSBcIm9iamVjdFwiKSB7XG4gICAgaWYgKF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eShhbGxvd2VkKS5jYWxsKGFsbG93ZWQsIHN1Yk9wdGlvbikgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjaG9vc2lmeTogc3ViT3B0aW9uICdcIiArIHN1Yk9wdGlvbiArIFwiJyBzaG91bGQgYmUgb25lIG9mIFwiICsgXCInXCIgKyBhbGxvd2VkLmpvaW4oXCInLCAnXCIpICsgXCInXCIpO1xuICAgIH1cbiAgICB2YXIgY2hvc2VuRWRnZSA9IHRvcE1vc3QocGlsZSwgW1wiY2hvc2VuXCIsIHN1Yk9wdGlvbl0pO1xuICAgIGlmICh0eXBlb2YgY2hvc2VuRWRnZSA9PT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIGNob3NlbkVkZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdmFsdWUgPSBjaG9zZW5FZGdlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHBvaW50IGZhbGxzIHdpdGhpbiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuICpcbiAqIEBwYXJhbSB7cmVjdH0gcmVjdFxuICogQHBhcmFtIHtwb2ludH0gcG9pbnRcbiAqIEBwYXJhbSB7cm90YXRpb25Qb2ludH0gW3JvdGF0aW9uUG9pbnRdIGlmIHNwZWNpZmllZCwgdGhlIHJvdGF0aW9uIHRoYXQgYXBwbGllcyB0byB0aGUgcmVjdGFuZ2xlLlxuICogQHJldHVybnMge2Jvb2xlYW59ICB0cnVlIGlmIHBvaW50IHdpdGhpbiByZWN0YW5nbGUsIGZhbHNlIG90aGVyd2lzZVxuICovXG5mdW5jdGlvbiBwb2ludEluUmVjdChyZWN0LCBwb2ludCwgcm90YXRpb25Qb2ludCkge1xuICBpZiAocmVjdC53aWR0aCA8PSAwIHx8IHJlY3QuaGVpZ2h0IDw9IDApIHtcbiAgICByZXR1cm4gZmFsc2U7IC8vIGVhcmx5IG91dFxuICB9XG5cbiAgaWYgKHJvdGF0aW9uUG9pbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFJvdGF0ZSB0aGUgcG9pbnQgdGhlIHNhbWUgYW1vdW50IGFzIHRoZSByZWN0YW5nbGVcbiAgICB2YXIgdG1wID0ge1xuICAgICAgeDogcG9pbnQueCAtIHJvdGF0aW9uUG9pbnQueCxcbiAgICAgIHk6IHBvaW50LnkgLSByb3RhdGlvblBvaW50LnlcbiAgICB9O1xuICAgIGlmIChyb3RhdGlvblBvaW50LmFuZ2xlICE9PSAwKSB7XG4gICAgICAvLyBJbiBvcmRlciB0byBnZXQgdGhlIGNvb3JkaW5hdGVzIHRoZSBzYW1lLCB5b3UgbmVlZCB0b1xuICAgICAgLy8gcm90YXRlIGluIHRoZSByZXZlcnNlIGRpcmVjdGlvblxuICAgICAgdmFyIGFuZ2xlID0gLXJvdGF0aW9uUG9pbnQuYW5nbGU7XG4gICAgICB2YXIgdG1wMiA9IHtcbiAgICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogdG1wLnggLSBNYXRoLnNpbihhbmdsZSkgKiB0bXAueSxcbiAgICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogdG1wLnggKyBNYXRoLmNvcyhhbmdsZSkgKiB0bXAueVxuICAgICAgfTtcbiAgICAgIHBvaW50ID0gdG1wMjtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnQgPSB0bXA7XG4gICAgfVxuXG4gICAgLy8gTm90ZSB0aGF0IGlmIGEgcm90YXRpb24gaXMgc3BlY2lmaWVkLCB0aGUgcmVjdGFuZ2xlIGNvb3JkaW5hdGVzXG4gICAgLy8gYXJlICoqbm90KiB0aGUgZnVsbCBjYW52YXMgY29vcmRpbmF0ZXMuIFRoZXkgYXJlIHJlbGF0aXZlIHRvIHRoZVxuICAgIC8vIHJvdGF0aW9uUG9pbnQuIEhlbmNlLCB0aGUgcG9pbnQgY29vcmRpbmF0ZXMgbmVlZCBub3QgYmUgdHJhbnNsYXRlZFxuICAgIC8vIGJhY2sgaW4gdGhpcyBjYXNlLlxuICB9XG5cbiAgdmFyIHJpZ2h0ID0gcmVjdC54ICsgcmVjdC53aWR0aDtcbiAgdmFyIGJvdHRvbSA9IHJlY3QueSArIHJlY3Qud2lkdGg7XG4gIHJldHVybiByZWN0LmxlZnQgPCBwb2ludC54ICYmIHJpZ2h0ID4gcG9pbnQueCAmJiByZWN0LnRvcCA8IHBvaW50LnkgJiYgYm90dG9tID4gcG9pbnQueTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBnaXZlbiB2YWx1ZSBpcyBhY2NlcHRhYmxlIGFzIGEgbGFiZWwgdGV4dC5cbiAqXG4gKiBAcGFyYW0geyp9IHRleHQgdmFsdWUgdG8gY2hlY2s7IGNhbiBiZSBhbnl0aGluZyBhdCB0aGlzIHBvaW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB2YWxpZCBsYWJlbCB2YWx1ZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRMYWJlbCh0ZXh0KSB7XG4gIC8vIE5vdGUgdGhhdCB0aGlzIGlzIHF1aXRlIHN0cmljdDogdHlwZXMgdGhhdCAqbWlnaHQqIGJlIGNvbnZlcnRlZCB0byBzdHJpbmcgYXJlIGRpc2FsbG93ZWRcbiAgcmV0dXJuIHR5cGVvZiB0ZXh0ID09PSBcInN0cmluZ1wiICYmIHRleHQgIT09IFwiXCI7XG59XG5cbi8qKlxuICogUmV0dXJucyB4LCB5IG9mIHNlbGYgcmVmZXJlbmNlIGNpcmNsZSBiYXNlZCBvbiBwcm92aWRlZCBhbmdsZVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjdHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1c1xuICogQHBhcmFtIHtWaXNOb2RlfSBub2RlXG4gKiBAcmV0dXJucyB7b2JqZWN0fSB4IGFuZCB5IGNvb3JkaW5hdGVzXG4gKi9cbmZ1bmN0aW9uIGdldFNlbGZSZWZDb29yZGluYXRlcyhjdHgsIGFuZ2xlLCByYWRpdXMsIG5vZGUpIHtcbiAgdmFyIHggPSBub2RlLng7XG4gIHZhciB5ID0gbm9kZS55O1xuICBpZiAodHlwZW9mIG5vZGUuZGlzdGFuY2VUb0JvcmRlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgLy9jYWxjdWxhdGluZyBvcHBvc2l0ZSBhbmQgYWRqYWNlbnRcbiAgICAvL2Rpc3RhbmVUb0JvcmRlciBiZWNvbWVzIEh5cG90ZW51c2UuXG4gICAgLy9Gb3JtdWxhcyBzaW4oYSkgPSBPcHBvc2l0ZSAvIEh5cG90ZW51c2UgYW5kIGNvcyhhKSA9IEFkamFjZW50IC8gSHlwb3RlbnVzZVxuICAgIHZhciB0b0JvcmRlckRpc3QgPSBub2RlLmRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgdmFyIHlGcm9tTm9kZUNlbnRlciA9IE1hdGguc2luKGFuZ2xlKSAqIHRvQm9yZGVyRGlzdDtcbiAgICB2YXIgeEZyb21Ob2RlQ2VudGVyID0gTWF0aC5jb3MoYW5nbGUpICogdG9Cb3JkZXJEaXN0O1xuICAgIC8veEZyb21Ob2RlQ2VudGVyIGlzIGJhc2ljYWxseSB4IGFuZCBpZiB4RnJvbU5vZGVDZW50ZXIgZXF1YWxzIHRvIHRoZSBkaXN0YW5jZSB0byBib3JkZXIgdGhlbiBpdCBtZWFuc1xuICAgIC8vdGhhdCB5IGRvZXMgbm90IG5lZWQgY2FsY3VsYXRpb24gYmVjYXVzZSBpdCBpcyBlcXVhbCBub2RlLmhlaWdodCAvIDIgb3Igbm9kZS55XG4gICAgLy9zYW1lIHRoaW5nIHdpdGggeUZyb21Ob2RlQ2VudGVyIGFuZCBpZiB5RnJvbU5vZGVDZW50ZXIgZXF1YWxzIHRvIHRoZSBkaXN0YW5jZSB0byBib3JkZXIgdGhlbiBpdCBtZWFuc1xuICAgIC8vdGhhdCB4IGlzIGVxdWFsIG5vZGUud2lkdGggLyAyIG9yIG5vZGUueFxuICAgIGlmICh4RnJvbU5vZGVDZW50ZXIgPT09IHRvQm9yZGVyRGlzdCkge1xuICAgICAgeCArPSB0b0JvcmRlckRpc3Q7XG4gICAgICB5ID0gbm9kZS55O1xuICAgIH0gZWxzZSBpZiAoeUZyb21Ob2RlQ2VudGVyID09PSB0b0JvcmRlckRpc3QpIHtcbiAgICAgIHggPSBub2RlLng7XG4gICAgICB5IC09IHRvQm9yZGVyRGlzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCArPSB4RnJvbU5vZGVDZW50ZXI7XG4gICAgICB5IC09IHlGcm9tTm9kZUNlbnRlcjtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS5zaGFwZS53aWR0aCA+IG5vZGUuc2hhcGUuaGVpZ2h0KSB7XG4gICAgeCA9IG5vZGUueCArIG5vZGUuc2hhcGUud2lkdGggKiAwLjU7XG4gICAgeSA9IG5vZGUueSAtIHJhZGl1cztcbiAgfSBlbHNlIHtcbiAgICB4ID0gbm9kZS54ICsgcmFkaXVzO1xuICAgIHkgPSBub2RlLnkgLSBub2RlLnNoYXBlLmhlaWdodCAqIDAuNTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufVxuXG52YXIgZW50cnlWaXJ0dWFsJDMgPSBlbnRyeVZpcnR1YWwkaTtcblxudmFyIHZhbHVlcyQzID0gZW50cnlWaXJ0dWFsJDMoJ0FycmF5JykudmFsdWVzO1xuXG52YXIgcGFyZW50JGwgPSB2YWx1ZXMkMztcblxudmFyIHZhbHVlcyQyID0gcGFyZW50JGw7XG5cbnZhciBjbGFzc29mJDEgPSBjbGFzc29mJGQ7XG52YXIgaGFzT3duJDIgPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIGlzUHJvdG90eXBlT2YkMyA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJDMgPSB2YWx1ZXMkMjtcblxudmFyIEFycmF5UHJvdG90eXBlJDMgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBET01JdGVyYWJsZXMgPSB7XG4gIERPTVRva2VuTGlzdDogdHJ1ZSxcbiAgTm9kZUxpc3Q6IHRydWVcbn07XG5cbnZhciB2YWx1ZXMkMSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgb3duID0gaXQudmFsdWVzO1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDMgfHwgKGlzUHJvdG90eXBlT2YkMyhBcnJheVByb3RvdHlwZSQzLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQzLnZhbHVlcylcbiAgICB8fCBoYXNPd24kMihET01JdGVyYWJsZXMsIGNsYXNzb2YkMShpdCkpID8gbWV0aG9kJDMgOiBvd247XG59O1xuXG52YXIgdmFsdWVzID0gdmFsdWVzJDE7XG5cbnZhciBfdmFsdWVzSW5zdGFuY2VQcm9wZXJ0eSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyh2YWx1ZXMpO1xuXG4vKipcbiAqIENhbGxiYWNrIHRvIGRldGVybWluZSB0ZXh0IGRpbWVuc2lvbnMsIHVzaW5nIHRoZSBwYXJlbnQgbGFiZWwgc2V0dGluZ3MuXG4gKlxuICogQGNhbGxiYWNrIE1lYXN1cmVUZXh0XG4gKiBAcGFyYW0ge3RleHR9IHRleHRcbiAqIEBwYXJhbSB7dGV4dH0gbW9kXG4gKiBAcmV0dXJucyB7b2JqZWN0fSB7IHdpZHRoLCB2YWx1ZXN9IHdpZHRoIGluIHBpeGVscyBhbmQgZm9udCBhdHRyaWJ1dGVzXG4gKi9cbi8qKlxuICogSGVscGVyIGNsYXNzIGZvciBMYWJlbCB3aGljaCBjb2xsZWN0cyByZXN1bHRzIG9mIHNwbGl0dGluZyBsYWJlbHMgaW50byBsaW5lcyBhbmQgYmxvY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBMYWJlbEFjY3VtdWxhdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7TWVhc3VyZVRleHR9IG1lYXN1cmVUZXh0XG4gICAqL1xuICBmdW5jdGlvbiBMYWJlbEFjY3VtdWxhdG9yKG1lYXN1cmVUZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhYmVsQWNjdW11bGF0b3IpO1xuICAgIHRoaXMubWVhc3VyZVRleHQgPSBtZWFzdXJlVGV4dDtcbiAgICB0aGlzLmN1cnJlbnQgPSAwO1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmxpbmVzID0gW107XG4gIH1cblxuICAvKipcbiAgICogQXBwZW5kIGdpdmVuIHRleHQgdG8gdGhlIGdpdmVuIGxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgbCAgICBpbmRleCBvZiBsaW5lIHRvIGFkZCB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gIHRleHQgc3RyaW5nIHRvIGFwcGVuZCB0byBsaW5lXG4gICAqIEBwYXJhbSB7J2JvbGQnfCdpdGFsJ3wnYm9sZGl0YWwnfCdtb25vJ3wnbm9ybWFsJ30gW21vZD0nbm9ybWFsJ11cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhMYWJlbEFjY3VtdWxhdG9yLCBbe1xuICAgIGtleTogXCJfYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGQobCwgdGV4dCkge1xuICAgICAgdmFyIG1vZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJub3JtYWxcIjtcbiAgICAgIGlmICh0aGlzLmxpbmVzW2xdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5saW5lc1tsXSA9IHtcbiAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgYmxvY2tzOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBXZSBzdGlsbCBuZWVkIHRvIHNldCBhIGJsb2NrIGZvciB1bmRlZmluZWQgYW5kIGVtcHR5IHRleHRzLCBoZW5jZSByZXR1cm4gYXQgdGhpcyBwb2ludFxuICAgICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB3ZSBkb24ndCBrbm93IGF0IHRoaXMgcG9pbnQgaWYgd2UncmUgYXQgdGhlXG4gICAgICAvLyBzdGFydCBvZiBhbiBlbXB0eSBsaW5lIG9yIG5vdC5cbiAgICAgIC8vIFRvIGNvbXBlbnNhdGUsIGVtcHR5IGJsb2NrcyBhcmUgcmVtb3ZlZCBpbiBgZmluYWxpemUoKWAuXG4gICAgICAvL1xuICAgICAgLy8gRW1wdHkgc3RyaW5ncyBzaG91bGQgc3RpbGwgaGF2ZSBhIGhlaWdodFxuICAgICAgdmFyIHRtcFRleHQgPSB0ZXh0O1xuICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCB8fCB0ZXh0ID09PSBcIlwiKSB0bXBUZXh0ID0gXCIgXCI7XG5cbiAgICAgIC8vIERldGVybWluZSB3aWR0aCBhbmQgZ2V0IHRoZSBmb250IHByb3BlcnRpZXNcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLm1lYXN1cmVUZXh0KHRtcFRleHQsIG1vZCk7XG4gICAgICB2YXIgYmxvY2sgPSBfT2JqZWN0JGFzc2lnbih7fSwgX3ZhbHVlc0luc3RhbmNlUHJvcGVydHkocmVzdWx0KSk7XG4gICAgICBibG9jay50ZXh0ID0gdGV4dDtcbiAgICAgIGJsb2NrLndpZHRoID0gcmVzdWx0LndpZHRoO1xuICAgICAgYmxvY2subW9kID0gbW9kO1xuICAgICAgaWYgKHRleHQgPT09IHVuZGVmaW5lZCB8fCB0ZXh0ID09PSBcIlwiKSB7XG4gICAgICAgIGJsb2NrLndpZHRoID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMubGluZXNbbF0uYmxvY2tzLnB1c2goYmxvY2spO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIGxpbmUgd2lkdGguIFdlIG5lZWQgdGhpcyBmb3IgZGV0ZXJtaW5pbmcgaWYgYSBzdHJpbmcgZ29lcyBvdmVyIG1heCB3aWR0aFxuICAgICAgdGhpcy5saW5lc1tsXS53aWR0aCArPSBibG9jay53aWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBpbiBwaXhlbHMgb2YgdGhlIGN1cnJlbnQgbGluZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY3VyV2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VyV2lkdGgoKSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbdGhpcy5jdXJyZW50XTtcbiAgICAgIGlmIChsaW5lID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICAgICAgcmV0dXJuIGxpbmUud2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHRleHQgaW4gYmxvY2sgdG8gY3VycmVudCBsaW5lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSB7J2JvbGQnfCdpdGFsJ3wnYm9sZGl0YWwnfCdtb25vJ3wnbm9ybWFsJ30gW21vZD0nbm9ybWFsJ11cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhcHBlbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXBwZW5kKHRleHQpIHtcbiAgICAgIHZhciBtb2QgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwibm9ybWFsXCI7XG4gICAgICB0aGlzLl9hZGQodGhpcy5jdXJyZW50LCB0ZXh0LCBtb2QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCB0ZXh0IGluIGJsb2NrIHRvIGN1cnJlbnQgbGluZSBhbmQgc3RhcnQgYSBuZXcgbGluZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcGFyYW0geydib2xkJ3wnaXRhbCd8J2JvbGRpdGFsJ3wnbW9ubyd8J25vcm1hbCd9IFttb2Q9J25vcm1hbCddXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibmV3TGluZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZXdMaW5lKHRleHQpIHtcbiAgICAgIHZhciBtb2QgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwibm9ybWFsXCI7XG4gICAgICB0aGlzLl9hZGQodGhpcy5jdXJyZW50LCB0ZXh0LCBtb2QpO1xuICAgICAgdGhpcy5jdXJyZW50Kys7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGFuZCBzZXQgdGhlIGhlaWdodHMgb2YgYWxsIHRoZSBsaW5lcyBjdXJyZW50bHkgY29udGFpbmVkIGluIHRoaXMgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB3aWR0aCBoYXMgYWxyZWFkeSBiZWVuIHNldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGV0ZXJtaW5lTGluZUhlaWdodHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGV0ZXJtaW5lTGluZUhlaWdodHMoKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2tdO1xuXG4gICAgICAgIC8vIExvb2tpbmcgZm9yIG1heCBoZWlnaHQgb2YgYmxvY2tzIGluIGxpbmVcbiAgICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICAgIGlmIChsaW5lLmJsb2NrcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gQ2FuIGhhcHBlbiBpZiB0ZXh0IGNvbnRhaW5zIGUuZy4gJ1xcbiAnXG4gICAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaW5lLmJsb2Nrcy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgdmFyIGJsb2NrID0gbGluZS5ibG9ja3NbbF07XG4gICAgICAgICAgICBpZiAoaGVpZ2h0IDwgYmxvY2suaGVpZ2h0KSB7XG4gICAgICAgICAgICAgIGhlaWdodCA9IGJsb2NrLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGluZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBmdWxsIHNpemUgb2YgdGhlIGxhYmVsIHRleHQsIGFzIGRldGVybWluZWQgYnkgY3VycmVudCBsaW5lcyBhbmQgYmxvY2tzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRldGVybWluZUxhYmVsU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRlcm1pbmVMYWJlbFNpemUoKSB7XG4gICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgdmFyIGhlaWdodCA9IDA7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGluZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2tdO1xuICAgICAgICBpZiAobGluZS53aWR0aCA+IHdpZHRoKSB7XG4gICAgICAgICAgd2lkdGggPSBsaW5lLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGhlaWdodCArPSBsaW5lLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgZW1wdHkgYmxvY2tzIGFuZCBlbXB0eSBsaW5lcyB3ZSBkb24ndCBuZWVkXG4gICAgICpcbiAgICAgKiBUaGlzIG11c3QgYmUgZG9uZSBhZnRlciB0aGUgd2lkdGgvaGVpZ2h0IGRldGVybWluYXRpb24sXG4gICAgICogc28gdGhhdCB0aGVzZSBhcmUgc2V0IHByb3Blcmx5IGZvciBwcm9jZXNzaW5nIGhlcmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXk8TGluZT59IExpbmVzIHdpdGggZW1wdHkgYmxvY2tzIChhbmQgc29tZSBlbXB0eSBsaW5lcykgcmVtb3ZlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRW1wdHlCbG9ja3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRW1wdHlCbG9ja3MoKSB7XG4gICAgICB2YXIgdG1wTGluZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5saW5lcy5sZW5ndGg7IGsrKykge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNba107XG5cbiAgICAgICAgLy8gTm90ZTogYW4gZW1wdHkgbGluZSBpbiBiZXR3ZWVuIHRleHQgaGFzIHdpZHRoIHplcm8gYnV0IGlzIHN0aWxsIHJlbGV2YW50IHRvIGxheW91dC5cbiAgICAgICAgLy8gU28gd2UgY2FuJ3QgdXNlIHdpZHRoIGZvciB0ZXN0aW5nIGVtcHR5IGxpbmUgaGVyZVxuICAgICAgICBpZiAobGluZS5ibG9ja3MubGVuZ3RoID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICAvLyBEaXNjYXJkIGZpbmFsIGVtcHR5IGxpbmUgYWx3YXlzXG4gICAgICAgIGlmIChrID09PSB0aGlzLmxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBpZiAobGluZS53aWR0aCA9PT0gMCkgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRtcExpbmUgPSB7fTtcbiAgICAgICAgX09iamVjdCRhc3NpZ24odG1wTGluZSwgbGluZSk7XG4gICAgICAgIHRtcExpbmUuYmxvY2tzID0gW107XG4gICAgICAgIHZhciBmaXJzdEVtcHR5QmxvY2sgPSB2b2lkIDA7XG4gICAgICAgIHZhciB0bXBCbG9ja3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsaW5lLmJsb2Nrcy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgIHZhciBibG9jayA9IGxpbmUuYmxvY2tzW2xdO1xuICAgICAgICAgIGlmIChibG9jay53aWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgdG1wQmxvY2tzLnB1c2goYmxvY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RFbXB0eUJsb2NrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZmlyc3RFbXB0eUJsb2NrID0gYmxvY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgKnNvbWUqIHRleHQgcHJlc2VudFxuICAgICAgICBpZiAodG1wQmxvY2tzLmxlbmd0aCA9PT0gMCAmJiBmaXJzdEVtcHR5QmxvY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRtcEJsb2Nrcy5wdXNoKGZpcnN0RW1wdHlCbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgdG1wTGluZS5ibG9ja3MgPSB0bXBCbG9ja3M7XG4gICAgICAgIHRtcExpbmVzLnB1c2godG1wTGluZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG1wTGluZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzaXplcyBmb3IgYWxsIGxpbmVzIGFuZCB0aGUgd2hvbGUgdGhpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e3dpZHRoOiAobnVtYmVyfCopLCBoZWlnaHQ6IChudW1iZXJ8KiksIGxpbmVzOiBBcnJheX19XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZmluYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluYWxpemUoKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHRoaXMubGluZXMsIG51bGwsIDIpKTtcblxuICAgICAgdGhpcy5kZXRlcm1pbmVMaW5lSGVpZ2h0cygpO1xuICAgICAgdGhpcy5kZXRlcm1pbmVMYWJlbFNpemUoKTtcbiAgICAgIHZhciB0bXBMaW5lcyA9IHRoaXMucmVtb3ZlRW1wdHlCbG9ja3MoKTtcblxuICAgICAgLy8gUmV0dXJuIGEgc2ltcGxlIGhhc2ggb2JqZWN0IGZvciBmdXJ0aGVyIHByb2Nlc3NpbmcuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgbGluZXM6IHRtcExpbmVzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTGFiZWxBY2N1bXVsYXRvcjtcbn0oKTtcblxuLy8gSGFzaCBvZiBwcmVwYXJlZCByZWdleHAncyBmb3IgdGFnc1xudmFyIHRhZ1BhdHRlcm4gPSB7XG4gIC8vIEhUTUxcbiAgXCI8Yj5cIjogLzxiPi8sXG4gIFwiPGk+XCI6IC88aT4vLFxuICBcIjxjb2RlPlwiOiAvPGNvZGU+LyxcbiAgXCI8L2I+XCI6IC88XFwvYj4vLFxuICBcIjwvaT5cIjogLzxcXC9pPi8sXG4gIFwiPC9jb2RlPlwiOiAvPFxcL2NvZGU+LyxcbiAgLy8gTWFya2Rvd25cbiAgXCIqXCI6IC9cXCovLFxuICAvLyBib2xkXG4gIF86IC9fLyxcbiAgLy8gaXRhbFxuICBcImBcIjogL2AvLFxuICAvLyBtb25vXG4gIGFmdGVyQm9sZDogL1teKl0vLFxuICBhZnRlckl0YWw6IC9bXl9dLyxcbiAgYWZ0ZXJNb25vOiAvW15gXS9cbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGNsYXNzIGZvciBwYXJzaW5nIHRoZSBtYXJrdXAgdGFncyBmb3IgSFRNTCBhbmQgTWFya2Rvd24uXG4gKlxuICogTk9URTogU2VxdWVuY2VzIG9mIHRhYnMgYW5kIHNwYWNlcyBhcmUgcmVkdWNlZCB0byBzaW5nbGUgc3BhY2UuXG4gKiAgICAgICBTY2FuIHVzYWdlIG9mIGB0aGlzLnNwYWNpbmdgIHdpdGhpbiBtZXRob2RcbiAqL1xudmFyIE1hcmt1cEFjY3VtdWxhdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBpbnN0YW5jZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAgdGV4dCB0byBwYXJzZSBmb3IgbWFya3VwXG4gICAqL1xuICBmdW5jdGlvbiBNYXJrdXBBY2N1bXVsYXRvcih0ZXh0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hcmt1cEFjY3VtdWxhdG9yKTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuYm9sZCA9IGZhbHNlO1xuICAgIHRoaXMuaXRhbCA9IGZhbHNlO1xuICAgIHRoaXMubW9ubyA9IGZhbHNlO1xuICAgIHRoaXMuc3BhY2luZyA9IGZhbHNlO1xuICAgIHRoaXMucG9zaXRpb24gPSAwO1xuICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICB0aGlzLm1vZFN0YWNrID0gW107XG4gICAgdGhpcy5ibG9ja3MgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1vZCBsYWJlbCBjdXJyZW50bHkgb24gdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ30gIGxhYmVsIG9mIHRvcG1vc3QgbW9kXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoTWFya3VwQWNjdW11bGF0b3IsIFt7XG4gICAga2V5OiBcIm1vZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb2QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2RTdGFjay5sZW5ndGggPT09IDAgPyBcIm5vcm1hbFwiIDogdGhpcy5tb2RTdGFja1swXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG1vZCBsYWJlbCBjdXJyZW50bHkgYWN0aXZlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSAgbGFiZWwgb2YgYWN0aXZlIG1vZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibW9kTmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb2ROYW1lKCkge1xuICAgICAgaWYgKHRoaXMubW9kU3RhY2subGVuZ3RoID09PSAwKSByZXR1cm4gXCJub3JtYWxcIjtlbHNlIGlmICh0aGlzLm1vZFN0YWNrWzBdID09PSBcIm1vbm9cIikgcmV0dXJuIFwibW9ub1wiO2Vsc2Uge1xuICAgICAgICBpZiAodGhpcy5ib2xkICYmIHRoaXMuaXRhbCkge1xuICAgICAgICAgIHJldHVybiBcImJvbGRpdGFsXCI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5ib2xkKSB7XG4gICAgICAgICAgcmV0dXJuIFwiYm9sZFwiO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXRhbCkge1xuICAgICAgICAgIHJldHVybiBcIml0YWxcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZW1pdEJsb2NrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXRCbG9jaygpIHtcbiAgICAgIGlmICh0aGlzLnNwYWNpbmcpIHtcbiAgICAgICAgdGhpcy5hZGQoXCIgXCIpO1xuICAgICAgICB0aGlzLnNwYWNpbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuYmxvY2tzLnB1c2goe1xuICAgICAgICAgIHRleHQ6IHRoaXMuYnVmZmVyLFxuICAgICAgICAgIG1vZDogdGhpcy5tb2ROYW1lKClcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gXCJcIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdXRwdXQgdGV4dCB0byBidWZmZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0ICB0ZXh0IHRvIGFkZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCh0ZXh0KSB7XG4gICAgICBpZiAodGV4dCA9PT0gXCIgXCIpIHtcbiAgICAgICAgdGhpcy5zcGFjaW5nID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNwYWNpbmcpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgKz0gXCIgXCI7XG4gICAgICAgIHRoaXMuc3BhY2luZyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQgIT0gXCIgXCIpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgKz0gdGV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcGFyc2luZyBvZiB3aGl0ZXNwYWNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2ggIHRoZSBjaGFyYWN0ZXIgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIHdhcyBwcm9jZXNzZWQgYXMgd2hpdGVzcGFjZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicGFyc2VXU1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVdTKGNoKSB7XG4gICAgICBpZiAoL1sgXFx0XS8udGVzdChjaCkpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1vbm8pIHtcbiAgICAgICAgICB0aGlzLnNwYWNpbmcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYWRkKGNoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSAgbGFiZWwgZm9yIGJsb2NrIHR5cGUgdG8gc2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGFnKHRhZ05hbWUpIHtcbiAgICAgIHRoaXMuZW1pdEJsb2NrKCk7XG4gICAgICB0aGlzW3RhZ05hbWVdID0gdHJ1ZTtcbiAgICAgIHRoaXMubW9kU3RhY2sudW5zaGlmdCh0YWdOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSAgbGFiZWwgZm9yIGJsb2NrIHR5cGUgdG8gdW5zZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVuc2V0VGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2V0VGFnKHRhZ05hbWUpIHtcbiAgICAgIHRoaXMuZW1pdEJsb2NrKCk7XG4gICAgICB0aGlzW3RhZ05hbWVdID0gZmFsc2U7XG4gICAgICB0aGlzLm1vZFN0YWNrLnNoaWZ0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgbGFiZWwgZm9yIGJsb2NrIHR5cGUgd2UgYXJlIGN1cnJlbnRseSBwcm9jZXNzaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSB0YWcgc3RyaW5nIHRvIG1hdGNoIGluIHRleHRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdGFnIHdhcyBwcm9jZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInBhcnNlU3RhcnRUYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VTdGFydFRhZyh0YWdOYW1lLCB0YWcpIHtcbiAgICAgIC8vIE5vdGU6IGlmICdtb25vJyBwYXNzZWQgYXMgdGFnTmFtZSwgdGhlcmUgaXMgYSBkb3VibGUgY2hlY2sgaGVyZS4gVGhpcyBpcyBPS1xuICAgICAgaWYgKCF0aGlzLm1vbm8gJiYgIXRoaXNbdGFnTmFtZV0gJiYgdGhpcy5tYXRjaCh0YWcpKSB7XG4gICAgICAgIHRoaXMuc2V0VGFnKHRhZ05hbWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IHRhZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYWR2YW5jZT10cnVlXSBpZiBzZXQsIGFkdmFuY2UgY3VycmVudCBwb3NpdGlvbiBpbiB0ZXh0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgbWF0Y2ggYXQgZ2l2ZW4gcG9zaXRpb24sIGZhbHNlIG90aGVyd2lzZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibWF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF0Y2godGFnKSB7XG4gICAgICB2YXIgYWR2YW5jZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHZhciBfdGhpcyRwcmVwYXJlUmVnRXhwID0gdGhpcy5wcmVwYXJlUmVnRXhwKHRhZyksXG4gICAgICAgIF90aGlzJHByZXBhcmVSZWdFeHAyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkcHJlcGFyZVJlZ0V4cCwgMiksXG4gICAgICAgIHJlZ0V4cCA9IF90aGlzJHByZXBhcmVSZWdFeHAyWzBdLFxuICAgICAgICBsZW5ndGggPSBfdGhpcyRwcmVwYXJlUmVnRXhwMlsxXTtcbiAgICAgIHZhciBtYXRjaGVkID0gcmVnRXhwLnRlc3QodGhpcy50ZXh0LnN1YnN0cih0aGlzLnBvc2l0aW9uLCBsZW5ndGgpKTtcbiAgICAgIGlmIChtYXRjaGVkICYmIGFkdmFuY2UpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBsZW5ndGggLSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgbGFiZWwgZm9yIGJsb2NrIHR5cGUgd2UgYXJlIGN1cnJlbnRseSBwcm9jZXNzaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSB0YWcgc3RyaW5nIHRvIG1hdGNoIGluIHRleHRcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW25leHRUYWddIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBmb3IgY2hhcmFjdGVycyAqZm9sbG93aW5nKiB0aGUgY3VycmVudCB0YWdcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdGFnIHdhcyBwcm9jZXNzZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInBhcnNlRW5kVGFnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlRW5kVGFnKHRhZ05hbWUsIHRhZywgbmV4dFRhZykge1xuICAgICAgdmFyIGNoZWNrVGFnID0gdGhpcy5tb2QoKSA9PT0gdGFnTmFtZTtcbiAgICAgIGlmICh0YWdOYW1lID09PSBcIm1vbm9cIikge1xuICAgICAgICAvLyBzcGVjaWFsIGhhbmRsaW5nIGZvciAnbW9ubydcbiAgICAgICAgY2hlY2tUYWcgPSBjaGVja1RhZyAmJiB0aGlzLm1vbm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVja1RhZyA9IGNoZWNrVGFnICYmICF0aGlzLm1vbm87XG4gICAgICB9XG4gICAgICBpZiAoY2hlY2tUYWcgJiYgdGhpcy5tYXRjaCh0YWcpKSB7XG4gICAgICAgIGlmIChuZXh0VGFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBQdXJwb3NlIG9mIHRoZSBmb2xsb3dpbmcgbWF0Y2ggaXMgdG8gcHJldmVudCBhIGRpcmVjdCB1bnNldC9zZXQgb2YgYSBnaXZlbiB0YWdcbiAgICAgICAgICAvLyBFLmcuICcqYm9sZCAqKnN0aWxsIGJvbGQqJyA9PiAnKmJvbGQgc3RpbGwgYm9sZConXG4gICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT09IHRoaXMudGV4dC5sZW5ndGggLSAxIHx8IHRoaXMubWF0Y2gobmV4dFRhZywgZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLnVuc2V0VGFnKHRhZ05hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnVuc2V0VGFnKHRhZ05hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gdGFnICBzdHJpbmcgdG8gbWF0Y2ggaW4gdGV4dFxuICAgICAqIEBwYXJhbSB7dmFsdWV9IHZhbHVlICBzdHJpbmcgdG8gcmVwbGFjZSB0YWcgd2l0aCwgaWYgZm91bmQgYXQgY3VycmVudCBwb3NpdGlvblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0YWcgd2FzIHByb2Nlc3NlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVwbGFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlKHRhZywgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKHRhZykpIHtcbiAgICAgICAgdGhpcy5hZGQodmFsdWUpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgdGhlIHRhZyBpZiBpdCBpc24ndCBhbHJlYWR5IG9uZS5cbiAgICAgKlxuICAgICAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gYXJyYXkgYFtSZWdFeHAsIG51bWJlcl1gLCB3aXRoIGV4YWN0bHkgdHdvIHZhbHVlLCB3aGVyZTpcbiAgICAgKiAgLSBSZWdFeHAgaXMgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB1c2VcbiAgICAgKiAgLSBudW1iZXIgaXMgdGhlIGxlbnRoIG9mIHRoZSBpbnB1dCBzdHJpbmcgdG8gbWF0Y2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gdGFnICBzdHJpbmcgdG8gbWF0Y2ggaW4gdGV4dFxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byB1c2UgYW5kIGxlbmd0aCBvZiBpbnB1dCBzdHJpbmcgdG8gbWF0Y2hcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInByZXBhcmVSZWdFeHBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJlcGFyZVJlZ0V4cCh0YWcpIHtcbiAgICAgIHZhciBsZW5ndGg7XG4gICAgICB2YXIgcmVnRXhwO1xuICAgICAgaWYgKHRhZyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZWdFeHAgPSB0YWc7XG4gICAgICAgIGxlbmd0aCA9IDE7IC8vIEFTU1VNUFRJT046IHJlZ2V4cCBvbmx5IHRlc3RzIG9uZSBjaGFyYWN0ZXJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVzZSBwcmVwYXJlZCByZWdleHAgaWYgcHJlc2VudFxuICAgICAgICB2YXIgcHJlcGFyZWQgPSB0YWdQYXR0ZXJuW3RhZ107XG4gICAgICAgIGlmIChwcmVwYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVnRXhwID0gcHJlcGFyZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVnRXhwID0gbmV3IFJlZ0V4cCh0YWcpO1xuICAgICAgICB9XG4gICAgICAgIGxlbmd0aCA9IHRhZy5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3JlZ0V4cCwgbGVuZ3RoXTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE1hcmt1cEFjY3VtdWxhdG9yO1xufSgpO1xuLyoqXG4gKiBIZWxwZXIgY2xhc3MgZm9yIExhYmVsIHdoaWNoIGV4cGxvZGVzIHRoZSBsYWJlbCB0ZXh0IGludG8gbGluZXMgYW5kIGJsb2NrcyB3aXRoaW4gbGluZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgTGFiZWxTcGxpdHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IENhbnZhcyByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAcGFyYW0ge0xhYmVsfSBwYXJlbnQgcmVmZXJlbmNlIHRvIHRoZSBMYWJlbCBpbnN0YW5jZSB1c2luZyBjdXJyZW50IGluc3RhbmNlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKi9cbiAgZnVuY3Rpb24gTGFiZWxTcGxpdHRlcihjdHgsIHBhcmVudCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGFiZWxTcGxpdHRlcik7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgIHRoaXMuaG92ZXIgPSBob3ZlcjtcblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHRvIGRldGVybWluZSB0ZXh0IHdpZHRoOyBwYXNzZWQgdG8gTGFiZWxBY2N1bXVsYXRvciBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IHN0cmluZyB0byBkZXRlcm1pbmUgd2lkdGggb2ZcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IG1vZCAgZm9udCB0eXBlIHRvIHVzZSBmb3IgdGhpcyB0ZXh0XG4gICAgICogQHJldHVybnMge29iamVjdH0geyB3aWR0aCwgdmFsdWVzfSB3aWR0aCBpbiBwaXhlbHMgYW5kIGZvbnQgYXR0cmlidXRlc1xuICAgICAqL1xuICAgIHZhciB0ZXh0V2lkdGggPSBmdW5jdGlvbiB0ZXh0V2lkdGgodGV4dCwgbW9kKSB7XG4gICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMDtcblxuICAgICAgLy8gVE9ETzogVGhpcyBjYW4gYmUgZG9uZSBtb3JlIGVmZmljaWVudGx5IHdpdGggY2FjaGluZ1xuICAgICAgLy8gVGhpcyB3aWxsIHNldCB0aGUgY3R4LmZvbnQgY29ycmVjdGx5LCBkZXBlbmRpbmcgb24gc2VsZWN0ZWQvaG92ZXIgYW5kIG1vZCAtIHNvIHRoYXQgY3R4Lm1lYXN1cmVUZXh0KCkgd2lsbCBiZSBhY2N1cmF0ZS5cbiAgICAgIHZhciB2YWx1ZXMgPSBfdGhpcy5wYXJlbnQuZ2V0Rm9ybWF0dGluZ1ZhbHVlcyhjdHgsIHNlbGVjdGVkLCBob3ZlciwgbW9kKTtcbiAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICBpZiAodGV4dCAhPT0gXCJcIikge1xuICAgICAgICB2YXIgbWVhc3VyZSA9IF90aGlzLmN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICAgICAgd2lkdGggPSBtZWFzdXJlLndpZHRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICB2YWx1ZXM6IHZhbHVlc1xuICAgICAgfTtcbiAgICB9O1xuICAgIHRoaXMubGluZXMgPSBuZXcgTGFiZWxBY2N1bXVsYXRvcih0ZXh0V2lkdGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0IHBhc3NlZCB0ZXh0IG9mIGEgbGFiZWwgaW50byBsaW5lcyBhbmQgYmxvY2tzLlxuICAgKlxuICAgKiAjIE5PVEVcbiAgICpcbiAgICogVGhlIGhhbmRsaW5nIG9mIHNwYWNpbmcgaXMgb3B0aW9uIGRlcGVuZGVudDpcbiAgICpcbiAgICogLSBpZiBgZm9udC5tdWx0aSA6IGZhbHNlYCwgYWxsIHNwYWNlcyBhcmUgcmV0YWluZWRcbiAgICogLSBpZiBgZm9udC5tdWx0aSA6IHRydWVgLCBldmVyeSBzZXF1ZW5jZSBvZiBzcGFjZXMgaXMgY29tcHJlc3NlZCB0byBhIHNpbmdsZSBzcGFjZVxuICAgKlxuICAgKiBUaGlzIG1pZ2h0IG5vdCBiZSB0aGUgYmVzdCB3YXkgdG8gZG8gaXQsIGJ1dCB0aGlzIGlzIGFzIGl0IGhhcyBiZWVuIHdvcmtpbmcgdGlsbCBub3cuXG4gICAqIEluIG9yZGVyIG5vdCB0byBicmVhayBleGlzdGluZyBmdW5jdGlvbmFsaXR5LCBmb3IgdGhlIHRpbWUgYmVpbmcgdGhpcyBiZWhhdmlvdXIgd2lsbFxuICAgKiBiZSByZXRhaW5lZCBpbiBhbnkgY29kZSBjaGFuZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAgdGV4dCB0byBzcGxpdFxuICAgKiBAcmV0dXJucyB7QXJyYXk8bGluZT59XG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoTGFiZWxTcGxpdHRlciwgW3tcbiAgICBrZXk6IFwicHJvY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzKHRleHQpIHtcbiAgICAgIGlmICghaXNWYWxpZExhYmVsKHRleHQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVzLmZpbmFsaXplKCk7XG4gICAgICB9XG4gICAgICB2YXIgZm9udCA9IHRoaXMucGFyZW50LmZvbnRPcHRpb25zO1xuXG4gICAgICAvLyBOb3JtYWxpemUgdGhlIGVuZC1vZi1saW5lJ3MgdG8gYSBzaW5nbGUgcmVwcmVzZW50YXRpb24gLSBvcmRlciBpbXBvcnRhbnRcbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbi9nLCBcIlxcblwiKTsgLy8gRG9zIEVPTCdzXG4gICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHIvZywgXCJcXG5cIik7IC8vIE1hYyBFT0wnc1xuXG4gICAgICAvLyBOb3RlIHRoYXQgYXQgdGhpcyBwb2ludCwgdGhlcmUgY2FuIGJlIG5vIFxccidzIGluIHRoZSB0ZXh0LlxuICAgICAgLy8gVGhpcyBpcyB1c2VkIGxhdGVyIG9uIHNwbGl0U3RyaW5nSW50b0xpbmVzKCkgdG8gc3BsaXQgbXVsdGlmb250IHRleHRzLlxuXG4gICAgICB2YXIgbmxMaW5lcyA9IFN0cmluZyh0ZXh0KS5zcGxpdChcIlxcblwiKTtcbiAgICAgIHZhciBsaW5lQ291bnQgPSBubExpbmVzLmxlbmd0aDtcbiAgICAgIGlmIChmb250Lm11bHRpKSB7XG4gICAgICAgIC8vIE11bHRpLWZvbnQgY2FzZTogc3R5bGluZyB0YWdzIGFjdGl2ZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGJsb2NrcyA9IHRoaXMuc3BsaXRCbG9ja3MobmxMaW5lc1tpXSwgZm9udC5tdWx0aSk7XG4gICAgICAgICAgLy8gUG9zdDogU2VxdWVuY2VzIG9mIHRhYnMgYW5kIHNwYWNlcyBhcmUgcmVkdWNlZCB0byBzaW5nbGUgc3BhY2VcblxuICAgICAgICAgIGlmIChibG9ja3MgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgICAgICAgaWYgKGJsb2Nrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubGluZXMubmV3TGluZShcIlwiKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm9udC5tYXhXZHQgPiAwKSB7XG4gICAgICAgICAgICAvLyB3aWR0aENvbnN0cmFpbnQubWF4aW11bSBkZWZpbmVkXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdSdW5uaW5nIHdpZHRoQ29uc3RyYWludCBtdWx0aSwgbWF4OiAnICsgdGhpcy5mb250T3B0aW9ucy5tYXhXZHQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBibG9ja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgdmFyIG1vZCA9IGJsb2Nrc1tqXS5tb2Q7XG4gICAgICAgICAgICAgIHZhciBfdGV4dCA9IGJsb2Nrc1tqXS50ZXh0O1xuICAgICAgICAgICAgICB0aGlzLnNwbGl0U3RyaW5nSW50b0xpbmVzKF90ZXh0LCBtb2QsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3aWR0aENvbnN0cmFpbnQubWF4aW11bSBOT1QgZGVmaW5lZFxuICAgICAgICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IGJsb2Nrcy5sZW5ndGg7IF9qKyspIHtcbiAgICAgICAgICAgICAgdmFyIF9tb2QgPSBibG9ja3NbX2pdLm1vZDtcbiAgICAgICAgICAgICAgdmFyIF90ZXh0MiA9IGJsb2Nrc1tfal0udGV4dDtcbiAgICAgICAgICAgICAgdGhpcy5saW5lcy5hcHBlbmQoX3RleHQyLCBfbW9kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5saW5lcy5uZXdMaW5lKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNpbmdsZS1mb250IGNhc2VcbiAgICAgICAgaWYgKGZvbnQubWF4V2R0ID4gMCkge1xuICAgICAgICAgIC8vIHdpZHRoQ29uc3RyYWludC5tYXhpbXVtIGRlZmluZWRcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUnVubmluZyB3aWR0aENvbnN0cmFpbnQgbm9ybWFsLCBtYXg6ICcgKyB0aGlzLmZvbnRPcHRpb25zLm1heFdkdCk7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxpbmVDb3VudDsgX2krKykge1xuICAgICAgICAgICAgdGhpcy5zcGxpdFN0cmluZ0ludG9MaW5lcyhubExpbmVzW19pXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdpZHRoQ29uc3RyYWludC5tYXhpbXVtIE5PVCBkZWZpbmVkXG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbGluZUNvdW50OyBfaTIrKykge1xuICAgICAgICAgICAgdGhpcy5saW5lcy5uZXdMaW5lKG5sTGluZXNbX2kyXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5saW5lcy5maW5hbGl6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG5vcm1hbGl6ZSB0aGUgbWFya3VwIHN5c3RlbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufCdtZCd8J21hcmtkb3duJ3wnaHRtbCd9IG1hcmt1cFN5c3RlbVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlTWFya3VwU3lzdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZU1hcmt1cFN5c3RlbShtYXJrdXBTeXN0ZW0pIHtcbiAgICAgIHZhciBzeXN0ZW0gPSBcIm5vbmVcIjtcbiAgICAgIGlmIChtYXJrdXBTeXN0ZW0gPT09IFwibWFya2Rvd25cIiB8fCBtYXJrdXBTeXN0ZW0gPT09IFwibWRcIikge1xuICAgICAgICBzeXN0ZW0gPSBcIm1hcmtkb3duXCI7XG4gICAgICB9IGVsc2UgaWYgKG1hcmt1cFN5c3RlbSA9PT0gdHJ1ZSB8fCBtYXJrdXBTeXN0ZW0gPT09IFwiaHRtbFwiKSB7XG4gICAgICAgIHN5c3RlbSA9IFwiaHRtbFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN5c3RlbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNwbGl0SHRtbEJsb2Nrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdEh0bWxCbG9ja3ModGV4dCkge1xuICAgICAgdmFyIHMgPSBuZXcgTWFya3VwQWNjdW11bGF0b3IodGV4dCk7XG4gICAgICB2YXIgcGFyc2VFbnRpdGllcyA9IGZ1bmN0aW9uIHBhcnNlRW50aXRpZXMoY2gpIHtcbiAgICAgICAgaWYgKC8mLy50ZXN0KGNoKSkge1xuICAgICAgICAgIHZhciBwYXJzZWQgPSBzLnJlcGxhY2Uocy50ZXh0LCBcIiZsdDtcIiwgXCI8XCIpIHx8IHMucmVwbGFjZShzLnRleHQsIFwiJmFtcDtcIiwgXCImXCIpO1xuICAgICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgICBzLmFkZChcIiZcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICB3aGlsZSAocy5wb3NpdGlvbiA8IHMudGV4dC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoID0gcy50ZXh0LmNoYXJBdChzLnBvc2l0aW9uKTtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHMucGFyc2VXUyhjaCkgfHwgLzwvLnRlc3QoY2gpICYmIChzLnBhcnNlU3RhcnRUYWcoXCJib2xkXCIsIFwiPGI+XCIpIHx8IHMucGFyc2VTdGFydFRhZyhcIml0YWxcIiwgXCI8aT5cIikgfHwgcy5wYXJzZVN0YXJ0VGFnKFwibW9ub1wiLCBcIjxjb2RlPlwiKSB8fCBzLnBhcnNlRW5kVGFnKFwiYm9sZFwiLCBcIjwvYj5cIikgfHwgcy5wYXJzZUVuZFRhZyhcIml0YWxcIiwgXCI8L2k+XCIpIHx8IHMucGFyc2VFbmRUYWcoXCJtb25vXCIsIFwiPC9jb2RlPlwiKSkgfHwgcGFyc2VFbnRpdGllcyhjaCk7XG4gICAgICAgIGlmICghcGFyc2VkKSB7XG4gICAgICAgICAgcy5hZGQoY2gpO1xuICAgICAgICB9XG4gICAgICAgIHMucG9zaXRpb24rKztcbiAgICAgIH1cbiAgICAgIHMuZW1pdEJsb2NrKCk7XG4gICAgICByZXR1cm4gcy5ibG9ja3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzcGxpdE1hcmtkb3duQmxvY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0TWFya2Rvd25CbG9ja3ModGV4dCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgcyA9IG5ldyBNYXJrdXBBY2N1bXVsYXRvcih0ZXh0KTtcbiAgICAgIHZhciBiZWdpbmFibGUgPSB0cnVlO1xuICAgICAgdmFyIHBhcnNlT3ZlcnJpZGUgPSBmdW5jdGlvbiBwYXJzZU92ZXJyaWRlKGNoKSB7XG4gICAgICAgIGlmICgvXFxcXC8udGVzdChjaCkpIHtcbiAgICAgICAgICBpZiAocy5wb3NpdGlvbiA8IF90aGlzMi50ZXh0Lmxlbmd0aCArIDEpIHtcbiAgICAgICAgICAgIHMucG9zaXRpb24rKztcbiAgICAgICAgICAgIGNoID0gX3RoaXMyLnRleHQuY2hhckF0KHMucG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKC8gXFx0Ly50ZXN0KGNoKSkge1xuICAgICAgICAgICAgICBzLnNwYWNpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcy5hZGQoY2gpO1xuICAgICAgICAgICAgICBiZWdpbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIHdoaWxlIChzLnBvc2l0aW9uIDwgcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICB2YXIgY2ggPSBzLnRleHQuY2hhckF0KHMucG9zaXRpb24pO1xuICAgICAgICB2YXIgcGFyc2VkID0gcy5wYXJzZVdTKGNoKSB8fCBwYXJzZU92ZXJyaWRlKGNoKSB8fCAoYmVnaW5hYmxlIHx8IHMuc3BhY2luZykgJiYgKHMucGFyc2VTdGFydFRhZyhcImJvbGRcIiwgXCIqXCIpIHx8IHMucGFyc2VTdGFydFRhZyhcIml0YWxcIiwgXCJfXCIpIHx8IHMucGFyc2VTdGFydFRhZyhcIm1vbm9cIiwgXCJgXCIpKSB8fCBzLnBhcnNlRW5kVGFnKFwiYm9sZFwiLCBcIipcIiwgXCJhZnRlckJvbGRcIikgfHwgcy5wYXJzZUVuZFRhZyhcIml0YWxcIiwgXCJfXCIsIFwiYWZ0ZXJJdGFsXCIpIHx8IHMucGFyc2VFbmRUYWcoXCJtb25vXCIsIFwiYFwiLCBcImFmdGVyTW9ub1wiKTtcbiAgICAgICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgICAgICBzLmFkZChjaCk7XG4gICAgICAgICAgYmVnaW5hYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcy5wb3NpdGlvbisrO1xuICAgICAgfVxuICAgICAgcy5lbWl0QmxvY2soKTtcbiAgICAgIHJldHVybiBzLmJsb2NrcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBsb2RlcyBhIHBpZWNlIG9mIHRleHQgaW50byBzaW5nbGUtZm9udCBibG9ja3MgdXNpbmcgYSBnaXZlbiBtYXJrdXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHBhcmFtIHtib29sZWFufCdtZCd8J21hcmtkb3duJ3wnaHRtbCd9IG1hcmt1cFN5c3RlbVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48e3RleHQ6IHN0cmluZywgbW9kOiBzdHJpbmd9Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNwbGl0QmxvY2tzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0QmxvY2tzKHRleHQsIG1hcmt1cFN5c3RlbSkge1xuICAgICAgdmFyIHN5c3RlbSA9IHRoaXMuZGVjb2RlTWFya3VwU3lzdGVtKG1hcmt1cFN5c3RlbSk7XG4gICAgICBpZiAoc3lzdGVtID09PSBcIm5vbmVcIikge1xuICAgICAgICByZXR1cm4gW3tcbiAgICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICAgIG1vZDogXCJub3JtYWxcIlxuICAgICAgICB9XTtcbiAgICAgIH0gZWxzZSBpZiAoc3lzdGVtID09PSBcIm1hcmtkb3duXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXRNYXJrZG93bkJsb2Nrcyh0ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoc3lzdGVtID09PSBcImh0bWxcIikge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGxpdEh0bWxCbG9ja3ModGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0ZXh0IGxlbmd0aCBvdmVyIHRoZSBjdXJyZW50IG1heCB3aXRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvdmVyTWF4V2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3Zlck1heFdpZHRoKHRleHQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgICAgcmV0dXJuIHRoaXMubGluZXMuY3VyV2lkdGgoKSArIHdpZHRoID4gdGhpcy5wYXJlbnQuZm9udE9wdGlvbnMubWF4V2R0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB0aGUgbG9uZ2VzdCBwYXJ0IG9mIHRoZSBzZW50ZW5jZSB3aGljaCBzdGlsbCBmaXRzIGluIHRoZVxuICAgICAqIGN1cnJlbnQgbWF4IHdpZHRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgIEFycmF5IG9mIHN0cmluZ3Mgc2lnbmlmeWluZyBhIHRleHQgbGluZXNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAgICAgIGluZGV4IG9mIGZpcnN0IGl0ZW0gaW4gc3RyaW5nIG1ha2luZyBzdHJpbmcgZ28gb3ZlciBtYXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldExvbmdlc3RGaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TG9uZ2VzdEZpdCh3b3Jkcykge1xuICAgICAgdmFyIHRleHQgPSBcIlwiO1xuICAgICAgdmFyIHcgPSAwO1xuICAgICAgd2hpbGUgKHcgPCB3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHByZSA9IHRleHQgPT09IFwiXCIgPyBcIlwiIDogXCIgXCI7XG4gICAgICAgIHZhciBuZXdUZXh0ID0gdGV4dCArIHByZSArIHdvcmRzW3ddO1xuICAgICAgICBpZiAodGhpcy5vdmVyTWF4V2lkdGgobmV3VGV4dCkpIGJyZWFrO1xuICAgICAgICB0ZXh0ID0gbmV3VGV4dDtcbiAgICAgICAgdysrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBsb25nZXN0IHBhcnQgb2YgdGhlIHN0cmluZyB3aGljaCBzdGlsbCBmaXRzIGluIHRoZVxuICAgICAqIGN1cnJlbnQgbWF4IHdpZHRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgQXJyYXkgb2Ygc3RyaW5ncyBzaWduaWZ5aW5nIGEgdGV4dCBsaW5lc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IGluZGV4IG9mIGZpcnN0IGl0ZW0gaW4gc3RyaW5nIG1ha2luZyBzdHJpbmcgZ28gb3ZlciBtYXhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRMb25nZXN0Rml0V29yZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMb25nZXN0Rml0V29yZCh3b3Jkcykge1xuICAgICAgdmFyIHcgPSAwO1xuICAgICAgd2hpbGUgKHcgPCB3b3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMub3Zlck1heFdpZHRoKF9zbGljZUluc3RhbmNlUHJvcGVydHkod29yZHMpLmNhbGwod29yZHMsIDAsIHcpKSkgYnJlYWs7XG4gICAgICAgIHcrKztcbiAgICAgIH1cbiAgICAgIHJldHVybiB3O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNwbGl0IHRoZSBwYXNzZWQgdGV4dCBpbnRvIGxpbmVzLCBhY2NvcmRpbmcgdG8gd2lkdGggY29uc3RyYWludCAoaWYgYW55KS5cbiAgICAgKlxuICAgICAqIFRoZSBtZXRob2QgYXNzdW1lcyB0aGF0IHRoZSBpbnB1dCBzdHJpbmcgaXMgYSBzaW5nbGUgbGluZSwgaS5lLiB3aXRob3V0IGxpbmVzIGJyZWFrLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcmV0YWlucyBzcGFjZXMsIGlmIHN0aWxsIHByZXNlbnQgKGNhc2UgYGZvbnQubXVsdGk6IGZhbHNlYCkuXG4gICAgICogQSBzcGFjZSB3aGljaCBmYWxscyBvbiBhbiBpbnRlcm5hbCBsaW5lIGJyZWFrLCB3aWxsIGJlIHJlcGxhY2VkIGJ5IGEgbmV3bGluZS5cbiAgICAgKiBUaGVyZSBpcyBubyBzcGVjaWFsIGhhbmRsaW5nIG9mIHRhYnM7IHRoZXNlIGdvIGFsb25nIHdpdGggdGhlIGZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttb2Q9J25vcm1hbCddXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYXBwZW5kTGFzdD1mYWxzZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNwbGl0U3RyaW5nSW50b0xpbmVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0U3RyaW5nSW50b0xpbmVzKHN0cikge1xuICAgICAgdmFyIG1vZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJub3JtYWxcIjtcbiAgICAgIHZhciBhcHBlbmRMYXN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIC8vIFNldCB0aGUgY2FudmFzIGNvbnRleHQgZm9udCwgYmFzZWQgdXBvbiB0aGUgY3VycmVudCBzZWxlY3RlZC9ob3ZlciBzdGF0ZVxuICAgICAgLy8gYW5kIHRoZSBwcm92aWRlZCBtb2QsIHNvIHRoZSB0ZXh0IG1lYXN1cmVtZW50IHBlcmZvcm1lZCBieSBnZXRMb25nZXN0Rml0XG4gICAgICAvLyB3aWxsIGJlIGFjY3VyYXRlIC0gYW5kIG5vdCBqdXN0IHVzZSB0aGUgZm9udCBvZiB3aG9ldmVyIGxhc3QgdXNlZCB0aGUgY2FudmFzLlxuICAgICAgdGhpcy5wYXJlbnQuZ2V0Rm9ybWF0dGluZ1ZhbHVlcyh0aGlzLmN0eCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgbW9kKTtcblxuICAgICAgLy8gU3RpbGwtcHJlc2VudCBzcGFjZXMgYXJlIHJlbGV2YW50LCByZXRhaW4gdGhlbVxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoL14oICspL2csIFwiJDFcXHJcIik7XG4gICAgICBzdHIgPSBzdHIucmVwbGFjZSgvKFteXFxyXVteIF0qKSggKykvZywgXCIkMVxcciQyXFxyXCIpO1xuICAgICAgdmFyIHdvcmRzID0gc3RyLnNwbGl0KFwiXFxyXCIpO1xuICAgICAgd2hpbGUgKHdvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLmdldExvbmdlc3RGaXQod29yZHMpO1xuICAgICAgICBpZiAodyA9PT0gMCkge1xuICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZTogdGhlIGZpcnN0IHdvcmQgaXMgYWxyZWFkeSBsYXJnZXIgdGhhbiB0aGUgbWF4IHdpZHRoLlxuICAgICAgICAgIHZhciB3b3JkID0gd29yZHNbMF07XG5cbiAgICAgICAgICAvLyBCcmVhayB0aGUgd29yZCB0byB0aGUgbGFyZ2VzdCBwYXJ0IHRoYXQgZml0cyB0aGUgbGluZVxuICAgICAgICAgIHZhciB4ID0gdGhpcy5nZXRMb25nZXN0Rml0V29yZCh3b3JkKTtcbiAgICAgICAgICB0aGlzLmxpbmVzLm5ld0xpbmUoX3NsaWNlSW5zdGFuY2VQcm9wZXJ0eSh3b3JkKS5jYWxsKHdvcmQsIDAsIHgpLCBtb2QpO1xuXG4gICAgICAgICAgLy8gQWRqdXN0IHRoZSB3b3JkLCBzbyB0aGF0IHRoZSByZXN0IHdpbGwgYmUgZG9uZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgIHdvcmRzWzBdID0gX3NsaWNlSW5zdGFuY2VQcm9wZXJ0eSh3b3JkKS5jYWxsKHdvcmQsIHgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHNraXAgYW55IHNwYWNlIHRoYXQgaXMgcmVwbGFjZWQgYnkgYSBuZXdsaW5lXG4gICAgICAgICAgdmFyIG5ld1cgPSB3O1xuICAgICAgICAgIGlmICh3b3Jkc1t3IC0gMV0gPT09IFwiIFwiKSB7XG4gICAgICAgICAgICB3LS07XG4gICAgICAgICAgfSBlbHNlIGlmICh3b3Jkc1tuZXdXXSA9PT0gXCIgXCIpIHtcbiAgICAgICAgICAgIG5ld1crKztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRleHQgPSBfc2xpY2VJbnN0YW5jZVByb3BlcnR5KHdvcmRzKS5jYWxsKHdvcmRzLCAwLCB3KS5qb2luKFwiXCIpO1xuICAgICAgICAgIGlmICh3ID09IHdvcmRzLmxlbmd0aCAmJiBhcHBlbmRMYXN0KSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVzLmFwcGVuZCh0ZXh0LCBtb2QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVzLm5ld0xpbmUodGV4dCwgbW9kKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBBZGp1c3QgdGhlIHdvcmQsIHNvIHRoYXQgdGhlIHJlc3Qgd2lsbCBiZSBkb25lIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgd29yZHMgPSBfc2xpY2VJbnN0YW5jZVByb3BlcnR5KHdvcmRzKS5jYWxsKHdvcmRzLCBuZXdXKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTGFiZWxTcGxpdHRlcjtcbn0oKTtcblxuLyoqXG4gKiBMaXN0IG9mIHNwZWNpYWwgc3R5bGVzIGZvciBtdWx0aS1mb250c1xuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBtdWx0aUZvbnRTdHlsZSA9IFtcImJvbGRcIiwgXCJpdGFsXCIsIFwiYm9sZGl0YWxcIiwgXCJtb25vXCJdO1xuXG4vKipcbiAqIEEgTGFiZWwgdG8gYmUgdXNlZCBmb3IgTm9kZXMgb3IgRWRnZXMuXG4gKi9cbnZhciBMYWJlbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtlZGdlbGFiZWw9ZmFsc2VdXG4gICAqL1xuICBmdW5jdGlvbiBMYWJlbChib2R5LCBvcHRpb25zKSB7XG4gICAgdmFyIGVkZ2VsYWJlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhYmVsKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMucG9pbnRUb1NlbGYgPSBmYWxzZTtcbiAgICB0aGlzLmJhc2VTaXplID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm9udE9wdGlvbnMgPSB7fTsgLy8gaW5zdGFuY2UgdmFyaWFibGUgY29udGFpbmluZyB0aGUgKmluc3RhbmNlLWxvY2FsKiBmb250IG9wdGlvbnNcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5zaXplID0ge1xuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgeUxpbmU6IDBcbiAgICB9O1xuICAgIHRoaXMuaXNFZGdlTGFiZWwgPSBlZGdlbGFiZWw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgb2YgdGhlIHBhcmVudCBOb2RlLWluc3RhbmNlXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoTGFiZWwsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLmVsZW1lbnRPcHRpb25zID0gb3B0aW9uczsgLy8gUmVmZXJlbmNlIHRvIHRoZSBvcHRpb25zIG9mIHRoZSBwYXJlbnQgTm9kZS1pbnN0YW5jZVxuXG4gICAgICB0aGlzLmluaXRGb250T3B0aW9ucyhvcHRpb25zLmZvbnQpO1xuICAgICAgaWYgKGlzVmFsaWRMYWJlbChvcHRpb25zLmxhYmVsKSkge1xuICAgICAgICB0aGlzLmxhYmVsRGlydHkgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQmFkIGxhYmVsISBDaGFuZ2UgdGhlIG9wdGlvbiB2YWx1ZSB0byBwcmV2ZW50IGJhZCBzdHVmZiBoYXBwZW5pbmdcbiAgICAgICAgb3B0aW9ucy5sYWJlbCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmZvbnQgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLmZvbnQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gZm9udCBvcHRpb25zIGNhbiBiZSBkZWxldGVkIGF0IHZhcmlvdXMgbGV2ZWxzXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mb250ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5iYXNlU2l6ZSA9IHRoaXMuZm9udE9wdGlvbnMuc2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKG9wdGlvbnMuZm9udCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB2YXIgc2l6ZSA9IG9wdGlvbnMuZm9udC5zaXplO1xuICAgICAgICAgIGlmIChzaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZVNpemUgPSBzaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXQgdGhlIGZvbnQgT3B0aW9ucyBzdHJ1Y3R1cmUuXG4gICAgICpcbiAgICAgKiBNZW1iZXIgZm9udE9wdGlvbnMgc2VydmVzIGFzIGFuIGFjY3VtdWxhdG9yIGZvciB0aGUgY3VycmVudCBmb250IG9wdGlvbnMuXG4gICAgICogQXMgc3VjaCwgaXQgbmVlZHMgdG8gYmUgY29tcGxldGVseSBzZXBhcmF0ZWQgZnJvbSB0aGUgbm9kZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG5ld0ZvbnRPcHRpb25zIHRoZSBuZXcgZm9udCBvcHRpb25zIHRvIHByb2Nlc3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImluaXRGb250T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0Rm9udE9wdGlvbnMobmV3Rm9udE9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAvLyBQcmVwYXJlIHRoZSBtdWx0aS1mb250IG9wdGlvbiBvYmplY3RzLlxuICAgICAgLy8gVGhlc2Ugd2lsbCBiZSBmaWxsZWQgaW4gcHJvcGFnYXRlRm9udHMoKSwgaWYgcmVxdWlyZWRcbiAgICAgIGZvckVhY2gkMShtdWx0aUZvbnRTdHlsZSwgZnVuY3Rpb24gKHN0eWxlKSB7XG4gICAgICAgIF90aGlzLmZvbnRPcHRpb25zW3N0eWxlXSA9IHt9O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEhhbmRsZSBzaG9ydGhhbmQgb3B0aW9uLCBpZiBwcmVzZW50XG4gICAgICBpZiAoTGFiZWwucGFyc2VGb250U3RyaW5nKHRoaXMuZm9udE9wdGlvbnMsIG5ld0ZvbnRPcHRpb25zKSkge1xuICAgICAgICB0aGlzLmZvbnRPcHRpb25zLnZhZGp1c3QgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENvcHkgb3ZlciB0aGUgbm9uLW11bHRpZm9udCBvcHRpb25zLCBpZiBzcGVjaWZpZWRcbiAgICAgIGZvckVhY2gkMShuZXdGb250T3B0aW9ucywgZnVuY3Rpb24gKHByb3AsIG4pIHtcbiAgICAgICAgaWYgKHByb3AgIT09IHVuZGVmaW5lZCAmJiBwcm9wICE9PSBudWxsICYmIF90eXBlb2YocHJvcCkgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBfdGhpcy5mb250T3B0aW9uc1tuXSA9IHByb3A7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIGluLXZhcmlhYmxlIGlzIGEgc3RyaW5nLCBwYXJzZSBpdCBhcyBhIGZvbnQgc3BlY2lmaWVyLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGZvbGxvd2luZyBpcyBub3QgZG9uZSBoZXJlIGFuZCBoYXZlIHRvIGJlIGRvbmUgYWZ0ZXIgdGhlIGNhbGw6XG4gICAgICogLSBOb3QgYWxsIGZvbnQgb3B0aW9ucyBhcmUgc2V0ICh2YWRqdXN0LCBtb2QpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3V0T3B0aW9ucyAgb3V0LXBhcmFtZXRlciwgb2JqZWN0IGluIHdoaWNoIHRvIHN0b3JlIHRoZSBwYXJzZSByZXN1bHRzIChpZiBhbnkpXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluT3B0aW9ucyAgZm9udCBvcHRpb25zIHRvIHBhcnNlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgZm9udCBwYXJzZWQgYXMgc3RyaW5nLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKiBAc3RhdGljXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY29uc3RyYWluXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGNvbnN0cmFpbnRzIGJhc2VkIG9uICduZWFyZXN0JyB2YWx1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGlsZSBhcnJheSBvZiBvcHRpb24gb2JqZWN0cyB0byBjb25zaWRlclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSBhY3R1YWwgY29uc3RyYWludCB2YWx1ZXMgdG8gdXNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdHJhaW4ocGlsZSkge1xuICAgICAgLy8gTk9URTogY29uc3RyYWluV2lkdGggYW5kICBjb25zdHJhaW5IZWlnaHQgbmV2ZXIgc2V0IVxuICAgICAgLy8gTk9URTogZm9yIGVkZ2UgbGFiZWxzLCBvbmx5ICdtYXhXZHQnIHNldFxuICAgICAgLy8gTm9kZSBsYWJlbHMgY2FuIHNldCBhbGwgdGhlIGZpZWxkc1xuICAgICAgdmFyIGZvbnRPcHRpb25zID0ge1xuICAgICAgICBjb25zdHJhaW5XaWR0aDogZmFsc2UsXG4gICAgICAgIG1heFdkdDogLTEsXG4gICAgICAgIG1pbldkdDogLTEsXG4gICAgICAgIGNvbnN0cmFpbkhlaWdodDogZmFsc2UsXG4gICAgICAgIG1pbkhndDogLTEsXG4gICAgICAgIHZhbGlnbjogXCJtaWRkbGVcIlxuICAgICAgfTtcbiAgICAgIHZhciB3aWR0aENvbnN0cmFpbnQgPSB0b3BNb3N0KHBpbGUsIFwid2lkdGhDb25zdHJhaW50XCIpO1xuICAgICAgaWYgKHR5cGVvZiB3aWR0aENvbnN0cmFpbnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZm9udE9wdGlvbnMubWF4V2R0ID0gTnVtYmVyKHdpZHRoQ29uc3RyYWludCk7XG4gICAgICAgIGZvbnRPcHRpb25zLm1pbldkdCA9IE51bWJlcih3aWR0aENvbnN0cmFpbnQpO1xuICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKHdpZHRoQ29uc3RyYWludCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIHdpZHRoQ29uc3RyYWludE1heGltdW0gPSB0b3BNb3N0KHBpbGUsIFtcIndpZHRoQ29uc3RyYWludFwiLCBcIm1heGltdW1cIl0pO1xuICAgICAgICBpZiAodHlwZW9mIHdpZHRoQ29uc3RyYWludE1heGltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBmb250T3B0aW9ucy5tYXhXZHQgPSBOdW1iZXIod2lkdGhDb25zdHJhaW50TWF4aW11bSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpZHRoQ29uc3RyYWludE1pbmltdW0gPSB0b3BNb3N0KHBpbGUsIFtcIndpZHRoQ29uc3RyYWludFwiLCBcIm1pbmltdW1cIl0pO1xuICAgICAgICBpZiAodHlwZW9mIHdpZHRoQ29uc3RyYWludE1pbmltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBmb250T3B0aW9ucy5taW5XZHQgPSBOdW1iZXIod2lkdGhDb25zdHJhaW50TWluaW11bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBoZWlnaHRDb25zdHJhaW50ID0gdG9wTW9zdChwaWxlLCBcImhlaWdodENvbnN0cmFpbnRcIik7XG4gICAgICBpZiAodHlwZW9mIGhlaWdodENvbnN0cmFpbnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgZm9udE9wdGlvbnMubWluSGd0ID0gTnVtYmVyKGhlaWdodENvbnN0cmFpbnQpO1xuICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKGhlaWdodENvbnN0cmFpbnQpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciBoZWlnaHRDb25zdHJhaW50TWluaW11bSA9IHRvcE1vc3QocGlsZSwgW1wiaGVpZ2h0Q29uc3RyYWludFwiLCBcIm1pbmltdW1cIl0pO1xuICAgICAgICBpZiAodHlwZW9mIGhlaWdodENvbnN0cmFpbnRNaW5pbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgZm9udE9wdGlvbnMubWluSGd0ID0gTnVtYmVyKGhlaWdodENvbnN0cmFpbnRNaW5pbXVtKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVpZ2h0Q29uc3RyYWludFZhbGlnbiA9IHRvcE1vc3QocGlsZSwgW1wiaGVpZ2h0Q29uc3RyYWludFwiLCBcInZhbGlnblwiXSk7XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0Q29uc3RyYWludFZhbGlnbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmIChoZWlnaHRDb25zdHJhaW50VmFsaWduID09PSBcInRvcFwiIHx8IGhlaWdodENvbnN0cmFpbnRWYWxpZ24gPT09IFwiYm90dG9tXCIpIHtcbiAgICAgICAgICAgIGZvbnRPcHRpb25zLnZhbGlnbiA9IGhlaWdodENvbnN0cmFpbnRWYWxpZ247XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9udE9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IG9wdGlvbnMgYW5kIHVwZGF0ZSBpbnRlcm5hbCBzdGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgIG9wdGlvbnMgdG8gc2V0XG4gICAgICogQHBhcmFtIHtBcnJheX0gIHBpbGUgICAgIGFycmF5IG9mIG9wdGlvbiBvYmplY3RzIHRvIGNvbnNpZGVyIGZvciBvcHRpb24gJ2Nob3NlbidcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKG9wdGlvbnMsIHBpbGUpIHtcbiAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zLCB0cnVlKTtcbiAgICAgIHRoaXMucHJvcGFnYXRlRm9udHMocGlsZSk7XG4gICAgICBkZWVwRXh0ZW5kKHRoaXMuZm9udE9wdGlvbnMsIHRoaXMuY29uc3RyYWluKHBpbGUpKTtcbiAgICAgIHRoaXMuZm9udE9wdGlvbnMuY2hvb3NlciA9IGNob29zaWZ5KFwibGFiZWxcIiwgcGlsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBtYXJnaW5zIGFyZSBzZXQgaW4gYW4gZWxlbWVudCwgYWRqdXN0IHNpemVzIGlzIGNhbGxlZCB0byByZW1vdmUgdGhlbVxuICAgICAqIGZyb20gdGhlIHdpZHRoL2hlaWdodCBjb25zdHJhaW50cy4gVGhpcyBtdXN0IGJlIGRvbmUgcHJpb3IgdG8gbGFiZWwgc2l6aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7dG9wOiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fSBtYXJnaW5zXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRqdXN0U2l6ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRqdXN0U2l6ZXMobWFyZ2lucykge1xuICAgICAgdmFyIHdpZHRoQmlhcyA9IG1hcmdpbnMgPyBtYXJnaW5zLnJpZ2h0ICsgbWFyZ2lucy5sZWZ0IDogMDtcbiAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLmNvbnN0cmFpbldpZHRoKSB7XG4gICAgICAgIHRoaXMuZm9udE9wdGlvbnMubWF4V2R0IC09IHdpZHRoQmlhcztcbiAgICAgICAgdGhpcy5mb250T3B0aW9ucy5taW5XZHQgLT0gd2lkdGhCaWFzO1xuICAgICAgfVxuICAgICAgdmFyIGhlaWdodEJpYXMgPSBtYXJnaW5zID8gbWFyZ2lucy50b3AgKyBtYXJnaW5zLmJvdHRvbSA6IDA7XG4gICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5jb25zdHJhaW5IZWlnaHQpIHtcbiAgICAgICAgdGhpcy5mb250T3B0aW9ucy5taW5IZ3QgLT0gaGVpZ2h0QmlhcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBNZXRob2RzIGZvciBoYW5kbGluZyBvcHRpb25zIHBpbGVzXG4gICAgLy8gRXZlbnR1YWxseSwgdGhlc2Ugd2lsbCBiZSBtb3ZlZCB0byBhIHNlcGFyYXRlIGNsYXNzXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIGZvbnQgbWVtYmVycyBvZiB0aGUgcGFzc2VkIGxpc3Qgb2Ygb3B0aW9uIG9iamVjdHMgdG8gdGhlIHBpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BpbGV9IGRzdFBpbGUgIHBpbGUgb2Ygb3B0aW9uIG9iamVjdHMgYWRkIHRvXG4gICAgICogQHBhcmFtIHtQaWxlfSBzcmNQaWxlICBwaWxlIG9mIG9wdGlvbiBvYmplY3RzIHRvIHRha2UgZm9udCBvcHRpb25zIGZyb21cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZEZvbnRPcHRpb25zVG9QaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEZvbnRPcHRpb25zVG9QaWxlKGRzdFBpbGUsIHNyY1BpbGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3JjUGlsZS5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLmFkZEZvbnRUb1BpbGUoZHN0UGlsZSwgc3JjUGlsZVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGdpdmVuIGZvbnQgb3B0aW9uIG9iamVjdCB0byB0aGUgbGlzdCBvZiBvYmplY3RzICh0aGUgJ3BpbGUnKSB0byBjb25zaWRlciBmb3IgZGV0ZXJtaW5pbmdcbiAgICAgKiBtdWx0aS1mb250IG9wdGlvbiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BpbGV9IHBpbGUgIHBpbGUgb2Ygb3B0aW9uIG9iamVjdHMgdG8gdXNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgIGluc3RhbmNlIHRvIGFkZCB0byBwaWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGRGb250VG9QaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEZvbnRUb1BpbGUocGlsZSwgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgICAgaWYgKG9wdGlvbnMuZm9udCA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuZm9udCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgdmFyIGl0ZW0gPSBvcHRpb25zLmZvbnQ7XG4gICAgICBwaWxlLnB1c2goaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdCBhbGwgb3duLXByb3BlcnR5IHZhbHVlcyBmcm9tIHRoZSBmb250IHBpbGUgdGhhdCBhcmVuJ3QgbXVsdGktZm9udCBvcHRpb24gb2JqZWN0c3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BpbGV9IHBpbGUgIHBpbGUgb2Ygb3B0aW9uIG9iamVjdHMgdG8gdXNlXG4gICAgICogQHJldHVybnMge29iamVjdH0gb2JqZWN0IHdpdGggYWxsIGN1cnJlbnQgb3duIGJhc2ljIGZvbnQgcHJvcGVydGllc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmFzaWNPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2ljT3B0aW9ucyhwaWxlKSB7XG4gICAgICB2YXIgcmV0ID0ge307XG5cbiAgICAgIC8vIFNjYW5zIHRoZSB3aG9sZSBwaWxlIHRvIGdldCBhbGwgb3B0aW9ucyBwcmVzZW50XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHBpbGUubGVuZ3RoOyArK24pIHtcbiAgICAgICAgdmFyIGZvbnRPcHRpb25zID0gcGlsZVtuXTtcblxuICAgICAgICAvLyBDb252ZXJ0IHNob3J0aGFuZCBpZiBuZWNlc3NhcnlcbiAgICAgICAgdmFyIHRtcFNob3J0aGFuZCA9IHt9O1xuICAgICAgICBpZiAoTGFiZWwucGFyc2VGb250U3RyaW5nKHRtcFNob3J0aGFuZCwgZm9udE9wdGlvbnMpKSB7XG4gICAgICAgICAgZm9udE9wdGlvbnMgPSB0bXBTaG9ydGhhbmQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yRWFjaCQxKGZvbnRPcHRpb25zLCBmdW5jdGlvbiAob3B0LCBuYW1lKSB7XG4gICAgICAgICAgaWYgKG9wdCA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIG11bHRpLWZvbnQgb3B0aW9uIG5lZWQgbm90IGJlIHByZXNlbnRcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJldCwgbmFtZSkpIHJldHVybjsgLy8gS2VlcCBmaXJzdCB2YWx1ZSB3ZSBlbmNvdW50ZXJcblxuICAgICAgICAgIGlmIChfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkobXVsdGlGb250U3R5bGUpLmNhbGwobXVsdGlGb250U3R5bGUsIG5hbWUpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gU2tpcCBtdWx0aS1mb250IHByb3BlcnRpZXMgYnV0IHdlIGRvIG5lZWQgdGhlIHN0cnVjdHVyZVxuICAgICAgICAgICAgcmV0W25hbWVdID0ge307XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldFtuYW1lXSA9IG9wdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHZhbHVlIGZvciBnaXZlbiBvcHRpb24gZm9yIHRoZSBnaXZlbiBtdWx0aS1mb250LlxuICAgICAqXG4gICAgICogQWxsIGF2YWlsYWJsZSBvcHRpb24gb2JqZWN0cyBhcmUgdHJhd2xlZCBpbiB0aGUgc2V0IG9yZGVyIHRvIGNvbnN0cnVjdCB0aGUgb3B0aW9uIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqICMjIFRyYXZlcnNhbCBvZiBwaWxlIGZvciBtdWx0aS1mb250c1xuICAgICAqXG4gICAgICogVGhlIGRldGVybWluYXRpb24gb2YgbXVsdGktZm9udCBvcHRpb24gdmFsdWVzIGlzIGEgc3BlY2lhbCBjYXNlLCBiZWNhdXNlIGFueSB2YWx1ZXMgbm90XG4gICAgICogcHJlc2VudCBpbiB0aGUgbXVsdGktZm9udCBvcHRpb25zIHNob3VsZCBieSBkZWZpbml0aW9uIGJlIHRha2VuIGZyb20gdGhlIG1haW4gZm9udCBvcHRpb25zLFxuICAgICAqIGkuZS4gZnJvbSB0aGUgY3VycmVudCAncGFyZW50JyBvYmplY3Qgb2YgdGhlIG11bHRpLWZvbnQgb3B0aW9uLlxuICAgICAqXG4gICAgICogIyMjIFNlYXJjaCBvcmRlciBmb3IgbXVsdGktZm9udHNcbiAgICAgKlxuICAgICAqICdib2xkJyB1c2VkIGFzIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgIC0gc2VhcmNoIGluIG9wdGlvbiBncm91cCAnYm9sZCcgaW4gbG9jYWwgcHJvcGVydGllc1xuICAgICAqICAgLSBzZWFyY2ggaW4gbWFpbiBmb250IG9wdGlvbiBncm91cCBpbiBsb2NhbCBwcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGlsZX0gcGlsZSAgcGlsZSBvZiBvcHRpb24gb2JqZWN0cyB0byB1c2VcbiAgICAgKiBAcGFyYW0ge011bHRpRm9udFN0eWxlfSBtdWx0aU5hbWUgc3ViIHBhdGggZm9yIHRoZSBtdWx0aS1mb250XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbiAgdGhlIG9wdGlvbiB0byBzZWFyY2ggZm9yLCBmb3IgdGhlIGdpdmVuIG11bHRpLWZvbnRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bWJlcn0gdGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gb3B0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRGb250T3B0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZvbnRPcHRpb24ocGlsZSwgbXVsdGlOYW1lLCBvcHRpb24pIHtcbiAgICAgIHZhciBtdWx0aUZvbnQ7XG5cbiAgICAgIC8vIFNlYXJjaCBtdWx0aSBmb250IGluIGxvY2FsIHByb3BlcnRpZXNcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgcGlsZS5sZW5ndGg7ICsrbikge1xuICAgICAgICB2YXIgZm9udE9wdGlvbnMgPSBwaWxlW25dO1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZvbnRPcHRpb25zLCBtdWx0aU5hbWUpKSB7XG4gICAgICAgICAgbXVsdGlGb250ID0gZm9udE9wdGlvbnNbbXVsdGlOYW1lXTtcbiAgICAgICAgICBpZiAobXVsdGlGb250ID09PSB1bmRlZmluZWQgfHwgbXVsdGlGb250ID09PSBudWxsKSBjb250aW51ZTtcblxuICAgICAgICAgIC8vIENvbnZlcnQgc2hvcnRoYW5kIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgIC8vIFRPRE86IGluZWZmaWNpZW50IHRvIGRvIHRoaXMgY29udmVyc2lvbiBldmVyeSB0aW1lOyBmaW5kIGEgYmV0dGVyIHdheS5cbiAgICAgICAgICB2YXIgdG1wU2hvcnRoYW5kID0ge307XG4gICAgICAgICAgaWYgKExhYmVsLnBhcnNlRm9udFN0cmluZyh0bXBTaG9ydGhhbmQsIG11bHRpRm9udCkpIHtcbiAgICAgICAgICAgIG11bHRpRm9udCA9IHRtcFNob3J0aGFuZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtdWx0aUZvbnQsIG9wdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBtdWx0aUZvbnRbb3B0aW9uXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gT3B0aW9uIGlzIG5vdCBtZW50aW9uZWQgaW4gdGhlIG11bHRpIGZvbnQgb3B0aW9uczsgdGFrZSBpdCBmcm9tIHRoZSBwYXJlbnQgZm9udCBvcHRpb25zLlxuICAgICAgLy8gVGhlc2UgaGF2ZSBhbHJlYWR5IGJlZW4gY29udmVydGVkIHdpdGggZ2V0QmFzaWNPcHRpb25zKCksIHNvIHVzZSB0aGUgY29udmVydGVkIHZhbHVlcy5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5mb250T3B0aW9ucywgb3B0aW9uKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb250T3B0aW9uc1tvcHRpb25dO1xuICAgICAgfVxuXG4gICAgICAvLyBBIHZhbHVlICoqbXVzdCoqIGJlIGZvdW5kOyB5b3Ugc2hvdWxkIG5ldmVyIGdldCBoZXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlkIG5vdCBmaW5kIHZhbHVlIGZvciBtdWx0aS1mb250IGZvciBwcm9wZXJ0eTogJ1wiICsgb3B0aW9uICsgXCInXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbGwgb3B0aW9ucyB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBtdWx0aS1mb250LlxuICAgICAqXG4gICAgICogQWxsIGF2YWlsYWJsZSBvcHRpb24gb2JqZWN0cyBhcmUgdHJhd2xlZCBpbiB0aGUgc2V0IG9yZGVyIHRvIGNvbnN0cnVjdCB0aGUgb3B0aW9uIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGlsZX0gcGlsZSAgcGlsZSBvZiBvcHRpb24gb2JqZWN0cyB0byB1c2VcbiAgICAgKiBAcGFyYW0ge011bHRpRm9udFN0eWxlfSBtdWx0aU5hbWUgc3ViIHBhdGggZm9yIHRoZSBtb2QtZm9udFxuICAgICAqIEByZXR1cm5zIHtNdWx0aUZvbnRPcHRpb25zfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rm9udE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9udE9wdGlvbnMocGlsZSwgbXVsdGlOYW1lKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICB2YXIgb3B0aW9uTmFtZXMgPSBbXCJjb2xvclwiLCBcInNpemVcIiwgXCJmYWNlXCIsIFwibW9kXCIsIFwidmFkanVzdFwiXTsgLy8gTGlzdCBvZiBhbGxvd2VkIG9wdGlvbnMgcGVyIG11bHRpLWZvbnRcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25OYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbW9kID0gb3B0aW9uTmFtZXNbaV07XG4gICAgICAgIHJlc3VsdFttb2RdID0gdGhpcy5nZXRGb250T3B0aW9uKHBpbGUsIG11bHRpTmFtZSwgbW9kKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gRW5kIG1ldGhvZHMgZm9yIGhhbmRsaW5nIG9wdGlvbnMgcGlsZXNcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlIHRoZSBmb250IG9wdGlvbnMgZm9yIHRoZSBtdWx0aS1mb250IHRvIHNpbmdsZSBvYmplY3RzLCBmcm9tXG4gICAgICogdGhlIGNoYWluIG9mIG9wdGlvbiBvYmplY3RzIHBhc3NlZCAodGhlICdwaWxlJykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BpbGV9IHBpbGUgIHNlcXVlbmNlIG9mIG9wdGlvbiBvYmplY3RzIHRvIGNvbnNpZGVyLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgRmlyc3QgaXRlbSBpbiBsaXN0IGFzc3VtZWQgdG8gYmUgdGhlIG5ld2x5IHNldCBvcHRpb25zLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInByb3BhZ2F0ZUZvbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb3BhZ2F0ZUZvbnRzKHBpbGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIGZvbnRQaWxlID0gW107IC8vIHNlcXVlbmNlIG9mIGZvbnQgb2JqZWN0cyB0byBjb25zaWRlciwgb3JkZXIgaW1wb3J0YW50XG5cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzLmVsZW1lbnRPcHRpb25zIGlzIG5vdCB1c2VkIGhlcmUuXG4gICAgICB0aGlzLmFkZEZvbnRPcHRpb25zVG9QaWxlKGZvbnRQaWxlLCBwaWxlKTtcbiAgICAgIHRoaXMuZm9udE9wdGlvbnMgPSB0aGlzLmdldEJhc2ljT3B0aW9ucyhmb250UGlsZSk7XG5cbiAgICAgIC8vIFdlIHNldCBtdWx0aWZvbnQgdmFsdWVzIGV2ZW4gaWYgbXVsdGkgPT09IGZhbHNlLCBmb3IgY29uc2lzdGVuY3kgKHRoaW5ncyBicmVhayBvdGhlcndpc2UpXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgdmFyIG1vZCA9IG11bHRpRm9udFN0eWxlW2ldO1xuICAgICAgICB2YXIgbW9kT3B0aW9ucyA9IF90aGlzMi5mb250T3B0aW9uc1ttb2RdO1xuICAgICAgICB2YXIgdG1wTXVsdGlGb250T3B0aW9ucyA9IF90aGlzMi5nZXRGb250T3B0aW9ucyhmb250UGlsZSwgbW9kKTtcblxuICAgICAgICAvLyBDb3B5IG92ZXIgZm91bmQgdmFsdWVzXG4gICAgICAgIGZvckVhY2gkMSh0bXBNdWx0aUZvbnRPcHRpb25zLCBmdW5jdGlvbiAob3B0aW9uLCBuKSB7XG4gICAgICAgICAgbW9kT3B0aW9uc1tuXSA9IG9wdGlvbjtcbiAgICAgICAgfSk7XG4gICAgICAgIG1vZE9wdGlvbnMuc2l6ZSA9IE51bWJlcihtb2RPcHRpb25zLnNpemUpO1xuICAgICAgICBtb2RPcHRpb25zLnZhZGp1c3QgPSBOdW1iZXIobW9kT3B0aW9ucy52YWRqdXN0KTtcbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11bHRpRm9udFN0eWxlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIF9sb29wKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWFpbiBmdW5jdGlvbi4gVGhpcyBpcyBjYWxsZWQgZnJvbSBhbnl0aGluZyB0aGF0IHdhbnRzIHRvIGRyYXcgYSBsYWJlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2Jhc2VsaW5lPSdtaWRkbGUnXVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdmFyIGJhc2VsaW5lID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiBcIm1pZGRsZVwiO1xuICAgICAgLy8gaWYgbm8gbGFiZWwsIHJldHVyblxuICAgICAgaWYgKHRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWwgPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIHRvIHJlbmRlciB0aGUgbGFiZWxcbiAgICAgIHZhciB2aWV3Rm9udFNpemUgPSB0aGlzLmZvbnRPcHRpb25zLnNpemUgKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRPcHRpb25zLmxhYmVsICYmIHZpZXdGb250U2l6ZSA8IHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5kcmF3VGhyZXNob2xkIC0gMSkgcmV0dXJuO1xuXG4gICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB0aGVyZSB3aWxsIG5vdCBiZSBIVUdFIGxldHRlcnMgb24gc2NyZWVuXG4gICAgICAvLyBieSBzZXR0aW5nIGFuIHVwcGVyIGxpbWl0IG9uIHRoZSB2aXNpYmxlIHRleHQgc2l6ZSAocmVnYXJkbGVzcyBvZiB6b29tTGV2ZWwpXG4gICAgICBpZiAodmlld0ZvbnRTaXplID49IHRoaXMuZWxlbWVudE9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXhWaXNpYmxlKSB7XG4gICAgICAgIHZpZXdGb250U2l6ZSA9IE51bWJlcih0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwubWF4VmlzaWJsZSkgLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIH1cblxuICAgICAgLy8gdXBkYXRlIHRoZSBzaXplIGNhY2hlIGlmIHJlcXVpcmVkXG4gICAgICB0aGlzLmNhbGN1bGF0ZUxhYmVsU2l6ZShjdHgsIHNlbGVjdGVkLCBob3ZlciwgeCwgeSwgYmFzZWxpbmUpO1xuICAgICAgdGhpcy5fZHJhd0JhY2tncm91bmQoY3R4KTtcbiAgICAgIHRoaXMuX2RyYXdUZXh0KGN0eCwgeCwgdGhpcy5zaXplLnlMaW5lLCBiYXNlbGluZSwgdmlld0ZvbnRTaXplKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgbGFiZWwgYmFja2dyb3VuZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdCYWNrZ3JvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3QmFja2dyb3VuZChjdHgpIHtcbiAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLmJhY2tncm91bmQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZvbnRPcHRpb25zLmJhY2tncm91bmQgIT09IFwibm9uZVwiKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmZvbnRPcHRpb25zLmJhY2tncm91bmQ7XG4gICAgICAgIHZhciBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICAgIGN0eC5maWxsUmVjdChzaXplLmxlZnQsIHNpemUudG9wLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbYmFzZWxpbmU9J21pZGRsZSddXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZpZXdGb250U2l6ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdUZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3VGV4dChjdHgsIHgsIHkpIHtcbiAgICAgIHZhciBiYXNlbGluZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJtaWRkbGVcIjtcbiAgICAgIHZhciB2aWV3Rm9udFNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBfdGhpcyRfc2V0QWxpZ25tZW50ID0gdGhpcy5fc2V0QWxpZ25tZW50KGN0eCwgeCwgeSwgYmFzZWxpbmUpO1xuICAgICAgdmFyIF90aGlzJF9zZXRBbGlnbm1lbnQyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX3NldEFsaWdubWVudCwgMik7XG4gICAgICB4ID0gX3RoaXMkX3NldEFsaWdubWVudDJbMF07XG4gICAgICB5ID0gX3RoaXMkX3NldEFsaWdubWVudDJbMV07XG4gICAgICBjdHgudGV4dEFsaWduID0gXCJsZWZ0XCI7XG4gICAgICB4ID0geCAtIHRoaXMuc2l6ZS53aWR0aCAvIDI7IC8vIFNoaWZ0IGxhYmVsIDEvMi1kaXN0YW5jZSB0byB0aGUgbGVmdFxuICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMudmFsaWduICYmIHRoaXMuc2l6ZS5oZWlnaHQgPiB0aGlzLnNpemUubGFiZWxIZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9udE9wdGlvbnMudmFsaWduID09PSBcInRvcFwiKSB7XG4gICAgICAgICAgeSAtPSAodGhpcy5zaXplLmhlaWdodCAtIHRoaXMuc2l6ZS5sYWJlbEhlaWdodCkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLnZhbGlnbiA9PT0gXCJib3R0b21cIikge1xuICAgICAgICAgIHkgKz0gKHRoaXMuc2l6ZS5oZWlnaHQgLSB0aGlzLnNpemUubGFiZWxIZWlnaHQpIC8gMjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkcmF3IHRoZSB0ZXh0XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGluZUNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2ldO1xuICAgICAgICBpZiAobGluZSAmJiBsaW5lLmJsb2Nrcykge1xuICAgICAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICAgICAgaWYgKHRoaXMuaXNFZGdlTGFiZWwgfHwgdGhpcy5mb250T3B0aW9ucy5hbGlnbiA9PT0gXCJjZW50ZXJcIikge1xuICAgICAgICAgICAgd2lkdGggKz0gKHRoaXMuc2l6ZS53aWR0aCAtIGxpbmUud2lkdGgpIC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gPT09IFwicmlnaHRcIikge1xuICAgICAgICAgICAgd2lkdGggKz0gdGhpcy5zaXplLndpZHRoIC0gbGluZS53aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lLmJsb2Nrcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGJsb2NrID0gbGluZS5ibG9ja3Nbal07XG4gICAgICAgICAgICBjdHguZm9udCA9IGJsb2NrLmZvbnQ7XG4gICAgICAgICAgICB2YXIgX3RoaXMkX2dldENvbG9yID0gdGhpcy5fZ2V0Q29sb3IoYmxvY2suY29sb3IsIHZpZXdGb250U2l6ZSwgYmxvY2suc3Ryb2tlQ29sb3IpLFxuICAgICAgICAgICAgICBfdGhpcyRfZ2V0Q29sb3IyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldENvbG9yLCAyKSxcbiAgICAgICAgICAgICAgZm9udENvbG9yID0gX3RoaXMkX2dldENvbG9yMlswXSxcbiAgICAgICAgICAgICAgc3Ryb2tlQ29sb3IgPSBfdGhpcyRfZ2V0Q29sb3IyWzFdO1xuICAgICAgICAgICAgaWYgKGJsb2NrLnN0cm9rZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gYmxvY2suc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yO1xuICAgICAgICAgICAgICBjdHgubGluZUpvaW4gPSBcInJvdW5kXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZm9udENvbG9yO1xuICAgICAgICAgICAgaWYgKGJsb2NrLnN0cm9rZVdpZHRoID4gMCkge1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlVGV4dChibG9jay50ZXh0LCB4ICsgd2lkdGgsIHkgKyBibG9jay52YWRqdXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChibG9jay50ZXh0LCB4ICsgd2lkdGgsIHkgKyBibG9jay52YWRqdXN0KTtcbiAgICAgICAgICAgIHdpZHRoICs9IGJsb2NrLndpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB5ICs9IGxpbmUuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlbGluZVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zZXRBbGlnbm1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEFsaWdubWVudChjdHgsIHgsIHksIGJhc2VsaW5lKSB7XG4gICAgICAvLyBjaGVjayBmb3IgbGFiZWwgYWxpZ25tZW50IChmb3IgZWRnZXMpXG4gICAgICAvLyBUT0RPOiBtYWtlIGFsaWdubWVudCBmb3Igbm9kZXNcbiAgICAgIGlmICh0aGlzLmlzRWRnZUxhYmVsICYmIHRoaXMuZm9udE9wdGlvbnMuYWxpZ24gIT09IFwiaG9yaXpvbnRhbFwiICYmIHRoaXMucG9pbnRUb1NlbGYgPT09IGZhbHNlKSB7XG4gICAgICAgIHggPSAwO1xuICAgICAgICB5ID0gMDtcbiAgICAgICAgdmFyIGxpbmVNYXJnaW4gPSAyO1xuICAgICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5hbGlnbiA9PT0gXCJ0b3BcIikge1xuICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcImFscGhhYmV0aWNcIjtcbiAgICAgICAgICB5IC09IDIgKiBsaW5lTWFyZ2luOyAvLyBkaXN0YW5jZSBmcm9tIGVkZ2UsIHJlcXVpcmVkIGJlY2F1c2Ugd2UgdXNlIGFscGhhYmV0aWMuIEFscGhhYmV0aWMgaGFzIGxlc3MgZGlmZmVyZW5jZSBiZXR3ZWVuIGJyb3dzZXJzXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5mb250T3B0aW9ucy5hbGlnbiA9PT0gXCJib3R0b21cIikge1xuICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcImhhbmdpbmdcIjtcbiAgICAgICAgICB5ICs9IDIgKiBsaW5lTWFyZ2luOyAvLyBkaXN0YW5jZSBmcm9tIGVkZ2UsIHJlcXVpcmVkIGJlY2F1c2Ugd2UgdXNlIGhhbmdpbmcuIEhhbmdpbmcgaGFzIGxlc3MgZGlmZmVyZW5jZSBiZXR3ZWVuIGJyb3dzZXJzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBiYXNlbGluZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbeCwgeV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmFkZSBpbiB3aGVuIHJlbGF0aXZlIHNjYWxlIGlzIGJldHdlZW4gdGhyZXNob2xkIGFuZCB0aHJlc2hvbGQgLSAxLlxuICAgICAqIElmIHRoZSByZWxhdGl2ZSBzY2FsZSB3b3VsZCBiZSBzbWFsbGVyIHRoYW4gdGhyZXNob2xkIC0xIHRoZSBkcmF3IGZ1bmN0aW9uIHdvdWxkIGhhdmUgcmV0dXJuZWQgYmVmb3JlIGNvbWluZyBoZXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yICBUaGUgZm9udCBjb2xvciB0byB1c2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmlld0ZvbnRTaXplXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGluaXRpYWxTdHJva2VDb2xvclxuICAgICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZm9udCBjb2xvciBhbmQgc3Ryb2tlIGNvbG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENvbG9yKGNvbG9yLCB2aWV3Rm9udFNpemUsIGluaXRpYWxTdHJva2VDb2xvcikge1xuICAgICAgdmFyIGZvbnRDb2xvciA9IGNvbG9yIHx8IFwiIzAwMDAwMFwiO1xuICAgICAgdmFyIHN0cm9rZUNvbG9yID0gaW5pdGlhbFN0cm9rZUNvbG9yIHx8IFwiI2ZmZmZmZlwiO1xuICAgICAgaWYgKHZpZXdGb250U2l6ZSA8PSB0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwuZHJhd1RocmVzaG9sZCkge1xuICAgICAgICB2YXIgb3BhY2l0eSA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIDEgLSAodGhpcy5lbGVtZW50T3B0aW9ucy5zY2FsaW5nLmxhYmVsLmRyYXdUaHJlc2hvbGQgLSB2aWV3Rm9udFNpemUpKSk7XG4gICAgICAgIGZvbnRDb2xvciA9IG92ZXJyaWRlT3BhY2l0eShmb250Q29sb3IsIG9wYWNpdHkpO1xuICAgICAgICBzdHJva2VDb2xvciA9IG92ZXJyaWRlT3BhY2l0eShzdHJva2VDb2xvciwgb3BhY2l0eSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2ZvbnRDb2xvciwgc3Ryb2tlQ29sb3JdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHJldHVybnMge3t3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn19XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGV4dFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGV4dFNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHRoaXMuX3Byb2Nlc3NMYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogdGhpcy5zaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuc2l6ZS5oZWlnaHQsXG4gICAgICAgIGxpbmVDb3VudDogdGhpcy5saW5lQ291bnRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGRpbWVuc2lvbnMgb2YgdGhlIGxhYmVsXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7cmVjdH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNpemUoKSB7XG4gICAgICB2YXIgbGluZU1hcmdpbiA9IDI7XG4gICAgICB2YXIgeCA9IHRoaXMuc2l6ZS5sZWZ0OyAvLyBkZWZhdWx0IHZhbHVlcyB3aGljaCBtaWdodCBiZSBvdmVycmlkZGVuIGJlbG93XG4gICAgICB2YXIgeSA9IHRoaXMuc2l6ZS50b3AgLSAwLjUgKiBsaW5lTWFyZ2luOyAvLyBpZGVtXG5cbiAgICAgIGlmICh0aGlzLmlzRWRnZUxhYmVsKSB7XG4gICAgICAgIHZhciB4MiA9IC10aGlzLnNpemUud2lkdGggKiAwLjU7XG4gICAgICAgIHN3aXRjaCAodGhpcy5mb250T3B0aW9ucy5hbGlnbikge1xuICAgICAgICAgIGNhc2UgXCJtaWRkbGVcIjpcbiAgICAgICAgICAgIHggPSB4MjtcbiAgICAgICAgICAgIHkgPSAtdGhpcy5zaXplLmhlaWdodCAqIDAuNTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgICAgIHggPSB4MjtcbiAgICAgICAgICAgIHkgPSAtKHRoaXMuc2l6ZS5oZWlnaHQgKyBsaW5lTWFyZ2luKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICAgIHggPSB4MjtcbiAgICAgICAgICAgIHkgPSBsaW5lTWFyZ2luO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciByZXQgPSB7XG4gICAgICAgIGxlZnQ6IHgsXG4gICAgICAgIHRvcDogeSxcbiAgICAgICAgd2lkdGg6IHRoaXMuc2l6ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLnNpemUuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXVxuICAgICAqIEBwYXJhbSB7J21pZGRsZSd8J2hhbmdpbmcnfSBbYmFzZWxpbmU9J21pZGRsZSddXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY3VsYXRlTGFiZWxTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUxhYmVsU2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgdmFyIHggPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICB2YXIgeSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMDtcbiAgICAgIHZhciBiYXNlbGluZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogXCJtaWRkbGVcIjtcbiAgICAgIHRoaXMuX3Byb2Nlc3NMYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLnNpemUubGVmdCA9IHggLSB0aGlzLnNpemUud2lkdGggKiAwLjU7XG4gICAgICB0aGlzLnNpemUudG9wID0geSAtIHRoaXMuc2l6ZS5oZWlnaHQgKiAwLjU7XG4gICAgICB0aGlzLnNpemUueUxpbmUgPSB5ICsgKDEgLSB0aGlzLmxpbmVDb3VudCkgKiAwLjUgKiB0aGlzLmZvbnRPcHRpb25zLnNpemU7XG4gICAgICBpZiAoYmFzZWxpbmUgPT09IFwiaGFuZ2luZ1wiKSB7XG4gICAgICAgIHRoaXMuc2l6ZS50b3AgKz0gMC41ICogdGhpcy5mb250T3B0aW9ucy5zaXplO1xuICAgICAgICB0aGlzLnNpemUudG9wICs9IDQ7IC8vIGRpc3RhbmNlIGZyb20gbm9kZSwgcmVxdWlyZWQgYmVjYXVzZSB3ZSB1c2UgaGFuZ2luZy4gSGFuZ2luZyBoYXMgbGVzcyBkaWZmZXJlbmNlIGJldHdlZW4gYnJvd3NlcnNcbiAgICAgICAgdGhpcy5zaXplLnlMaW5lICs9IDQ7IC8vIGRpc3RhbmNlIGZyb20gbm9kZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZFxuICAgICAqIEByZXR1cm5zIHt7Y29sb3IsIHNpemUsIGZhY2UsIG1vZCwgdmFkanVzdCwgc3Ryb2tlV2lkdGg6ICosIHN0cm9rZUNvbG9yOiAoKnxzdHJpbmd8YWxsT3B0aW9ucy5lZGdlcy5mb250LnN0cm9rZUNvbG9yfHtzdHJpbmd9fGFsbE9wdGlvbnMubm9kZXMuZm9udC5zdHJva2VDb2xvcnxBcnJheSl9fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEZvcm1hdHRpbmdWYWx1ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9ybWF0dGluZ1ZhbHVlcyhjdHgsIHNlbGVjdGVkLCBob3ZlciwgbW9kKSB7XG4gICAgICB2YXIgZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZShmb250T3B0aW9ucywgbW9kLCBvcHRpb24pIHtcbiAgICAgICAgaWYgKG1vZCA9PT0gXCJub3JtYWxcIikge1xuICAgICAgICAgIGlmIChvcHRpb24gPT09IFwibW9kXCIpIHJldHVybiBcIlwiO1xuICAgICAgICAgIHJldHVybiBmb250T3B0aW9uc1tvcHRpb25dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb250T3B0aW9uc1ttb2RdW29wdGlvbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIEdydW1ibCBsZWF2aW5nIG91dCB0ZXN0IG9uIHVuZGVmaW5lZCBlcXVhbHMgZmFsc2UgZm9yIFwiXCJcbiAgICAgICAgICByZXR1cm4gZm9udE9wdGlvbnNbbW9kXVtvcHRpb25dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRha2UgZnJvbSBwYXJlbnQgZm9udCBvcHRpb25cbiAgICAgICAgICByZXR1cm4gZm9udE9wdGlvbnNbb3B0aW9uXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciB2YWx1ZXMgPSB7XG4gICAgICAgIGNvbG9yOiBnZXRWYWx1ZSh0aGlzLmZvbnRPcHRpb25zLCBtb2QsIFwiY29sb3JcIiksXG4gICAgICAgIHNpemU6IGdldFZhbHVlKHRoaXMuZm9udE9wdGlvbnMsIG1vZCwgXCJzaXplXCIpLFxuICAgICAgICBmYWNlOiBnZXRWYWx1ZSh0aGlzLmZvbnRPcHRpb25zLCBtb2QsIFwiZmFjZVwiKSxcbiAgICAgICAgbW9kOiBnZXRWYWx1ZSh0aGlzLmZvbnRPcHRpb25zLCBtb2QsIFwibW9kXCIpLFxuICAgICAgICB2YWRqdXN0OiBnZXRWYWx1ZSh0aGlzLmZvbnRPcHRpb25zLCBtb2QsIFwidmFkanVzdFwiKSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuZm9udE9wdGlvbnMuc3Ryb2tlV2lkdGgsXG4gICAgICAgIHN0cm9rZUNvbG9yOiB0aGlzLmZvbnRPcHRpb25zLnN0cm9rZUNvbG9yXG4gICAgICB9O1xuICAgICAgaWYgKHNlbGVjdGVkIHx8IGhvdmVyKSB7XG4gICAgICAgIGlmIChtb2QgPT09IFwibm9ybWFsXCIgJiYgdGhpcy5mb250T3B0aW9ucy5jaG9vc2VyID09PSB0cnVlICYmIHRoaXMuZWxlbWVudE9wdGlvbnMubGFiZWxIaWdobGlnaHRCb2xkKSB7XG4gICAgICAgICAgdmFsdWVzLm1vZCA9IFwiYm9sZFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5mb250T3B0aW9ucy5jaG9vc2VyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZm9udE9wdGlvbnMuY2hvb3Nlcih2YWx1ZXMsIHRoaXMuZWxlbWVudE9wdGlvbnMuaWQsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZm9udFN0cmluZyA9IFwiXCI7XG4gICAgICBpZiAodmFsdWVzLm1vZCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlcy5tb2QgIT09IFwiXCIpIHtcbiAgICAgICAgLy8gc2FmZWd1YXJkIGZvciB1bmRlZmluZWQgLSB0aGlzIGhhcHBlbmVkXG4gICAgICAgIGZvbnRTdHJpbmcgKz0gdmFsdWVzLm1vZCArIFwiIFwiO1xuICAgICAgfVxuICAgICAgZm9udFN0cmluZyArPSB2YWx1ZXMuc2l6ZSArIFwicHggXCIgKyB2YWx1ZXMuZmFjZTtcbiAgICAgIGN0eC5mb250ID0gZm9udFN0cmluZy5yZXBsYWNlKC9cIi9nLCBcIlwiKTtcbiAgICAgIHZhbHVlcy5mb250ID0gY3R4LmZvbnQ7XG4gICAgICB2YWx1ZXMuaGVpZ2h0ID0gdmFsdWVzLnNpemU7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaWZmZXJlbnRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaWZmZXJlbnRTdGF0ZShzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIHJldHVybiBzZWxlY3RlZCAhPT0gdGhpcy5zZWxlY3RlZFN0YXRlIHx8IGhvdmVyICE9PSB0aGlzLmhvdmVyU3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBleHBsb2RlcyB0aGUgcGFzc2VkIHRleHQgaW50byBsaW5lcyBhbmQgZGV0ZXJtaW5lcyB0aGUgd2lkdGgsIGhlaWdodCBhbmQgbnVtYmVyIG9mIGxpbmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGluVGV4dCAgdGhlIHRleHQgdG8gZXhwbG9kZVxuICAgICAqIEByZXR1cm5zIHt7d2lkdGgsIGhlaWdodCwgbGluZXN9fCp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcHJvY2Vzc0xhYmVsVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJvY2Vzc0xhYmVsVGV4dChjdHgsIHNlbGVjdGVkLCBob3ZlciwgaW5UZXh0KSB7XG4gICAgICB2YXIgc3BsaXR0ZXIgPSBuZXcgTGFiZWxTcGxpdHRlcihjdHgsIHRoaXMsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICByZXR1cm4gc3BsaXR0ZXIucHJvY2VzcyhpblRleHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXhwbG9kZXMgdGhlIGxhYmVsIHN0cmluZyBpbnRvIGxpbmVzIGFuZCBzZXRzIHRoZSB3aWR0aCwgaGVpZ2h0IGFuZCBudW1iZXIgb2YgbGluZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9wcm9jZXNzTGFiZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Byb2Nlc3NMYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHRoaXMubGFiZWxEaXJ0eSA9PT0gZmFsc2UgJiYgIXRoaXMuZGlmZmVyZW50U3RhdGUoc2VsZWN0ZWQsIGhvdmVyKSkgcmV0dXJuO1xuICAgICAgdmFyIHN0YXRlID0gdGhpcy5fcHJvY2Vzc0xhYmVsVGV4dChjdHgsIHNlbGVjdGVkLCBob3ZlciwgdGhpcy5lbGVtZW50T3B0aW9ucy5sYWJlbCk7XG4gICAgICBpZiAodGhpcy5mb250T3B0aW9ucy5taW5XZHQgPiAwICYmIHN0YXRlLndpZHRoIDwgdGhpcy5mb250T3B0aW9ucy5taW5XZHQpIHtcbiAgICAgICAgc3RhdGUud2lkdGggPSB0aGlzLmZvbnRPcHRpb25zLm1pbldkdDtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2l6ZS5sYWJlbEhlaWdodCA9IHN0YXRlLmhlaWdodDtcbiAgICAgIGlmICh0aGlzLmZvbnRPcHRpb25zLm1pbkhndCA+IDAgJiYgc3RhdGUuaGVpZ2h0IDwgdGhpcy5mb250T3B0aW9ucy5taW5IZ3QpIHtcbiAgICAgICAgc3RhdGUuaGVpZ2h0ID0gdGhpcy5mb250T3B0aW9ucy5taW5IZ3Q7XG4gICAgICB9XG4gICAgICB0aGlzLmxpbmVzID0gc3RhdGUubGluZXM7XG4gICAgICB0aGlzLmxpbmVDb3VudCA9IHN0YXRlLmxpbmVzLmxlbmd0aDtcbiAgICAgIHRoaXMuc2l6ZS53aWR0aCA9IHN0YXRlLndpZHRoO1xuICAgICAgdGhpcy5zaXplLmhlaWdodCA9IHN0YXRlLmhlaWdodDtcbiAgICAgIHRoaXMuc2VsZWN0ZWRTdGF0ZSA9IHNlbGVjdGVkO1xuICAgICAgdGhpcy5ob3ZlclN0YXRlID0gaG92ZXI7XG4gICAgICB0aGlzLmxhYmVsRGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGlzIGxhYmVsIGlzIHZpc2libGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoaXMgbGFiZWwgd2lsbCBiZSBzaG93LCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ2aXNpYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpc2libGUoKSB7XG4gICAgICBpZiAodGhpcy5zaXplLndpZHRoID09PSAwIHx8IHRoaXMuc2l6ZS5oZWlnaHQgPT09IDAgfHwgdGhpcy5lbGVtZW50T3B0aW9ucy5sYWJlbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gbm90aGluZyB0byBkaXNwbGF5XG4gICAgICB9XG5cbiAgICAgIHZhciB2aWV3Rm9udFNpemUgPSB0aGlzLmZvbnRPcHRpb25zLnNpemUgKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIGlmICh2aWV3Rm9udFNpemUgPCB0aGlzLmVsZW1lbnRPcHRpb25zLnNjYWxpbmcubGFiZWwuZHJhd1RocmVzaG9sZCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBUb28gc21hbGwgb3IgdG9vIGZhciBhd2F5IHRvIHNob3dcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwicGFyc2VGb250U3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhcnNlRm9udFN0cmluZyhvdXRPcHRpb25zLCBpbk9wdGlvbnMpIHtcbiAgICAgIGlmICghaW5PcHRpb25zIHx8IHR5cGVvZiBpbk9wdGlvbnMgIT09IFwic3RyaW5nXCIpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBuZXdPcHRpb25zQXJyYXkgPSBpbk9wdGlvbnMuc3BsaXQoXCIgXCIpO1xuICAgICAgb3V0T3B0aW9ucy5zaXplID0gK25ld09wdGlvbnNBcnJheVswXS5yZXBsYWNlKFwicHhcIiwgXCJcIik7XG4gICAgICBvdXRPcHRpb25zLmZhY2UgPSBuZXdPcHRpb25zQXJyYXlbMV07XG4gICAgICBvdXRPcHRpb25zLmNvbG9yID0gbmV3T3B0aW9uc0FycmF5WzJdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBMYWJlbDtcbn0oKTtcblxudmFyIGlzQ29uc3RydWN0b3IgPSBpc0NvbnN0cnVjdG9yJDQ7XG52YXIgdHJ5VG9TdHJpbmcgPSB0cnlUb1N0cmluZyQ2O1xuXG52YXIgJFR5cGVFcnJvciQxID0gVHlwZUVycm9yO1xuXG4vLyBgQXNzZXJ0OiBJc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSBpcyB0cnVlYFxudmFyIGFDb25zdHJ1Y3RvciQxID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NvbnN0cnVjdG9yKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBuZXcgJFR5cGVFcnJvciQxKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGEgY29uc3RydWN0b3InKTtcbn07XG5cbnZhciAkJDYgPSBfZXhwb3J0O1xudmFyIGdldEJ1aWx0SW4gPSBnZXRCdWlsdEluJGM7XG52YXIgYXBwbHkgPSBmdW5jdGlvbkFwcGx5O1xudmFyIGJpbmQkMyA9IGZ1bmN0aW9uQmluZDtcbnZhciBhQ29uc3RydWN0b3IgPSBhQ29uc3RydWN0b3IkMTtcbnZhciBhbk9iamVjdCQyID0gYW5PYmplY3QkZDtcbnZhciBpc09iamVjdCQzID0gaXNPYmplY3QkajtcbnZhciBjcmVhdGUkMyA9IG9iamVjdENyZWF0ZTtcbnZhciBmYWlscyQyID0gZmFpbHMkdztcblxudmFyIG5hdGl2ZUNvbnN0cnVjdCA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnY29uc3RydWN0Jyk7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBwdXNoJDEgPSBbXS5wdXNoO1xuXG4vLyBgUmVmbGVjdC5jb25zdHJ1Y3RgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZWZsZWN0LmNvbnN0cnVjdFxuLy8gTVMgRWRnZSBzdXBwb3J0cyBvbmx5IDIgYXJndW1lbnRzIGFuZCBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG4vLyBGRiBOaWdodGx5IHNldHMgdGhpcmQgYXJndW1lbnQgYXMgYG5ldy50YXJnZXRgLCBidXQgZG9lcyBub3QgY3JlYXRlIGB0aGlzYCBmcm9tIGl0XG52YXIgTkVXX1RBUkdFVF9CVUcgPSBmYWlscyQyKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gIShuYXRpdmVDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pO1xuXG52YXIgQVJHU19CVUcgPSAhZmFpbHMkMihmdW5jdGlvbiAoKSB7XG4gIG5hdGl2ZUNvbnN0cnVjdChmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbnZhciBGT1JDRUQkMyA9IE5FV19UQVJHRVRfQlVHIHx8IEFSR1NfQlVHO1xuXG4kJDYoeyB0YXJnZXQ6ICdSZWZsZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQkMywgc2hhbTogRk9SQ0VEJDMgfSwge1xuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIGNvbnN0cnVjdChUYXJnZXQsIGFyZ3MgLyogLCBuZXdUYXJnZXQgKi8pIHtcbiAgICBhQ29uc3RydWN0b3IoVGFyZ2V0KTtcbiAgICBhbk9iamVjdCQyKGFyZ3MpO1xuICAgIHZhciBuZXdUYXJnZXQgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IFRhcmdldCA6IGFDb25zdHJ1Y3Rvcihhcmd1bWVudHNbMl0pO1xuICAgIGlmIChBUkdTX0JVRyAmJiAhTkVXX1RBUkdFVF9CVUcpIHJldHVybiBuYXRpdmVDb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzLCBuZXdUYXJnZXQpO1xuICAgIGlmIChUYXJnZXQgPT09IG5ld1RhcmdldCkge1xuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBvcHRpbWl6YXRpb24gZm9yIDAtNCBhcmd1bWVudHNcbiAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOiByZXR1cm4gbmV3IFRhcmdldCgpO1xuICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0pO1xuICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgVGFyZ2V0KGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfVxuICAgICAgLy8gdy9vIGFsdGVyZWQgbmV3VGFyZ2V0LCBsb3Qgb2YgYXJndW1lbnRzIGNhc2VcbiAgICAgIHZhciAkYXJncyA9IFtudWxsXTtcbiAgICAgIGFwcGx5KHB1c2gkMSwgJGFyZ3MsIGFyZ3MpO1xuICAgICAgcmV0dXJuIG5ldyAoYXBwbHkoYmluZCQzLCBUYXJnZXQsICRhcmdzKSkoKTtcbiAgICB9XG4gICAgLy8gd2l0aCBhbHRlcmVkIG5ld1RhcmdldCwgbm90IHN1cHBvcnQgYnVpbHQtaW4gY29uc3RydWN0b3JzXG4gICAgdmFyIHByb3RvID0gbmV3VGFyZ2V0LnByb3RvdHlwZTtcbiAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGUkMyhpc09iamVjdCQzKHByb3RvKSA/IHByb3RvIDogT2JqZWN0UHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gYXBwbHkoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0JDMocmVzdWx0KSA/IHJlc3VsdCA6IGluc3RhbmNlO1xuICB9XG59KTtcblxudmFyIHBhdGgkNiA9IHBhdGgkdztcblxudmFyIGNvbnN0cnVjdCQyID0gcGF0aCQ2LlJlZmxlY3QuY29uc3RydWN0O1xuXG52YXIgcGFyZW50JGsgPSBjb25zdHJ1Y3QkMjtcblxudmFyIGNvbnN0cnVjdCQxID0gcGFyZW50JGs7XG5cbnZhciBjb25zdHJ1Y3QgPSBjb25zdHJ1Y3QkMTtcblxudmFyIF9SZWZsZWN0JGNvbnN0cnVjdCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhjb25zdHJ1Y3QpO1xuXG52YXIgcGFyZW50JGogPSBjcmVhdGUkNjtcblxudmFyIGNyZWF0ZSQyID0gcGFyZW50JGo7XG5cbnZhciBwYXJlbnQkaSA9IGNyZWF0ZSQyO1xuXG52YXIgY3JlYXRlJDEgPSBwYXJlbnQkaTtcblxudmFyIGNyZWF0ZSA9IGNyZWF0ZSQxO1xuXG52YXIgX09iamVjdCRjcmVhdGUgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoY3JlYXRlKTtcblxudmFyICQkNSA9IF9leHBvcnQ7XG52YXIgc2V0UHJvdG90eXBlT2YkNSA9IG9iamVjdFNldFByb3RvdHlwZU9mO1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnNldHByb3RvdHlwZW9mXG4kJDUoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlIH0sIHtcbiAgc2V0UHJvdG90eXBlT2Y6IHNldFByb3RvdHlwZU9mJDVcbn0pO1xuXG52YXIgcGF0aCQ1ID0gcGF0aCR3O1xuXG52YXIgc2V0UHJvdG90eXBlT2YkNCA9IHBhdGgkNS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG5cbnZhciBwYXJlbnQkaCA9IHNldFByb3RvdHlwZU9mJDQ7XG5cbnZhciBzZXRQcm90b3R5cGVPZiQzID0gcGFyZW50JGg7XG5cbnZhciBwYXJlbnQkZyA9IHNldFByb3RvdHlwZU9mJDM7XG5cbnZhciBzZXRQcm90b3R5cGVPZiQyID0gcGFyZW50JGc7XG5cbnZhciBwYXJlbnQkZiA9IHNldFByb3RvdHlwZU9mJDI7XG5cbnZhciBzZXRQcm90b3R5cGVPZiQxID0gcGFyZW50JGY7XG5cbnZhciBzZXRQcm90b3R5cGVPZiA9IHNldFByb3RvdHlwZU9mJDE7XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU9mID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHNldFByb3RvdHlwZU9mKTtcblxudmFyIHBhcmVudCRlID0gYmluZCQ5O1xuXG52YXIgYmluZCQyID0gcGFyZW50JGU7XG5cbnZhciBwYXJlbnQkZCA9IGJpbmQkMjtcblxudmFyIGJpbmQkMSA9IHBhcmVudCRkO1xuXG52YXIgYmluZCA9IGJpbmQkMTtcblxudmFyIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhiaW5kKTtcblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgdmFyIF9jb250ZXh0O1xuICBfc2V0UHJvdG90eXBlT2YgPSBfT2JqZWN0JHNldFByb3RvdHlwZU9mID8gX2JpbmRJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0ID0gX09iamVjdCRzZXRQcm90b3R5cGVPZikuY2FsbChfY29udGV4dCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gX09iamVjdCRjcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIF9PYmplY3QkZGVmaW5lUHJvcGVydHkkMShzdWJDbGFzcywgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICB9XG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG52YXIgcGFyZW50JGMgPSBnZXRQcm90b3R5cGVPZiQ1O1xuXG52YXIgZ2V0UHJvdG90eXBlT2YkMyA9IHBhcmVudCRjO1xuXG52YXIgcGFyZW50JGIgPSBnZXRQcm90b3R5cGVPZiQzO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YkMiA9IHBhcmVudCRiO1xuXG52YXIgZ2V0UHJvdG90eXBlT2YkMSA9IGdldFByb3RvdHlwZU9mJDI7XG5cbnZhciBfT2JqZWN0JGdldFByb3RvdHlwZU9mID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGdldFByb3RvdHlwZU9mJDEpO1xuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICB2YXIgX2NvbnRleHQ7XG4gIF9nZXRQcm90b3R5cGVPZiA9IF9PYmplY3Qkc2V0UHJvdG90eXBlT2YgPyBfYmluZEluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQgPSBfT2JqZWN0JGdldFByb3RvdHlwZU9mKS5jYWxsKF9jb250ZXh0KSA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gICAgcmV0dXJuIG8uX19wcm90b19fIHx8IF9PYmplY3QkZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbi8qKlxuICogVGhlIEJhc2UgY2xhc3MgZm9yIGFsbCBOb2Rlcy5cbiAqL1xudmFyIE5vZGVCYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBOb2RlQmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlQmFzZSk7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmxhYmVsTW9kdWxlID0gbGFiZWxNb2R1bGU7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWFyZ2luID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmVmcmVzaE5lZWRlZCA9IHRydWU7XG4gICAgdGhpcy5ib3VuZGluZ0JveCA9IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhOb2RlQmFzZSwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldE1hcmdpbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldE1hcmdpbnMobGFiZWxNb2R1bGUpIHtcbiAgICAgIHRoaXMubWFyZ2luID0ge307XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm1hcmdpbikge1xuICAgICAgICBpZiAoX3R5cGVvZih0aGlzLm9wdGlvbnMubWFyZ2luKSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhpcy5tYXJnaW4udG9wID0gdGhpcy5vcHRpb25zLm1hcmdpbi50b3A7XG4gICAgICAgICAgdGhpcy5tYXJnaW4ucmlnaHQgPSB0aGlzLm9wdGlvbnMubWFyZ2luLnJpZ2h0O1xuICAgICAgICAgIHRoaXMubWFyZ2luLmJvdHRvbSA9IHRoaXMub3B0aW9ucy5tYXJnaW4uYm90dG9tO1xuICAgICAgICAgIHRoaXMubWFyZ2luLmxlZnQgPSB0aGlzLm9wdGlvbnMubWFyZ2luLmxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tYXJnaW4udG9wID0gdGhpcy5vcHRpb25zLm1hcmdpbjtcbiAgICAgICAgICB0aGlzLm1hcmdpbi5yaWdodCA9IHRoaXMub3B0aW9ucy5tYXJnaW47XG4gICAgICAgICAgdGhpcy5tYXJnaW4uYm90dG9tID0gdGhpcy5vcHRpb25zLm1hcmdpbjtcbiAgICAgICAgICB0aGlzLm1hcmdpbi5sZWZ0ID0gdGhpcy5vcHRpb25zLm1hcmdpbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFiZWxNb2R1bGUuYWRqdXN0U2l6ZXModGhpcy5tYXJnaW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5hYnModGhpcy53aWR0aCAvIDIgLyBNYXRoLmNvcyhhbmdsZSkpLCBNYXRoLmFicyh0aGlzLmhlaWdodCAvIDIgLyBNYXRoLnNpbihhbmdsZSkpKSArIGJvcmRlcldpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJlbmFibGVTaGFkb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLnNoYWRvdykge1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSB2YWx1ZXMuc2hhZG93Q29sb3I7XG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gdmFsdWVzLnNoYWRvd1NpemU7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gdmFsdWVzLnNoYWRvd1g7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gdmFsdWVzLnNoYWRvd1k7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRpc2FibGVTaGFkb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5zaGFkb3cpIHtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gXCJyZ2JhKDAsMCwwLDApXCI7XG4gICAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSAwO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImVuYWJsZUJvcmRlckRhc2hlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVCb3JkZXJEYXNoZXMoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuYm9yZGVyRGFzaGVzICE9PSBmYWxzZSkge1xuICAgICAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZGFzaGVzID0gdmFsdWVzLmJvcmRlckRhc2hlcztcbiAgICAgICAgICBpZiAoZGFzaGVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBkYXNoZXMgPSBbNSwgMTVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguc2V0TGluZURhc2goZGFzaGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRMaW5lRGFzaCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gVGhlIGRhc2hlZCBib3JkZXJzIGNhbm5vdCBiZSB1c2VkLlwiKTtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlckRhc2hlcyA9IGZhbHNlO1xuICAgICAgICAgIHZhbHVlcy5ib3JkZXJEYXNoZXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXNhYmxlQm9yZGVyRGFzaGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVCb3JkZXJEYXNoZXMoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuYm9yZGVyRGFzaGVzICE9PSBmYWxzZSkge1xuICAgICAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjdHguc2V0TGluZURhc2goWzBdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRMaW5lRGFzaCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gVGhlIGRhc2hlZCBib3JkZXJzIGNhbm5vdCBiZSB1c2VkLlwiKTtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlckRhc2hlcyA9IGZhbHNlO1xuICAgICAgICAgIHZhbHVlcy5ib3JkZXJEYXNoZXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgc2hhcGUgb2YgYSBub2RlIG5lZWRzIHRvIGJlIHJlY2FsY3VsYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm5lZWRzUmVmcmVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBuZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICBpZiAodGhpcy5yZWZyZXNoTmVlZGVkID09PSB0cnVlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgcHJvYmFibHkgbm90IHRoZSBiZXN0IGxvY2F0aW9uIHRvIHJlc2V0IHRoaXMgbWVtYmVyLlxuICAgICAgICAvLyBIb3dldmVyLCBpbiB0aGUgY3VycmVudCBsb2dpYywgaXQgaXMgdGhlIG1vc3QgY29udmVuaWVudCBvbmUuXG4gICAgICAgIHRoaXMucmVmcmVzaE5lZWRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndpZHRoID09PSB1bmRlZmluZWQgfHwgdGhpcy5sYWJlbE1vZHVsZS5kaWZmZXJlbnRTdGF0ZShzZWxlY3RlZCwgaG92ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpbml0Q29udGV4dEZvckRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKSB7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSB2YWx1ZXMuYm9yZGVyV2lkdGggLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLm1pbih0aGlzLndpZHRoLCBib3JkZXJXaWR0aCk7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZXMuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdmFsdWVzLmNvbG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwZXJmb3JtU3Ryb2tlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBlcmZvcm1TdHJva2UoY3R4LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IHZhbHVlcy5ib3JkZXJXaWR0aCAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuXG4gICAgICAvL2RyYXcgZGFzaGVkIGJvcmRlciBpZiBlbmFibGVkLCBzYXZlIGFuZCByZXN0b3JlIGlzIHJlcXVpcmVkIGZvciBmaXJlZm94IG5vdCB0byBjcmFzaCBvbiB1bml4LlxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIC8vIGlmIGJvcmRlcnMgYXJlIHplcm8gd2lkdGgsIHRoZXkgd2lsbCBiZSBkcmF3biB3aXRoIHdpZHRoIDEgYnkgZGVmYXVsdC4gVGhpcyBwcmV2ZW50cyB0aGF0XG4gICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlQm9yZGVyRGFzaGVzKGN0eCwgdmFsdWVzKTtcbiAgICAgICAgLy9kcmF3IHRoZSBib3JkZXJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAvL2Rpc2FibGUgZGFzaGVkIGJvcmRlciBmb3Igb3RoZXIgZWxlbWVudHNcbiAgICAgICAgdGhpcy5kaXNhYmxlQm9yZGVyRGFzaGVzKGN0eCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInBlcmZvcm1GaWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBlcmZvcm1GaWxsKGN0eCwgdmFsdWVzKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHZhbHVlcy5jb2xvcjtcbiAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIC8vIGRyYXcgdGhlIGJhY2tncm91bmRcbiAgICAgIF9maWxsSW5zdGFuY2VQcm9wZXJ0eShjdHgpLmNhbGwoY3R4KTtcbiAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMucGVyZm9ybVN0cm9rZShjdHgsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWFyZ2luXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfYWRkQm91bmRpbmdCb3hNYXJnaW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEJvdW5kaW5nQm94TWFyZ2luKG1hcmdpbikge1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0IC09IG1hcmdpbjtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wIC09IG1hcmdpbjtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICs9IG1hcmdpbjtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgKz0gbWFyZ2luO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFjdHVhbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBjYWxsLlxuICAgICAqXG4gICAgICogRG9pbmcgaXQgbGlrZSB0aGlzIG1ha2VzIGl0IGVhc2llciB0byBvdmVycmlkZVxuICAgICAqIGluIHRoZSBjaGlsZCBjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIGlmIChjdHggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB9XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHRoaXMudG9wO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB0aGlzLnRvcCArIHRoaXMuaGVpZ2h0O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHRoaXMubGVmdCArIHRoaXMud2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBjYWxsLlxuICAgICAqIFRoaXMgYWN0cyBhcyBhIHN0dWIgd2hpY2ggY2FuIGJlIG92ZXJyaWRkZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICB0aGlzLl91cGRhdGVCb3VuZGluZ0JveCh4LCB5LCBjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBkaW1lbnNpb25zIHRvIHVzZSBmb3Igbm9kZXMgd2l0aCBhbiBpbnRlcm5hbCBsYWJlbFxuICAgICAqXG4gICAgICogQ3VycmVudGx5LCB0aGVzZSBhcmU6IENpcmNsZSwgRWxsaXBzZSwgRGF0YWJhc2UsIEJveFxuICAgICAqIFRoZSBvdGhlciBub2RlcyBoYXZlIGV4dGVybmFsIGxhYmVscywgYW5kIHdpbGwgbm90IGNhbGwgdGhpcyBtZXRob2RcbiAgICAgKlxuICAgICAqIElmIHRoZXJlIGlzIG5vIGxhYmVsLCBkZWNlbnQgZGVmYXVsdCB2YWx1ZXMgYXJlIHN1cHBsaWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgICAqIEByZXR1cm5zIHt7d2lkdGg6bnVtYmVyLCBoZWlnaHQ6bnVtYmVyfX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXREaW1lbnNpb25zRnJvbUxhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpbWVuc2lvbnNGcm9tTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIC8vIE5PVEU6IHByZXZpb3VzbHkgJ3RleHRTaXplJyB3YXMgbm90IHB1dCBpbiAndGhpcycgZm9yIEVsbGlwc2VcbiAgICAgIC8vIFRPRE86IGV4YW1pbmUgdGhlIGNvbnNlcXVlbmNlcy5cbiAgICAgIHRoaXMudGV4dFNpemUgPSB0aGlzLmxhYmVsTW9kdWxlLmdldFRleHRTaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMudGV4dFNpemUud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy50ZXh0U2l6ZS5oZWlnaHQ7XG4gICAgICB2YXIgREVGQVVMVF9TSVpFID0gMTQ7XG4gICAgICBpZiAod2lkdGggPT09IDApIHtcbiAgICAgICAgLy8gVGhpcyBoYXBwZW5zIHdoZW4gdGhlcmUgaXMgbm8gbGFiZWwgdGV4dCBzZXRcbiAgICAgICAgd2lkdGggPSBERUZBVUxUX1NJWkU7IC8vIHVzZSBhIGRlY2VudCBkZWZhdWx0XG4gICAgICAgIGhlaWdodCA9IERFRkFVTFRfU0laRTsgLy8gaWYgd2lkdGggemVybywgdGhlbiBoZWlnaHQgYWxzbyBhbHdheXMgemVyb1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTm9kZUJhc2U7XG59KCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRzKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHMoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQSBCb3ggTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBOb2RlQmFzZVxuICovXG52YXIgQm94JDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICBfaW5oZXJpdHMoQm94LCBfTm9kZUJhc2UpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJHMoQm94KTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBCb3gob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJveCk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gICAgX3RoaXMuX3NldE1hcmdpbnMobGFiZWxNb2R1bGUpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhCb3gsIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuaG92ZXI7XG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9uc0Zyb21MYWJlbChjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIHRoaXMud2lkdGggPSBkaW1lbnNpb25zLndpZHRoICsgdGhpcy5tYXJnaW4ucmlnaHQgKyB0aGlzLm1hcmdpbi5sZWZ0O1xuICAgICAgICB0aGlzLmhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0ICsgdGhpcy5tYXJnaW4udG9wICsgdGhpcy5tYXJnaW4uYm90dG9tO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIHRoaXMuaW5pdENvbnRleHRGb3JEcmF3KGN0eCwgdmFsdWVzKTtcbiAgICAgIGRyYXdSb3VuZFJlY3QoY3R4LCB0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdmFsdWVzLmJvcmRlclJhZGl1cyk7XG4gICAgICB0aGlzLnBlcmZvcm1GaWxsKGN0eCwgdmFsdWVzKTtcbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgdGhpcy5sZWZ0ICsgdGhpcy50ZXh0U2l6ZS53aWR0aCAvIDIgKyB0aGlzLm1hcmdpbi5sZWZ0LCB0aGlzLnRvcCArIHRoaXMudGV4dFNpemUuaGVpZ2h0IC8gMiArIHRoaXMubWFyZ2luLnRvcCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHZhciBib3JkZXJSYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmJvcmRlclJhZGl1czsgLy8gb25seSBlZmZlY3RpdmUgZm9yIGJveFxuICAgICAgdGhpcy5fYWRkQm91bmRpbmdCb3hNYXJnaW4oYm9yZGVyUmFkaXVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICB9XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5hYnModGhpcy53aWR0aCAvIDIgLyBNYXRoLmNvcyhhbmdsZSkpLCBNYXRoLmFicyh0aGlzLmhlaWdodCAvIDIgLyBNYXRoLnNpbihhbmdsZSkpKSArIGJvcmRlcldpZHRoO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQm94O1xufShOb2RlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHIoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogTk9URTogVGhpcyBpcyBhIGJhZCBiYXNlIGNsYXNzXG4gKlxuICogQ2hpbGQgY2xhc3NlcyBhcmU6XG4gKlxuICogICBJbWFnZSAgICAgICAtIHVzZXMgKm9ubHkqIGltYWdlIG1ldGhvZHNcbiAqICAgQ2lyY2xlICAgICAgLSB1c2VzICpvbmx5KiBfZHJhd1Jhd0NpcmNsZVxuICogICBDaXJjbGVJbWFnZSAtIHVzZXMgYWxsXG4gKlxuICogVE9ETzogUmVmYWN0b3IsIG1vdmUgX2RyYXdSYXdDaXJjbGUgdG8gZGlmZmVyZW50IG1vZHVsZSwgZGVyaXZlIENpcmNsZSBmcm9tIE5vZGVCYXNlXG4gKiAgICAgICBSZW5hbWUgdGhpcyB0byBJbWFnZUJhc2VcbiAqICAgICAgIENvbnNvbGlkYXRlIGNvbW1vbiBjb2RlIGluIEltYWdlIGFuZCBDaXJjbGVJbWFnZSB0byBiYXNlIGNsYXNzXG4gKlxuICogQGF1Z21lbnRzIE5vZGVCYXNlXG4gKi9cbnZhciBDaXJjbGVJbWFnZUJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICBfaW5oZXJpdHMoQ2lyY2xlSW1hZ2VCYXNlLCBfTm9kZUJhc2UpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJHIoQ2lyY2xlSW1hZ2VCYXNlKTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBDaXJjbGVJbWFnZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmNsZUltYWdlQmFzZSk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gICAgX3RoaXMubGFiZWxPZmZzZXQgPSAwO1xuICAgIF90aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbaW1hZ2VPYmpdXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbaW1hZ2VPYmpBbHRdXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoQ2lyY2xlSW1hZ2VCYXNlLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucywgaW1hZ2VPYmosIGltYWdlT2JqQWx0KSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgaWYgKCEoaW1hZ2VPYmogPT09IHVuZGVmaW5lZCAmJiBpbWFnZU9iakFsdCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB0aGlzLnNldEltYWdlcyhpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaW1hZ2VzIGZvciB0aGlzIG5vZGUuXG4gICAgICpcbiAgICAgKiBUaGUgaW1hZ2VzIGNhbiBiZSB1cGRhdGVkIGFmdGVyIHRoZSBpbml0aWFsIHNldHRpbmcgb2Ygb3B0aW9ucztcbiAgICAgKiB0aGVyZWZvcmUsIHRoaXMgbWV0aG9kIG5lZWRzIHRvIGJlIHJlZW50cmFudC5cbiAgICAgKlxuICAgICAqIEZvciBjb3JyZWN0IHdvcmtpbmcgaW4gZXJyb3IgY2FzZXMsIGl0IGlzIG5lY2Vzc2FyeSB0byBwcm9wZXJseSBzZXRcbiAgICAgKiBmaWVsZCAnbm9kZXMuYnJva2VuSW1hZ2UnIGluIHRoZSBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VPYmogIHJlcXVpcmVkOyBtYWluIGltYWdlIHRvIHNob3cgZm9yIHRoaXMgbm9kZVxuICAgICAqIEBwYXJhbSB7SW1hZ2V8dW5kZWZpbmVkfSBpbWFnZU9iakFsdCBvcHRpb25hbDsgaW1hZ2UgdG8gc2hvdyB3aGVuIG5vZGUgaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRJbWFnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW1hZ2VzKGltYWdlT2JqLCBpbWFnZU9iakFsdCkge1xuICAgICAgaWYgKGltYWdlT2JqQWx0ICYmIHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5pbWFnZU9iaiA9IGltYWdlT2JqQWx0O1xuICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gaW1hZ2VPYmo7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmltYWdlT2JqID0gaW1hZ2VPYmo7XG4gICAgICAgIHRoaXMuaW1hZ2VPYmpBbHQgPSBpbWFnZU9iakFsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgc2VsZWN0aW9uIGFuZCBzd2l0Y2ggYmV0d2VlbiB0aGUgYmFzZSBhbmQgdGhlIHNlbGVjdGVkIGltYWdlLlxuICAgICAqXG4gICAgICogRG8gdGhlIHN3aXRjaCBvbmx5IGlmIGltYWdlT2JqQWx0IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWQgdmFsdWUgb2YgbmV3IHNlbGVjdGVkIHN0YXRlIGZvciBjdXJyZW50IG5vZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzd2l0Y2hJbWFnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3dpdGNoSW1hZ2VzKHNlbGVjdGVkKSB7XG4gICAgICB2YXIgc2VsZWN0aW9uX2NoYW5nZWQgPSBzZWxlY3RlZCAmJiAhdGhpcy5zZWxlY3RlZCB8fCAhc2VsZWN0ZWQgJiYgdGhpcy5zZWxlY3RlZDtcbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSBzZWxlY3RlZDsgLy8gUmVtZW1iZXIgbmV3IHNlbGVjdGlvblxuXG4gICAgICBpZiAodGhpcy5pbWFnZU9iakFsdCAhPT0gdW5kZWZpbmVkICYmIHNlbGVjdGlvbl9jaGFuZ2VkKSB7XG4gICAgICAgIHZhciBpbWFnZVRtcCA9IHRoaXMuaW1hZ2VPYmo7XG4gICAgICAgIHRoaXMuaW1hZ2VPYmogPSB0aGlzLmltYWdlT2JqQWx0O1xuICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gaW1hZ2VUbXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBJbWFnZSBQYWRkaW5nIGZyb20gbm9kZSBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e3RvcDogbnVtYmVyLGxlZnQ6IG51bWJlcixib3R0b206IG51bWJlcixyaWdodDogbnVtYmVyfX0gaW1hZ2UgcGFkZGluZyBpbnNpZGUgdGhpcyBzaGFwZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEltYWdlUGFkZGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0SW1hZ2VQYWRkaW5nKCkge1xuICAgICAgdmFyIGltZ1BhZGRpbmcgPSB7XG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgbGVmdDogMFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2VQYWRkaW5nKSB7XG4gICAgICAgIHZhciBvcHRJbWdQYWRkaW5nID0gdGhpcy5vcHRpb25zLmltYWdlUGFkZGluZztcbiAgICAgICAgaWYgKF90eXBlb2Yob3B0SW1nUGFkZGluZykgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGltZ1BhZGRpbmcudG9wID0gb3B0SW1nUGFkZGluZy50b3A7XG4gICAgICAgICAgaW1nUGFkZGluZy5yaWdodCA9IG9wdEltZ1BhZGRpbmcucmlnaHQ7XG4gICAgICAgICAgaW1nUGFkZGluZy5ib3R0b20gPSBvcHRJbWdQYWRkaW5nLmJvdHRvbTtcbiAgICAgICAgICBpbWdQYWRkaW5nLmxlZnQgPSBvcHRJbWdQYWRkaW5nLmxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW1nUGFkZGluZy50b3AgPSBvcHRJbWdQYWRkaW5nO1xuICAgICAgICAgIGltZ1BhZGRpbmcucmlnaHQgPSBvcHRJbWdQYWRkaW5nO1xuICAgICAgICAgIGltZ1BhZGRpbmcuYm90dG9tID0gb3B0SW1nUGFkZGluZztcbiAgICAgICAgICBpbWdQYWRkaW5nLmxlZnQgPSBvcHRJbWdQYWRkaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW1nUGFkZGluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgdGhlIG5vZGUgZGltZW5zaW9ucyBmb3IgYSBsb2FkZWQgaW1hZ2UuXG4gICAgICpcbiAgICAgKiBQcmU6IHRoaXMuaW1hZ2VPYmogaXMgdmFsaWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcmVzaXplSW1hZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZUltYWdlKCkge1xuICAgICAgdmFyIHdpZHRoLCBoZWlnaHQ7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy51c2VJbWFnZVNpemUgPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgc2l6ZSBwcm9wZXJ0eVxuICAgICAgICB2YXIgcmF0aW9fd2lkdGggPSAxO1xuICAgICAgICB2YXIgcmF0aW9faGVpZ2h0ID0gMTtcblxuICAgICAgICAvLyBPbmx5IGNhbGN1bGF0ZSB0aGUgcHJvcGVyIHJhdGlvIGlmIGJvdGggd2lkdGggYW5kIGhlaWdodCBub3QgemVyb1xuICAgICAgICBpZiAodGhpcy5pbWFnZU9iai53aWR0aCAmJiB0aGlzLmltYWdlT2JqLmhlaWdodCkge1xuICAgICAgICAgIGlmICh0aGlzLmltYWdlT2JqLndpZHRoID4gdGhpcy5pbWFnZU9iai5oZWlnaHQpIHtcbiAgICAgICAgICAgIHJhdGlvX3dpZHRoID0gdGhpcy5pbWFnZU9iai53aWR0aCAvIHRoaXMuaW1hZ2VPYmouaGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByYXRpb19oZWlnaHQgPSB0aGlzLmltYWdlT2JqLmhlaWdodCAvIHRoaXMuaW1hZ2VPYmoud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdpZHRoID0gdGhpcy5vcHRpb25zLnNpemUgKiAyICogcmF0aW9fd2lkdGg7XG4gICAgICAgIGhlaWdodCA9IHRoaXMub3B0aW9ucy5zaXplICogMiAqIHJhdGlvX2hlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVzZSB0aGUgaW1hZ2Ugc2l6ZSB3aXRoIGltYWdlIHBhZGRpbmdcbiAgICAgICAgdmFyIGltZ1BhZGRpbmcgPSB0aGlzLl9nZXRJbWFnZVBhZGRpbmcoKTtcbiAgICAgICAgd2lkdGggPSB0aGlzLmltYWdlT2JqLndpZHRoICsgaW1nUGFkZGluZy5sZWZ0ICsgaW1nUGFkZGluZy5yaWdodDtcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5pbWFnZU9iai5oZWlnaHQgKyBpbWdQYWRkaW5nLnRvcCArIGltZ1BhZGRpbmcuYm90dG9tO1xuICAgICAgfVxuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLnJhZGl1cyA9IDAuNSAqIHRoaXMud2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd1Jhd0NpcmNsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd1Jhd0NpcmNsZShjdHgsIHgsIHksIHZhbHVlcykge1xuICAgICAgdGhpcy5pbml0Q29udGV4dEZvckRyYXcoY3R4LCB2YWx1ZXMpO1xuICAgICAgZHJhd0NpcmNsZShjdHgsIHgsIHksIHZhbHVlcy5zaXplKTtcbiAgICAgIHRoaXMucGVyZm9ybUZpbGwoY3R4LCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3SW1hZ2VBdFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodGhpcy5pbWFnZU9iai53aWR0aCAhPSAwKSB7XG4gICAgICAgIC8vIGRyYXcgdGhlIGltYWdlXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHZhbHVlcy5vcGFjaXR5ICE9PSB1bmRlZmluZWQgPyB2YWx1ZXMub3BhY2l0eSA6IDE7XG5cbiAgICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgICB0aGlzLmVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICAgIHZhciBmYWN0b3IgPSAxO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5pbnRlcnBvbGF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgZmFjdG9yID0gdGhpcy5pbWFnZU9iai53aWR0aCAvIHRoaXMud2lkdGggLyB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW1nUGFkZGluZyA9IHRoaXMuX2dldEltYWdlUGFkZGluZygpO1xuICAgICAgICB2YXIgaW1nUG9zTGVmdCA9IHRoaXMubGVmdCArIGltZ1BhZGRpbmcubGVmdDtcbiAgICAgICAgdmFyIGltZ1Bvc1RvcCA9IHRoaXMudG9wICsgaW1nUGFkZGluZy50b3A7XG4gICAgICAgIHZhciBpbWdXaWR0aCA9IHRoaXMud2lkdGggLSBpbWdQYWRkaW5nLmxlZnQgLSBpbWdQYWRkaW5nLnJpZ2h0O1xuICAgICAgICB2YXIgaW1nSGVpZ2h0ID0gdGhpcy5oZWlnaHQgLSBpbWdQYWRkaW5nLnRvcCAtIGltZ1BhZGRpbmcuYm90dG9tO1xuICAgICAgICB0aGlzLmltYWdlT2JqLmRyYXdJbWFnZUF0UG9zaXRpb24oY3R4LCBmYWN0b3IsIGltZ1Bvc0xlZnQsIGltZ1Bvc1RvcCwgaW1nV2lkdGgsIGltZ0hlaWdodCk7XG5cbiAgICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd0ltYWdlTGFiZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdJbWFnZUxhYmVsKGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIGlmICh0aGlzLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9mZnNldCA9IHRoaXMuaGVpZ2h0ICogMC41O1xuICAgICAgICB2YXIgbGFiZWxEaW1lbnNpb25zID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRUZXh0U2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICAgIGlmIChsYWJlbERpbWVuc2lvbnMubGluZUNvdW50ID49IDEpIHtcbiAgICAgICAgICBvZmZzZXQgKz0gbGFiZWxEaW1lbnNpb25zLmhlaWdodCAvIDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB5TGFiZWwgPSB5ICsgb2Zmc2V0O1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCkge1xuICAgICAgICB0aGlzLmxhYmVsT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfVxuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgeCwgeUxhYmVsLCBzZWxlY3RlZCwgaG92ZXIsIFwiaGFuZ2luZ1wiKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENpcmNsZUltYWdlQmFzZTtcbn0oTm9kZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkcShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRxKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JHEoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIEEgQ2lyY2xlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgQ2lyY2xlSW1hZ2VCYXNlXG4gKi9cbnZhciBDaXJjbGUkMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NpcmNsZUltYWdlQmFzZSkge1xuICBfaW5oZXJpdHMoQ2lyY2xlLCBfQ2lyY2xlSW1hZ2VCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRxKENpcmNsZSk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gQ2lyY2xlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjbGUpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICAgIF90aGlzLl9zZXRNYXJnaW5zKGxhYmVsTW9kdWxlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoQ2lyY2xlLCBbe1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCkge1xuICAgICAgdmFyIHNlbGVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnNlbGVjdGVkO1xuICAgICAgdmFyIGhvdmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLmhvdmVyO1xuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmdldERpbWVuc2lvbnNGcm9tTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICB2YXIgZGlhbWV0ZXIgPSBNYXRoLm1heChkaW1lbnNpb25zLndpZHRoICsgdGhpcy5tYXJnaW4ucmlnaHQgKyB0aGlzLm1hcmdpbi5sZWZ0LCBkaW1lbnNpb25zLmhlaWdodCArIHRoaXMubWFyZ2luLnRvcCArIHRoaXMubWFyZ2luLmJvdHRvbSk7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zaXplID0gZGlhbWV0ZXIgLyAyOyAvLyBOT1RFOiB0aGlzIHNpemUgZmllbGQgb25seSBzZXQgaGVyZSwgbm90IGluIEVsbGlwc2UsIERhdGFiYXNlLCBCb3hcbiAgICAgICAgdGhpcy53aWR0aCA9IGRpYW1ldGVyO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGRpYW1ldGVyO1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIHRoaXMuX2RyYXdSYXdDaXJjbGUoY3R4LCB4LCB5LCB2YWx1ZXMpO1xuICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHRoaXMubGVmdCArIHRoaXMudGV4dFNpemUud2lkdGggLyAyICsgdGhpcy5tYXJnaW4ubGVmdCwgeSwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQm91bmRpbmdCb3goeCwgeSkge1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB5IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB5ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4KSB7XG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53aWR0aCAqIDAuNTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENpcmNsZTtcbn0oQ2lyY2xlSW1hZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJHAoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkcCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRwKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBBIENpcmN1bGFySW1hZ2UgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBDaXJjbGVJbWFnZUJhc2VcbiAqL1xudmFyIENpcmN1bGFySW1hZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DaXJjbGVJbWFnZUJhc2UpIHtcbiAgX2luaGVyaXRzKENpcmN1bGFySW1hZ2UsIF9DaXJjbGVJbWFnZUJhc2UpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJHAoQ2lyY3VsYXJJbWFnZSk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZU9ialxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZU9iakFsdFxuICAgKi9cbiAgZnVuY3Rpb24gQ2lyY3VsYXJJbWFnZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSwgaW1hZ2VPYmosIGltYWdlT2JqQWx0KSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDaXJjdWxhckltYWdlKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgICBfdGhpcy5zZXRJbWFnZXMoaW1hZ2VPYmosIGltYWdlT2JqQWx0KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoQ2lyY3VsYXJJbWFnZSwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zZWxlY3RlZDtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5ob3ZlcjtcbiAgICAgIHZhciBpbWFnZUFic2VudCA9IHRoaXMuaW1hZ2VPYmouc3JjID09PSB1bmRlZmluZWQgfHwgdGhpcy5pbWFnZU9iai53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaW1hZ2VPYmouaGVpZ2h0ID09PSB1bmRlZmluZWQ7XG4gICAgICBpZiAoaW1hZ2VBYnNlbnQpIHtcbiAgICAgICAgdmFyIGRpYW1ldGVyID0gdGhpcy5vcHRpb25zLnNpemUgKiAyO1xuICAgICAgICB0aGlzLndpZHRoID0gZGlhbWV0ZXI7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZGlhbWV0ZXI7XG4gICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBdCB0aGlzIHBvaW50LCBhbiBpbWFnZSBpcyBwcmVzZW50LCBpLmUuIHRoaXMuaW1hZ2VPYmogaXMgdmFsaWQuXG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB0aGlzLl9yZXNpemVJbWFnZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuc3dpdGNoSW1hZ2VzKHNlbGVjdGVkKTtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICB2YXIgbGFiZWxYID0geCxcbiAgICAgICAgbGFiZWxZID0geTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4gPT09IFwidG9wLWxlZnRcIikge1xuICAgICAgICB0aGlzLmxlZnQgPSB4O1xuICAgICAgICB0aGlzLnRvcCA9IHk7XG4gICAgICAgIGxhYmVsWCArPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgbGFiZWxZICs9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgfVxuXG4gICAgICAvLyBkcmF3IHRoZSBiYWNrZ3JvdW5kIGNpcmNsZS4gSU1QT1JUQU5UOiB0aGUgc3Ryb2tlIGluIHRoaXMgbWV0aG9kIGlzIHVzZWQgYnkgdGhlIGNsaXAgbWV0aG9kIGJlbG93LlxuICAgICAgdGhpcy5fZHJhd1Jhd0NpcmNsZShjdHgsIGxhYmVsWCwgbGFiZWxZLCB2YWx1ZXMpO1xuXG4gICAgICAvLyBub3cgd2UgZHJhdyBpbiB0aGUgY2lyY2xlLCB3ZSBzYXZlIHNvIHdlIGNhbiByZXZlcnQgdGhlIGNsaXAgb3BlcmF0aW9uIGFmdGVyIGRyYXdpbmcuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgLy8gY2xpcCBpcyB1c2VkIHRvIHVzZSB0aGUgc3Ryb2tlIGluIGRyYXdSYXdDaXJjbGUgYXMgYW4gYXJlYSB0aGF0IHdlIGNhbiBkcmF3IGluLlxuICAgICAgY3R4LmNsaXAoKTtcbiAgICAgIC8vIGRyYXcgdGhlIGltYWdlXG4gICAgICB0aGlzLl9kcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCwgdmFsdWVzKTtcbiAgICAgIC8vIHJlc3RvcmUgc28gd2UgY2FuIGFnYWluIGRyYXcgb24gdGhlIGZ1bGwgY2FudmFzXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy5fZHJhd0ltYWdlTGFiZWwoY3R4LCBsYWJlbFgsIGxhYmVsWSwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogY29tcGFyZSB3aXRoIENpcmNsZS51cGRhdGVCb3VuZGluZ0JveCgpLCBjb25zb2xpZGF0ZT8gTW9yZSBzdHVmZiBpcyBoYXBwZW5pbmcgaGVyZVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5jb29yZGluYXRlT3JpZ2luID09PSBcInRvcC1sZWZ0XCIpIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB5O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0geCArIHRoaXMub3B0aW9ucy5zaXplICogMjtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB5ICsgdGhpcy5vcHRpb25zLnNpemUgKiAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB5IC0gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHggLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IHggKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5ib3R0b20gPSB5ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IGNvbXBhcmUgd2l0aCBJbWFnZS51cGRhdGVCb3VuZGluZ0JveCgpLCBjb25zb2xpZGF0ZT9cbiAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IE1hdGgubWluKHRoaXMuYm91bmRpbmdCb3gubGVmdCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQpO1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5yaWdodCA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3gucmlnaHQsIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5sZWZ0ICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoKTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5ib3R0b20sIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICsgdGhpcy5sYWJlbE9mZnNldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4KSB7XG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53aWR0aCAqIDAuNTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENpcmN1bGFySW1hZ2U7XG59KENpcmNsZUltYWdlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRvKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG8oKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgY29uc3RydWN0aW5nIE5vZGUvQ2x1c3RlciBTaGFwZXMuXG4gKlxuICogQGF1Z21lbnRzIE5vZGVCYXNlXG4gKi9cbnZhciBTaGFwZUJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlQmFzZSkge1xuICBfaW5oZXJpdHMoU2hhcGVCYXNlLCBfTm9kZUJhc2UpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJG8oU2hhcGVCYXNlKTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBTaGFwZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2hhcGVCYXNlKTtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2VsZWN0ZWRdXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hvdmVyXVxuICAgKiBAcGFyYW0ge29iamVjdH0gW3ZhbHVlcz17c2l6ZTogdGhpcy5vcHRpb25zLnNpemV9XVxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFNoYXBlQmFzZSwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zZWxlY3RlZDtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5ob3ZlcjtcbiAgICAgIHZhciB2YWx1ZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IHtcbiAgICAgICAgc2l6ZTogdGhpcy5vcHRpb25zLnNpemVcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB2YXIgX3RoaXMkY3VzdG9tU2l6ZVdpZHRoLCBfdGhpcyRjdXN0b21TaXplSGVpZ2g7XG4gICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICB2YXIgc2l6ZSA9IDIgKiB2YWx1ZXMuc2l6ZTtcbiAgICAgICAgdGhpcy53aWR0aCA9IChfdGhpcyRjdXN0b21TaXplV2lkdGggPSB0aGlzLmN1c3RvbVNpemVXaWR0aCkgIT09IG51bGwgJiYgX3RoaXMkY3VzdG9tU2l6ZVdpZHRoICE9PSB2b2lkIDAgPyBfdGhpcyRjdXN0b21TaXplV2lkdGggOiBzaXplO1xuICAgICAgICB0aGlzLmhlaWdodCA9IChfdGhpcyRjdXN0b21TaXplSGVpZ2ggPSB0aGlzLmN1c3RvbVNpemVIZWlnaHQpICE9PSBudWxsICYmIF90aGlzJGN1c3RvbVNpemVIZWlnaCAhPT0gdm9pZCAwID8gX3RoaXMkY3VzdG9tU2l6ZUhlaWdoIDogc2l6ZTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaGFwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplTXVsdGlwbGllciAtIFVudXNlZCEgVE9ETzogUmVtb3ZlIG5leHQgbWFqb3IgcmVsZWFzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdTaGFwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd1NoYXBlKGN0eCwgc2hhcGUsIHNpemVNdWx0aXBsaWVyLCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgdGhpcy5pbml0Q29udGV4dEZvckRyYXcoY3R4LCB2YWx1ZXMpO1xuICAgICAgZ2V0U2hhcGUoc2hhcGUpKGN0eCwgeCwgeSwgdmFsdWVzLnNpemUpO1xuICAgICAgdGhpcy5wZXJmb3JtRmlsbChjdHgsIHZhbHVlcyk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmljb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmljb24uY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY3R4LmZvbnQgPSAoc2VsZWN0ZWQgPyBcImJvbGQgXCIgOiBcIlwiKSArIHRoaXMuaGVpZ2h0IC8gMiArIFwicHggXCIgKyAodGhpcy5vcHRpb25zLmljb24uZmFjZSB8fCBcIkZvbnRBd2Vzb21lXCIpO1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLm9wdGlvbnMuaWNvbi5jb2xvciB8fCBcImJsYWNrXCI7XG4gICAgICAgICAgY3R4LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMub3B0aW9ucy5pY29uLmNvZGUsIHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkcmF3RXh0ZXJuYWxMYWJlbDogZnVuY3Rpb24gZHJhd0V4dGVybmFsTGFiZWwoKSB7XG4gICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gTmVlZCB0byBjYWxsIGZvbGxvd2luZyBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB2YWx1ZSBmb3JcbiAgICAgICAgICAgIC8vIGB0aGlzLmxhYmVsTW9kdWxlLnNpemUuaGVpZ2h0YC5cbiAgICAgICAgICAgIF90aGlzLmxhYmVsTW9kdWxlLmNhbGN1bGF0ZUxhYmVsU2l6ZShjdHgsIHNlbGVjdGVkLCBob3ZlciwgeCwgeSwgXCJoYW5naW5nXCIpO1xuICAgICAgICAgICAgdmFyIHlMYWJlbCA9IHkgKyAwLjUgKiBfdGhpcy5oZWlnaHQgKyAwLjUgKiBfdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodDtcbiAgICAgICAgICAgIF90aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCB4LCB5TGFiZWwsIHNlbGVjdGVkLCBob3ZlciwgXCJoYW5naW5nXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy51cGRhdGVCb3VuZGluZ0JveCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnRvcCA9IHkgLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IHggLSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLnNpemU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IHkgKyB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGggPiAwKSB7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gubGVmdCA9IE1hdGgubWluKHRoaXMuYm91bmRpbmdCb3gubGVmdCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5yaWdodCwgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmxlZnQgKyB0aGlzLmxhYmVsTW9kdWxlLnNpemUud2lkdGgpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSA9IE1hdGgubWF4KHRoaXMuYm91bmRpbmdCb3guYm90dG9tLCB0aGlzLmJvdW5kaW5nQm94LmJvdHRvbSArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS5oZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU2hhcGVCYXNlO1xufShOb2RlQmFzZSk7XG5cbmZ1bmN0aW9uIG93bktleXMkMyhlLCByKSB7IHZhciB0ID0gX09iamVjdCRrZXlzKGUpOyBpZiAoX09iamVjdCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIG8gPSBfT2JqZWN0JGdldE93blByb3BlcnR5U3ltYm9scyhlKTsgciAmJiAobyA9IF9maWx0ZXJJbnN0YW5jZVByb3BlcnR5KG8pLmNhbGwobywgZnVuY3Rpb24gKHIpIHsgcmV0dXJuIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEoZSwgcikuZW51bWVyYWJsZTsgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7IH0gcmV0dXJuIHQ7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMyhlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciBfY29udGV4dCwgX2NvbnRleHQyOyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0ID0gb3duS2V5cyQzKE9iamVjdCh0KSwgITApKS5jYWxsKF9jb250ZXh0LCBmdW5jdGlvbiAocikgeyBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7IH0pIDogX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gX09iamVjdCRkZWZpbmVQcm9wZXJ0aWVzKGUsIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBfZm9yRWFjaEluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQyID0gb3duS2V5cyQzKE9iamVjdCh0KSkpLmNhbGwoX2NvbnRleHQyLCBmdW5jdGlvbiAocikgeyBfT2JqZWN0JGRlZmluZVByb3BlcnR5KGUsIHIsIF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEodCwgcikpOyB9KTsgfSByZXR1cm4gZTsgfVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJG4oRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRuKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBBIEN1c3RvbVNoYXBlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cbnZhciBDdXN0b21TaGFwZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBfaW5oZXJpdHMoQ3VzdG9tU2hhcGUsIF9TaGFwZUJhc2UpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJG4oQ3VzdG9tU2hhcGUpO1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3R4UmVuZGVyZXJcbiAgICovXG4gIGZ1bmN0aW9uIEN1c3RvbVNoYXBlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlLCBjdHhSZW5kZXJlcikge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3VzdG9tU2hhcGUpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUsIGN0eFJlbmRlcmVyKTtcbiAgICBfdGhpcy5jdHhSZW5kZXJlciA9IGN0eFJlbmRlcmVyO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBkaWZmZXJlbnQgbGF5ZXJzLlxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKEN1c3RvbVNoYXBlLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG5cbiAgICAgIC8vIEd1YXJkIHJpZ2h0IGF3YXkgYmVjYXVzZSBzb21lb25lIG1heSBqdXN0IGRyYXcgaW4gdGhlIGZ1bmN0aW9uIGl0c2VsZi5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgZHJhd0xhdGVyID0gdGhpcy5jdHhSZW5kZXJlcih7XG4gICAgICAgIGN0eDogY3R4LFxuICAgICAgICBpZDogdGhpcy5vcHRpb25zLmlkLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgICAgICBob3ZlcjogaG92ZXJcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IF9vYmplY3RTcHJlYWQkMyh7fSwgdmFsdWVzKSxcbiAgICAgICAgbGFiZWw6IHRoaXMub3B0aW9ucy5sYWJlbFxuICAgICAgfSk7XG4gICAgICAvLyBSZW5kZXIgdGhlIG5vZGUgc2hhcGUgYmVsbG93IGFycm93cy5cbiAgICAgIGlmIChkcmF3TGF0ZXIuZHJhd05vZGUgIT0gbnVsbCkge1xuICAgICAgICBkcmF3TGF0ZXIuZHJhd05vZGUoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBpZiAoZHJhd0xhdGVyLmRyYXdFeHRlcm5hbExhYmVsKSB7XG4gICAgICAgIC8vIEd1YXJkIHRoZSBleHRlcm5hbCBsYWJlbCAoYWJvdmUgYXJyb3dzKSBkcmF3aW5nIGZ1bmN0aW9uLlxuICAgICAgICB2YXIgZHJhd0V4dGVybmFsTGFiZWwgPSBkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWw7XG4gICAgICAgIGRyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIGRyYXdFeHRlcm5hbExhYmVsKCk7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChkcmF3TGF0ZXIubm9kZURpbWVuc2lvbnMpIHtcbiAgICAgICAgdGhpcy5jdXN0b21TaXplV2lkdGggPSBkcmF3TGF0ZXIubm9kZURpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgIHRoaXMuY3VzdG9tU2l6ZUhlaWdodCA9IGRyYXdMYXRlci5ub2RlRGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZHJhd0xhdGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ3VzdG9tU2hhcGU7XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRtKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JG0oKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkbSgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQSBEYXRhYmFzZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIE5vZGVCYXNlXG4gKi9cbnZhciBEYXRhYmFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGVCYXNlKSB7XG4gIF9pbmhlcml0cyhEYXRhYmFzZSwgX05vZGVCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRtKERhdGFiYXNlKTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBEYXRhYmFzZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGF0YWJhc2UpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICAgIF90aGlzLl9zZXRNYXJnaW5zKGxhYmVsTW9kdWxlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhEYXRhYmFzZSwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmdldERpbWVuc2lvbnNGcm9tTGFiZWwoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICB2YXIgc2l6ZSA9IGRpbWVuc2lvbnMud2lkdGggKyB0aGlzLm1hcmdpbi5yaWdodCArIHRoaXMubWFyZ2luLmxlZnQ7XG4gICAgICAgIHRoaXMud2lkdGggPSBzaXplO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNpemU7XG4gICAgICAgIHRoaXMucmFkaXVzID0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sZWZ0ID0geCAtIHRoaXMud2lkdGggLyAyO1xuICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgdGhpcy5pbml0Q29udGV4dEZvckRyYXcoY3R4LCB2YWx1ZXMpO1xuICAgICAgZHJhd0RhdGFiYXNlKGN0eCwgeCAtIHRoaXMud2lkdGggLyAyLCB5IC0gdGhpcy5oZWlnaHQgLyAyLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICB0aGlzLnBlcmZvcm1GaWxsKGN0eCwgdmFsdWVzKTtcbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgdGhpcy5sZWZ0ICsgdGhpcy50ZXh0U2l6ZS53aWR0aCAvIDIgKyB0aGlzLm1hcmdpbi5sZWZ0LCB0aGlzLnRvcCArIHRoaXMudGV4dFNpemUuaGVpZ2h0IC8gMiArIHRoaXMubWFyZ2luLnRvcCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEYXRhYmFzZTtcbn0oTm9kZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkbChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRsKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGwoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIEEgRGlhbW9uZCBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIFNoYXBlQmFzZVxuICovXG52YXIgRGlhbW9uZCQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gIF9pbmhlcml0cyhEaWFtb25kLCBfU2hhcGVCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRsKERpYW1vbmQpO1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtMYWJlbH0gbGFiZWxNb2R1bGVcbiAgICovXG4gIGZ1bmN0aW9uIERpYW1vbmQob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGlhbW9uZCk7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKERpYW1vbmQsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZHJhd1NoYXBlKGN0eCwgXCJkaWFtb25kXCIsIDQsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIERpYW1vbmQ7XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRrKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGsoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQSBEb3QgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBTaGFwZUJhc2VcbiAqL1xudmFyIERvdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBfaW5oZXJpdHMoRG90LCBfU2hhcGVCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRrKERvdCk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gRG90KG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERvdCk7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKERvdCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kcmF3U2hhcGUoY3R4LCBcImNpcmNsZVwiLCAyLCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4KSB7XG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNpemU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBEb3Q7XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRqKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGooKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQW0gRWxsaXBzZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIE5vZGVCYXNlXG4gKi9cbnZhciBFbGxpcHNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgX2luaGVyaXRzKEVsbGlwc2UsIF9Ob2RlQmFzZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkaihFbGxpcHNlKTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBFbGxpcHNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVsbGlwc2UpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoRWxsaXBzZSwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5zZWxlY3RlZDtcbiAgICAgIHZhciBob3ZlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdGhpcy5ob3ZlcjtcbiAgICAgIGlmICh0aGlzLm5lZWRzUmVmcmVzaChzZWxlY3RlZCwgaG92ZXIpKSB7XG4gICAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zRnJvbUxhYmVsKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodCAqIDI7XG4gICAgICAgIHRoaXMud2lkdGggPSBkaW1lbnNpb25zLndpZHRoICsgZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB0aGlzLnJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAqIDAuNTtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0ICogMC41O1xuICAgICAgdGhpcy5pbml0Q29udGV4dEZvckRyYXcoY3R4LCB2YWx1ZXMpO1xuICAgICAgZHJhd0VsbGlwc2UoY3R4LCB0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICB0aGlzLnBlcmZvcm1GaWxsKGN0eCwgdmFsdWVzKTtcbiAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goeCwgeSwgY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIHRoaXMucmVzaXplKGN0eCk7XG4gICAgICB9XG4gICAgICB2YXIgYSA9IHRoaXMud2lkdGggKiAwLjU7XG4gICAgICB2YXIgYiA9IHRoaXMuaGVpZ2h0ICogMC41O1xuICAgICAgdmFyIHcgPSBNYXRoLnNpbihhbmdsZSkgKiBhO1xuICAgICAgdmFyIGggPSBNYXRoLmNvcyhhbmdsZSkgKiBiO1xuICAgICAgcmV0dXJuIGEgKiBiIC8gTWF0aC5zcXJ0KHcgKiB3ICsgaCAqIGgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRWxsaXBzZTtcbn0oTm9kZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkaShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRpKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGkoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG4vKipcbiAqIEFuIGljb24gcmVwbGFjZW1lbnQgZm9yIHRoZSBkZWZhdWx0IE5vZGUgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIE5vZGVCYXNlXG4gKi9cbnZhciBJY29uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgX2luaGVyaXRzKEljb24sIF9Ob2RlQmFzZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkaShJY29uKTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBJY29uKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJY29uKTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgICBfdGhpcy5fc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBVbnVzZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NlbGVjdGVkXVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtob3Zlcl1cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhJY29uLCBbe1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB0aGlzLmljb25TaXplID0ge1xuICAgICAgICAgIHdpZHRoOiBOdW1iZXIodGhpcy5vcHRpb25zLmljb24uc2l6ZSksXG4gICAgICAgICAgaGVpZ2h0OiBOdW1iZXIodGhpcy5vcHRpb25zLmljb24uc2l6ZSlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaWNvblNpemUud2lkdGggKyB0aGlzLm1hcmdpbi5yaWdodCArIHRoaXMubWFyZ2luLmxlZnQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5pY29uU2l6ZS5oZWlnaHQgKyB0aGlzLm1hcmdpbi50b3AgKyB0aGlzLm1hcmdpbi5ib3R0b207XG4gICAgICAgIHRoaXMucmFkaXVzID0gMC41ICogdGhpcy53aWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCB3aWR0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IGhlaWdodFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdGhpcy5yZXNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgdGhpcy5vcHRpb25zLmljb24uc2l6ZSA9IHRoaXMub3B0aW9ucy5pY29uLnNpemUgfHwgNTA7XG4gICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnRvcCA9IHkgLSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB0aGlzLl9pY29uKGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZHJhd0V4dGVybmFsTGFiZWw6IGZ1bmN0aW9uIGRyYXdFeHRlcm5hbExhYmVsKCkge1xuICAgICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgaWNvblRleHRTcGFjaW5nID0gNTtcbiAgICAgICAgICAgIF90aGlzMi5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgX3RoaXMyLmxlZnQgKyBfdGhpczIuaWNvblNpemUud2lkdGggLyAyICsgX3RoaXMyLm1hcmdpbi5sZWZ0LCB5ICsgX3RoaXMyLmhlaWdodCAvIDIgKyBpY29uVGV4dFNwYWNpbmcsIHNlbGVjdGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMyLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpIHtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gudG9wID0geSAtIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LmxlZnQgPSB4IC0gdGhpcy5vcHRpb25zLmljb24uc2l6ZSAqIDAuNTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB4ICsgdGhpcy5vcHRpb25zLmljb24uc2l6ZSAqIDAuNTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0geSArIHRoaXMub3B0aW9ucy5pY29uLnNpemUgKiAwLjU7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sYWJlbE1vZHVsZS5zaXplLndpZHRoID4gMCkge1xuICAgICAgICB2YXIgaWNvblRleHRTcGFjaW5nID0gNTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gTWF0aC5taW4odGhpcy5ib3VuZGluZ0JveC5sZWZ0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5ib3R0b20sIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICsgdGhpcy5sYWJlbE1vZHVsZS5zaXplLmhlaWdodCArIGljb25UZXh0U3BhY2luZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBob3ZlciAtIFVudXNlZFxuICAgICAqIEBwYXJhbSB7QXJyb3dPcHRpb25zfSB2YWx1ZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfaWNvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaWNvbihjdHgsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKSB7XG4gICAgICB2YXIgaWNvblNpemUgPSBOdW1iZXIodGhpcy5vcHRpb25zLmljb24uc2l6ZSk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmljb24uY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5mb250ID0gW3RoaXMub3B0aW9ucy5pY29uLndlaWdodCAhPSBudWxsID8gdGhpcy5vcHRpb25zLmljb24ud2VpZ2h0IDogc2VsZWN0ZWQgPyBcImJvbGRcIiA6IFwiXCIsXG4gICAgICAgIC8vIElmIHRoZSB3ZWlnaHQgaXMgZm9yY2VkIChmb3IgZXhhbXBsZSB0byBtYWtlIEZvbnQgQXdlc29tZSA1IHdvcmtcbiAgICAgICAgLy8gcHJvcGVybHkpIHN1YnN0aXR1dGUgc2xpZ2h0bHkgYmlnZ2VyIHNpemUgZm9yIGJvbGQgZm9udCBmYWNlLlxuICAgICAgICAodGhpcy5vcHRpb25zLmljb24ud2VpZ2h0ICE9IG51bGwgJiYgc2VsZWN0ZWQgPyA1IDogMCkgKyBpY29uU2l6ZSArIFwicHhcIiwgdGhpcy5vcHRpb25zLmljb24uZmFjZV0uam9pbihcIiBcIik7XG5cbiAgICAgICAgLy8gZHJhdyBpY29uXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLm9wdGlvbnMuaWNvbi5jb2xvciB8fCBcImJsYWNrXCI7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcblxuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMub3B0aW9ucy5pY29uLmNvZGUsIHgsIHkpO1xuXG4gICAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiV2hlbiB1c2luZyB0aGUgaWNvbiBzaGFwZSwgeW91IG5lZWQgdG8gZGVmaW5lIHRoZSBjb2RlIGluIHRoZSBpY29uIG9wdGlvbnMgb2JqZWN0LiBUaGlzIGNhbiBiZSBkb25lIHBlciBub2RlIG9yIGdsb2JhbGx5LlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEljb247XG59KE5vZGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGgoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkaCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRoKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBBbiBpbWFnZS1iYXNlZCByZXBsYWNlbWVudCBmb3IgdGhlIGRlZmF1bHQgTm9kZSBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgQ2lyY2xlSW1hZ2VCYXNlXG4gKi9cbnZhciBJbWFnZSQyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2lyY2xlSW1hZ2VCYXNlKSB7XG4gIF9pbmhlcml0cyhJbWFnZSwgX0NpcmNsZUltYWdlQmFzZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkaChJbWFnZSk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZU9ialxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZU9iakFsdFxuICAgKi9cbiAgZnVuY3Rpb24gSW1hZ2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUsIGltYWdlT2JqLCBpbWFnZU9iakFsdCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW1hZ2UpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICAgIF90aGlzLnNldEltYWdlcyhpbWFnZU9iaiwgaW1hZ2VPYmpBbHQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gVW51c2VkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzZWxlY3RlZF1cbiAgICogQHBhcmFtIHtib29sZWFufSBbaG92ZXJdXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoSW1hZ2UsIFt7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoY3R4KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc2VsZWN0ZWQ7XG4gICAgICB2YXIgaG92ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuaG92ZXI7XG4gICAgICB2YXIgaW1hZ2VBYnNlbnQgPSB0aGlzLmltYWdlT2JqLnNyYyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuaW1hZ2VPYmoud2lkdGggPT09IHVuZGVmaW5lZCB8fCB0aGlzLmltYWdlT2JqLmhlaWdodCA9PT0gdW5kZWZpbmVkO1xuICAgICAgaWYgKGltYWdlQWJzZW50KSB7XG4gICAgICAgIHZhciBzaWRlID0gdGhpcy5vcHRpb25zLnNpemUgKiAyO1xuICAgICAgICB0aGlzLndpZHRoID0gc2lkZTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzaWRlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWVkc1JlZnJlc2goc2VsZWN0ZWQsIGhvdmVyKSkge1xuICAgICAgICB0aGlzLl9yZXNpemVJbWFnZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLnN3aXRjaEltYWdlcyhzZWxlY3RlZCk7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgdmFyIGxhYmVsWCA9IHgsXG4gICAgICAgIGxhYmVsWSA9IHk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXBlUHJvcGVydGllcy5jb29yZGluYXRlT3JpZ2luID09PSBcInRvcC1sZWZ0XCIpIHtcbiAgICAgICAgdGhpcy5sZWZ0ID0geDtcbiAgICAgICAgdGhpcy50b3AgPSB5O1xuICAgICAgICBsYWJlbFggKz0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIGxhYmVsWSArPSB0aGlzLmhlaWdodCAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxlZnQgPSB4IC0gdGhpcy53aWR0aCAvIDI7XG4gICAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLnVzZUJvcmRlcldpdGhJbWFnZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgbmV1dHJhbGJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoO1xuICAgICAgICB2YXIgc2VsZWN0aW9uTGluZVdpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoU2VsZWN0ZWQgfHwgMiAqIHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gKHNlbGVjdGVkID8gc2VsZWN0aW9uTGluZVdpZHRoIDogbmV1dHJhbGJvcmRlcldpZHRoKSAvIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5taW4odGhpcy53aWR0aCwgYm9yZGVyV2lkdGgpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciBzdHJva2VTdHlsZSA9IHNlbGVjdGVkID8gdGhpcy5vcHRpb25zLmNvbG9yLmhpZ2hsaWdodC5ib3JkZXIgOiBob3ZlciA/IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5ib3JkZXIgOiB0aGlzLm9wdGlvbnMuY29sb3IuYm9yZGVyO1xuICAgICAgICB2YXIgZmlsbFN0eWxlID0gc2VsZWN0ZWQgPyB0aGlzLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJhY2tncm91bmQgOiBob3ZlciA/IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5iYWNrZ3JvdW5kIDogdGhpcy5vcHRpb25zLmNvbG9yLmJhY2tncm91bmQ7XG4gICAgICAgIGlmICh2YWx1ZXMub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3Ryb2tlU3R5bGUgPSBvdmVycmlkZU9wYWNpdHkoc3Ryb2tlU3R5bGUsIHZhbHVlcy5vcGFjaXR5KTtcbiAgICAgICAgICBmaWxsU3R5bGUgPSBvdmVycmlkZU9wYWNpdHkoZmlsbFN0eWxlLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0dXAgdGhlIGxpbmUgcHJvcGVydGllcy5cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlU3R5bGU7XG5cbiAgICAgICAgLy8gc2V0IGEgZmlsbHN0eWxlXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG5cbiAgICAgICAgLy8gZHJhdyBhIHJlY3RhbmdsZSB0byBmb3JtIHRoZSBib3JkZXIgYXJvdW5kLiBUaGlzIHJlY3RhbmdsZSBpcyBmaWxsZWQgc28gdGhlIG9wYWNpdHkgb2YgYSBwaWN0dXJlIChpbiBmdXR1cmUgdmlzIHJlbGVhc2VzPykgY2FuIGJlIHVzZWQgdG8gdGludCB0aGUgaW1hZ2VcbiAgICAgICAgY3R4LnJlY3QodGhpcy5sZWZ0IC0gMC41ICogY3R4LmxpbmVXaWR0aCwgdGhpcy50b3AgLSAwLjUgKiBjdHgubGluZVdpZHRoLCB0aGlzLndpZHRoICsgY3R4LmxpbmVXaWR0aCwgdGhpcy5oZWlnaHQgKyBjdHgubGluZVdpZHRoKTtcbiAgICAgICAgX2ZpbGxJbnN0YW5jZVByb3BlcnR5KGN0eCkuY2FsbChjdHgpO1xuICAgICAgICB0aGlzLnBlcmZvcm1TdHJva2UoY3R4LCB2YWx1ZXMpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kcmF3SW1hZ2VBdFBvc2l0aW9uKGN0eCwgdmFsdWVzKTtcbiAgICAgIHRoaXMuX2RyYXdJbWFnZUxhYmVsKGN0eCwgbGFiZWxYLCBsYWJlbFksIHNlbGVjdGVkLCBob3Zlcik7XG4gICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHkpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVCb3VuZGluZ0JveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVCb3VuZGluZ0JveCh4LCB5KSB7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuY29vcmRpbmF0ZU9yaWdpbiA9PT0gXCJ0b3AtbGVmdFwiKSB7XG4gICAgICAgIHRoaXMubGVmdCA9IHg7XG4gICAgICAgIHRoaXMudG9wID0geTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgICAgdGhpcy50b3AgPSB5IC0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgfVxuICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gdGhpcy5sZWZ0O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC50b3AgPSB0aGlzLnRvcDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gdGhpcy50b3AgKyB0aGlzLmhlaWdodDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSB0aGlzLmxlZnQgKyB0aGlzLndpZHRoO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYWJlbCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCA+IDApIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5sZWZ0ID0gTWF0aC5taW4odGhpcy5ib3VuZGluZ0JveC5sZWZ0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3gucmlnaHQgPSBNYXRoLm1heCh0aGlzLmJvdW5kaW5nQm94LnJpZ2h0LCB0aGlzLmxhYmVsTW9kdWxlLnNpemUubGVmdCArIHRoaXMubGFiZWxNb2R1bGUuc2l6ZS53aWR0aCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3guYm90dG9tID0gTWF0aC5tYXgodGhpcy5ib3VuZGluZ0JveC5ib3R0b20sIHRoaXMuYm91bmRpbmdCb3guYm90dG9tICsgdGhpcy5sYWJlbE9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXN0YW5jZVRvQm9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBJbWFnZTtcbn0oQ2lyY2xlSW1hZ2VCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGcoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRnKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBBIFNxdWFyZSBOb2RlL0NsdXN0ZXIgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIFNoYXBlQmFzZVxuICovXG52YXIgU3F1YXJlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gIF9pbmhlcml0cyhTcXVhcmUsIF9TaGFwZUJhc2UpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGcoU3F1YXJlKTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBTcXVhcmUob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3F1YXJlKTtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoU3F1YXJlLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RyYXdTaGFwZShjdHgsIFwic3F1YXJlXCIsIDIsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNxdWFyZTtcbn0oU2hhcGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGYoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRmKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBBIEhleGFnb24gTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBTaGFwZUJhc2VcbiAqL1xudmFyIEhleGFnb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgX2luaGVyaXRzKEhleGFnb24sIF9TaGFwZUJhc2UpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGYoSGV4YWdvbik7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gSGV4YWdvbihvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIZXhhZ29uKTtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoSGV4YWdvbiwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kcmF3U2hhcGUoY3R4LCBcImhleGFnb25cIiwgNCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSGV4YWdvbjtcbn0oU2hhcGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGUoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRlKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBBIFN0YXIgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBTaGFwZUJhc2VcbiAqL1xudmFyIFN0YXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TaGFwZUJhc2UpIHtcbiAgX2luaGVyaXRzKFN0YXIsIF9TaGFwZUJhc2UpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGUoU3Rhcik7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gU3RhcihvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGFyKTtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggd2lkdGhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoU3RhciwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kcmF3U2hhcGUoY3R4LCBcInN0YXJcIiwgNCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3Rhcjtcbn0oU2hhcGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGQoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkZCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRkKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBBIHRleHQtYmFzZWQgcmVwbGFjZW1lbnQgZm9yIHRoZSBkZWZhdWx0IE5vZGUgc2hhcGUuXG4gKlxuICogQGF1Z21lbnRzIE5vZGVCYXNlXG4gKi9cbnZhciBUZXh0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZUJhc2UpIHtcbiAgX2luaGVyaXRzKFRleHQsIF9Ob2RlQmFzZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkZChUZXh0KTtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7TGFiZWx9IGxhYmVsTW9kdWxlXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0KG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0KTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgICBfdGhpcy5fc2V0TWFyZ2lucyhsYWJlbE1vZHVsZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhvdmVyXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoVGV4dCwgW3tcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgsIHNlbGVjdGVkLCBob3Zlcikge1xuICAgICAgaWYgKHRoaXMubmVlZHNSZWZyZXNoKHNlbGVjdGVkLCBob3ZlcikpIHtcbiAgICAgICAgdGhpcy50ZXh0U2l6ZSA9IHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCBzZWxlY3RlZCwgaG92ZXIpO1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy50ZXh0U2l6ZS53aWR0aCArIHRoaXMubWFyZ2luLnJpZ2h0ICsgdGhpcy5tYXJnaW4ubGVmdDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLnRleHRTaXplLmhlaWdodCArIHRoaXMubWFyZ2luLnRvcCArIHRoaXMubWFyZ2luLmJvdHRvbTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAwLjUgKiB0aGlzLndpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KGN0eCwgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMucmVzaXplKGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICAgIHRoaXMubGVmdCA9IHggLSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHRoaXMudG9wID0geSAtIHRoaXMuaGVpZ2h0IC8gMjtcblxuICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS5kcmF3KGN0eCwgdGhpcy5sZWZ0ICsgdGhpcy50ZXh0U2l6ZS53aWR0aCAvIDIgKyB0aGlzLm1hcmdpbi5sZWZ0LCB0aGlzLnRvcCArIHRoaXMudGV4dFNpemUuaGVpZ2h0IC8gMiArIHRoaXMubWFyZ2luLnRvcCwgc2VsZWN0ZWQsIGhvdmVyKTtcblxuICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KHgsIHksIGN0eCwgc2VsZWN0ZWQsIGhvdmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRleHQ7XG59KE5vZGVCYXNlKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJGMoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRjKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBBIFRyaWFuZ2xlIE5vZGUvQ2x1c3RlciBzaGFwZS5cbiAqXG4gKiBAYXVnbWVudHMgU2hhcGVCYXNlXG4gKi9cbnZhciBUcmlhbmdsZSQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU2hhcGVCYXNlKSB7XG4gIF9pbmhlcml0cyhUcmlhbmdsZSwgX1NoYXBlQmFzZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkYyhUcmlhbmdsZSk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gVHJpYW5nbGUob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJpYW5nbGUpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaG92ZXJcbiAgICogQHBhcmFtIHtBcnJvd09wdGlvbnN9IHZhbHVlc1xuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFRyaWFuZ2xlLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RyYXdTaGFwZShjdHgsIFwidHJpYW5nbGVcIiwgMywgeCwgeSwgc2VsZWN0ZWQsIGhvdmVyLCB2YWx1ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVHJpYW5nbGU7XG59KFNoYXBlQmFzZSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciRiKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGIoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkYigpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFfUmVmbGVjdCRjb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKF9SZWZsZWN0JGNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChfUmVmbGVjdCRjb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogQSBkb3dud2FyZCBmYWNpbmcgVHJpYW5nbGUgTm9kZS9DbHVzdGVyIHNoYXBlLlxuICpcbiAqIEBhdWdtZW50cyBTaGFwZUJhc2VcbiAqL1xudmFyIFRyaWFuZ2xlRG93biA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1NoYXBlQmFzZSkge1xuICBfaW5oZXJpdHMoVHJpYW5nbGVEb3duLCBfU2hhcGVCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciRiKFRyaWFuZ2xlRG93bik7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbE1vZHVsZVxuICAgKi9cbiAgZnVuY3Rpb24gVHJpYW5nbGVEb3duKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyaWFuZ2xlRG93bik7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICogQHBhcmFtIHtib29sZWFufSBob3ZlclxuICAgKiBAcGFyYW0ge0Fycm93T3B0aW9uc30gdmFsdWVzXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IENhbGxiYWNrcyB0byBkcmF3IGxhdGVyIG9uIGhpZ2hlciBsYXllcnMuXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoVHJpYW5nbGVEb3duLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoY3R4LCB4LCB5LCBzZWxlY3RlZCwgaG92ZXIsIHZhbHVlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX2RyYXdTaGFwZShjdHgsIFwidHJpYW5nbGVEb3duXCIsIDMsIHgsIHksIHNlbGVjdGVkLCBob3ZlciwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRpc3RhbmNlVG9Cb3JkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzdGFuY2VUb0JvcmRlcihjdHgsIGFuZ2xlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRyaWFuZ2xlRG93bjtcbn0oU2hhcGVCYXNlKTtcblxuZnVuY3Rpb24gb3duS2V5cyQyKGUsIHIpIHsgdmFyIHQgPSBfT2JqZWN0JGtleXMoZSk7IGlmIChfT2JqZWN0JGdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IF9PYmplY3QkZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gX2ZpbHRlckluc3RhbmNlUHJvcGVydHkobykuY2FsbChvLCBmdW5jdGlvbiAocikgeyByZXR1cm4gX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMShlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKGUpIHsgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHsgdmFyIF9jb250ZXh0NSwgX2NvbnRleHQ2OyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0NSA9IG93bktleXMkMihPYmplY3QodCksICEwKSkuY2FsbChfY29udGV4dDUsIGZ1bmN0aW9uIChyKSB7IF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTsgfSkgOiBfT2JqZWN0JGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBfT2JqZWN0JGRlZmluZVByb3BlcnRpZXMoZSwgX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDYgPSBvd25LZXlzJDIoT2JqZWN0KHQpKSkuY2FsbChfY29udGV4dDYsIGZ1bmN0aW9uIChyKSB7IF9PYmplY3QkZGVmaW5lUHJvcGVydHkoZSwgciwgX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSh0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5cbi8qKlxuICogQSBub2RlLiBBIG5vZGUgY2FuIGJlIGNvbm5lY3RlZCB0byBvdGhlciBub2RlcyB2aWEgb25lIG9yIG11bHRpcGxlIGVkZ2VzLlxuICovXG52YXIgTm9kZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZyBvcHRpb25zIGZvciB0aGUgbm9kZS4gQWxsXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgYXJlIG9wdGlvbmFsLCBleGNlcHQgZm9yIHRoZSBpZC5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSBpZCAgICAgSWQgb2YgdGhlIG5vZGUuIFJlcXVpcmVkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3N0cmluZ30gbGFiZWwgIFRleHQgbGFiZWwgZm9yIHRoZSBub2RlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge251bWJlcn0geCAgICAgIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bnVtYmVyfSB5ICAgICAgVmVydGljYWwgcG9zaXRpb24gb2YgdGhlIG5vZGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSBzaGFwZSAgTm9kZSBzaGFwZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzdHJpbmd9IGltYWdlICBBbiBpbWFnZSB1cmxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7c3RyaW5nfSB0aXRsZSAgQSB0aXRsZSB0ZXh0LCBjYW4gYmUgSFRNTFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHthbnl0eXBlfSBncm91cCBBIGdyb3VwIG5hbWUgb3IgbnVtYmVyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5ICAgICAgICAgICAgICAgU2hhcmVkIHN0YXRlIG9mIGN1cnJlbnQgbmV0d29yayBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge05ldHdvcmsuSW1hZ2VzfSBpbWFnZWxpc3QgIEEgbGlzdCB3aXRoIGltYWdlcy4gT25seSBuZWVkZWQgd2hlbiB0aGUgbm9kZSBoYXMgYW4gaW1hZ2VcbiAgICogQHBhcmFtIHtHcm91cHN9IGdyb3VwbGlzdCAgICAgICAgICBBIGxpc3Qgd2l0aCBncm91cHMuIE5lZWRlZCBmb3IgcmV0cmlldmluZyBncm91cCBvcHRpb25zXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxPcHRpb25zICAgICAgQ3VycmVudCBnbG9iYWwgbm9kZSBvcHRpb25zOyB0aGVzZSBzZXJ2ZSBhcyBkZWZhdWx0cyBmb3IgdGhlIG5vZGUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtvYmplY3R9IGRlZmF1bHRPcHRpb25zICAgICBHbG9iYWwgZGVmYXVsdCBvcHRpb25zIGZvciBub2Rlczsgbm90ZSB0aGF0IHRoaXMgaXMgYWxzbyB0aGUgcHJvdG90eXBlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIHBhcmFtZXRlciBgZ2xvYmFsT3B0aW9uc2AuXG4gICAqL1xuICBmdW5jdGlvbiBOb2RlKG9wdGlvbnMsIGJvZHksIGltYWdlbGlzdCwgZ3JvdXBsaXN0LCBnbG9iYWxPcHRpb25zLCBkZWZhdWx0T3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBicmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucyk7XG4gICAgdGhpcy5nbG9iYWxPcHRpb25zID0gZ2xvYmFsT3B0aW9ucztcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmVkZ2VzID0gW107IC8vIGFsbCBlZGdlcyBjb25uZWN0ZWQgdG8gdGhpcyBub2RlXG5cbiAgICAvLyBzZXQgZGVmYXVsdHMgZm9yIHRoZSBvcHRpb25zXG4gICAgdGhpcy5pZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmltYWdlbGlzdCA9IGltYWdlbGlzdDtcbiAgICB0aGlzLmdyb3VwbGlzdCA9IGdyb3VwbGlzdDtcblxuICAgIC8vIHN0YXRlIG9wdGlvbnNcbiAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFzZVNpemUgPSB0aGlzLm9wdGlvbnMuc2l6ZTtcbiAgICB0aGlzLmJhc2VGb250U2l6ZSA9IHRoaXMub3B0aW9ucy5mb250LnNpemU7XG4gICAgdGhpcy5wcmVkZWZpbmVkUG9zaXRpb24gPSBmYWxzZTsgLy8gdXNlZCB0byBjaGVjayBpZiBpbml0aWFsIGZpdCBzaG91bGQganVzdCB0YWtlIHRoZSByYW5nZSBvciBhcHByb3hpbWF0ZVxuICAgIHRoaXMuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmhvdmVyID0gZmFsc2U7XG4gICAgdGhpcy5sYWJlbE1vZHVsZSA9IG5ldyBMYWJlbCh0aGlzLmJvZHksIHRoaXMub3B0aW9ucywgZmFsc2UgLyogTm90IGVkZ2UgbGFiZWwgKi8pO1xuXG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGFjaCBhIGVkZ2UgdG8gdGhlIG5vZGVcbiAgICpcbiAgICogQHBhcmFtIHtFZGdlfSBlZGdlXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoTm9kZSwgW3tcbiAgICBrZXk6IFwiYXR0YWNoRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRhY2hFZGdlKGVkZ2UpIHtcbiAgICAgIHZhciBfY29udGV4dDtcbiAgICAgIGlmIChfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQgPSB0aGlzLmVkZ2VzKS5jYWxsKF9jb250ZXh0LCBlZGdlKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5lZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGFjaCBhIGVkZ2UgZnJvbSB0aGUgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtFZGdlfSBlZGdlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGV0YWNoRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXRhY2hFZGdlKGVkZ2UpIHtcbiAgICAgIHZhciBfY29udGV4dDI7XG4gICAgICB2YXIgaW5kZXggPSBfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQyID0gdGhpcy5lZGdlcykuY2FsbChfY29udGV4dDIsIGVkZ2UpO1xuICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgIHZhciBfY29udGV4dDM7XG4gICAgICAgIF9zcGxpY2VJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MyA9IHRoaXMuZWRnZXMpLmNhbGwoX2NvbnRleHQzLCBpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IG9yIG92ZXJ3cml0ZSBvcHRpb25zIGZvciB0aGUgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgYW4gb2JqZWN0IHdpdGggb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtudWxsfGJvb2xlYW59XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHZhciBjdXJyZW50U2hhcGUgPSB0aGlzLm9wdGlvbnMuc2hhcGU7XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBOb3RlIHRoYXQgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlICd1bmRlZmluZWQnISBUaGlzIGlzIE9LLlxuICAgICAgfVxuXG4gICAgICAvLyBTYXZlIHRoZSBjb2xvciBmb3IgbGF0ZXIuXG4gICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBpbiBvcmRlciB0byBwcmV2ZW50IGxvY2FsIGNvbG9yIGZyb20gYmVpbmcgb3ZlcndyaXR0ZW4gYnkgZ3JvdXAgY29sb3IuXG4gICAgICAvLyBUT0RPOiBUbyBwcmV2ZW50IHN1Y2ggd29ya2Fyb3VuZHMgdGhlIHdheSBvcHRpb25zIGFyZSBoYW5kbGVkIHNob3VsZCBiZSByZXdyaXR0ZW4gZnJvbSBzY3JhdGNoLlxuICAgICAgLy8gVGhpcyBpcyBub3QgdGhlIG9ubHkgcHJvYmxlbSB3aXRoIGN1cnJlbnQgb3B0aW9ucyBoYW5kbGluZy5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jb2xvciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLl9sb2NhbENvbG9yID0gb3B0aW9ucy5jb2xvcjtcbiAgICAgIH1cblxuICAgICAgLy8gYmFzaWMgb3B0aW9uc1xuICAgICAgaWYgKG9wdGlvbnMuaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmlkID0gb3B0aW9ucy5pZDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBtdXN0IGhhdmUgYW4gaWRcIik7XG4gICAgICB9XG4gICAgICBOb2RlLmNoZWNrTWFzcyhvcHRpb25zLCB0aGlzLmlkKTtcblxuICAgICAgLy8gc2V0IHRoZXNlIG9wdGlvbnMgbG9jYWxseVxuICAgICAgLy8gY2xlYXIgeCBhbmQgeSBwb3NpdGlvbnNcbiAgICAgIGlmIChvcHRpb25zLnggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy54ID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy54ID0gX3BhcnNlSW50JDEob3B0aW9ucy54KTtcbiAgICAgICAgICB0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAob3B0aW9ucy55ID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy55ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMucHJlZGVmaW5lZFBvc2l0aW9uID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy55ID0gX3BhcnNlSW50JDEob3B0aW9ucy55KTtcbiAgICAgICAgICB0aGlzLnByZWRlZmluZWRQb3NpdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJhc2VTaXplID0gb3B0aW9ucy5zaXplO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLnZhbHVlID0gX3BhcnNlRmxvYXQkMShvcHRpb25zLnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhpcyB0cmFuc2Zvcm1zIGFsbCBzaG9ydGhhbmRzIGludG8gZnVsbHkgZGVmaW5lZCBvcHRpb25zXG4gICAgICBOb2RlLnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIHRydWUsIHRoaXMuZ2xvYmFsT3B0aW9ucywgdGhpcy5ncm91cGxpc3QpO1xuICAgICAgdmFyIHBpbGUgPSBbb3B0aW9ucywgdGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zXTtcbiAgICAgIHRoaXMuY2hvb3NlciA9IGNob29zaWZ5KFwibm9kZVwiLCBwaWxlKTtcbiAgICAgIHRoaXMuX2xvYWRfaW1hZ2VzKCk7XG4gICAgICB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKG9wdGlvbnMpO1xuXG4gICAgICAvLyBOZWVkIHRvIHNldCBsb2NhbCBvcGFjaXR5IGFmdGVyIGB0aGlzLnVwZGF0ZUxhYmVsTW9kdWxlKG9wdGlvbnMpO2AgYmVjYXVzZSBgdGhpcy51cGRhdGVMYWJlbE1vZHVsZShvcHRpb25zKTtgIG92ZXJyaXRlcyBsb2NhbCBvcGFjaXR5IHdpdGggZ3JvdXAgb3BhY2l0eVxuICAgICAgaWYgKG9wdGlvbnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkICYmIE5vZGUuY2hlY2tPcGFjaXR5KG9wdGlvbnMub3BhY2l0eSkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVNoYXBlKGN1cnJlbnRTaGFwZSk7XG4gICAgICByZXR1cm4gb3B0aW9ucy5oaWRkZW4gIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLnBoeXNpY3MgIT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkIHRoZSBpbWFnZXMgZnJvbSB0aGUgb3B0aW9ucywgZm9yIHRoZSBub2RlcyB0aGF0IG5lZWQgdGhlbS5cbiAgICAgKlxuICAgICAqIEltYWdlcyBhcmUgYWx3YXlzIGxvYWRlZCwgZXZlbiBpZiB0aGV5IGFyZSBub3QgdXNlZCBpbiB0aGUgY3VycmVudCBzaGFwZS5cbiAgICAgKiBUaGUgdXNlciBtYXkgc3dpdGNoIHRvIGFuIGltYWdlIHNoYXBlIGxhdGVyIG9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfbG9hZF9pbWFnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRfaW1hZ2VzKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFwZSA9PT0gXCJjaXJjdWxhckltYWdlXCIgfHwgdGhpcy5vcHRpb25zLnNoYXBlID09PSBcImltYWdlXCIpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbWFnZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9uIGltYWdlIG11c3QgYmUgZGVmaW5lZCBmb3Igbm9kZSB0eXBlICdcIiArIHRoaXMub3B0aW9ucy5zaGFwZSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbWFnZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmltYWdlbGlzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludGVybmFsIEVycm9yOiBObyBpbWFnZXMgcHJvdmlkZWRcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pbWFnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aGlzLmltYWdlT2JqID0gdGhpcy5pbWFnZWxpc3QubG9hZCh0aGlzLm9wdGlvbnMuaW1hZ2UsIHRoaXMub3B0aW9ucy5icm9rZW5JbWFnZSwgdGhpcy5pZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmltYWdlLnVuc2VsZWN0ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHVuc2VsZWN0ZWQgaW1hZ2UgcHJvdmlkZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbWFnZU9iaiA9IHRoaXMuaW1hZ2VsaXN0LmxvYWQodGhpcy5vcHRpb25zLmltYWdlLnVuc2VsZWN0ZWQsIHRoaXMub3B0aW9ucy5icm9rZW5JbWFnZSwgdGhpcy5pZCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW1hZ2Uuc2VsZWN0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuaW1hZ2VPYmpBbHQgPSB0aGlzLmltYWdlbGlzdC5sb2FkKHRoaXMub3B0aW9ucy5pbWFnZS5zZWxlY3RlZCwgdGhpcy5vcHRpb25zLmJyb2tlbkltYWdlLCB0aGlzLmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmltYWdlT2JqQWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBvcGFjaXR5IGlzIG9ubHkgYmV0d2VlbiAwIGFuZCAxXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEZvcm1hdHRpbmdWYWx1ZXNcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHt7Y29sb3I6ICosIGJvcmRlcldpZHRoOiAqLCBib3JkZXJDb2xvcjogKiwgc2l6ZTogKiwgYm9yZGVyRGFzaGVzOiAoYm9vbGVhbnxBcnJheXxhbGxPcHRpb25zLm5vZGVzLnNoYXBlUHJvcGVydGllcy5ib3JkZXJEYXNoZXN8e2Jvb2xlYW4sIGFycmF5fSksIGJvcmRlclJhZGl1czogKG51bWJlcnxhbGxPcHRpb25zLm5vZGVzLnNoYXBlUHJvcGVydGllcy5ib3JkZXJSYWRpdXN8e251bWJlcn18QXJyYXkpLCBzaGFkb3c6ICosIHNoYWRvd0NvbG9yOiAqLCBzaGFkb3dTaXplOiAqLCBzaGFkb3dYOiAqLCBzaGFkb3dZOiAqfX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGb3JtYXR0aW5nVmFsdWVzKCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHtcbiAgICAgICAgY29sb3I6IHRoaXMub3B0aW9ucy5jb2xvci5iYWNrZ3JvdW5kLFxuICAgICAgICBvcGFjaXR5OiB0aGlzLm9wdGlvbnMub3BhY2l0eSxcbiAgICAgICAgYm9yZGVyV2lkdGg6IHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICAgICAgYm9yZGVyQ29sb3I6IHRoaXMub3B0aW9ucy5jb2xvci5ib3JkZXIsXG4gICAgICAgIHNpemU6IHRoaXMub3B0aW9ucy5zaXplLFxuICAgICAgICBib3JkZXJEYXNoZXM6IHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyRGFzaGVzLFxuICAgICAgICBib3JkZXJSYWRpdXM6IHRoaXMub3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuYm9yZGVyUmFkaXVzLFxuICAgICAgICBzaGFkb3c6IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZCxcbiAgICAgICAgc2hhZG93Q29sb3I6IHRoaXMub3B0aW9ucy5zaGFkb3cuY29sb3IsXG4gICAgICAgIHNoYWRvd1NpemU6IHRoaXMub3B0aW9ucy5zaGFkb3cuc2l6ZSxcbiAgICAgICAgc2hhZG93WDogdGhpcy5vcHRpb25zLnNoYWRvdy54LFxuICAgICAgICBzaGFkb3dZOiB0aGlzLm9wdGlvbnMuc2hhZG93LnlcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5zZWxlY3RlZCB8fCB0aGlzLmhvdmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNob29zZXIgPT09IHRydWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aFNlbGVjdGVkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFsdWVzLmJvcmRlcldpZHRoID0gdGhpcy5vcHRpb25zLmJvcmRlcldpZHRoU2VsZWN0ZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWx1ZXMuYm9yZGVyV2lkdGggKj0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlcy5jb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYmFja2dyb3VuZDtcbiAgICAgICAgICAgIHZhbHVlcy5ib3JkZXJDb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyO1xuICAgICAgICAgICAgdmFsdWVzLnNoYWRvdyA9IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaG92ZXIpIHtcbiAgICAgICAgICAgIHZhbHVlcy5jb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5ob3Zlci5iYWNrZ3JvdW5kO1xuICAgICAgICAgICAgdmFsdWVzLmJvcmRlckNvbG9yID0gdGhpcy5vcHRpb25zLmNvbG9yLmhvdmVyLmJvcmRlcjtcbiAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNob29zZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRoaXMuY2hvb3Nlcih2YWx1ZXMsIHRoaXMub3B0aW9ucy5pZCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3Zlcik7XG4gICAgICAgICAgaWYgKHZhbHVlcy5zaGFkb3cgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLnNoYWRvd0NvbG9yICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LmNvbG9yIHx8IHZhbHVlcy5zaGFkb3dTaXplICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LnNpemUgfHwgdmFsdWVzLnNoYWRvd1ggIT09IHRoaXMub3B0aW9ucy5zaGFkb3cueCB8fCB2YWx1ZXMuc2hhZG93WSAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy55KSB7XG4gICAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzLnNoYWRvdyA9IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XG4gICAgICAgIHZhbHVlcy5ib3JkZXJDb2xvciA9IG92ZXJyaWRlT3BhY2l0eSh2YWx1ZXMuYm9yZGVyQ29sb3IsIG9wYWNpdHkpO1xuICAgICAgICB2YWx1ZXMuY29sb3IgPSBvdmVycmlkZU9wYWNpdHkodmFsdWVzLmNvbG9yLCBvcGFjaXR5KTtcbiAgICAgICAgdmFsdWVzLnNoYWRvd0NvbG9yID0gb3ZlcnJpZGVPcGFjaXR5KHZhbHVlcy5zaGFkb3dDb2xvciwgb3BhY2l0eSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVMYWJlbE1vZHVsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVMYWJlbE1vZHVsZShvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxhYmVsID09PSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLmxhYmVsID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5sYWJlbCA9IFwiXCI7XG4gICAgICB9XG4gICAgICBOb2RlLnVwZGF0ZUdyb3VwT3B0aW9ucyh0aGlzLm9wdGlvbnMsIF9vYmplY3RTcHJlYWQkMihfb2JqZWN0U3ByZWFkJDIoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgICBjb2xvcjogb3B0aW9ucyAmJiBvcHRpb25zLmNvbG9yIHx8IHRoaXMuX2xvY2FsQ29sb3IgfHwgdW5kZWZpbmVkXG4gICAgICB9KSwgdGhpcy5ncm91cGxpc3QpO1xuXG4gICAgICAvL1xuICAgICAgLy8gTm90ZTpUaGUgcHJvdG90eXBlIGNoYWluIGZvciB0aGlzLm9wdGlvbnMgaXM6XG4gICAgICAvL1xuICAgICAgLy8gdGhpcy5vcHRpb25zIC0+ICAgIE5vZGVzSGFuZGxlci5vcHRpb25zICAgIC0+IE5vZGVzSGFuZGxlci5kZWZhdWx0T3B0aW9uc1xuICAgICAgLy8gICAgICAgICAgICAgICAgIChhbHNvOiB0aGlzLmdsb2JhbE9wdGlvbnMpXG4gICAgICAvL1xuICAgICAgLy8gTm90ZSB0aGF0IHRoZSBwcm90b3R5cGVzIGFyZSBtZW50aW9uZWQgZXhwbGljaXRseSBpbiB0aGUgcGlsZSBsaXN0IGJlbG93O1xuICAgICAgLy8gV0UgRE9OJ1QgV0FOVCBUSEUgT1JERVIgT0YgVEhFIFBST1RPVFlQRVMhISEhIEF0IGxlYXN0LCBub3QgZm9yIGZvbnQgaGFuZGxpbmcgb2YgbGFiZWxzLlxuICAgICAgLy8gVGhpcyBpcyBhIGdvb2QgaW5kaWNhdGlvbiB0aGF0IHRoZSBwcm90b3R5cGUgdXNhZ2Ugb2Ygb3B0aW9ucyBpcyBkZWZpY2llbnQuXG4gICAgICAvL1xuICAgICAgdmFyIGN1cnJlbnRHcm91cCA9IHRoaXMuZ3JvdXBsaXN0LmdldCh0aGlzLm9wdGlvbnMuZ3JvdXAsIGZhbHNlKTtcbiAgICAgIHZhciBwaWxlID0gW29wdGlvbnMsXG4gICAgICAvLyBuZXcgb3B0aW9uc1xuICAgICAgdGhpcy5vcHRpb25zLFxuICAgICAgLy8gY3VycmVudCBub2RlIG9wdGlvbnMsIHNlZSBjb21tZW50IGFib3ZlIGZvciBwcm90b3R5cGVcbiAgICAgIGN1cnJlbnRHcm91cCxcbiAgICAgIC8vIGdyb3VwIG9wdGlvbnMsIGlmIGFueVxuICAgICAgdGhpcy5nbG9iYWxPcHRpb25zLFxuICAgICAgLy8gQ3VycmVudGx5IHNldCBnbG9iYWwgbm9kZSBvcHRpb25zXG4gICAgICB0aGlzLmRlZmF1bHRPcHRpb25zIC8vIERlZmF1bHQgZ2xvYmFsIG5vZGUgb3B0aW9uc1xuICAgICAgXTtcblxuICAgICAgdGhpcy5sYWJlbE1vZHVsZS51cGRhdGUodGhpcy5vcHRpb25zLCBwaWxlKTtcbiAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5iYXNlRm9udFNpemUgPSB0aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnRTaGFwZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVNoYXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVNoYXBlKGN1cnJlbnRTaGFwZSkge1xuICAgICAgaWYgKGN1cnJlbnRTaGFwZSA9PT0gdGhpcy5vcHRpb25zLnNoYXBlICYmIHRoaXMuc2hhcGUpIHtcbiAgICAgICAgdGhpcy5zaGFwZS5zZXRPcHRpb25zKHRoaXMub3B0aW9ucywgdGhpcy5pbWFnZU9iaiwgdGhpcy5pbWFnZU9iakFsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjaG9vc2UgZHJhdyBtZXRob2QgZGVwZW5kaW5nIG9uIHRoZSBzaGFwZVxuICAgICAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5zaGFwZSkge1xuICAgICAgICAgIGNhc2UgXCJib3hcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgQm94JDEodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNpcmNsZVwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBDaXJjbGUkMSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiY2lyY3VsYXJJbWFnZVwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBDaXJjdWxhckltYWdlKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlLCB0aGlzLmltYWdlT2JqLCB0aGlzLmltYWdlT2JqQWx0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJjdXN0b21cIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgQ3VzdG9tU2hhcGUodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUsIHRoaXMub3B0aW9ucy5jdHhSZW5kZXJlcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZGF0YWJhc2VcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgRGF0YWJhc2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImRpYW1vbmRcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgRGlhbW9uZCQxKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJkb3RcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgRG90KHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJlbGxpcHNlXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IEVsbGlwc2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImljb25cIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgSWNvbih0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiaW1hZ2VcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgSW1hZ2UkMih0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSwgdGhpcy5pbWFnZU9iaiwgdGhpcy5pbWFnZU9iakFsdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic3F1YXJlXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFNxdWFyZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiaGV4YWdvblwiOlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBIZXhhZ29uKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzdGFyXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFN0YXIodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgVGV4dCh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidHJpYW5nbGVcIjpcbiAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBuZXcgVHJpYW5nbGUkMSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidHJpYW5nbGVEb3duXCI6XG4gICAgICAgICAgICB0aGlzLnNoYXBlID0gbmV3IFRyaWFuZ2xlRG93bih0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG5ldyBFbGxpcHNlKHRoaXMub3B0aW9ucywgdGhpcy5ib2R5LCB0aGlzLmxhYmVsTW9kdWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm5lZWRzUmVmcmVzaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNlbGVjdCB0aGlzIG5vZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0KCkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgICB0aGlzLm5lZWRzUmVmcmVzaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHVuc2VsZWN0IHRoaXMgbm9kZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVuc2VsZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2VsZWN0KCkge1xuICAgICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5uZWVkc1JlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgY2FsY3VsYXRlZCBzaXplIG9mIHRoZSBub2RlLCBmb3JjZXMgaXQgdG8gcmVjYWxjdWxhdGUgaXRzIHNpemVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJuZWVkc1JlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmVlZHNSZWZyZXNoKCkge1xuICAgICAgdGhpcy5zaGFwZS5yZWZyZXNoTmVlZGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHRpdGxlIG9mIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRpdGxlICAgIFRoZSB0aXRsZSBvZiB0aGUgbm9kZSwgb3IgdW5kZWZpbmVkIHdoZW4gbm8gdGl0bGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhcyBiZWVuIHNldC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRUaXRsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUaXRsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSB0byB0aGUgYm9yZGVyIG9mIHRoZSBOb2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgICAgICAgIEFuZ2xlIGluIHJhZGlhbnNcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBkaXN0YW5jZSAgIERpc3RhbmNlIHRvIHRoZSBib3JkZXIgaW4gcGl4ZWxzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzdGFuY2VUb0JvcmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnNoYXBlLmRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBub2RlIGhhcyBhIGZpeGVkIHggYW5kIHkgcG9zaXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAgICAgIHRydWUgaWYgZml4ZWQsIGZhbHNlIGlmIG5vdFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImlzRml4ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNGaXhlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZml4ZWQueCAmJiB0aGlzLm9wdGlvbnMuZml4ZWQueTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjaGVjayBpZiB0aGlzIG5vZGUgaXMgc2VsZWN0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHNlbGVjdGVkICAgVHJ1ZSBpZiBub2RlIGlzIHNlbGVjdGVkLCBlbHNlIGZhbHNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTZWxlY3RlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NlbGVjdGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIHZhbHVlIG9mIHRoZSBub2RlLiBDYW4gYmUgdW5kZWZpbmVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB2YWx1ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgZGltZW5zaW9ucyBvZiB0aGUgbGFiZWxcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtyZWN0fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbFNpemUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYWJlbE1vZHVsZS5zaXplKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRqdXN0IHRoZSB2YWx1ZSByYW5nZSBvZiB0aGUgbm9kZS4gVGhlIG5vZGUgd2lsbCBhZGp1c3QgaXQncyBzaXplXG4gICAgICogYmFzZWQgb24gaXRzIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG90YWxcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRWYWx1ZVJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlUmFuZ2UobWluLCBtYXgsIHRvdGFsKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5vcHRpb25zLnNjYWxpbmcuY3VzdG9tU2NhbGluZ0Z1bmN0aW9uKG1pbiwgbWF4LCB0b3RhbCwgdGhpcy5vcHRpb25zLnZhbHVlKTtcbiAgICAgICAgdmFyIHNpemVEaWZmID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWF4IC0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWluO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBmb250RGlmZiA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1heCAtIHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1pbjtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZm9udC5zaXplID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubGFiZWwubWluICsgc2NhbGUgKiBmb250RGlmZjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMuc2l6ZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLm1pbiArIHNjYWxlICogc2l6ZURpZmY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wdGlvbnMuc2l6ZSA9IHRoaXMuYmFzZVNpemU7XG4gICAgICAgIHRoaXMub3B0aW9ucy5mb250LnNpemUgPSB0aGlzLmJhc2VGb250U2l6ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlTGFiZWxNb2R1bGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3IHRoaXMgbm9kZSBpbiB0aGUgZ2l2ZW4gY2FudmFzXG4gICAgICogVGhlIDJkIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhcyBjYW4gYmUgcmV0cmlldmVkIGJ5IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldEZvcm1hdHRpbmdWYWx1ZXMoKTtcbiAgICAgIHJldHVybiB0aGlzLnNoYXBlLmRyYXcoY3R4LCB0aGlzLngsIHRoaXMueSwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgdmFsdWVzKSB8fCB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgc2hhcGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUJvdW5kaW5nQm94KGN0eCkge1xuICAgICAgdGhpcy5zaGFwZS51cGRhdGVCb3VuZGluZ0JveCh0aGlzLngsIHRoaXMueSwgY3R4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZSB0aGUgc2l6ZSBvZiB0aGlzIG5vZGUgaW4gdGhlIGdpdmVuIGNhbnZhc1xuICAgICAqIFRoZSAyZCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXMgY2FuIGJlIHJldHJpZXZlZCBieSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICAgY3R4XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZShjdHgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldEZvcm1hdHRpbmdWYWx1ZXMoKTtcbiAgICAgIHRoaXMuc2hhcGUucmVzaXplKGN0eCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3ZlciwgdmFsdWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgYWxsIHZpc3VhbCBlbGVtZW50cyBvZiB0aGlzIG5vZGUgaW5zdGFuY2UsIGluIHdoaWNoIHRoZSBnaXZlblxuICAgICAqIHBvaW50IGZhbGxzIHdpdGhpbiB0aGUgYm91bmRpbmcgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3BvaW50fSBwb2ludFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48bm9kZUNsaWNrSXRlbXxub2RlTGFiZWxDbGlja0l0ZW0+fSBsaXN0IHdpdGggdGhlIGl0ZW1zIHdoaWNoIGFyZSBvbiB0aGUgcG9pbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRJdGVtc09uUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SXRlbXNPblBvaW50KHBvaW50KSB7XG4gICAgICB2YXIgcmV0ID0gW107XG4gICAgICBpZiAodGhpcy5sYWJlbE1vZHVsZS52aXNpYmxlKCkpIHtcbiAgICAgICAgaWYgKHBvaW50SW5SZWN0KHRoaXMubGFiZWxNb2R1bGUuZ2V0U2l6ZSgpLCBwb2ludCkpIHtcbiAgICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgICBub2RlSWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBsYWJlbElkOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb2ludEluUmVjdCh0aGlzLnNoYXBlLmJvdW5kaW5nQm94LCBwb2ludCkpIHtcbiAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgIG5vZGVJZDogdGhpcy5pZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3QgaXMgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJvdmlkZWQgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqICAgYW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgIFRydWUgaWYgbG9jYXRpb24gaXMgbG9jYXRlZCBvbiBub2RlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNPdmVybGFwcGluZ1dpdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNPdmVybGFwcGluZ1dpdGgob2JqKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaGFwZS5sZWZ0IDwgb2JqLnJpZ2h0ICYmIHRoaXMuc2hhcGUubGVmdCArIHRoaXMuc2hhcGUud2lkdGggPiBvYmoubGVmdCAmJiB0aGlzLnNoYXBlLnRvcCA8IG9iai5ib3R0b20gJiYgdGhpcy5zaGFwZS50b3AgKyB0aGlzLnNoYXBlLmhlaWdodCA+IG9iai50b3A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3QgaXMgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJvdmlkZWQgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqICAgYW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgIFRydWUgaWYgbG9jYXRpb24gaXMgbG9jYXRlZCBvbiBub2RlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNCb3VuZGluZ0JveE92ZXJsYXBwaW5nV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0JvdW5kaW5nQm94T3ZlcmxhcHBpbmdXaXRoKG9iaikge1xuICAgICAgcmV0dXJuIHRoaXMuc2hhcGUuYm91bmRpbmdCb3gubGVmdCA8IG9iai5yaWdodCAmJiB0aGlzLnNoYXBlLmJvdW5kaW5nQm94LnJpZ2h0ID4gb2JqLmxlZnQgJiYgdGhpcy5zaGFwZS5ib3VuZGluZ0JveC50b3AgPCBvYmouYm90dG9tICYmIHRoaXMuc2hhcGUuYm91bmRpbmdCb3guYm90dG9tID4gb2JqLnRvcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB2YWxpZCB2YWx1ZXMgZm9yIG1hc3NcbiAgICAgKlxuICAgICAqIFRoZSBtYXNzIG1heSBub3QgYmUgbmVnYXRpdmUgb3IgemVyby4gSWYgaXQgaXMsIHJlc2V0IHRvIDFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBpZFxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgfV0sIFt7XG4gICAga2V5OiBcImNoZWNrT3BhY2l0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja09wYWNpdHkob3BhY2l0eSkge1xuICAgICAgcmV0dXJuIDAgPD0gb3BhY2l0eSAmJiBvcGFjaXR5IDw9IDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCBvcmlnaW4gaXMgJ2NlbnRlcicgb3IgJ3RvcC1sZWZ0J1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNoZWNrQ29vcmRpbmF0ZU9yaWdpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0Nvb3JkaW5hdGVPcmlnaW4ob3JpZ2luKSB7XG4gICAgICByZXR1cm4gb3JpZ2luID09PSB1bmRlZmluZWQgfHwgb3JpZ2luID09PSBcImNlbnRlclwiIHx8IG9yaWdpbiA9PT0gXCJ0b3AtbGVmdFwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcHkgZ3JvdXAgb3B0aW9uIHZhbHVlcyBpbnRvIHRoZSBub2RlIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBUaGUgZ3JvdXAgb3B0aW9ucyBvdmVycmlkZSB0aGUgZ2xvYmFsIG5vZGUgb3B0aW9ucywgc28gdGhlIGNvcHkgb2YgZ3JvdXAgb3B0aW9uc1xuICAgICAqICBtdXN0IGhhcHBlbiAqYWZ0ZXIqIHRoZSBnbG9iYWwgbm9kZSBvcHRpb25zIGhhdmUgYmVlbiBzZXQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtdXN0IGFsc28gYmUgY2FsbGVkIGFsc28gaWYgdGhlIGdsb2JhbCBub2RlIG9wdGlvbnMgaGF2ZSBjaGFuZ2VkIGFuZCB0aGUgZ3JvdXAgb3B0aW9ucyBkaWQgbm90LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3T3B0aW9ucyAgbmV3IHZhbHVlcyBmb3IgdGhlIG9wdGlvbnMsIGN1cnJlbnRseSBvbmx5IHBhc3NlZCBpbiBmb3IgY2hlY2tcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZ3JvdXBMaXN0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlR3JvdXBPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUdyb3VwT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBncm91cExpc3QpIHtcbiAgICAgIHZhciBfY29udGV4dDQ7XG4gICAgICBpZiAoZ3JvdXBMaXN0ID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gTm8gZ3JvdXBzLCBub3RoaW5nIHRvIGRvXG5cbiAgICAgIHZhciBncm91cCA9IHBhcmVudE9wdGlvbnMuZ3JvdXA7XG5cbiAgICAgIC8vIHBhcmFub2lhOiB0aGUgc2VsZWN0ZWQgZ3JvdXAgaXMgYWxyZWFkeSBtZXJnZWQgaW50byBub2RlIG9wdGlvbnMsIGNoZWNrLlxuICAgICAgaWYgKG5ld09wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmdyb3VwICE9PSB1bmRlZmluZWQgJiYgZ3JvdXAgIT09IG5ld09wdGlvbnMuZ3JvdXApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidXBkYXRlR3JvdXBPcHRpb25zOiBncm91cCB2YWx1ZXMgaW4gb3B0aW9ucyBkb24ndCBtYXRjaC5cIik7XG4gICAgICB9XG4gICAgICB2YXIgaGFzR3JvdXAgPSB0eXBlb2YgZ3JvdXAgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGdyb3VwID09PSBcInN0cmluZ1wiICYmIGdyb3VwICE9IFwiXCI7XG4gICAgICBpZiAoIWhhc0dyb3VwKSByZXR1cm47IC8vIGN1cnJlbnQgbm9kZSBoYXMgbm8gZ3JvdXAsIG5vIG5lZWQgdG8gbWVyZ2VcblxuICAgICAgdmFyIGdyb3VwT2JqID0gZ3JvdXBMaXN0LmdldChncm91cCk7XG4gICAgICBpZiAoZ3JvdXBPYmoub3BhY2l0eSAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMub3BhY2l0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghTm9kZS5jaGVja09wYWNpdHkoZ3JvdXBPYmoub3BhY2l0eSkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBvcHRpb24gZm9yIG5vZGUgb3BhY2l0eS4gVmFsdWUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEsIGZvdW5kOiBcIiArIGdyb3VwT2JqLm9wYWNpdHkpO1xuICAgICAgICAgIGdyb3VwT2JqLm9wYWNpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBhbnkgbmV3IG9wdGlvbiB0byBhdm9pZCB0aGVtIGJlaW5nIG92ZXJyaWRkZW4gYnkgdGhlIGdyb3VwIG9wdGlvbnMuXG4gICAgICB2YXIgc2tpcFByb3BlcnRpZXMgPSBfZmlsdGVySW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDQgPSBfT2JqZWN0JGdldE93blByb3BlcnR5TmFtZXMobmV3T3B0aW9ucykpLmNhbGwoX2NvbnRleHQ0LCBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gbmV3T3B0aW9uc1twXSAhPSBudWxsO1xuICAgICAgfSk7XG4gICAgICAvLyBBbHdheXMgc2tpcCBtZXJnaW5nIGdyb3VwIGZvbnQgb3B0aW9ucyBpbnRvIHBhcmVudDsgdGhlc2UgYXJlIHJlcXVpcmVkIHRvIGJlIGRpc3RpbmN0IGZvciBsYWJlbHNcbiAgICAgIHNraXBQcm9wZXJ0aWVzLnB1c2goXCJmb250XCIpO1xuICAgICAgc2VsZWN0aXZlTm90RGVlcEV4dGVuZChza2lwUHJvcGVydGllcywgcGFyZW50T3B0aW9ucywgZ3JvdXBPYmopO1xuXG4gICAgICAvLyB0aGUgY29sb3Igb2JqZWN0IG5lZWRzIHRvIGJlIGNvbXBsZXRlbHkgZGVmaW5lZC5cbiAgICAgIC8vIFNpbmNlIGdyb3VwcyBjYW4gcGFydGlhbGx5IG92ZXJ3cml0ZSB0aGUgY29sb3JzLCB3ZSBwYXJzZSBpdCBhZ2FpbiwganVzdCBpbiBjYXNlLlxuICAgICAgcGFyZW50T3B0aW9ucy5jb2xvciA9IHBhcnNlQ29sb3IocGFyZW50T3B0aW9ucy5jb2xvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBwcm9jZXNzIGFsbCBwb3NzaWJsZSBzaG9ydGhhbmRzIGluIHRoZSBuZXcgb3B0aW9ucyBhbmQgbWFrZXMgc3VyZSB0aGF0IHRoZSBwYXJlbnRPcHRpb25zIGFyZSBmdWxseSBkZWZpbmVkLlxuICAgICAqIFN0YXRpYyBzbyBpdCBjYW4gYWxzbyBiZSB1c2VkIGJ5IHRoZSBoYW5kbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FsbG93RGVsZXRpb249ZmFsc2VdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtnbG9iYWxPcHRpb25zPXt9XVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZ3JvdXBMaXN0XVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgICAgIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHZhciBnbG9iYWxPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICAgIHZhciBncm91cExpc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBmaWVsZHMgPSBbXCJjb2xvclwiLCBcImZpeGVkXCIsIFwic2hhZG93XCJdO1xuICAgICAgc2VsZWN0aXZlTm90RGVlcEV4dGVuZChmaWVsZHMsIHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIGFsbG93RGVsZXRpb24pO1xuICAgICAgTm9kZS5jaGVja01hc3MobmV3T3B0aW9ucyk7XG4gICAgICBpZiAocGFyZW50T3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCFOb2RlLmNoZWNrT3BhY2l0eShwYXJlbnRPcHRpb25zLm9wYWNpdHkpKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgb3B0aW9uIGZvciBub2RlIG9wYWNpdHkuIFZhbHVlIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBmb3VuZDogXCIgKyBwYXJlbnRPcHRpb25zLm9wYWNpdHkpO1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMub3BhY2l0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5ld09wdGlvbnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICghTm9kZS5jaGVja09wYWNpdHkobmV3T3B0aW9ucy5vcGFjaXR5KSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIG9wdGlvbiBmb3Igbm9kZSBvcGFjaXR5LiBWYWx1ZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMSwgZm91bmQ6IFwiICsgbmV3T3B0aW9ucy5vcGFjaXR5KTtcbiAgICAgICAgICBuZXdPcHRpb25zLm9wYWNpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXdPcHRpb25zLnNoYXBlUHJvcGVydGllcyAmJiAhTm9kZS5jaGVja0Nvb3JkaW5hdGVPcmlnaW4obmV3T3B0aW9ucy5zaGFwZVByb3BlcnRpZXMuY29vcmRpbmF0ZU9yaWdpbikpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkludmFsaWQgb3B0aW9uIGZvciBub2RlIGNvb3JkaW5hdGVPcmlnaW4sIGZvdW5kOiBcIiArIG5ld09wdGlvbnMuc2hhcGVQcm9wZXJ0aWVzLmNvb3JkaW5hdGVPcmlnaW4pO1xuICAgICAgfVxuXG4gICAgICAvLyBtZXJnZSB0aGUgc2hhZG93IG9wdGlvbnMgaW50byB0aGUgcGFyZW50LlxuICAgICAgbWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIFwic2hhZG93XCIsIGdsb2JhbE9wdGlvbnMpO1xuXG4gICAgICAvLyBpbmRpdmlkdWFsIHNoYXBlIG5ld09wdGlvbnNcbiAgICAgIGlmIChuZXdPcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5jb2xvciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcGFyc2VkQ29sb3IgPSBwYXJzZUNvbG9yKG5ld09wdGlvbnMuY29sb3IpO1xuICAgICAgICBmaWxsSWZEZWZpbmVkKHBhcmVudE9wdGlvbnMuY29sb3IsIHBhcnNlZENvbG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmNvbG9yID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IgPSBicmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucy5jb2xvcik7IC8vIHNldCB0aGUgb2JqZWN0IGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb25zXG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSB0aGUgZml4ZWQgb3B0aW9uc1xuICAgICAgaWYgKG5ld09wdGlvbnMuZml4ZWQgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmZpeGVkICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmV3T3B0aW9ucy5maXhlZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmZpeGVkLnggPSBuZXdPcHRpb25zLmZpeGVkO1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuZml4ZWQueSA9IG5ld09wdGlvbnMuZml4ZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKG5ld09wdGlvbnMuZml4ZWQueCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBuZXdPcHRpb25zLmZpeGVkLnggPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBwYXJlbnRPcHRpb25zLmZpeGVkLnggPSBuZXdPcHRpb25zLmZpeGVkLng7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXdPcHRpb25zLmZpeGVkLnkgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgbmV3T3B0aW9ucy5maXhlZC55ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgcGFyZW50T3B0aW9ucy5maXhlZC55ID0gbmV3T3B0aW9ucy5maXhlZC55O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5mb250ID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuZm9udCA9IGJyaWRnZU9iamVjdChnbG9iYWxPcHRpb25zLmZvbnQpOyAvLyBzZXQgdGhlIG9iamVjdCBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uc1xuICAgICAgfVxuXG4gICAgICBOb2RlLnVwZGF0ZUdyb3VwT3B0aW9ucyhwYXJlbnRPcHRpb25zLCBuZXdPcHRpb25zLCBncm91cExpc3QpO1xuXG4gICAgICAvLyBoYW5kbGUgdGhlIHNjYWxpbmcgb3B0aW9ucywgc3BlY2lmaWNhbGx5IHRoZSBsYWJlbCBwYXJ0XG4gICAgICBpZiAobmV3T3B0aW9ucy5zY2FsaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMuc2NhbGluZywgbmV3T3B0aW9ucy5zY2FsaW5nLCBcImxhYmVsXCIsIGdsb2JhbE9wdGlvbnMuc2NhbGluZyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNoZWNrTWFzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja01hc3Mob3B0aW9ucywgaWQpIHtcbiAgICAgIGlmIChvcHRpb25zLm1hc3MgIT09IHVuZGVmaW5lZCAmJiBvcHRpb25zLm1hc3MgPD0gMCkge1xuICAgICAgICB2YXIgc3RySWQgPSBcIlwiO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHN0cklkID0gXCIgaW4gbm9kZSBpZDogXCIgKyBpZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKFwiJWNOZWdhdGl2ZSBvciB6ZXJvIG1hc3MgZGlzYWxsb3dlZFwiICsgc3RySWQgKyBcIiwgc2V0dGluZyBtYXNzIHRvIDEuXCIsIFZBTElEQVRPUl9QUklOVF9TVFlMRSk7XG4gICAgICAgIG9wdGlvbnMubWFzcyA9IDE7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOb2RlO1xufSgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ1KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBfU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIF9nZXRJdGVyYXRvck1ldGhvZChvKSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoX0FycmF5JGlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDUobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDUobywgbWluTGVuKSB7IHZhciBfY29udGV4dDQ7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ1KG8sIG1pbkxlbik7IHZhciBuID0gX3NsaWNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDQgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQ0LCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBfQXJyYXkkZnJvbSQxKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDUobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxuXG4vKipcbiAqIEhhbmRsZXIgZm9yIE5vZGVzXG4gKi9cbnZhciBOb2Rlc0hhbmRsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtJbWFnZXN9IGltYWdlc1xuICAgKiBAcGFyYW0ge0FycmF5LjxHcm91cD59IGdyb3Vwc1xuICAgKiBAcGFyYW0ge0xheW91dEVuZ2luZX0gbGF5b3V0RW5naW5lXG4gICAqL1xuICBmdW5jdGlvbiBOb2Rlc0hhbmRsZXIoYm9keSwgaW1hZ2VzLCBncm91cHMsIGxheW91dEVuZ2luZSkge1xuICAgIHZhciBfY29udGV4dCxcbiAgICAgIF90aGlzID0gdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZXNIYW5kbGVyKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuaW1hZ2VzID0gaW1hZ2VzO1xuICAgIHRoaXMuZ3JvdXBzID0gZ3JvdXBzO1xuICAgIHRoaXMubGF5b3V0RW5naW5lID0gbGF5b3V0RW5naW5lO1xuXG4gICAgLy8gY3JlYXRlIHRoZSBub2RlIEFQSSBpbiB0aGUgYm9keSBjb250YWluZXJcbiAgICB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUgPSBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dCA9IHRoaXMuY3JlYXRlKS5jYWxsKF9jb250ZXh0LCB0aGlzKTtcbiAgICB0aGlzLm5vZGVzTGlzdGVuZXJzID0ge1xuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy5hZGQocGFyYW1zLml0ZW1zKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShldmVudCwgcGFyYW1zKSB7XG4gICAgICAgIF90aGlzLnVwZGF0ZShwYXJhbXMuaXRlbXMsIHBhcmFtcy5kYXRhLCBwYXJhbXMub2xkRGF0YSk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy5yZW1vdmUocGFyYW1zLml0ZW1zKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgIGJvcmRlcldpZHRoU2VsZWN0ZWQ6IHVuZGVmaW5lZCxcbiAgICAgIGJyb2tlbkltYWdlOiB1bmRlZmluZWQsXG4gICAgICBjb2xvcjoge1xuICAgICAgICBib3JkZXI6IFwiIzJCN0NFOVwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIiM5N0MyRkNcIixcbiAgICAgICAgaGlnaGxpZ2h0OiB7XG4gICAgICAgICAgYm9yZGVyOiBcIiMyQjdDRTlcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBcIiNEMkU1RkZcIlxuICAgICAgICB9LFxuICAgICAgICBob3Zlcjoge1xuICAgICAgICAgIGJvcmRlcjogXCIjMkI3Q0U5XCIsXG4gICAgICAgICAgYmFja2dyb3VuZDogXCIjRDJFNUZGXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHVuZGVmaW5lZCxcbiAgICAgIC8vIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgIGZpeGVkOiB7XG4gICAgICAgIHg6IGZhbHNlLFxuICAgICAgICB5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGZvbnQ6IHtcbiAgICAgICAgY29sb3I6IFwiIzM0MzQzNFwiLFxuICAgICAgICBzaXplOiAxNCxcbiAgICAgICAgLy8gcHhcbiAgICAgICAgZmFjZTogXCJhcmlhbFwiLFxuICAgICAgICBiYWNrZ3JvdW5kOiBcIm5vbmVcIixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDAsXG4gICAgICAgIC8vIHB4XG4gICAgICAgIHN0cm9rZUNvbG9yOiBcIiNmZmZmZmZcIixcbiAgICAgICAgYWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgIHZhZGp1c3Q6IDAsXG4gICAgICAgIG11bHRpOiBmYWxzZSxcbiAgICAgICAgYm9sZDoge1xuICAgICAgICAgIG1vZDogXCJib2xkXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9sZGl0YWw6IHtcbiAgICAgICAgICBtb2Q6IFwiYm9sZCBpdGFsaWNcIlxuICAgICAgICB9LFxuICAgICAgICBpdGFsOiB7XG4gICAgICAgICAgbW9kOiBcIml0YWxpY1wiXG4gICAgICAgIH0sXG4gICAgICAgIG1vbm86IHtcbiAgICAgICAgICBtb2Q6IFwiXCIsXG4gICAgICAgICAgc2l6ZTogMTUsXG4gICAgICAgICAgLy8gcHhcbiAgICAgICAgICBmYWNlOiBcIm1vbm9zcGFjZVwiLFxuICAgICAgICAgIHZhZGp1c3Q6IDJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdyb3VwOiB1bmRlZmluZWQsXG4gICAgICBoaWRkZW46IGZhbHNlLFxuICAgICAgaWNvbjoge1xuICAgICAgICBmYWNlOiBcIkZvbnRBd2Vzb21lXCIsXG4gICAgICAgIC8vJ0ZvbnRBd2Vzb21lJyxcbiAgICAgICAgY29kZTogdW5kZWZpbmVkLFxuICAgICAgICAvLydcXHVmMDA3JyxcbiAgICAgICAgc2l6ZTogNTAsXG4gICAgICAgIC8vNTAsXG4gICAgICAgIGNvbG9yOiBcIiMyQjdDRTlcIiAvLycjYWEwMGZmJ1xuICAgICAgfSxcblxuICAgICAgaW1hZ2U6IHVuZGVmaW5lZCxcbiAgICAgIC8vIC0tPiBVUkxcbiAgICAgIGltYWdlUGFkZGluZzoge1xuICAgICAgICAvLyBvbmx5IGZvciBpbWFnZSBzaGFwZVxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIGxlZnQ6IDBcbiAgICAgIH0sXG4gICAgICBsYWJlbDogdW5kZWZpbmVkLFxuICAgICAgbGFiZWxIaWdobGlnaHRCb2xkOiB0cnVlLFxuICAgICAgbGV2ZWw6IHVuZGVmaW5lZCxcbiAgICAgIG1hcmdpbjoge1xuICAgICAgICB0b3A6IDUsXG4gICAgICAgIHJpZ2h0OiA1LFxuICAgICAgICBib3R0b206IDUsXG4gICAgICAgIGxlZnQ6IDVcbiAgICAgIH0sXG4gICAgICBtYXNzOiAxLFxuICAgICAgcGh5c2ljczogdHJ1ZSxcbiAgICAgIHNjYWxpbmc6IHtcbiAgICAgICAgbWluOiAxMCxcbiAgICAgICAgbWF4OiAzMCxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBtaW46IDE0LFxuICAgICAgICAgIG1heDogMzAsXG4gICAgICAgICAgbWF4VmlzaWJsZTogMzAsXG4gICAgICAgICAgZHJhd1RocmVzaG9sZDogNVxuICAgICAgICB9LFxuICAgICAgICBjdXN0b21TY2FsaW5nRnVuY3Rpb246IGZ1bmN0aW9uIGN1c3RvbVNjYWxpbmdGdW5jdGlvbihtaW4sIG1heCwgdG90YWwsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgICAgICByZXR1cm4gMC41O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc2NhbGUgPSAxIC8gKG1heCAtIG1pbik7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgKHZhbHVlIC0gbWluKSAqIHNjYWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiBcInJnYmEoMCwwLDAsMC41KVwiLFxuICAgICAgICBzaXplOiAxMCxcbiAgICAgICAgeDogNSxcbiAgICAgICAgeTogNVxuICAgICAgfSxcbiAgICAgIHNoYXBlOiBcImVsbGlwc2VcIixcbiAgICAgIHNoYXBlUHJvcGVydGllczoge1xuICAgICAgICBib3JkZXJEYXNoZXM6IGZhbHNlLFxuICAgICAgICAvLyBvbmx5IGZvciBib3JkZXJzXG4gICAgICAgIGJvcmRlclJhZGl1czogNixcbiAgICAgICAgLy8gb25seSBmb3IgYm94IHNoYXBlXG4gICAgICAgIGludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgIC8vIG9ubHkgZm9yIGltYWdlIGFuZCBjaXJjdWxhckltYWdlIHNoYXBlc1xuICAgICAgICB1c2VJbWFnZVNpemU6IGZhbHNlLFxuICAgICAgICAvLyBvbmx5IGZvciBpbWFnZSBhbmQgY2lyY3VsYXJJbWFnZSBzaGFwZXNcbiAgICAgICAgdXNlQm9yZGVyV2l0aEltYWdlOiBmYWxzZSxcbiAgICAgICAgLy8gb25seSBmb3IgaW1hZ2Ugc2hhcGVcbiAgICAgICAgY29vcmRpbmF0ZU9yaWdpbjogXCJjZW50ZXJcIiAvLyBvbmx5IGZvciBpbWFnZSBhbmQgY2lyY3VsYXJJbWFnZSBzaGFwZXNcbiAgICAgIH0sXG5cbiAgICAgIHNpemU6IDI1LFxuICAgICAgdGl0bGU6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB4OiB1bmRlZmluZWQsXG4gICAgICB5OiB1bmRlZmluZWRcbiAgICB9O1xuXG4gICAgLy8gUHJvdGVjdCBmcm9tIGlkaW9jeVxuICAgIGlmICh0aGlzLmRlZmF1bHRPcHRpb25zLm1hc3MgPD0gMCkge1xuICAgICAgdGhyb3cgXCJJbnRlcm5hbCBlcnJvcjogbWFzcyBpbiBkZWZhdWx0T3B0aW9ucyBvZiBOb2Rlc0hhbmRsZXIgbWF5IG5vdCBiZSB6ZXJvIG9yIG5lZ2F0aXZlXCI7XG4gICAgfVxuICAgIHRoaXMub3B0aW9ucyA9IGJyaWRnZU9iamVjdCh0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKE5vZGVzSGFuZGxlciwgW3tcbiAgICBrZXk6IFwiYmluZEV2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfY29udGV4dDIsXG4gICAgICAgIF9jb250ZXh0MyxcbiAgICAgICAgX3RoaXMyID0gdGhpcztcbiAgICAgIC8vIHJlZnJlc2ggdGhlIG5vZGVzLiBVc2VkIHdoZW4gcmV2ZXJ0aW5nIGZyb20gaGllcmFyY2hpY2FsIGxheW91dFxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJyZWZyZXNoTm9kZXNcIiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQyID0gdGhpcy5yZWZyZXNoKS5jYWxsKF9jb250ZXh0MiwgdGhpcykpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJyZWZyZXNoXCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MyA9IHRoaXMucmVmcmVzaCkuY2FsbChfY29udGV4dDMsIHRoaXMpKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvckVhY2gkMShfdGhpczIubm9kZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLmJvZHkuZGF0YS5ub2RlcykgX3RoaXMyLmJvZHkuZGF0YS5ub2Rlcy5vZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuYm9keS5mdW5jdGlvbnMuY3JlYXRlTm9kZTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ub2Rlc0xpc3RlbmVycy5hZGQ7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIubm9kZXNMaXN0ZW5lcnMudXBkYXRlO1xuICAgICAgICBkZWxldGUgX3RoaXMyLm5vZGVzTGlzdGVuZXJzLnJlbW92ZTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5ub2Rlc0xpc3RlbmVycztcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBOb2RlLnBhcnNlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIE5lZWQgdG8gc2V0IG9wYWNpdHkgaGVyZSBiZWNhdXNlIE5vZGUucGFyc2VPcHRpb25zIGlzIGFsc28gdXNlZCBmb3IgZ3JvdXBzLFxuICAgICAgICAvLyBpZiB5b3Ugc2V0IG9wYWNpdHkgaW4gTm9kZS5wYXJzZU9wdGlvbnMgaXQgb3ZlcndyaXRlcyBncm91cCBvcGFjaXR5LlxuICAgICAgICBpZiAob3B0aW9ucy5vcGFjaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoX051bWJlciRpc05hTihvcHRpb25zLm9wYWNpdHkpIHx8ICFfTnVtYmVyJGlzRmluaXRlKG9wdGlvbnMub3BhY2l0eSkgfHwgb3B0aW9ucy5vcGFjaXR5IDwgMCB8fCBvcHRpb25zLm9wYWNpdHkgPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiSW52YWxpZCBvcHRpb24gZm9yIG5vZGUgb3BhY2l0eS4gVmFsdWUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEsIGZvdW5kOiBcIiArIG9wdGlvbnMub3BhY2l0eSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgc2hhcGUgaW4gYWxsIG5vZGVzXG4gICAgICAgIGlmIChvcHRpb25zLnNoYXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS51cGRhdGVTaGFwZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFiZWxzIG9mIG5vZGVzIGlmIGFueSByZWxldmFudCBvcHRpb25zIGNoYW5nZWQuXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mb250ICE9PSBcInVuZGVmaW5lZFwiIHx8IHR5cGVvZiBvcHRpb25zLndpZHRoQ29uc3RyYWludCAhPT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2Ygb3B0aW9ucy5oZWlnaHRDb25zdHJhaW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfT2JqZWN0JGtleXMkMSA9IF9PYmplY3Qka2V5cyh0aGlzLmJvZHkubm9kZXMpOyBfaSA8IF9PYmplY3Qka2V5cyQxLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIF9ub2RlSWQgPSBfT2JqZWN0JGtleXMkMVtfaV07XG4gICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbX25vZGVJZF0udXBkYXRlTGFiZWxNb2R1bGUoKTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1tfbm9kZUlkXS5uZWVkc1JlZnJlc2goKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHNoYXBlIHNpemUgaW4gYWxsIG5vZGVzXG4gICAgICAgIGlmIChvcHRpb25zLnNpemUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGZvciAodmFyIF9ub2RlSWQyIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsIF9ub2RlSWQyKSkge1xuICAgICAgICAgICAgICB0aGlzLmJvZHkubm9kZXNbX25vZGVJZDJdLm5lZWRzUmVmcmVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgc3RhdGUgb2YgdGhlIHZhcmlhYmxlcyBpZiBuZWVkZWRcbiAgICAgICAgaWYgKG9wdGlvbnMuaGlkZGVuICE9PSB1bmRlZmluZWQgfHwgb3B0aW9ucy5waHlzaWNzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGEgZGF0YSBzZXQgd2l0aCBub2RlcyBmb3IgdGhlIG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkgfCBEYXRhU2V0IHwgRGF0YVZpZXd9IG5vZGVzICAgICAgICAgVGhlIGRhdGEgY29udGFpbmluZyB0aGUgbm9kZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZG9Ob3RFbWl0PWZhbHNlXSAtIFN1cHByZXNzIGRhdGEgY2hhbmdlZCBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGF0YShub2Rlcykge1xuICAgICAgdmFyIGRvTm90RW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgb2xkTm9kZXNEYXRhID0gdGhpcy5ib2R5LmRhdGEubm9kZXM7XG4gICAgICBpZiAoaXNEYXRhVmlld0xpa2UoXCJpZFwiLCBub2RlcykpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMgPSBub2RlcztcbiAgICAgIH0gZWxzZSBpZiAoX0FycmF5JGlzQXJyYXkobm9kZXMpKSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzID0gbmV3IERhdGFTZXQoKTtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMuYWRkKG5vZGVzKTtcbiAgICAgIH0gZWxzZSBpZiAoIW5vZGVzKSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzID0gbmV3IERhdGFTZXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcnJheSBvciBEYXRhU2V0IGV4cGVjdGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG9sZE5vZGVzRGF0YSkge1xuICAgICAgICAvLyB1bnN1YnNjcmliZSBmcm9tIG9sZCBkYXRhc2V0XG4gICAgICAgIGZvckVhY2gkMSh0aGlzLm5vZGVzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgb2xkTm9kZXNEYXRhLm9mZihldmVudCwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGRyYXduIG5vZGVzXG4gICAgICB0aGlzLmJvZHkubm9kZXMgPSB7fTtcbiAgICAgIGlmICh0aGlzLmJvZHkuZGF0YS5ub2Rlcykge1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGRhdGFzZXRcbiAgICAgICAgdmFyIG1lID0gdGhpcztcbiAgICAgICAgZm9yRWFjaCQxKHRoaXMubm9kZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICBtZS5ib2R5LmRhdGEubm9kZXMub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZHJhdyBhbGwgbmV3IG5vZGVzXG4gICAgICAgIHZhciBpZHMgPSB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXRJZHMoKTtcbiAgICAgICAgdGhpcy5hZGQoaWRzLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChkb05vdEVtaXQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nW119IGlkc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RvTm90RW1pdD1mYWxzZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoaWRzKSB7XG4gICAgICB2YXIgZG9Ob3RFbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBpZDtcbiAgICAgIHZhciBuZXdOb2RlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWQgPSBpZHNbaV07XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0KGlkKTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZShwcm9wZXJ0aWVzKTtcbiAgICAgICAgbmV3Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW2lkXSA9IG5vZGU7IC8vIG5vdGU6IHRoaXMgbWF5IHJlcGxhY2UgYW4gZXhpc3Rpbmcgbm9kZVxuICAgICAgfVxuXG4gICAgICB0aGlzLmxheW91dEVuZ2luZS5wb3NpdGlvbkluaXRpYWxseShuZXdOb2Rlcyk7XG4gICAgICBpZiAoZG9Ob3RFbWl0ID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBleGlzdGluZyBub2Rlcywgb3IgY3JlYXRlIHRoZW0gd2hlbiBub3QgeWV0IGV4aXN0aW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nW119IGlkcyBpZCdzIG9mIGNoYW5nZWQgbm9kZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBjaGFuZ2VkRGF0YSBhcnJheSB3aXRoIGNoYW5nZWQgZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXl8dW5kZWZpbmVkfSBvbGREYXRhIG9wdGlvbmFsOyBhcnJheSB3aXRoIHByZXZpb3VzIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoaWRzLCBjaGFuZ2VkRGF0YSwgb2xkRGF0YSkge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaWRdO1xuICAgICAgICB2YXIgZGF0YSA9IGNoYW5nZWREYXRhW2ldO1xuICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIG5vZGVcbiAgICAgICAgICBpZiAobm9kZS5zZXRPcHRpb25zKGRhdGEpKSB7XG4gICAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAvLyBjcmVhdGUgbm9kZVxuICAgICAgICAgIG5vZGUgPSB0aGlzLmNyZWF0ZShkYXRhKTtcbiAgICAgICAgICBub2Rlc1tpZF0gPSBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWRhdGFDaGFuZ2VkICYmIG9sZERhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBDaGVjayBmb3IgYW55IGNoYW5nZXMgd2hpY2ggc2hvdWxkIHRyaWdnZXIgYSBsYXlvdXQgcmVjYWxjdWxhdGlvblxuICAgICAgICAvLyBGb3Igbm93LCB0aGlzIGlzIGp1c3QgJ2xldmVsJyBmb3IgaGllcmFyY2hpY2FsIGxheW91dFxuICAgICAgICAvLyBBc3N1bXB0aW9uOiBvbGQgYW5kIG5ldyBkYXRhIGFycmFuZ2VkIGluIHNhbWUgb3JkZXI7IGF0IHRpbWUgb2Ygd3JpdGluZywgdGhpcyBob2xkcy5cbiAgICAgICAgZGF0YUNoYW5nZWQgPSBfc29tZUluc3RhbmNlUHJvcGVydHkoY2hhbmdlZERhdGEpLmNhbGwoY2hhbmdlZERhdGEsIGZ1bmN0aW9uIChuZXdWYWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBvbGREYXRhW2luZGV4XTtcbiAgICAgICAgICByZXR1cm4gb2xkVmFsdWUgJiYgb2xkVmFsdWUubGV2ZWwgIT09IG5ld1ZhbHVlLmxldmVsO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhVXBkYXRlZFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXhpc3Rpbmcgbm9kZXMuIElmIG5vZGVzIGRvIG5vdCBleGlzdCwgdGhlIG1ldGhvZCB3aWxsIGp1c3QgaWdub3JlIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoaWRzKSB7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgIGRlbGV0ZSBub2Rlc1tpZF07XG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNyZWF0ZSBhIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtjbGFzc30gW2NvbnN0cnVjdG9yQ2xhc3M9Tm9kZS5kZWZhdWx0XVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgICAgdmFyIGNvbnN0cnVjdG9yQ2xhc3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IE5vZGU7XG4gICAgICByZXR1cm4gbmV3IGNvbnN0cnVjdG9yQ2xhc3MocHJvcGVydGllcywgdGhpcy5ib2R5LCB0aGlzLmltYWdlcywgdGhpcy5ncm91cHMsIHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjbGVhclBvc2l0aW9ucz1mYWxzZV1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2goKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciBjbGVhclBvc2l0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgICBmb3JFYWNoJDEodGhpcy5ib2R5Lm5vZGVzLCBmdW5jdGlvbiAobm9kZSwgbm9kZUlkKSB7XG4gICAgICAgIHZhciBkYXRhID0gX3RoaXMzLmJvZHkuZGF0YS5ub2Rlcy5nZXQobm9kZUlkKTtcbiAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChjbGVhclBvc2l0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbm9kZS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgeDogbnVsbCxcbiAgICAgICAgICAgICAgeTogbnVsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBmaXhlZDogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBub2RlLnNldE9wdGlvbnMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlLmlkPiB8IHN0cmluZ30gW2lkc10gIC0tPiBvcHRpb25hbCwgY2FuIGJlIGFycmF5IG9mIG5vZGVJZHMsIGNhbiBiZSBzdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zaXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9ucyhpZHMpIHtcbiAgICAgIHZhciBkYXRhQXJyYXkgPSB7fTtcbiAgICAgIGlmIChpZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoX0FycmF5JGlzQXJyYXkoaWRzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW2lkc1tpXV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpZHNbaV1dO1xuICAgICAgICAgICAgICBkYXRhQXJyYXlbaWRzW2ldXSA9IHtcbiAgICAgICAgICAgICAgICB4OiBNYXRoLnJvdW5kKG5vZGUueCksXG4gICAgICAgICAgICAgICAgeTogTWF0aC5yb3VuZChub2RlLnkpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbaWRzXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgX25vZGUgPSB0aGlzLmJvZHkubm9kZXNbaWRzXTtcbiAgICAgICAgICAgIGRhdGFBcnJheVtpZHNdID0ge1xuICAgICAgICAgICAgICB4OiBNYXRoLnJvdW5kKF9ub2RlLngpLFxuICAgICAgICAgICAgICB5OiBNYXRoLnJvdW5kKF9ub2RlLnkpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgX25vZGUyID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tfaTJdXTtcbiAgICAgICAgICBkYXRhQXJyYXlbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW19pMl1dID0ge1xuICAgICAgICAgICAgeDogTWF0aC5yb3VuZChfbm9kZTIueCksXG4gICAgICAgICAgICB5OiBNYXRoLnJvdW5kKF9ub2RlMi55KVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhQXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB4IHkgcG9zaXRpb24gb2YgYSBzcGVjaWZpYyBpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgaWQgdG8gcmV0cmlldmUuXG4gICAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBubyBpZCBpcyBpbmNsdWRlZC5cbiAgICAgKiBAdGhyb3dzIHtSZWZlcmVuY2VFcnJvcn0gSWYgYW4gaW52YWxpZCBpZCBpcyBwcm92aWRlZC5cbiAgICAgKiBAcmV0dXJucyB7eyB4OiBudW1iZXIsIHk6IG51bWJlciB9fSBSZXR1cm5zIFgsIFkgY2FudmFzIHBvc2l0aW9uIG9mIHRoZSBub2RlIHdpdGggZ2l2ZW4gaWQuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpb24oaWQpIHtcbiAgICAgIGlmIChpZCA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIGlkIHdhcyBzcGVjaWZpZWQgZm9yIGdldFBvc2l0aW9uIG1ldGhvZC5cIik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYm9keS5ub2Rlc1tpZF0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIk5vZGVJZCBwcm92aWRlZCBmb3IgZ2V0UG9zaXRpb24gZG9lcyBub3QgZXhpc3QuIFByb3ZpZGVkOiBcIi5jb25jYXQoaWQpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogTWF0aC5yb3VuZCh0aGlzLmJvZHkubm9kZXNbaWRdLngpLFxuICAgICAgICAgIHk6IE1hdGgucm91bmQodGhpcy5ib2R5Lm5vZGVzW2lkXS55KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIFhZIHBvc2l0aW9ucyBvZiB0aGUgbm9kZXMgaW50byB0aGUgZGF0YXNldC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzdG9yZVBvc2l0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9yZVBvc2l0aW9ucygpIHtcbiAgICAgIC8vIHRvZG86IGFkZCBzdXBwb3J0IGZvciBjbHVzdGVycyBhbmQgaGllcmFyY2hpY2FsLlxuICAgICAgdmFyIGRhdGFBcnJheSA9IFtdO1xuICAgICAgdmFyIGRhdGFzZXQgPSB0aGlzLmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCk7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNShkYXRhc2V0LmdldCgpKSxcbiAgICAgICAgX3N0ZXA7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBkc05vZGUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIgaWQgPSBkc05vZGUuaWQ7XG4gICAgICAgICAgdmFyIGJvZHlOb2RlID0gdGhpcy5ib2R5Lm5vZGVzW2lkXTtcbiAgICAgICAgICB2YXIgeCA9IE1hdGgucm91bmQoYm9keU5vZGUueCk7XG4gICAgICAgICAgdmFyIHkgPSBNYXRoLnJvdW5kKGJvZHlOb2RlLnkpO1xuICAgICAgICAgIGlmIChkc05vZGUueCAhPT0geCB8fCBkc05vZGUueSAhPT0geSkge1xuICAgICAgICAgICAgZGF0YUFycmF5LnB1c2goe1xuICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgICAgZGF0YXNldC51cGRhdGUoZGF0YUFycmF5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIGJvdW5kaW5nIGJveCBvZiBhIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtqfCp9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm91bmRpbmdCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm91bmRpbmdCb3gobm9kZUlkKSB7XG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0uc2hhcGUuYm91bmRpbmdCb3g7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBJZHMgb2Ygbm9kZXMgY29ubmVjdGVkIHRvIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHBhcmFtIHsndG8nfCdmcm9tJ3x1bmRlZmluZWR9IGRpcmVjdGlvbiB2YWx1ZXMgJ2Zyb20nIGFuZCAndG8nIHNlbGVjdCByZXNwZWN0aXZlbHkgcGFyZW50IGFuZCBjaGlsZCBub2RlcyBvbmx5LlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQW55IG90aGVyIHZhbHVlIHJldHVybnMgYm90aCBwYXJlbnQgYW5kIGNoaWxkIG5vZGVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb25uZWN0ZWROb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25uZWN0ZWROb2Rlcyhub2RlSWQsIGRpcmVjdGlvbikge1xuICAgICAgdmFyIG5vZGVMaXN0ID0gW107XG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICB2YXIgbm9kZU9iaiA9IHt9OyAvLyB1c2VkIHRvIHF1aWNrbHkgY2hlY2sgaWYgbm9kZSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IG5vZGUuZWRnZXNbaV07XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiAhPT0gXCJ0b1wiICYmIGVkZ2UudG9JZCA9PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAvLyB0aGVzZSBhcmUgZG91YmxlIGVxdWFscyBzaW5jZSBpZHMgY2FuIGJlIG51bWVyaWMgb3Igc3RyaW5nXG4gICAgICAgICAgICBpZiAobm9kZU9ialtlZGdlLmZyb21JZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBub2RlTGlzdC5wdXNoKGVkZ2UuZnJvbUlkKTtcbiAgICAgICAgICAgICAgbm9kZU9ialtlZGdlLmZyb21JZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICE9PSBcImZyb21cIiAmJiBlZGdlLmZyb21JZCA9PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAvLyB0aGVzZSBhcmUgZG91YmxlIGVxdWFscyBzaW5jZSBpZHMgY2FuIGJlIG51bWVyaWMgb3Igc3RyaW5nXG4gICAgICAgICAgICBpZiAobm9kZU9ialtlZGdlLnRvSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbm9kZUxpc3QucHVzaChlZGdlLnRvSWQpO1xuICAgICAgICAgICAgICBub2RlT2JqW2VkZ2UudG9JZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGVMaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaWRzIG9mIHRoZSBlZGdlcyBjb25uZWN0ZWQgdG8gdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb25uZWN0ZWRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb25uZWN0ZWRFZGdlcyhub2RlSWQpIHtcbiAgICAgIHZhciBlZGdlTGlzdCA9IFtdO1xuICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZWRnZUxpc3QucHVzaChub2RlLmVkZ2VzW2ldLmlkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vZGVJZCBwcm92aWRlZCBmb3IgZ2V0Q29ubmVjdGVkRWRnZXMgZG9lcyBub3QgZXhpc3QuIFByb3ZpZGVkOiBcIiwgbm9kZUlkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlZGdlTGlzdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIGEgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm1vdmVOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVOb2RlKG5vZGVJZCwgeCwgeSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS54ID0gTnVtYmVyKHgpO1xuICAgICAgICB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS55ID0gTnVtYmVyKHkpO1xuICAgICAgICBfc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM0LmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOb2RlIGlkIHN1cHBsaWVkIHRvIG1vdmVOb2RlIGRvZXMgbm90IGV4aXN0LiBQcm92aWRlZDogXCIsIG5vZGVJZCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOb2Rlc0hhbmRsZXI7XG59KCk7XG5cbnZhciBoYXNPd24kMSA9IGhhc093blByb3BlcnR5XzE7XG5cbnZhciBpc0RhdGFEZXNjcmlwdG9yJDEgPSBmdW5jdGlvbiAoZGVzY3JpcHRvcikge1xuICByZXR1cm4gZGVzY3JpcHRvciAhPT0gdW5kZWZpbmVkICYmIChoYXNPd24kMShkZXNjcmlwdG9yLCAndmFsdWUnKSB8fCBoYXNPd24kMShkZXNjcmlwdG9yLCAnd3JpdGFibGUnKSk7XG59O1xuXG52YXIgJCQ0ID0gX2V4cG9ydDtcbnZhciBjYWxsID0gZnVuY3Rpb25DYWxsO1xudmFyIGlzT2JqZWN0JDIgPSBpc09iamVjdCRqO1xudmFyIGFuT2JqZWN0JDEgPSBhbk9iamVjdCRkO1xudmFyIGlzRGF0YURlc2NyaXB0b3IgPSBpc0RhdGFEZXNjcmlwdG9yJDE7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gb2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldFByb3RvdHlwZU9mID0gb2JqZWN0R2V0UHJvdG90eXBlT2Y7XG5cbi8vIGBSZWZsZWN0LmdldGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlZmxlY3QuZ2V0XG5mdW5jdGlvbiBnZXQkNSh0YXJnZXQsIHByb3BlcnR5S2V5IC8qICwgcmVjZWl2ZXIgKi8pIHtcbiAgdmFyIHJlY2VpdmVyID0gYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiBhcmd1bWVudHNbMl07XG4gIHZhciBkZXNjcmlwdG9yLCBwcm90b3R5cGU7XG4gIGlmIChhbk9iamVjdCQxKHRhcmdldCkgPT09IHJlY2VpdmVyKSByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mKHRhcmdldCwgcHJvcGVydHlLZXkpO1xuICBpZiAoZGVzY3JpcHRvcikgcmV0dXJuIGlzRGF0YURlc2NyaXB0b3IoZGVzY3JpcHRvcilcbiAgICA/IGRlc2NyaXB0b3IudmFsdWVcbiAgICA6IGRlc2NyaXB0b3IuZ2V0ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjYWxsKGRlc2NyaXB0b3IuZ2V0LCByZWNlaXZlcik7XG4gIGlmIChpc09iamVjdCQyKHByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKHRhcmdldCkpKSByZXR1cm4gZ2V0JDUocHJvdG90eXBlLCBwcm9wZXJ0eUtleSwgcmVjZWl2ZXIpO1xufVxuXG4kJDQoeyB0YXJnZXQ6ICdSZWZsZWN0Jywgc3RhdDogdHJ1ZSB9LCB7XG4gIGdldDogZ2V0JDVcbn0pO1xuXG52YXIgcGF0aCQ0ID0gcGF0aCR3O1xuXG52YXIgZ2V0JDQgPSBwYXRoJDQuUmVmbGVjdC5nZXQ7XG5cbnZhciBwYXJlbnQkYSA9IGdldCQ0O1xuXG52YXIgZ2V0JDMgPSBwYXJlbnQkYTtcblxudmFyIHBhcmVudCQ5ID0gZ2V0JDM7XG5cbnZhciBnZXQkMiA9IHBhcmVudCQ5O1xuXG52YXIgcGFyZW50JDggPSBnZXQkMjtcblxudmFyIGdldCQxID0gcGFyZW50JDg7XG5cbnZhciBnZXQgPSBnZXQkMTtcblxudmFyIF9SZWZsZWN0JGdldCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhnZXQpO1xuXG52YXIgcGFyZW50JDcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkNDtcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyID0gcGFyZW50JDc7XG5cbnZhciBwYXJlbnQkNiA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQyO1xuXG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJDEgPSBwYXJlbnQkNjtcblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxO1xuXG52YXIgX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKTtcblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIF9nZXQoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBfUmVmbGVjdCRnZXQpIHtcbiAgICB2YXIgX2NvbnRleHQ7XG4gICAgX2dldCA9IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dCA9IF9SZWZsZWN0JGdldCkuY2FsbChfY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG52YXIgJCQzID0gX2V4cG9ydDtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW1hdGgtaHlwb3QgLS0gcmVxdWlyZWQgZm9yIHRlc3RpbmdcbnZhciAkaHlwb3QgPSBNYXRoLmh5cG90O1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG5cbi8vIENocm9tZSA3NyBidWdcbi8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTk1NDZcbnZhciBGT1JDRUQkMiA9ICEhJGh5cG90ICYmICRoeXBvdChJbmZpbml0eSwgTmFOKSAhPT0gSW5maW5pdHk7XG5cbi8vIGBNYXRoLmh5cG90YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbWF0aC5oeXBvdFxuJCQzKHsgdGFyZ2V0OiAnTWF0aCcsIHN0YXQ6IHRydWUsIGFyaXR5OiAyLCBmb3JjZWQ6IEZPUkNFRCQyIH0sIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIHJlcXVpcmVkIGZvciBgLmxlbmd0aGBcbiAgaHlwb3Q6IGZ1bmN0aW9uIGh5cG90KHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBhTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgbGFyZyA9IDA7XG4gICAgdmFyIGFyZywgZGl2O1xuICAgIHdoaWxlIChpIDwgYUxlbikge1xuICAgICAgYXJnID0gYWJzKGFyZ3VtZW50c1tpKytdKTtcbiAgICAgIGlmIChsYXJnIDwgYXJnKSB7XG4gICAgICAgIGRpdiA9IGxhcmcgLyBhcmc7XG4gICAgICAgIHN1bSA9IHN1bSAqIGRpdiAqIGRpdiArIDE7XG4gICAgICAgIGxhcmcgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYgKGFyZyA+IDApIHtcbiAgICAgICAgZGl2ID0gYXJnIC8gbGFyZztcbiAgICAgICAgc3VtICs9IGRpdiAqIGRpdjtcbiAgICAgIH0gZWxzZSBzdW0gKz0gYXJnO1xuICAgIH1cbiAgICByZXR1cm4gbGFyZyA9PT0gSW5maW5pdHkgPyBJbmZpbml0eSA6IGxhcmcgKiBzcXJ0KHN1bSk7XG4gIH1cbn0pO1xuXG52YXIgcGF0aCQzID0gcGF0aCR3O1xuXG52YXIgaHlwb3QkMiA9IHBhdGgkMy5NYXRoLmh5cG90O1xuXG52YXIgcGFyZW50JDUgPSBoeXBvdCQyO1xuXG52YXIgaHlwb3QkMSA9IHBhcmVudCQ1O1xuXG52YXIgaHlwb3QgPSBoeXBvdCQxO1xuXG52YXIgX01hdGgkaHlwb3QgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoaHlwb3QpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkYShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCRhKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JGEoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXHJcbiAqIENvbW1vbiBtZXRob2RzIGZvciBlbmRwb2ludHNcclxuICpcclxuICogQGNsYXNzXHJcbiAqL1xudmFyIEVuZFBvaW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRW5kUG9pbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVuZFBvaW50KTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoRW5kUG9pbnQsIG51bGwsIFt7XG4gICAga2V5OiBcInRyYW5zZm9ybVwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgdHJhbnNmb3JtYXRpb24gb24gcG9pbnRzIGZvciBkaXNwbGF5LlxyXG4gICAgICpcclxuICAgICAqIFRoZSBmb2xsb3dpbmcgaXMgZG9uZTpcclxuICAgICAqIC0gcm90YXRlIGJ5IHRoZSBzcGVjaWZpZWQgYW5nbGVcclxuICAgICAqIC0gbXVsdGlwbHkgdGhlIChub3JtYWxpemVkKSBjb29yZGluYXRlcyBieSB0aGUgcGFzc2VkIGxlbmd0aFxyXG4gICAgICogLSBvZmZzZXQgYnkgdGhlIHRhcmdldCBjb29yZGluYXRlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb2ludHMgLSBUaGUgcG9pbnQocykgdG8gYmUgdHJhbnNmb3JtZWQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHJlc3VsdCBvZiB0aGUgdHJhbnNmb3JtYXRpb24uXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpIHtcbiAgICAgIGlmICghX0FycmF5JGlzQXJyYXkocG9pbnRzKSkge1xuICAgICAgICBwb2ludHMgPSBbcG9pbnRzXTtcbiAgICAgIH1cbiAgICAgIHZhciB4ID0gYXJyb3dEYXRhLnBvaW50Lng7XG4gICAgICB2YXIgeSA9IGFycm93RGF0YS5wb2ludC55O1xuICAgICAgdmFyIGFuZ2xlID0gYXJyb3dEYXRhLmFuZ2xlO1xuICAgICAgdmFyIGxlbmd0aCA9IGFycm93RGF0YS5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgdmFyIHh0ID0gcC54ICogTWF0aC5jb3MoYW5nbGUpIC0gcC55ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICB2YXIgeXQgPSBwLnggKiBNYXRoLnNpbihhbmdsZSkgKyBwLnkgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIHAueCA9IHggKyBsZW5ndGggKiB4dDtcbiAgICAgICAgcC55ID0geSArIGxlbmd0aCAqIHl0O1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIERyYXcgYSBjbG9zZWQgcGF0aCB1c2luZyB0aGUgZ2l2ZW4gcmVhbCBjb29yZGluYXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHBhdGggd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBwb2ludHMgLSBUaGUgcG9pbnRzIG9mIHRoZSBwYXRoLlxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1BhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1BhdGgoY3R4LCBwb2ludHMpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGN0eC5saW5lVG8ocG9pbnRzW2ldLngsIHBvaW50c1tpXS55KTtcbiAgICAgIH1cbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEVuZFBvaW50O1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGFycm93IGVuZHBvaW50LlxyXG4gKi9cbnZhciBJbWFnZSQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRW5kUG9pbnQpIHtcbiAgX2luaGVyaXRzKEltYWdlLCBfRW5kUG9pbnQpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJGEoSW1hZ2UpO1xuICBmdW5jdGlvbiBJbWFnZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW1hZ2UpO1xuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoSW1hZ2UsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgRmFsc2UgYXMgdGhlcmUgaXMgbm8gd2F5IHRvIGZpbGwgYW4gaW1hZ2UuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICBpZiAoYXJyb3dEYXRhLmltYWdlKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoYXJyb3dEYXRhLnBvaW50LngsIGFycm93RGF0YS5wb2ludC55KTtcbiAgICAgICAgY3R4LnJvdGF0ZShNYXRoLlBJIC8gMiArIGFycm93RGF0YS5hbmdsZSk7XG4gICAgICAgIHZhciB3aWR0aCA9IGFycm93RGF0YS5pbWFnZVdpZHRoICE9IG51bGwgPyBhcnJvd0RhdGEuaW1hZ2VXaWR0aCA6IGFycm93RGF0YS5pbWFnZS53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGFycm93RGF0YS5pbWFnZUhlaWdodCAhPSBudWxsID8gYXJyb3dEYXRhLmltYWdlSGVpZ2h0IDogYXJyb3dEYXRhLmltYWdlLmhlaWdodDtcbiAgICAgICAgYXJyb3dEYXRhLmltYWdlLmRyYXdJbWFnZUF0UG9zaXRpb24oY3R4LCAxLFxuICAgICAgICAvLyBzY2FsZVxuICAgICAgICAtd2lkdGggLyAyLFxuICAgICAgICAvLyB4XG4gICAgICAgIDAsXG4gICAgICAgIC8vIHlcbiAgICAgICAgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBJbWFnZTtcbn0oRW5kUG9pbnQpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGFycm93IGVuZHBvaW50LlxyXG4gKi9cbnZhciBBcnJvdyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VuZFBvaW50Mikge1xuICBfaW5oZXJpdHMoQXJyb3csIF9FbmRQb2ludDIpO1xuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlciRhKEFycm93KTtcbiAgZnVuY3Rpb24gQXJyb3coKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFycm93KTtcbiAgICByZXR1cm4gX3N1cGVyMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhBcnJvdywgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZWQgcG9pbnRzIG9mIGNsb3NlZCBwYXRoLCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgIC8vICgwLCAwKSBpcyB0aGUgYXR0YWNobWVudCBwb2ludCwgYW5kIHRoZSBwb2ludCBhcm91bmQgd2hpY2ggc2hvdWxkIGJlIHJvdGF0ZWRcbiAgICAgIHZhciBwb2ludHMgPSBbe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAwLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuOSxcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogLTAuM1xuICAgICAgfV07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBcnJvdztcbn0oRW5kUG9pbnQpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGNyb3cgZW5kcG9pbnQuXHJcbiAqL1xudmFyIENyb3cgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDcm93KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDcm93KTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoQ3JvdywgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZWQgcG9pbnRzIG9mIGNsb3NlZCBwYXRoLCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IHNob3VsZCBiZSBkcmF3bi5cbiAgICAgIC8vICgwLCAwKSBpcyB0aGUgYXR0YWNobWVudCBwb2ludCwgYW5kIHRoZSBwb2ludCBhcm91bmQgd2hpY2ggc2hvdWxkIGJlIHJvdGF0ZWRcbiAgICAgIHZhciBwb2ludHMgPSBbe1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuNCxcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENyb3c7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgY3VydmUgZW5kcG9pbnQuXHJcbiAqL1xudmFyIEN1cnZlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3VydmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1cnZlKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoQ3VydmUsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgIHg6IC0wLjQsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnQsIGFycm93RGF0YSk7XG4gICAgICAvLyBVcGRhdGUgZW5kcG9pbnQgc3R5bGUgZm9yIGRyYXdpbmcgdHJhbnNwYXJlbnQgYXJjLlxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMCwgMCwgMCwgMClcIjtcbiAgICAgIC8vIERlZmluZSBjdXJ2ZSBlbmRwb2ludCBhcyBzZW1pY2lyY2xlLlxuICAgICAgdmFyIHBpID0gTWF0aC5QSTtcbiAgICAgIHZhciBzdGFydEFuZ2xlID0gYXJyb3dEYXRhLmFuZ2xlIC0gcGkgLyAyO1xuICAgICAgdmFyIGVuZEFuZ2xlID0gYXJyb3dEYXRhLmFuZ2xlICsgcGkgLyAyO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCBhcnJvd0RhdGEubGVuZ3RoICogMC40LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZmFsc2UpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDdXJ2ZTtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBpbnZlcnRlZCBjdXJ2ZSBlbmRwb2ludC5cclxuICovXG52YXIgSW52ZXJ0ZWRDdXJ2ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEludmVydGVkQ3VydmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEludmVydGVkQ3VydmUpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhJbnZlcnRlZEN1cnZlLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICB4OiAtMC4zLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50LCBhcnJvd0RhdGEpO1xuICAgICAgLy8gVXBkYXRlIGVuZHBvaW50IHN0eWxlIGZvciBkcmF3aW5nIHRyYW5zcGFyZW50IGFyYy5cbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgICBjdHguZmlsbFN0eWxlID0gXCJyZ2JhKDAsIDAsIDAsIDApXCI7XG4gICAgICAvLyBEZWZpbmUgaW52ZXJ0ZWQgY3VydmUgZW5kcG9pbnQgYXMgc2VtaWNpcmNsZS5cbiAgICAgIHZhciBwaSA9IE1hdGguUEk7XG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IGFycm93RGF0YS5hbmdsZSArIHBpIC8gMjtcbiAgICAgIHZhciBlbmRBbmdsZSA9IGFycm93RGF0YS5hbmdsZSArIDMgKiBwaSAvIDI7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIGFycm93RGF0YS5sZW5ndGggKiAwLjQsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBmYWxzZSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEludmVydGVkQ3VydmU7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgdHJpbmFnbGUgZW5kcG9pbnQuXHJcbiAqL1xudmFyIFRyaWFuZ2xlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJpYW5nbGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRyaWFuZ2xlKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoVHJpYW5nbGUsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnRzID0gW3tcbiAgICAgICAgeDogMC4wMixcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRyaWFuZ2xlO1xufSgpO1xuLyoqXHJcbiAqIERyYXdpbmcgbWV0aG9kcyBmb3IgdGhlIGludmVydGVkIHRyaW5hZ2xlIGVuZHBvaW50LlxyXG4gKi9cbnZhciBJbnZlcnRlZFRyaWFuZ2xlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSW52ZXJ0ZWRUcmlhbmdsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW52ZXJ0ZWRUcmlhbmdsZSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEludmVydGVkVHJpYW5nbGUsIG51bGwsIFt7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhpcyBzaGFwZSBhdCB0aGUgZW5kIG9mIGEgbGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIHNoYXBlIHdpbGwgYmUgcmVuZGVyZWQgaW50byB0aGlzIGNvbnRleHQuXHJcbiAgICAgKiBAcGFyYW0gYXJyb3dEYXRhIC0gVGhlIGRhdGEgZGV0ZXJtaW5pbmcgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybnMgVHJ1ZSBiZWNhdXNlIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3cuXHJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcmF3KGN0eCwgYXJyb3dEYXRhKSB7XG4gICAgICAvLyBOb3JtYWxpemVkIHBvaW50cyBvZiBjbG9zZWQgcGF0aCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBzaG91bGQgYmUgZHJhd24uXG4gICAgICAvLyAoMCwgMCkgaXMgdGhlIGF0dGFjaG1lbnQgcG9pbnQsIGFuZCB0aGUgcG9pbnQgYXJvdW5kIHdoaWNoIHNob3VsZCBiZSByb3RhdGVkXG4gICAgICB2YXIgcG9pbnRzID0gW3tcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IC0wLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTEsXG4gICAgICAgIHk6IDBcbiAgICAgIH1dO1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSW52ZXJ0ZWRUcmlhbmdsZTtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBjaXJjbGUgZW5kcG9pbnQuXHJcbiAqL1xudmFyIENpcmNsZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2lyY2xlKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoQ2lyY2xlLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICB4OiAtMC40LFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50LCBhcnJvd0RhdGEpO1xuICAgICAgZHJhd0NpcmNsZShjdHgsIHBvaW50LngsIHBvaW50LnksIGFycm93RGF0YS5sZW5ndGggKiAwLjQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDaXJjbGU7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgYmFyIGVuZHBvaW50LlxyXG4gKi9cbnZhciBCYXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhcik7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEJhciwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIC8qXHJcbiAgICAgIHZhciBwb2ludHMgPSBbXHJcbiAgICAgICAge3g6MCwgeTowLjV9LFxyXG4gICAgICAgIHt4OjAsIHk6LTAuNX1cclxuICAgICAgXTtcclxuICAgICAgICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xyXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcclxuICAgICAgY3R4LmxpbmVUbyhwb2ludHNbMV0ueCwgcG9pbnRzWzFdLnkpO1xyXG4gICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICovXG4gICAgICB2YXIgcG9pbnRzID0gW3tcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMC41XG4gICAgICB9LCB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IC0wLjVcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuMTUsXG4gICAgICAgIHk6IC0wLjVcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuMTUsXG4gICAgICAgIHk6IDAuNVxuICAgICAgfV07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCYXI7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgYm94IGVuZHBvaW50LlxyXG4gKi9cbnZhciBCb3ggPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCb3goKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJveCk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEJveCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGlzIHNoYXBlIGF0IHRoZSBlbmQgb2YgYSBsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGJlY2F1c2UgY3R4LmZpbGwoKSBjYW4gYmUgdXNlZCB0byBmaWxsIHRoZSBhcnJvdy5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIHZhciBwb2ludHMgPSBbe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogLTAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAtMC42LFxuICAgICAgICB5OiAtMC4zXG4gICAgICB9LCB7XG4gICAgICAgIHg6IC0wLjYsXG4gICAgICAgIHk6IDAuM1xuICAgICAgfV07XG4gICAgICBFbmRQb2ludC50cmFuc2Zvcm0ocG9pbnRzLCBhcnJvd0RhdGEpO1xuICAgICAgRW5kUG9pbnQuZHJhd1BhdGgoY3R4LCBwb2ludHMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCb3g7XG59KCk7XG4vKipcclxuICogRHJhd2luZyBtZXRob2RzIGZvciB0aGUgZGlhbW9uZCBlbmRwb2ludC5cclxuICovXG52YXIgRGlhbW9uZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERpYW1vbmQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpYW1vbmQpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhEaWFtb25kLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuNSxcbiAgICAgICAgeTogLTAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAtMC41LFxuICAgICAgICB5OiAwLjNcbiAgICAgIH1dO1xuICAgICAgRW5kUG9pbnQudHJhbnNmb3JtKHBvaW50cywgYXJyb3dEYXRhKTtcbiAgICAgIEVuZFBvaW50LmRyYXdQYXRoKGN0eCwgcG9pbnRzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRGlhbW9uZDtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSB2ZWUgZW5kcG9pbnQuXHJcbiAqL1xudmFyIFZlZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZlZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmVlKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoVmVlLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoaXMgc2hhcGUgYXQgdGhlIGVuZCBvZiBhIGxpbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBzaGFwZSB3aWxsIGJlIHJlbmRlcmVkIGludG8gdGhpcyBjb250ZXh0LlxyXG4gICAgICogQHBhcmFtIGFycm93RGF0YSAtIFRoZSBkYXRhIGRldGVybWluaW5nIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgYmVjYXVzZSBjdHguZmlsbCgpIGNhbiBiZSB1c2VkIHRvIGZpbGwgdGhlIGFycm93LlxyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJhdyhjdHgsIGFycm93RGF0YSkge1xuICAgICAgLy8gTm9ybWFsaXplZCBwb2ludHMgb2YgY2xvc2VkIHBhdGgsIGluIHRoZSBvcmRlciB0aGF0IHRoZXkgc2hvdWxkIGJlIGRyYXduLlxuICAgICAgLy8gKDAsIDApIGlzIHRoZSBhdHRhY2htZW50IHBvaW50LCBhbmQgdGhlIHBvaW50IGFyb3VuZCB3aGljaCBzaG91bGQgYmUgcm90YXRlZFxuICAgICAgdmFyIHBvaW50cyA9IFt7XG4gICAgICAgIHg6IC0xLFxuICAgICAgICB5OiAwLjNcbiAgICAgIH0sIHtcbiAgICAgICAgeDogLTAuNSxcbiAgICAgICAgeTogMFxuICAgICAgfSwge1xuICAgICAgICB4OiAtMSxcbiAgICAgICAgeTogLTAuM1xuICAgICAgfSwge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9XTtcbiAgICAgIEVuZFBvaW50LnRyYW5zZm9ybShwb2ludHMsIGFycm93RGF0YSk7XG4gICAgICBFbmRQb2ludC5kcmF3UGF0aChjdHgsIHBvaW50cyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFZlZTtcbn0oKTtcbi8qKlxyXG4gKiBEcmF3aW5nIG1ldGhvZHMgZm9yIHRoZSBlbmRwb2ludHMuXHJcbiAqL1xudmFyIEVuZFBvaW50cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEVuZFBvaW50cygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW5kUG9pbnRzKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoRW5kUG9pbnRzLCBudWxsLCBbe1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGFuIGVuZHBvaW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgc2hhcGUgd2lsbCBiZSByZW5kZXJlZCBpbnRvIHRoaXMgY29udGV4dC5cclxuICAgICAqIEBwYXJhbSBhcnJvd0RhdGEgLSBUaGUgZGF0YSBkZXRlcm1pbmluZyB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIGN0eC5maWxsKCkgY2FuIGJlIHVzZWQgdG8gZmlsbCB0aGUgYXJyb3csIGZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRyYXcoY3R4LCBhcnJvd0RhdGEpIHtcbiAgICAgIHZhciB0eXBlO1xuICAgICAgaWYgKGFycm93RGF0YS50eXBlKSB7XG4gICAgICAgIHR5cGUgPSBhcnJvd0RhdGEudHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgICAgIHJldHVybiBJbWFnZSQxLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgICBjYXNlIFwiY2lyY2xlXCI6XG4gICAgICAgICAgcmV0dXJuIENpcmNsZS5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgICAgY2FzZSBcImJveFwiOlxuICAgICAgICAgIHJldHVybiBCb3guZHJhdyhjdHgsIGFycm93RGF0YSk7XG4gICAgICAgIGNhc2UgXCJjcm93XCI6XG4gICAgICAgICAgcmV0dXJuIENyb3cuZHJhdyhjdHgsIGFycm93RGF0YSk7XG4gICAgICAgIGNhc2UgXCJjdXJ2ZVwiOlxuICAgICAgICAgIHJldHVybiBDdXJ2ZS5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgICAgY2FzZSBcImRpYW1vbmRcIjpcbiAgICAgICAgICByZXR1cm4gRGlhbW9uZC5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgICAgY2FzZSBcImludl9jdXJ2ZVwiOlxuICAgICAgICAgIHJldHVybiBJbnZlcnRlZEN1cnZlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgICBjYXNlIFwidHJpYW5nbGVcIjpcbiAgICAgICAgICByZXR1cm4gVHJpYW5nbGUuZHJhdyhjdHgsIGFycm93RGF0YSk7XG4gICAgICAgIGNhc2UgXCJpbnZfdHJpYW5nbGVcIjpcbiAgICAgICAgICByZXR1cm4gSW52ZXJ0ZWRUcmlhbmdsZS5kcmF3KGN0eCwgYXJyb3dEYXRhKTtcbiAgICAgICAgY2FzZSBcImJhclwiOlxuICAgICAgICAgIHJldHVybiBCYXIuZHJhdyhjdHgsIGFycm93RGF0YSk7XG4gICAgICAgIGNhc2UgXCJ2ZWVcIjpcbiAgICAgICAgICByZXR1cm4gVmVlLmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgICBjYXNlIFwiYXJyb3dcIjogLy8gZmFsbC10aHJvdWdoXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIEFycm93LmRyYXcoY3R4LCBhcnJvd0RhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRW5kUG9pbnRzO1xufSgpO1xuXG5mdW5jdGlvbiBvd25LZXlzJDEoZSwgcikgeyB2YXIgdCA9IF9PYmplY3Qka2V5cyhlKTsgaWYgKF9PYmplY3QkZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBvID0gX09iamVjdCRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7IHIgJiYgKG8gPSBfZmlsdGVySW5zdGFuY2VQcm9wZXJ0eShvKS5jYWxsKG8sIGZ1bmN0aW9uIChyKSB7IHJldHVybiBfT2JqZWN0JGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKGUsIHIpLmVudW1lcmFibGU7IH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pOyB9IHJldHVybiB0OyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEoZSkgeyBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykgeyB2YXIgX2NvbnRleHQyLCBfY29udGV4dDM7IHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTsgciAlIDIgPyBfZm9yRWFjaEluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQyID0gb3duS2V5cyQxKE9iamVjdCh0KSwgITApKS5jYWxsKF9jb250ZXh0MiwgZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IF9PYmplY3QkZGVmaW5lUHJvcGVydGllcyhlLCBfT2JqZWN0JGdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MyA9IG93bktleXMkMShPYmplY3QodCkpKS5jYWxsKF9jb250ZXh0MywgZnVuY3Rpb24gKHIpIHsgX09iamVjdCRkZWZpbmVQcm9wZXJ0eShlLCByLCBfT2JqZWN0JGdldE93blByb3BlcnR5RGVzY3JpcHRvciQxKHQsIHIpKTsgfSk7IH0gcmV0dXJuIGU7IH1cbi8qKlxyXG4gKiBUaGUgQmFzZSBDbGFzcyBmb3IgYWxsIGVkZ2VzLlxyXG4gKi9cbnZhciBFZGdlQmFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IG9mIGdpdmVuIGVkZ2UuXHJcbiAgICogQHBhcmFtIF9ib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG5ldHdvcmsuXHJcbiAgICogQHBhcmFtIF9sYWJlbE1vZHVsZSAtIExhYmVsIG1vZHVsZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gRWRnZUJhc2Uob3B0aW9ucywgX2JvZHksIF9sYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlQmFzZSk7XG4gICAgdGhpcy5fYm9keSA9IF9ib2R5O1xuICAgIHRoaXMuX2xhYmVsTW9kdWxlID0gX2xhYmVsTW9kdWxlO1xuICAgIHRoaXMuY29sb3IgPSB7fTtcbiAgICB0aGlzLmNvbG9yRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuaG92ZXJXaWR0aCA9IDEuNTtcbiAgICB0aGlzLnNlbGVjdGlvbldpZHRoID0gMjtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5mcm9tUG9pbnQgPSB0aGlzLmZyb207XG4gICAgdGhpcy50b1BvaW50ID0gdGhpcy50bztcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgX2NyZWF0ZUNsYXNzKEVkZ2VCYXNlLCBbe1xuICAgIGtleTogXCJjb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICB0aGlzLmZyb20gPSB0aGlzLl9ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy5mcm9tXTtcbiAgICAgIHRoaXMudG8gPSB0aGlzLl9ib2R5Lm5vZGVzW3RoaXMub3B0aW9ucy50b107XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsZWFudXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbmV3IGVkZ2Ugb3B0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBuZXcgZWRnZSBvcHRpb25zIG9iamVjdC5cclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgdGhpcy5mcm9tID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICB0aGlzLnRvID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dO1xuICAgICAgdGhpcy5pZCA9IHRoaXMub3B0aW9ucy5pZDtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0xpbmUoY3R4LCB2YWx1ZXMsIF9zZWxlY3RlZCwgX2hvdmVyKSB7XG4gICAgICB2YXIgdmlhTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogdGhpcy5nZXRWaWFOb2RlKCk7XG4gICAgICAvLyBzZXQgc3R5bGVcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuZ2V0Q29sb3IoY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHZhbHVlcy53aWR0aDtcbiAgICAgIGlmICh2YWx1ZXMuZGFzaGVzICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLl9kcmF3RGFzaGVkTGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9kcmF3TGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIGxpbmUgd2l0aCBnaXZlbiBzdHlsZSBiZXR3ZWVuIHR3byBub2RlcyB0aHJvdWdoIHN1cHBsaWVkIG5vZGUocykuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gRm9ybWF0dGluZyB2YWx1ZXMgbGlrZSBjb2xvciwgb3BhY2l0eSBvciBzaGFkb3cuXHJcbiAgICAgKiBAcGFyYW0gdmlhTm9kZSAtIEFkZGl0aW9uYWwgY29udHJvbCBwb2ludChzKSBmb3IgdGhlIGVkZ2UuXHJcbiAgICAgKiBAcGFyYW0gZnJvbVBvaW50IC0gVE9ETzogU2VlbXMgaWdub3JlZCwgcmVtb3ZlP1xyXG4gICAgICogQHBhcmFtIHRvUG9pbnQgLSBUT0RPOiBTZWVtcyBpZ25vcmVkLCByZW1vdmU/XHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd0xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdMaW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlLCBmcm9tUG9pbnQsIHRvUG9pbnQpIHtcbiAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICAvLyBkcmF3IGxpbmVcbiAgICAgICAgdGhpcy5fbGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSwgZnJvbVBvaW50LCB0b1BvaW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfdGhpcyRfZ2V0Q2lyY2xlRGF0YSA9IHRoaXMuX2dldENpcmNsZURhdGEoY3R4KSxcbiAgICAgICAgICBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YSwgMyksXG4gICAgICAgICAgeCA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMlswXSxcbiAgICAgICAgICB5ID0gX3RoaXMkX2dldENpcmNsZURhdGEyWzFdLFxuICAgICAgICAgIHJhZGl1cyA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMlsyXTtcbiAgICAgICAgdGhpcy5fY2lyY2xlKGN0eCwgdmFsdWVzLCB4LCB5LCByYWRpdXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIERyYXcgYSBkYXNoZWQgbGluZSB3aXRoIGdpdmVuIHN0eWxlIGJldHdlZW4gdHdvIG5vZGVzIHRocm91Z2ggc3VwcGxpZWQgbm9kZShzKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBGb3JtYXR0aW5nIHZhbHVlcyBsaWtlIGNvbG9yLCBvcGFjaXR5IG9yIHNoYWRvdy5cclxuICAgICAqIEBwYXJhbSB2aWFOb2RlIC0gQWRkaXRpb25hbCBjb250cm9sIHBvaW50KHMpIGZvciB0aGUgZWRnZS5cclxuICAgICAqIEBwYXJhbSBfZnJvbVBvaW50IC0gSWdub3JlZCAoVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUpLlxyXG4gICAgICogQHBhcmFtIF90b1BvaW50IC0gSWdub3JlZCAoVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUpLlxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdEYXNoZWRMaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3RGFzaGVkTGluZShjdHgsIHZhbHVlcywgdmlhTm9kZSwgX2Zyb21Qb2ludCwgX3RvUG9pbnQpIHtcbiAgICAgIGN0eC5saW5lQ2FwID0gXCJyb3VuZFwiO1xuICAgICAgdmFyIHBhdHRlcm4gPSBfQXJyYXkkaXNBcnJheSh2YWx1ZXMuZGFzaGVzKSA/IHZhbHVlcy5kYXNoZXMgOiBbNSwgNV07XG4gICAgICAvLyBvbmx5IGZpcmVmb3ggYW5kIGNocm9tZSBzdXBwb3J0IHRoaXMgbWV0aG9kLCBlbHNlIHdlIHVzZSB0aGUgbGVnYWN5IG9uZS5cbiAgICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAvLyBzZXQgZGFzaCBzZXR0aW5ncyBmb3IgY2hyb21lIG9yIGZpcmVmb3hcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKHBhdHRlcm4pO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSAwO1xuICAgICAgICAvLyBkcmF3IHRoZSBsaW5lXG4gICAgICAgIGlmICh0aGlzLmZyb20gIT0gdGhpcy50bykge1xuICAgICAgICAgIC8vIGRyYXcgbGluZVxuICAgICAgICAgIHRoaXMuX2xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTMgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCksXG4gICAgICAgICAgICBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTQgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YTMsIDMpLFxuICAgICAgICAgICAgeCA9IF90aGlzJF9nZXRDaXJjbGVEYXRhNFswXSxcbiAgICAgICAgICAgIHkgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTRbMV0sXG4gICAgICAgICAgICByYWRpdXMgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTRbMl07XG4gICAgICAgICAgdGhpcy5fY2lyY2xlKGN0eCwgdmFsdWVzLCB4LCB5LCByYWRpdXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIGRhc2ggc2V0dGluZ3MuXG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChbMF0pO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSAwO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdW5zdXBwb3J0aW5nIHNtb290aCBsaW5lc1xuICAgICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgICAvLyBkcmF3IGxpbmVcbiAgICAgICAgICBkcmF3RGFzaGVkTGluZShjdHgsIHRoaXMuZnJvbS54LCB0aGlzLmZyb20ueSwgdGhpcy50by54LCB0aGlzLnRvLnksIHBhdHRlcm4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTUgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCksXG4gICAgICAgICAgICBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTYgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0Q2lyY2xlRGF0YTUsIDMpLFxuICAgICAgICAgICAgX3ggPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTZbMF0sXG4gICAgICAgICAgICBfeSA9IF90aGlzJF9nZXRDaXJjbGVEYXRhNlsxXSxcbiAgICAgICAgICAgIF9yYWRpdXMgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTZbMl07XG4gICAgICAgICAgdGhpcy5fY2lyY2xlKGN0eCwgdmFsdWVzLCBfeCwgX3ksIF9yYWRpdXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIC8vIGRpc2FibGUgc2hhZG93cyBmb3Igb3RoZXIgZWxlbWVudHMuXG4gICAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogRmluZCB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIGJvcmRlciBvZiB0aGUgbm9kZSBhbmQgdGhlIGVkZ2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSAoZWl0aGVyIGZyb20gb3IgdG8gbm9kZSBvZiB0aGUgZWRnZSkuXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zLlxyXG4gICAgICogQHJldHVybnMgQ2FydGVzaWFuIGNvb3JkaW5hdGVzIG9mIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgYm9yZGVyIG9mIHRoZSBub2RlIGFuZCB0aGUgZWRnZS5cclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZpbmRCb3JkZXJQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQm9yZGVyUG9zaXRpb24obm9kZSwgY3R4LCBvcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbihub2RlLCBjdHgsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZShub2RlLCBjdHgsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJmaW5kQm9yZGVyUG9zaXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRCb3JkZXJQb3NpdGlvbnMoY3R4KSB7XG4gICAgICBpZiAodGhpcy5mcm9tICE9IHRoaXMudG8pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBmcm9tOiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb24odGhpcy5mcm9tLCBjdHgpLFxuICAgICAgICAgIHRvOiB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb24odGhpcy50bywgY3R4KVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9jb250ZXh0O1xuICAgICAgICB2YXIgX3RoaXMkX2dldENpcmNsZURhdGEkID0gX3NsaWNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dCA9IHRoaXMuX2dldENpcmNsZURhdGEoY3R4KSkuY2FsbChfY29udGV4dCwgMCwgMiksXG4gICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGEkMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRDaXJjbGVEYXRhJCwgMiksXG4gICAgICAgICAgeCA9IF90aGlzJF9nZXRDaXJjbGVEYXRhJDJbMF0sXG4gICAgICAgICAgeSA9IF90aGlzJF9nZXRDaXJjbGVEYXRhJDJbMV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZnJvbTogdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSwgY3R4LCB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIGxvdzogMC4yNSxcbiAgICAgICAgICAgIGhpZ2g6IDAuNixcbiAgICAgICAgICAgIGRpcmVjdGlvbjogLTFcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0bzogdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSwgY3R4LCB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIGxvdzogMC42LFxuICAgICAgICAgICAgaGlnaDogMC44LFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAxXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBDb21wdXRlIHRoZSBjZW50ZXIgcG9pbnQgYW5kIHJhZGl1cyBvZiBhbiBlZGdlIGNvbm5lY3RlZCB0byB0aGUgc2FtZSBub2RlIGF0IGJvdGggZW5kcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEByZXR1cm5zIGBbeCwgeSwgcmFkaXVzXWBcclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDaXJjbGVEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDaXJjbGVEYXRhKGN0eCkge1xuICAgICAgdmFyIHJhZGl1cyA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLnNpemU7XG4gICAgICBpZiAoY3R4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5zaGFwZS53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5mcm9tLnNoYXBlLnJlc2l6ZShjdHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBnZXQgY2lyY2xlIGNvb3JkaW5hdGVzXG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZXRTZWxmUmVmQ29vcmRpbmF0ZXMoY3R4LCB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSwgcmFkaXVzLCB0aGlzLmZyb20pO1xuICAgICAgcmV0dXJuIFtjb29yZGluYXRlcy54LCBjb29yZGluYXRlcy55LCByYWRpdXNdO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdldCBhIHBvaW50IG9uIGEgY2lyY2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB4IC0gQ2VudGVyIG9mIHRoZSBjaXJjbGUgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5IC0gQ2VudGVyIG9mIHRoZSBjaXJjbGUgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSByYWRpdXMgLSBSYWRpdXMgb2YgdGhlIGNpcmNsZS5cclxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiAtIFZhbHVlIGJldHdlZW4gMCAobGluZSBzdGFydCkgYW5kIDEgKGxpbmUgZW5kKS5cclxuICAgICAqIEByZXR1cm5zIENhcnRlc2lhbiBjb29yZGluYXRlcyBvZiByZXF1ZXN0ZWQgcG9pbnQgb24gdGhlIGNpcmNsZS5cclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9wb2ludE9uQ2lyY2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb2ludE9uQ2lyY2xlKHgsIHksIHJhZGl1cywgcG9zaXRpb24pIHtcbiAgICAgIHZhciBhbmdsZSA9IHBvc2l0aW9uICogMiAqIE1hdGguUEk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5OiB5IC0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICB9O1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUgYW5kIHRoZSBlZGdlLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHVzZXMgYmluYXJ5IHNlYXJjaCB0byBsb29rIGZvciB0aGUgcG9pbnQgd2hlcmUgdGhlIGNpcmNsZSBjcm9zc2VzIHRoZSBib3JkZXIgb2YgdGhlIG5vZGUuXHJcbiAgICAgKiBAcGFyYW0gbmVhck5vZGUgLSBUaGUgbm9kZSAoZWl0aGVyIGZyb20gb3IgdG8gbm9kZSBvZiB0aGUgZWRnZSkuXHJcbiAgICAgKiBAcGFyYW0gY3R4IC0gVGhlIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgZm9yIHJlbmRlcmluZy5cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zLlxyXG4gICAgICogQHJldHVybnMgQ2FydGVzaWFuIGNvb3JkaW5hdGVzIG9mIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgYm9yZGVyIG9mIHRoZSBub2RlIGFuZCB0aGUgZWRnZS5cclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9maW5kQm9yZGVyUG9zaXRpb25DaXJjbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZShuZWFyTm9kZSwgY3R4LCBvcHRpb25zKSB7XG4gICAgICB2YXIgeCA9IG9wdGlvbnMueDtcbiAgICAgIHZhciB5ID0gb3B0aW9ucy55O1xuICAgICAgdmFyIGxvdyA9IG9wdGlvbnMubG93O1xuICAgICAgdmFyIGhpZ2ggPSBvcHRpb25zLmhpZ2g7XG4gICAgICB2YXIgZGlyZWN0aW9uID0gb3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IDEwO1xuICAgICAgdmFyIHJhZGl1cyA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLnNpemU7XG4gICAgICB2YXIgdGhyZXNob2xkID0gMC4wNTtcbiAgICAgIHZhciBwb3M7XG4gICAgICB2YXIgbWlkZGxlID0gKGxvdyArIGhpZ2gpICogMC41O1xuICAgICAgdmFyIGVuZFBvaW50T2Zmc2V0ID0gMDtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dTdHJpa2V0aHJvdWdoID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAgICAgZW5kUG9pbnRPZmZzZXQgPSB0aGlzLm9wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IDEpIHtcbiAgICAgICAgICBlbmRQb2ludE9mZnNldCA9IHRoaXMub3B0aW9ucy5lbmRQb2ludE9mZnNldC50bztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGl0ZXJhdGlvbiA9IDA7XG4gICAgICBkbyB7XG4gICAgICAgIG1pZGRsZSA9IChsb3cgKyBoaWdoKSAqIDAuNTtcbiAgICAgICAgcG9zID0gdGhpcy5fcG9pbnRPbkNpcmNsZSh4LCB5LCByYWRpdXMsIG1pZGRsZSk7XG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIobmVhck5vZGUueSAtIHBvcy55LCBuZWFyTm9kZS54IC0gcG9zLngpO1xuICAgICAgICB2YXIgZGlzdGFuY2VUb0JvcmRlciA9IG5lYXJOb2RlLmRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkgKyBlbmRQb2ludE9mZnNldDtcbiAgICAgICAgdmFyIGRpc3RhbmNlVG9Qb2ludCA9IE1hdGguc3FydChNYXRoLnBvdyhwb3MueCAtIG5lYXJOb2RlLngsIDIpICsgTWF0aC5wb3cocG9zLnkgLSBuZWFyTm9kZS55LCAyKSk7XG4gICAgICAgIHZhciBkaWZmZXJlbmNlID0gZGlzdGFuY2VUb0JvcmRlciAtIGRpc3RhbmNlVG9Qb2ludDtcbiAgICAgICAgaWYgKE1hdGguYWJzKGRpZmZlcmVuY2UpIDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgYnJlYWs7IC8vIGZvdW5kXG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZmVyZW5jZSA+IDApIHtcbiAgICAgICAgICAvLyBkaXN0YW5jZSB0byBub2RlcyBpcyBsYXJnZXIgdGhhbiBkaXN0YW5jZSB0byBib3JkZXIgLS0+IHQgbmVlZHMgdG8gYmUgYmlnZ2VyIGlmIHdlJ3JlIGxvb2tpbmcgYXQgdGhlIHRvIG5vZGUuXG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZGRsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZGRsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWRkbGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZGRsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKytpdGVyYXRpb247XG4gICAgICB9IHdoaWxlIChsb3cgPD0gaGlnaCAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKTtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDEoX29iamVjdFNwcmVhZCQxKHt9LCBwb3MpLCB7fSwge1xuICAgICAgICB0OiBtaWRkbGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbGluZSB3aWR0aCBvZiB0aGUgZWRnZS4gRGVwZW5kcyBvbiB3aWR0aCBhbmQgd2hldGhlciBvbmUgb2YgdGhlIGNvbm5lY3RlZCBub2RlcyBpcyBzZWxlY3RlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc2VsZWN0ZWQgLSBEZXRlcm1pbmVzIHdoZXRlciB0aGUgbGluZSBpcyBzZWxlY3RlZC5cclxuICAgICAqIEBwYXJhbSBob3ZlciAtIERldGVybWluZXMgd2hldGVyIHRoZSBsaW5lIGlzIGJlaW5nIGhvdmVyZWQsIG9ubHkgYXBwbGllcyBpZiBzZWxlY3RlZCBpcyBmYWxzZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSB3aWR0aCBvZiB0aGUgbGluZS5cclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldExpbmVXaWR0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMaW5lV2lkdGgoc2VsZWN0ZWQsIGhvdmVyKSB7XG4gICAgICBpZiAoc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuc2VsZWN0aW9uV2lkdGgsIDAuMyAvIHRoaXMuX2JvZHkudmlldy5zY2FsZSk7XG4gICAgICB9IGVsc2UgaWYgKGhvdmVyID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0aGlzLmhvdmVyV2lkdGgsIDAuMyAvIHRoaXMuX2JvZHkudmlldy5zY2FsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5vcHRpb25zLndpZHRoLCAwLjMgLyB0aGlzLl9ib2R5LnZpZXcuc2NhbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIENvbXB1dGUgdGhlIGNvbG9yIG9yIGdyYWRpZW50IGZvciBnaXZlbiBlZGdlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIEZvcm1hdHRpbmcgdmFsdWVzIGxpa2UgY29sb3IsIG9wYWNpdHkgb3Igc2hhZG93LlxyXG4gICAgICogQHBhcmFtIF9zZWxlY3RlZCAtIElnbm9yZWQgKFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlKS5cclxuICAgICAqIEBwYXJhbSBfaG92ZXIgLSBJZ25vcmVkIChUT0RPOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSkuXHJcbiAgICAgKiBAcmV0dXJucyBDb2xvciBzdHJpbmcgaWYgc2luZ2xlIGNvbG9yIGlzIGluaGVyaXRlZCBvciBncmFkaWVudCBpZiB0d28uXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb2xvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb2xvcihjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5pbmhlcml0c0NvbG9yICE9PSBmYWxzZSkge1xuICAgICAgICAvLyB3aGVuIHRoaXMgaXMgYSBsb29wIGVkZ2UsIGp1c3QgdXNlIHRoZSAnZnJvbScgbWV0aG9kXG4gICAgICAgIGlmICh2YWx1ZXMuaW5oZXJpdHNDb2xvciA9PT0gXCJib3RoXCIgJiYgdGhpcy5mcm9tLmlkICE9PSB0aGlzLnRvLmlkKSB7XG4gICAgICAgICAgdmFyIGdyZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLmZyb20ueCwgdGhpcy5mcm9tLnksIHRoaXMudG8ueCwgdGhpcy50by55KTtcbiAgICAgICAgICB2YXIgZnJvbUNvbG9yID0gdGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuaGlnaGxpZ2h0LmJvcmRlcjtcbiAgICAgICAgICB2YXIgdG9Db2xvciA9IHRoaXMudG8ub3B0aW9ucy5jb2xvci5oaWdobGlnaHQuYm9yZGVyO1xuICAgICAgICAgIGlmICh0aGlzLmZyb20uc2VsZWN0ZWQgPT09IGZhbHNlICYmIHRoaXMudG8uc2VsZWN0ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmcm9tQ29sb3IgPSBvdmVycmlkZU9wYWNpdHkodGhpcy5mcm9tLm9wdGlvbnMuY29sb3IuYm9yZGVyLCB2YWx1ZXMub3BhY2l0eSk7XG4gICAgICAgICAgICB0b0NvbG9yID0gb3ZlcnJpZGVPcGFjaXR5KHRoaXMudG8ub3B0aW9ucy5jb2xvci5ib3JkZXIsIHZhbHVlcy5vcGFjaXR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZnJvbS5zZWxlY3RlZCA9PT0gdHJ1ZSAmJiB0aGlzLnRvLnNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdG9Db2xvciA9IHRoaXMudG8ub3B0aW9ucy5jb2xvci5ib3JkZXI7XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZyb20uc2VsZWN0ZWQgPT09IGZhbHNlICYmIHRoaXMudG8uc2VsZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGZyb21Db2xvciA9IHRoaXMuZnJvbS5vcHRpb25zLmNvbG9yLmJvcmRlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZ3JkLmFkZENvbG9yU3RvcCgwLCBmcm9tQ29sb3IpO1xuICAgICAgICAgIGdyZC5hZGRDb2xvclN0b3AoMSwgdG9Db2xvcik7XG4gICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0gdGhpcyByZXR1cm5zIC0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4gICAgICAgICAgcmV0dXJuIGdyZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVzLmluaGVyaXRzQ29sb3IgPT09IFwidG9cIikge1xuICAgICAgICAgIHJldHVybiBvdmVycmlkZU9wYWNpdHkodGhpcy50by5vcHRpb25zLmNvbG9yLmJvcmRlciwgdmFsdWVzLm9wYWNpdHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFwiZnJvbVwiXG4gICAgICAgICAgcmV0dXJuIG92ZXJyaWRlT3BhY2l0eSh0aGlzLmZyb20ub3B0aW9ucy5jb2xvci5ib3JkZXIsIHZhbHVlcy5vcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG92ZXJyaWRlT3BhY2l0eSh2YWx1ZXMuY29sb3IsIHZhbHVlcy5vcGFjaXR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgbGluZSBmcm9tIGEgbm9kZSB0byBpdHNlbGYsIGEgY2lyY2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIEZvcm1hdHRpbmcgdmFsdWVzIGxpa2UgY29sb3IsIG9wYWNpdHkgb3Igc2hhZG93LlxyXG4gICAgICogQHBhcmFtIHggLSBDZW50ZXIgb2YgdGhlIGNpcmNsZSBvbiB0aGUgeCBheGlzLlxyXG4gICAgICogQHBhcmFtIHkgLSBDZW50ZXIgb2YgdGhlIGNpcmNsZSBvbiB0aGUgeSBheGlzLlxyXG4gICAgICogQHBhcmFtIHJhZGl1cyAtIFJhZGl1cyBvZiB0aGUgY2lyY2xlLlxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NpcmNsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2lyY2xlKGN0eCwgdmFsdWVzLCB4LCB5LCByYWRpdXMpIHtcbiAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIC8vZnVsbCBjaXJjbGVcbiAgICAgIHZhciBhbmdsZUZyb20gPSAwO1xuICAgICAgdmFyIGFuZ2xlVG8gPSBNYXRoLlBJICogMjtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UucmVuZGVyQmVoaW5kVGhlTm9kZSkge1xuICAgICAgICAvL3JlbmRlciBvbmx5IHBhcnRzIHdoaWNoIGFyZSBub3Qgb3ZlcmxhcGluZyB3aXRoIHBhcmVudCBub2RlXG4gICAgICAgIC8vbmVlZCB0byBmaW5kIHgseSBvZiBmcm9tIHBvaW50IGFuZCB4LHkgdG8gcG9pbnRcbiAgICAgICAgLy9jYWxjdWxhdGluZyByYWRpYW5zXG4gICAgICAgIHZhciBsb3cgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZTtcbiAgICAgICAgdmFyIGhpZ2ggPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSArIE1hdGguUEk7XG4gICAgICAgIHZhciBwb2ludFRGcm9tID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSwgY3R4LCB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIGxvdzogbG93LFxuICAgICAgICAgIGhpZ2g6IGhpZ2gsXG4gICAgICAgICAgZGlyZWN0aW9uOiAtMVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBvaW50VFRvID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSwgY3R4LCB7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5LFxuICAgICAgICAgIGxvdzogbG93LFxuICAgICAgICAgIGhpZ2g6IGhpZ2gsXG4gICAgICAgICAgZGlyZWN0aW9uOiAxXG4gICAgICAgIH0pO1xuICAgICAgICBhbmdsZUZyb20gPSBNYXRoLmF0YW4yKHBvaW50VEZyb20ueSAtIHksIHBvaW50VEZyb20ueCAtIHgpO1xuICAgICAgICBhbmdsZVRvID0gTWF0aC5hdGFuMihwb2ludFRUby55IC0geSwgcG9pbnRUVG8ueCAtIHgpO1xuICAgICAgfVxuICAgICAgLy8gZHJhdyBhIGNpcmNsZVxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIGFuZ2xlRnJvbSwgYW5nbGVUbywgZmFsc2UpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgLy8gZGlzYWJsZSBzaGFkb3dzIGZvciBvdGhlciBlbGVtZW50cy5cbiAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQGluaGVyaXREb2NcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg0OTIxMS9zaG9ydGVzdC1kaXN0YW5jYWUtYmV0d2Vlbi1hLXBvaW50LWFuZC1hLWxpbmUtc2VnbWVudFxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGlzdGFuY2VUb0VkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGlzdGFuY2VUb0VkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgaWYgKHRoaXMuZnJvbSAhPSB0aGlzLnRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTcgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKHVuZGVmaW5lZCksXG4gICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGE4ID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldENpcmNsZURhdGE3LCAzKSxcbiAgICAgICAgICB4ID0gX3RoaXMkX2dldENpcmNsZURhdGE4WzBdLFxuICAgICAgICAgIHkgPSBfdGhpcyRfZ2V0Q2lyY2xlRGF0YThbMV0sXG4gICAgICAgICAgcmFkaXVzID0gX3RoaXMkX2dldENpcmNsZURhdGE4WzJdO1xuICAgICAgICB2YXIgZHggPSB4IC0geDM7XG4gICAgICAgIHZhciBkeSA9IHkgLSB5MztcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgLSByYWRpdXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiBhIHBvaW50ICh4MywgeTMpIGFuZCBhIGxpbmUgc2VnbWVudCBmcm9tICh4MSwgeTEpIHRvICh4MiwgeTIpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB4MSAtIEZpcnN0IGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB4IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geTEgLSBGaXJzdCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeSBheGlzLlxyXG4gICAgICogQHBhcmFtIHgyIC0gU2Vjb25kIGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB4IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geTIgLSBTZWNvbmQgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSB4MyAtIFBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzLlxyXG4gICAgICogQHBhcmFtIHkzIC0gUG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgbGluZSBzZWdtZW50IGFuZCB0aGUgcG9pbnQuXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RGlzdGFuY2VUb0xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9MaW5lKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIHZhciBweCA9IHgyIC0geDE7XG4gICAgICB2YXIgcHkgPSB5MiAtIHkxO1xuICAgICAgdmFyIHNvbWV0aGluZyA9IHB4ICogcHggKyBweSAqIHB5O1xuICAgICAgdmFyIHUgPSAoKHgzIC0geDEpICogcHggKyAoeTMgLSB5MSkgKiBweSkgLyBzb21ldGhpbmc7XG4gICAgICBpZiAodSA+IDEpIHtcbiAgICAgICAgdSA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHUgPCAwKSB7XG4gICAgICAgIHUgPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHggPSB4MSArIHUgKiBweDtcbiAgICAgIHZhciB5ID0geTEgKyB1ICogcHk7XG4gICAgICB2YXIgZHggPSB4IC0geDM7XG4gICAgICB2YXIgZHkgPSB5IC0geTM7XG4gICAgICAvLyMgTm90ZTogSWYgdGhlIGFjdHVhbCBkaXN0YW5jZSBkb2VzIG5vdCBtYXR0ZXIsXG4gICAgICAvLyMgaWYgeW91IG9ubHkgd2FudCB0byBjb21wYXJlIHdoYXQgdGhpcyBmdW5jdGlvblxuICAgICAgLy8jIHJldHVybnMgdG8gb3RoZXIgcmVzdWx0cyBvZiB0aGlzIGZ1bmN0aW9uLCB5b3VcbiAgICAgIC8vIyBjYW4ganVzdCByZXR1cm4gdGhlIHNxdWFyZWQgZGlzdGFuY2UgaW5zdGVhZFxuICAgICAgLy8jIChpLmUuIHJlbW92ZSB0aGUgc3FydCkgdG8gZ2FpbiBhIGxpdHRsZSBwZXJmb3JtYW5jZVxuICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEFycm93RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBcnJvd0RhdGEoY3R4LCBwb3NpdGlvbiwgdmlhTm9kZSwgX3NlbGVjdGVkLCBfaG92ZXIsIHZhbHVlcykge1xuICAgICAgLy8gc2V0IGxldHNcbiAgICAgIHZhciBhbmdsZTtcbiAgICAgIHZhciBhcnJvd1BvaW50O1xuICAgICAgdmFyIG5vZGUxO1xuICAgICAgdmFyIG5vZGUyO1xuICAgICAgdmFyIHJldmVyc2VkO1xuICAgICAgdmFyIHNjYWxlRmFjdG9yO1xuICAgICAgdmFyIHR5cGU7XG4gICAgICB2YXIgbGluZVdpZHRoID0gdmFsdWVzLndpZHRoO1xuICAgICAgaWYgKHBvc2l0aW9uID09PSBcImZyb21cIikge1xuICAgICAgICBub2RlMSA9IHRoaXMuZnJvbTtcbiAgICAgICAgbm9kZTIgPSB0aGlzLnRvO1xuICAgICAgICByZXZlcnNlZCA9IHZhbHVlcy5mcm9tQXJyb3dTY2FsZSA8IDA7XG4gICAgICAgIHNjYWxlRmFjdG9yID0gTWF0aC5hYnModmFsdWVzLmZyb21BcnJvd1NjYWxlKTtcbiAgICAgICAgdHlwZSA9IHZhbHVlcy5mcm9tQXJyb3dUeXBlO1xuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gXCJ0b1wiKSB7XG4gICAgICAgIG5vZGUxID0gdGhpcy50bztcbiAgICAgICAgbm9kZTIgPSB0aGlzLmZyb207XG4gICAgICAgIHJldmVyc2VkID0gdmFsdWVzLnRvQXJyb3dTY2FsZSA8IDA7XG4gICAgICAgIHNjYWxlRmFjdG9yID0gTWF0aC5hYnModmFsdWVzLnRvQXJyb3dTY2FsZSk7XG4gICAgICAgIHR5cGUgPSB2YWx1ZXMudG9BcnJvd1R5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlMSA9IHRoaXMudG87XG4gICAgICAgIG5vZGUyID0gdGhpcy5mcm9tO1xuICAgICAgICByZXZlcnNlZCA9IHZhbHVlcy5taWRkbGVBcnJvd1NjYWxlIDwgMDtcbiAgICAgICAgc2NhbGVGYWN0b3IgPSBNYXRoLmFicyh2YWx1ZXMubWlkZGxlQXJyb3dTY2FsZSk7XG4gICAgICAgIHR5cGUgPSB2YWx1ZXMubWlkZGxlQXJyb3dUeXBlO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IDE1ICogc2NhbGVGYWN0b3IgKyAzICogbGluZVdpZHRoOyAvLyAzKiBsaW5lV2lkdGggaXMgdGhlIHdpZHRoIG9mIHRoZSBlZGdlLlxuICAgICAgLy8gaWYgbm90IGNvbm5lY3RlZCB0byBpdHNlbGZcbiAgICAgIGlmIChub2RlMSAhPSBub2RlMikge1xuICAgICAgICB2YXIgYXBwcm94aW1hdGVFZGdlTGVuZ3RoID0gX01hdGgkaHlwb3Qobm9kZTEueCAtIG5vZGUyLngsIG5vZGUxLnkgLSBub2RlMi55KTtcbiAgICAgICAgdmFyIHJlbGF0aXZlTGVuZ3RoID0gbGVuZ3RoIC8gYXBwcm94aW1hdGVFZGdlTGVuZ3RoO1xuICAgICAgICBpZiAocG9zaXRpb24gIT09IFwibWlkZGxlXCIpIHtcbiAgICAgICAgICAvLyBkcmF3IGFycm93IGhlYWRcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNtb290aC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRUID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uKG5vZGUxLCBjdHgsIHtcbiAgICAgICAgICAgICAgdmlhOiB2aWFOb2RlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBndWlkZVBvcyA9IHRoaXMuZ2V0UG9pbnQocG9pbnRULnQgKyByZWxhdGl2ZUxlbmd0aCAqIChwb3NpdGlvbiA9PT0gXCJmcm9tXCIgPyAxIDogLTEpLCB2aWFOb2RlKTtcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMihwb2ludFQueSAtIGd1aWRlUG9zLnksIHBvaW50VC54IC0gZ3VpZGVQb3MueCk7XG4gICAgICAgICAgICBhcnJvd1BvaW50ID0gcG9pbnRUO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIobm9kZTEueSAtIG5vZGUyLnksIG5vZGUxLnggLSBub2RlMi54KTtcbiAgICAgICAgICAgIGFycm93UG9pbnQgPSB0aGlzLl9maW5kQm9yZGVyUG9zaXRpb24obm9kZTEsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5lZ2F0aXZlIGhhbGYgbGVuZ3RoIHJldmVyc2VzIGFycm93IGRpcmVjdGlvbi5cbiAgICAgICAgICB2YXIgaGFsZkxlbmd0aCA9IChyZXZlcnNlZCA/IC1yZWxhdGl2ZUxlbmd0aCA6IHJlbGF0aXZlTGVuZ3RoKSAvIDI7XG4gICAgICAgICAgdmFyIGd1aWRlUG9zMSA9IHRoaXMuZ2V0UG9pbnQoMC41ICsgaGFsZkxlbmd0aCwgdmlhTm9kZSk7XG4gICAgICAgICAgdmFyIGd1aWRlUG9zMiA9IHRoaXMuZ2V0UG9pbnQoMC41IC0gaGFsZkxlbmd0aCwgdmlhTm9kZSk7XG4gICAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKGd1aWRlUG9zMS55IC0gZ3VpZGVQb3MyLnksIGd1aWRlUG9zMS54IC0gZ3VpZGVQb3MyLngpO1xuICAgICAgICAgIGFycm93UG9pbnQgPSB0aGlzLmdldFBvaW50KDAuNSwgdmlhTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRyYXcgY2lyY2xlXG4gICAgICAgIHZhciBfdGhpcyRfZ2V0Q2lyY2xlRGF0YTkgPSB0aGlzLl9nZXRDaXJjbGVEYXRhKGN0eCksXG4gICAgICAgICAgX3RoaXMkX2dldENpcmNsZURhdGExMCA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRDaXJjbGVEYXRhOSwgMyksXG4gICAgICAgICAgeCA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMTBbMF0sXG4gICAgICAgICAgeSA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMTBbMV0sXG4gICAgICAgICAgcmFkaXVzID0gX3RoaXMkX2dldENpcmNsZURhdGExMFsyXTtcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSBcImZyb21cIikge1xuICAgICAgICAgIHZhciBsb3cgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZTtcbiAgICAgICAgICB2YXIgaGlnaCA9IHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLmFuZ2xlICsgTWF0aC5QSTtcbiAgICAgICAgICB2YXIgX3BvaW50VCA9IHRoaXMuX2ZpbmRCb3JkZXJQb3NpdGlvbkNpcmNsZSh0aGlzLmZyb20sIGN0eCwge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICBsb3c6IGxvdyxcbiAgICAgICAgICAgIGhpZ2g6IGhpZ2gsXG4gICAgICAgICAgICBkaXJlY3Rpb246IC0xXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYW5nbGUgPSBfcG9pbnRULnQgKiAtMiAqIE1hdGguUEkgKyAxLjUgKiBNYXRoLlBJICsgMC4xICogTWF0aC5QSTtcbiAgICAgICAgICBhcnJvd1BvaW50ID0gX3BvaW50VDtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gXCJ0b1wiKSB7XG4gICAgICAgICAgdmFyIF9sb3cgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZTtcbiAgICAgICAgICB2YXIgX2hpZ2ggPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSArIE1hdGguUEk7XG4gICAgICAgICAgdmFyIF9wb2ludFQyID0gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQ2lyY2xlKHRoaXMuZnJvbSwgY3R4LCB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeSxcbiAgICAgICAgICAgIGxvdzogX2xvdyxcbiAgICAgICAgICAgIGhpZ2g6IF9oaWdoLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAxXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYW5nbGUgPSBfcG9pbnRUMi50ICogLTIgKiBNYXRoLlBJICsgMS41ICogTWF0aC5QSSAtIDEuMSAqIE1hdGguUEk7XG4gICAgICAgICAgYXJyb3dQb2ludCA9IF9wb2ludFQyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwb3MgPSB0aGlzLm9wdGlvbnMuc2VsZlJlZmVyZW5jZS5hbmdsZSAvICgyICogTWF0aC5QSSk7XG4gICAgICAgICAgYXJyb3dQb2ludCA9IHRoaXMuX3BvaW50T25DaXJjbGUoeCwgeSwgcmFkaXVzLCBwb3MpO1xuICAgICAgICAgIGFuZ2xlID0gcG9zICogLTIgKiBNYXRoLlBJICsgMS41ICogTWF0aC5QSSArIDAuMSAqIE1hdGguUEk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciB4aSA9IGFycm93UG9pbnQueCAtIGxlbmd0aCAqIDAuOSAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIHZhciB5aSA9IGFycm93UG9pbnQueSAtIGxlbmd0aCAqIDAuOSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIHZhciBhcnJvd0NvcmUgPSB7XG4gICAgICAgIHg6IHhpLFxuICAgICAgICB5OiB5aVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiBhcnJvd1BvaW50LFxuICAgICAgICBjb3JlOiBhcnJvd0NvcmUsXG4gICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgbGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdBcnJvd0hlYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0Fycm93SGVhZChjdHgsIHZhbHVlcywgX3NlbGVjdGVkLCBfaG92ZXIsIGFycm93RGF0YSkge1xuICAgICAgLy8gc2V0IHN0eWxlXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmdldENvbG9yKGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGU7XG4gICAgICBjdHgubGluZVdpZHRoID0gdmFsdWVzLndpZHRoO1xuICAgICAgdmFyIGNhbkZpbGwgPSBFbmRQb2ludHMuZHJhdyhjdHgsIGFycm93RGF0YSk7XG4gICAgICBpZiAoY2FuRmlsbCkge1xuICAgICAgICAvLyBkcmF3IHNoYWRvdyBpZiBlbmFibGVkXG4gICAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgICAgX2ZpbGxJbnN0YW5jZVByb3BlcnR5KGN0eCkuY2FsbChjdHgpO1xuICAgICAgICAvLyBkaXNhYmxlIHNoYWRvd3MgZm9yIG90aGVyIGVsZW1lbnRzLlxuICAgICAgICB0aGlzLmRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgc2hhZG93IGZvcm1hdHRpbmcgdmFsdWVzIGluIHRoZSBjb250ZXh0IGlmIGVuYWJsZWQsIGRvIG5vdGhpbmcgb3RoZXJ3aXNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIEZvcm1hdHRpbmcgdmFsdWVzIGZvciB0aGUgc2hhZG93LlxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlU2hhZG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZVNoYWRvdyhjdHgsIHZhbHVlcykge1xuICAgICAgaWYgKHZhbHVlcy5zaGFkb3cgPT09IHRydWUpIHtcbiAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdmFsdWVzLnNoYWRvd0NvbG9yO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IHZhbHVlcy5zaGFkb3dTaXplO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHZhbHVlcy5zaGFkb3dYO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHZhbHVlcy5zaGFkb3dZO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBzaGFkb3cgZm9ybWF0dGluZyB2YWx1ZXMgaW4gdGhlIGNvbnRleHQgaWYgZW5hYmxlZCwgZG8gbm90aGluZyBvdGhlcndpc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gRm9ybWF0dGluZyB2YWx1ZXMgZm9yIHRoZSBzaGFkb3cuXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXNhYmxlU2hhZG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVTaGFkb3coY3R4LCB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuc2hhZG93ID09PSB0cnVlKSB7XG4gICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IFwicmdiYSgwLDAsMCwwKVwiO1xuICAgICAgICBjdHguc2hhZG93Qmx1ciA9IDA7XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcclxuICAgICAqIFJlbmRlciB0aGUgYmFja2dyb3VuZCBhY2NvcmRpbmcgdG8gdGhlIGZvcm1hdHRpbmcgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIHZhbHVlcyAtIEZvcm1hdHRpbmcgdmFsdWVzIGZvciB0aGUgYmFja2dyb3VuZC5cclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdCYWNrZ3JvdW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKGN0eCwgdmFsdWVzKSB7XG4gICAgICBpZiAodmFsdWVzLmJhY2tncm91bmQgIT09IGZhbHNlKSB7XG4gICAgICAgIC8vIHNhdmUgb3JpZ2luYWwgbGluZSBhdHRyc1xuICAgICAgICB2YXIgb3JpZ0N0eEF0dHIgPSB7XG4gICAgICAgICAgc3Ryb2tlU3R5bGU6IGN0eC5zdHJva2VTdHlsZSxcbiAgICAgICAgICBsaW5lV2lkdGg6IGN0eC5saW5lV2lkdGgsXG4gICAgICAgICAgZGFzaGVzOiBjdHguZGFzaGVzXG4gICAgICAgIH07XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlcy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB2YWx1ZXMuYmFja2dyb3VuZFNpemU7XG4gICAgICAgIHRoaXMuc2V0U3Ryb2tlRGFzaGVkKGN0eCwgdmFsdWVzLmJhY2tncm91bmREYXNoZXMpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgbGluZSBhdHRyc1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcmlnQ3R4QXR0ci5zdHJva2VTdHlsZTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9yaWdDdHhBdHRyLmxpbmVXaWR0aDtcbiAgICAgICAgY3R4LmRhc2hlcyA9IG9yaWdDdHhBdHRyLmRhc2hlcztcbiAgICAgICAgdGhpcy5zZXRTdHJva2VEYXNoZWQoY3R4LCB2YWx1ZXMuZGFzaGVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGxpbmUgZGFzaCBwYXR0ZXJuIGlmIHN1cHBvcnRlZC4gTG9ncyBhIHdhcm5pbmcgdG8gdGhlIGNvbnNvbGUgaWYgaXQgaXNuJ3Qgc3VwcG9ydGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjdHggLSBUaGUgY29udGV4dCB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICogQHBhcmFtIGRhc2hlcyAtIFRoZSBwYXR0ZXJuIFtsaW5lLCBzcGFjZSwgbGluZeKApl0sIHRydWUgZm9yIGRlZmF1bHQgZGFzaGVkIGxpbmUgb3IgZmFsc2UgZm9yIG5vcm1hbCBsaW5lLlxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U3Ryb2tlRGFzaGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0cm9rZURhc2hlZChjdHgsIGRhc2hlcykge1xuICAgICAgaWYgKGRhc2hlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHBhdHRlcm4gPSBfQXJyYXkkaXNBcnJheShkYXNoZXMpID8gZGFzaGVzIDogWzUsIDVdO1xuICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChwYXR0ZXJuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRMaW5lRGFzaCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4gVGhlIGRhc2hlZCBzdHJva2UgY2Fubm90IGJlIHVzZWQuXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcInNldExpbmVEYXNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLiBUaGUgZGFzaGVkIHN0cm9rZSBjYW5ub3QgYmUgdXNlZC5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEVkZ2VCYXNlO1xufSgpO1xuXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHsgdmFyIHQgPSBfT2JqZWN0JGtleXMoZSk7IGlmIChfT2JqZWN0JGdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgbyA9IF9PYmplY3QkZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpOyByICYmIChvID0gX2ZpbHRlckluc3RhbmNlUHJvcGVydHkobykuY2FsbChvLCBmdW5jdGlvbiAocikgeyByZXR1cm4gX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMShlLCByKS5lbnVtZXJhYmxlOyB9KSksIHQucHVzaC5hcHBseSh0LCBvKTsgfSByZXR1cm4gdDsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZChlKSB7IGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7IHZhciBfY29udGV4dCwgX2NvbnRleHQyOyB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307IHIgJSAyID8gX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0ID0gb3duS2V5cyhPYmplY3QodCksICEwKSkuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKHIpIHsgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pOyB9KSA6IF9PYmplY3QkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IF9PYmplY3QkZGVmaW5lUHJvcGVydGllcyhlLCBfT2JqZWN0JGdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MiA9IG93bktleXMoT2JqZWN0KHQpKSkuY2FsbChfY29udGV4dDIsIGZ1bmN0aW9uIChyKSB7IF9PYmplY3QkZGVmaW5lUHJvcGVydHkoZSwgciwgX09iamVjdCRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IkMSh0LCByKSk7IH0pOyB9IHJldHVybiBlOyB9XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkOShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ5KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDkoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXHJcbiAqIFRoZSBCYXNlIENsYXNzIGZvciBhbGwgQmV6aWVyIGVkZ2VzLlxyXG4gKiBCZXppZXIgY3VydmVzIGFyZSB1c2VkIHRvIG1vZGVsIHNtb290aCBncmFkdWFsIGN1cnZlcyBpbiBwYXRocyBiZXR3ZWVuIG5vZGVzLlxyXG4gKi9cbnZhciBCZXppZXJFZGdlQmFzZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VkZ2VCYXNlKSB7XG4gIF9pbmhlcml0cyhCZXppZXJFZGdlQmFzZSwgX0VkZ2VCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ5KEJlemllckVkZ2VCYXNlKTtcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3Qgb2YgZ2l2ZW4gZWRnZS5cclxuICAgKiBAcGFyYW0gYm9keSAtIFRoZSBib2R5IG9mIHRoZSBuZXR3b3JrLlxyXG4gICAqIEBwYXJhbSBsYWJlbE1vZHVsZSAtIExhYmVsIG1vZHVsZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gQmV6aWVyRWRnZUJhc2Uob3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmV6aWVyRWRnZUJhc2UpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogRmluZCB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIGJvcmRlciBvZiB0aGUgbm9kZSBhbmQgdGhlIGVkZ2UuXHJcbiAgICpcclxuICAgKiBAcmVtYXJrc1xyXG4gICAqIFRoaXMgZnVuY3Rpb24gdXNlcyBiaW5hcnkgc2VhcmNoIHRvIGxvb2sgZm9yIHRoZSBwb2ludCB3aGVyZSB0aGUgYmV6aWVyIGN1cnZlIGNyb3NzZXMgdGhlIGJvcmRlciBvZiB0aGUgbm9kZS5cclxuICAgKiBAcGFyYW0gbmVhck5vZGUgLSBUaGUgbm9kZSAoZWl0aGVyIGZyb20gb3IgdG8gbm9kZSBvZiB0aGUgZWRnZSkuXHJcbiAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICogQHBhcmFtIHZpYU5vZGUgLSBBZGRpdGlvbmFsIG5vZGUocykgdGhlIGVkZ2UgcGFzc2VzIHRocm91Z2guXHJcbiAgICogQHJldHVybnMgQ2FydGVzaWFuIGNvb3JkaW5hdGVzIG9mIHRoZSBpbnRlcnNlY3Rpb24gYmV0d2VlbiB0aGUgYm9yZGVyIG9mIHRoZSBub2RlIGFuZCB0aGUgZWRnZS5cclxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKEJlemllckVkZ2VCYXNlLCBbe1xuICAgIGtleTogXCJfZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb25CZXppZXIobmVhck5vZGUsIGN0eCkge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IDEwO1xuICAgICAgdmFyIHRocmVzaG9sZCA9IDAuMjtcbiAgICAgIHZhciBmcm9tID0gZmFsc2U7XG4gICAgICB2YXIgaGlnaCA9IDE7XG4gICAgICB2YXIgbG93ID0gMDtcbiAgICAgIHZhciBub2RlID0gdGhpcy50bztcbiAgICAgIHZhciBwb3M7XG4gICAgICB2YXIgbWlkZGxlO1xuICAgICAgdmFyIGVuZFBvaW50T2Zmc2V0ID0gdGhpcy5vcHRpb25zLmVuZFBvaW50T2Zmc2V0ID8gdGhpcy5vcHRpb25zLmVuZFBvaW50T2Zmc2V0LnRvIDogMDtcbiAgICAgIGlmIChuZWFyTm9kZS5pZCA9PT0gdGhpcy5mcm9tLmlkKSB7XG4gICAgICAgIG5vZGUgPSB0aGlzLmZyb207XG4gICAgICAgIGZyb20gPSB0cnVlO1xuICAgICAgICBlbmRQb2ludE9mZnNldCA9IHRoaXMub3B0aW9ucy5lbmRQb2ludE9mZnNldCA/IHRoaXMub3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tIDogMDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXJyb3dTdHJpa2V0aHJvdWdoID09PSBmYWxzZSkge1xuICAgICAgICBlbmRQb2ludE9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgICB2YXIgaXRlcmF0aW9uID0gMDtcbiAgICAgIGRvIHtcbiAgICAgICAgbWlkZGxlID0gKGxvdyArIGhpZ2gpICogMC41O1xuICAgICAgICBwb3MgPSB0aGlzLmdldFBvaW50KG1pZGRsZSwgdmlhTm9kZSk7XG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIobm9kZS55IC0gcG9zLnksIG5vZGUueCAtIHBvcy54KTtcbiAgICAgICAgdmFyIGRpc3RhbmNlVG9Cb3JkZXIgPSBub2RlLmRpc3RhbmNlVG9Cb3JkZXIoY3R4LCBhbmdsZSkgKyBlbmRQb2ludE9mZnNldDtcbiAgICAgICAgdmFyIGRpc3RhbmNlVG9Qb2ludCA9IE1hdGguc3FydChNYXRoLnBvdyhwb3MueCAtIG5vZGUueCwgMikgKyBNYXRoLnBvdyhwb3MueSAtIG5vZGUueSwgMikpO1xuICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IGRpc3RhbmNlVG9Cb3JkZXIgLSBkaXN0YW5jZVRvUG9pbnQ7XG4gICAgICAgIGlmIChNYXRoLmFicyhkaWZmZXJlbmNlKSA8IHRocmVzaG9sZCkge1xuICAgICAgICAgIGJyZWFrOyAvLyBmb3VuZFxuICAgICAgICB9IGVsc2UgaWYgKGRpZmZlcmVuY2UgPCAwKSB7XG4gICAgICAgICAgLy8gZGlzdGFuY2UgdG8gbm9kZXMgaXMgbGFyZ2VyIHRoYW4gZGlzdGFuY2UgdG8gYm9yZGVyIC0tPiB0IG5lZWRzIHRvIGJlIGJpZ2dlciBpZiB3ZSdyZSBsb29raW5nIGF0IHRoZSB0byBub2RlLlxuICAgICAgICAgIGlmIChmcm9tID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbG93ID0gbWlkZGxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkZGxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZnJvbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWRkbGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZGRsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKytpdGVyYXRpb247XG4gICAgICB9IHdoaWxlIChsb3cgPD0gaGlnaCAmJiBpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKTtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBvcyksIHt9LCB7XG4gICAgICAgIHQ6IG1pZGRsZVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgKHgzLHkzKSBhbmQgYSBsaW5lIHNlZ21lbnQgZnJvbSAoeDEseTEpIHRvICh4Mix5MikuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ5MjExL3Nob3J0ZXN0LWRpc3RhbmNhZS1iZXR3ZWVuLWEtcG9pbnQtYW5kLWEtbGluZS1zZWdtZW50XHJcbiAgICAgKiBAcGFyYW0geDEgLSBGaXJzdCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeCBheGlzLlxyXG4gICAgICogQHBhcmFtIHkxIC0gRmlyc3QgZW5kIG9mIHRoZSBsaW5lIHNlZ21lbnQgb24gdGhlIHkgYXhpcy5cclxuICAgICAqIEBwYXJhbSB4MiAtIFNlY29uZCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeCBheGlzLlxyXG4gICAgICogQHBhcmFtIHkyIC0gU2Vjb25kIGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICAgKiBAcGFyYW0geDMgLSBQb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpcy5cclxuICAgICAqIEBwYXJhbSB5MyAtIFBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzLlxyXG4gICAgICogQHBhcmFtIHZpYSAtIFRoZSBjb250cm9sIHBvaW50IGZvciB0aGUgZWRnZS5cclxuICAgICAqIEByZXR1cm5zIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBsaW5lIHNlZ21lbnQgYW5kIHRoZSBwb2ludC5cclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdmlhKSB7XG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHZhciBtaW5EaXN0YW5jZSA9IDFlOTtcbiAgICAgIHZhciBkaXN0YW5jZTtcbiAgICAgIHZhciBpLCB0LCB4LCB5O1xuICAgICAgdmFyIGxhc3RYID0geDE7XG4gICAgICB2YXIgbGFzdFkgPSB5MTtcbiAgICAgIGZvciAoaSA9IDE7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIHQgPSAwLjEgKiBpO1xuICAgICAgICB4ID0gTWF0aC5wb3coMSAtIHQsIDIpICogeDEgKyAyICogdCAqICgxIC0gdCkgKiB2aWEueCArIE1hdGgucG93KHQsIDIpICogeDI7XG4gICAgICAgIHkgPSBNYXRoLnBvdygxIC0gdCwgMikgKiB5MSArIDIgKiB0ICogKDEgLSB0KSAqIHZpYS55ICsgTWF0aC5wb3codCwgMikgKiB5MjtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgZGlzdGFuY2UgPSB0aGlzLl9nZXREaXN0YW5jZVRvTGluZShsYXN0WCwgbGFzdFksIHgsIHksIHgzLCB5Myk7XG4gICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZSA8IG1pbkRpc3RhbmNlID8gZGlzdGFuY2UgOiBtaW5EaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgIGxhc3RZID0geTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtaW5EaXN0YW5jZTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXIgYSBiZXppZXIgY3VydmUgYmV0d2VlbiB0d28gbm9kZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIFRoZSBtZXRob2QgYWNjZXB0cyB6ZXJvLCBvbmUgb3IgdHdvIGNvbnRyb2wgcG9pbnRzLlxyXG4gICAgICogUGFzc2luZyB6ZXJvIGNvbnRyb2wgcG9pbnRzIGp1c3QgZHJhd3MgYSBzdHJhaWdodCBsaW5lLlxyXG4gICAgICogQHBhcmFtIGN0eCAtIFRoZSBjb250ZXh0IHRoYXQgd2lsbCBiZSB1c2VkIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gU3R5bGUgb3B0aW9ucyBmb3IgZWRnZSBkcmF3aW5nLlxyXG4gICAgICogQHBhcmFtIHZpYU5vZGUxIC0gRmlyc3QgY29udHJvbCBwb2ludCBmb3IgY3VydmUgZHJhd2luZy5cclxuICAgICAqIEBwYXJhbSB2aWFOb2RlMiAtIFNlY29uZCBjb250cm9sIHBvaW50IGZvciBjdXJ2ZSBkcmF3aW5nLlxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2JlemllckN1cnZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iZXppZXJDdXJ2ZShjdHgsIHZhbHVlcywgdmlhTm9kZTEsIHZpYU5vZGUyKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHRoaXMuZnJvbVBvaW50LngsIHRoaXMuZnJvbVBvaW50LnkpO1xuICAgICAgaWYgKHZpYU5vZGUxICE9IG51bGwgJiYgdmlhTm9kZTEueCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh2aWFOb2RlMiAhPSBudWxsICYmIHZpYU5vZGUyLnggIT0gbnVsbCkge1xuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHZpYU5vZGUxLngsIHZpYU5vZGUxLnksIHZpYU5vZGUyLngsIHZpYU5vZGUyLnksIHRoaXMudG9Qb2ludC54LCB0aGlzLnRvUG9pbnQueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8odmlhTm9kZTEueCwgdmlhTm9kZTEueSwgdGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZmFsbGJhY2sgdG8gbm9ybWFsIHN0cmFpZ2h0IGVkZ2VcbiAgICAgICAgY3R4LmxpbmVUbyh0aGlzLnRvUG9pbnQueCwgdGhpcy50b1BvaW50LnkpO1xuICAgICAgfVxuICAgICAgLy8gZHJhdyBhIGJhY2tncm91bmRcbiAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQoY3R4LCB2YWx1ZXMpO1xuICAgICAgLy8gZHJhdyBzaGFkb3cgaWYgZW5hYmxlZFxuICAgICAgdGhpcy5lbmFibGVTaGFkb3coY3R4LCB2YWx1ZXMpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgdGhpcy5kaXNhYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmlhTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCZXppZXJFZGdlQmFzZTtcbn0oRWRnZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkOChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ4KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDgoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXHJcbiAqIEEgRHluYW1pYyBCZXppZXIgRWRnZS4gQmV6aWVyIGN1cnZlcyBhcmUgdXNlZCB0byBtb2RlbCBzbW9vdGggZ3JhZHVhbFxyXG4gKiBjdXJ2ZXMgaW4gcGF0aHMgYmV0d2VlbiBub2Rlcy4gVGhlIER5bmFtaWMgcGllY2UgcmVmZXJzIHRvIGhvdyB0aGUgY3VydmVcclxuICogcmVhY3RzIHRvIHBoeXNpY3MgY2hhbmdlcy5cclxuICpcclxuICogQGF1Z21lbnRzIEJlemllckVkZ2VCYXNlXHJcbiAqL1xudmFyIEJlemllckVkZ2VEeW5hbWljID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmV6aWVyRWRnZUJhc2UpIHtcbiAgX2luaGVyaXRzKEJlemllckVkZ2VEeW5hbWljLCBfQmV6aWVyRWRnZUJhc2UpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDgoQmV6aWVyRWRnZUR5bmFtaWMpO1xuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBvZiBnaXZlbiBlZGdlLlxyXG4gICAqIEBwYXJhbSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG5ldHdvcmsuXHJcbiAgICogQHBhcmFtIGxhYmVsTW9kdWxlIC0gTGFiZWwgbW9kdWxlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBCZXppZXJFZGdlRHluYW1pYyhvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmV6aWVyRWRnZUR5bmFtaWMpO1xuICAgIC8vdGhpcy52aWEgPSB1bmRlZmluZWQ7IC8vIEhlcmUgZm9yIGNvbXBsZXRlbmVzcyBidXQgbm90IGFsbG93ZWQgdG8gZGVmaW5lZCBiZWZvcmUgc3VwZXIoKSBpcyBpbnZva2VkLlxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpOyAvLyAtLT4gdGhpcyBjYWxscyB0aGUgc2V0T3B0aW9ucyBiZWxvd1xuICAgIF90aGlzLnZpYSA9IF90aGlzLnZpYTsgLy8gY29uc3RydWN0b3Ig4oaSIHN1cGVyIOKGkiBzdXBlciDihpIgc2V0T3B0aW9ucyDihpIgc2V0dXBTdXBwb3J0Tm9kZVxuICAgIF90aGlzLl9ib3VuZEZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMucG9zaXRpb25CZXppZXJOb2RlKCk7XG4gICAgfTtcbiAgICBfdGhpcy5fYm9keS5lbWl0dGVyLm9uKFwiX3JlcG9zaXRpb25CZXppZXJOb2Rlc1wiLCBfdGhpcy5fYm91bmRGdW5jdGlvbik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBfY3JlYXRlQ2xhc3MoQmV6aWVyRWRnZUR5bmFtaWMsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihCZXppZXJFZGdlRHluYW1pYy5wcm90b3R5cGUpLCBcInNldE9wdGlvbnNcIiwgdGhpcykuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgIC8vIGNoZWNrIGlmIHRoZSBwaHlzaWNzIGhhcyBjaGFuZ2VkLlxuICAgICAgdmFyIHBoeXNpY3NDaGFuZ2UgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucGh5c2ljcyAhPT0gb3B0aW9ucy5waHlzaWNzKSB7XG4gICAgICAgIHBoeXNpY3NDaGFuZ2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gc2V0IHRoZSBvcHRpb25zIGFuZCB0aGUgdG8gYW5kIGZyb20gbm9kZXNcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB0aGlzLmlkID0gdGhpcy5vcHRpb25zLmlkO1xuICAgICAgdGhpcy5mcm9tID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICB0aGlzLnRvID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dO1xuICAgICAgLy8gc2V0dXAgdGhlIHN1cHBvcnQgbm9kZSBhbmQgY29ubmVjdFxuICAgICAgdGhpcy5zZXR1cFN1cHBvcnROb2RlKCk7XG4gICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgIC8vIHdoZW4gd2UgY2hhbmdlIHRoZSBwaHlzaWNzIHN0YXRlIG9mIHRoZSBlZGdlLCB3ZSByZXBvc2l0aW9uIHRoZSBzdXBwb3J0IG5vZGUuXG4gICAgICBpZiAocGh5c2ljc0NoYW5nZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHtcbiAgICAgICAgICBwaHlzaWNzOiB0aGlzLm9wdGlvbnMucGh5c2ljc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkJlemllck5vZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY29ubmVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgICAgdGhpcy5mcm9tID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMuZnJvbV07XG4gICAgICB0aGlzLnRvID0gdGhpcy5fYm9keS5ub2Rlc1t0aGlzLm9wdGlvbnMudG9dO1xuICAgICAgaWYgKHRoaXMuZnJvbSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudG8gPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMucGh5c2ljcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy52aWEuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgcGh5c2ljczogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBmaXggd2VpcmQgYmVoYXZpb3VyIHdoZXJlIGEgc2VsZiByZWZlcmVuY2luZyBub2RlIGhhcyBwaHlzaWNzIGVuYWJsZWRcbiAgICAgICAgaWYgKHRoaXMuZnJvbS5pZCA9PT0gdGhpcy50by5pZCkge1xuICAgICAgICAgIHRoaXMudmlhLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgcGh5c2ljczogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnZpYS5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIHBoeXNpY3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbGVhbnVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICB0aGlzLl9ib2R5LmVtaXR0ZXIub2ZmKFwiX3JlcG9zaXRpb25CZXppZXJOb2Rlc1wiLCB0aGlzLl9ib3VuZEZ1bmN0aW9uKTtcbiAgICAgIGlmICh0aGlzLnZpYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ib2R5Lm5vZGVzW3RoaXMudmlhLmlkXTtcbiAgICAgICAgdGhpcy52aWEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbmQgYWRkIGEgc3VwcG9ydCBub2RlIGlmIG5vdCBhbHJlYWR5IHByZXNlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHJlbWFya3NcclxuICAgICAqIEJlemllciBjdXJ2ZXMgcmVxdWlyZSBhbiBhbmNob3IgcG9pbnQgdG8gY2FsY3VsYXRlIHRoZSBzbW9vdGggZmxvdy5cclxuICAgICAqIFRoZXNlIHBvaW50cyBhcmUgbm9kZXMuXHJcbiAgICAgKiBUaGVzZSBub2RlcyBhcmUgaW52aXNpYmxlIGJ1dCBhcmUgdXNlZCBmb3IgdGhlIGZvcmNlIGNhbGN1bGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBjaGFuZ2VkIGRhdGEgaXMgbm90IGNhbGxlZCwgaWYgbmVlZGVkLCBpdCBpcyByZXR1cm5lZCBieSB0aGUgbWFpbiBlZGdlIGNvbnN0cnVjdG9yLlxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0dXBTdXBwb3J0Tm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cFN1cHBvcnROb2RlKCkge1xuICAgICAgaWYgKHRoaXMudmlhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IFwiZWRnZUlkOlwiICsgdGhpcy5pZDtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9ib2R5LmZ1bmN0aW9ucy5jcmVhdGVOb2RlKHtcbiAgICAgICAgICBpZDogbm9kZUlkLFxuICAgICAgICAgIHNoYXBlOiBcImNpcmNsZVwiLFxuICAgICAgICAgIHBoeXNpY3M6IHRydWUsXG4gICAgICAgICAgaGlkZGVuOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9ib2R5Lm5vZGVzW25vZGVJZF0gPSBub2RlO1xuICAgICAgICB0aGlzLnZpYSA9IG5vZGU7XG4gICAgICAgIHRoaXMudmlhLnBhcmVudEVkZ2VJZCA9IHRoaXMuaWQ7XG4gICAgICAgIHRoaXMucG9zaXRpb25CZXppZXJOb2RlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogUG9zaXRpb24gYmV6aWVyIG5vZGUuXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJwb3NpdGlvbkJlemllck5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb25CZXppZXJOb2RlKCkge1xuICAgICAgaWYgKHRoaXMudmlhICE9PSB1bmRlZmluZWQgJiYgdGhpcy5mcm9tICE9PSB1bmRlZmluZWQgJiYgdGhpcy50byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudmlhLnggPSAwLjUgKiAodGhpcy5mcm9tLnggKyB0aGlzLnRvLngpO1xuICAgICAgICB0aGlzLnZpYS55ID0gMC41ICogKHRoaXMuZnJvbS55ICsgdGhpcy50by55KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy52aWEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnZpYS54ID0gMDtcbiAgICAgICAgdGhpcy52aWEueSA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9saW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9saW5lKGN0eCwgdmFsdWVzLCB2aWFOb2RlKSB7XG4gICAgICB0aGlzLl9iZXppZXJDdXJ2ZShjdHgsIHZhbHVlcywgdmlhTm9kZSk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWaWFDb29yZGluYXRlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmlhQ29vcmRpbmF0ZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWE7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFZpYU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmlhTm9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpYTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQocG9zaXRpb24pIHtcbiAgICAgIHZhciB2aWFOb2RlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLnZpYTtcbiAgICAgIGlmICh0aGlzLmZyb20gPT09IHRoaXMudG8pIHtcbiAgICAgICAgdmFyIF90aGlzJF9nZXRDaXJjbGVEYXRhID0gdGhpcy5fZ2V0Q2lyY2xlRGF0YSgpLFxuICAgICAgICAgIF90aGlzJF9nZXRDaXJjbGVEYXRhMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRDaXJjbGVEYXRhLCAzKSxcbiAgICAgICAgICBjeCA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMlswXSxcbiAgICAgICAgICBjeSA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMlsxXSxcbiAgICAgICAgICBjciA9IF90aGlzJF9nZXRDaXJjbGVEYXRhMlsyXTtcbiAgICAgICAgdmFyIGEgPSAyICogTWF0aC5QSSAqICgxIC0gcG9zaXRpb24pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGN4ICsgY3IgKiBNYXRoLnNpbihhKSxcbiAgICAgICAgICB5OiBjeSArIGNyIC0gY3IgKiAoMSAtIE1hdGguY29zKGEpKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBNYXRoLnBvdygxIC0gcG9zaXRpb24sIDIpICogdGhpcy5mcm9tUG9pbnQueCArIDIgKiBwb3NpdGlvbiAqICgxIC0gcG9zaXRpb24pICogdmlhTm9kZS54ICsgTWF0aC5wb3cocG9zaXRpb24sIDIpICogdGhpcy50b1BvaW50LngsXG4gICAgICAgICAgeTogTWF0aC5wb3coMSAtIHBvc2l0aW9uLCAyKSAqIHRoaXMuZnJvbVBvaW50LnkgKyAyICogcG9zaXRpb24gKiAoMSAtIHBvc2l0aW9uKSAqIHZpYU5vZGUueSArIE1hdGgucG93KHBvc2l0aW9uLCAyKSAqIHRoaXMudG9Qb2ludC55XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9maW5kQm9yZGVyUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyKG5lYXJOb2RlLCBjdHgsIHRoaXMudmlhKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERpc3RhbmNlVG9FZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICAvLyB4Myx5MyBpcyB0aGUgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLl9nZXREaXN0YW5jZVRvQmV6aWVyRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0aGlzLnZpYSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCZXppZXJFZGdlRHluYW1pYztcbn0oQmV6aWVyRWRnZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkNyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ3KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDcoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXHJcbiAqIEEgU3RhdGljIEJlemllciBFZGdlLiBCZXppZXIgY3VydmVzIGFyZSB1c2VkIHRvIG1vZGVsIHNtb290aCBncmFkdWFsIGN1cnZlcyBpbiBwYXRocyBiZXR3ZWVuIG5vZGVzLlxyXG4gKi9cbnZhciBCZXppZXJFZGdlU3RhdGljID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmV6aWVyRWRnZUJhc2UpIHtcbiAgX2luaGVyaXRzKEJlemllckVkZ2VTdGF0aWMsIF9CZXppZXJFZGdlQmFzZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkNyhCZXppZXJFZGdlU3RhdGljKTtcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3Qgb2YgZ2l2ZW4gZWRnZS5cclxuICAgKiBAcGFyYW0gYm9keSAtIFRoZSBib2R5IG9mIHRoZSBuZXR3b3JrLlxyXG4gICAqIEBwYXJhbSBsYWJlbE1vZHVsZSAtIExhYmVsIG1vZHVsZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gQmV6aWVyRWRnZVN0YXRpYyhvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCZXppZXJFZGdlU3RhdGljKTtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucywgYm9keSwgbGFiZWxNb2R1bGUpO1xuICB9XG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBfY3JlYXRlQ2xhc3MoQmV6aWVyRWRnZVN0YXRpYywgW3tcbiAgICBrZXk6IFwiX2xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGUpIHtcbiAgICAgIHRoaXMuX2JlemllckN1cnZlKGN0eCwgdmFsdWVzLCB2aWFOb2RlKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmlhTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgfVxuICAgIC8qKlxyXG4gICAgICogQ29tcHV0ZSB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHZpYSBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEByZW1hcmtzXHJcbiAgICAgKiBXZSBkbyBub3QgdXNlIHRoZSB0byBhbmQgZnJvbVBvaW50cyBoZXJlIHRvIG1ha2UgdGhlIHZpYSBub2RlcyB0aGUgc2FtZSBhcyBlZGdlcyB3aXRob3V0IGFycm93cy5cclxuICAgICAqIEByZXR1cm5zIENhcnRlc2lhbiBjb29yZGluYXRlcyBvZiB0aGUgdmlhIG5vZGUuXHJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0VmlhQ29vcmRpbmF0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZpYUNvb3JkaW5hdGVzKCkge1xuICAgICAgLy8gQXNzdW1wdGlvbjogeC95IGNvb3JkaW5hdGVzIGluIGZyb20vdG8gYWx3YXlzIGRlZmluZWRcbiAgICAgIHZhciBmYWN0b3IgPSB0aGlzLm9wdGlvbnMuc21vb3RoLnJvdW5kbmVzcztcbiAgICAgIHZhciB0eXBlID0gdGhpcy5vcHRpb25zLnNtb290aC50eXBlO1xuICAgICAgdmFyIGR4ID0gTWF0aC5hYnModGhpcy5mcm9tLnggLSB0aGlzLnRvLngpO1xuICAgICAgdmFyIGR5ID0gTWF0aC5hYnModGhpcy5mcm9tLnkgLSB0aGlzLnRvLnkpO1xuICAgICAgaWYgKHR5cGUgPT09IFwiZGlzY3JldGVcIiB8fCB0eXBlID09PSBcImRpYWdvbmFsQ3Jvc3NcIikge1xuICAgICAgICB2YXIgc3RlcFg7XG4gICAgICAgIHZhciBzdGVwWTtcbiAgICAgICAgaWYgKGR4IDw9IGR5KSB7XG4gICAgICAgICAgc3RlcFggPSBzdGVwWSA9IGZhY3RvciAqIGR5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ZXBYID0gc3RlcFkgPSBmYWN0b3IgKiBkeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mcm9tLnggPiB0aGlzLnRvLngpIHtcbiAgICAgICAgICBzdGVwWCA9IC1zdGVwWDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mcm9tLnkgPj0gdGhpcy50by55KSB7XG4gICAgICAgICAgc3RlcFkgPSAtc3RlcFk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHhWaWEgPSB0aGlzLmZyb20ueCArIHN0ZXBYO1xuICAgICAgICB2YXIgeVZpYSA9IHRoaXMuZnJvbS55ICsgc3RlcFk7XG4gICAgICAgIGlmICh0eXBlID09PSBcImRpc2NyZXRlXCIpIHtcbiAgICAgICAgICBpZiAoZHggPD0gZHkpIHtcbiAgICAgICAgICAgIHhWaWEgPSBkeCA8IGZhY3RvciAqIGR5ID8gdGhpcy5mcm9tLnggOiB4VmlhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5VmlhID0gZHkgPCBmYWN0b3IgKiBkeCA/IHRoaXMuZnJvbS55IDogeVZpYTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB4VmlhLFxuICAgICAgICAgIHk6IHlWaWFcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJzdHJhaWdodENyb3NzXCIpIHtcbiAgICAgICAgdmFyIF9zdGVwWCA9ICgxIC0gZmFjdG9yKSAqIGR4O1xuICAgICAgICB2YXIgX3N0ZXBZID0gKDEgLSBmYWN0b3IpICogZHk7XG4gICAgICAgIGlmIChkeCA8PSBkeSkge1xuICAgICAgICAgIC8vIHVwIC0gZG93blxuICAgICAgICAgIF9zdGVwWCA9IDA7XG4gICAgICAgICAgaWYgKHRoaXMuZnJvbS55IDwgdGhpcy50by55KSB7XG4gICAgICAgICAgICBfc3RlcFkgPSAtX3N0ZXBZO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsZWZ0IC0gcmlnaHRcbiAgICAgICAgICBpZiAodGhpcy5mcm9tLnggPCB0aGlzLnRvLngpIHtcbiAgICAgICAgICAgIF9zdGVwWCA9IC1fc3RlcFg7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9zdGVwWSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB0aGlzLnRvLnggKyBfc3RlcFgsXG4gICAgICAgICAgeTogdGhpcy50by55ICsgX3N0ZXBZXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiaG9yaXpvbnRhbFwiKSB7XG4gICAgICAgIHZhciBfc3RlcFgyID0gKDEgLSBmYWN0b3IpICogZHg7XG4gICAgICAgIGlmICh0aGlzLmZyb20ueCA8IHRoaXMudG8ueCkge1xuICAgICAgICAgIF9zdGVwWDIgPSAtX3N0ZXBYMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHRoaXMudG8ueCArIF9zdGVwWDIsXG4gICAgICAgICAgeTogdGhpcy5mcm9tLnlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XG4gICAgICAgIHZhciBfc3RlcFkyID0gKDEgLSBmYWN0b3IpICogZHk7XG4gICAgICAgIGlmICh0aGlzLmZyb20ueSA8IHRoaXMudG8ueSkge1xuICAgICAgICAgIF9zdGVwWTIgPSAtX3N0ZXBZMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IHRoaXMuZnJvbS54LFxuICAgICAgICAgIHk6IHRoaXMudG8ueSArIF9zdGVwWTJcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjdXJ2ZWRDV1wiKSB7XG4gICAgICAgIGR4ID0gdGhpcy50by54IC0gdGhpcy5mcm9tLng7XG4gICAgICAgIGR5ID0gdGhpcy5mcm9tLnkgLSB0aGlzLnRvLnk7XG4gICAgICAgIHZhciByYWRpdXMgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB2YXIgcGkgPSBNYXRoLlBJO1xuICAgICAgICB2YXIgb3JpZ2luYWxBbmdsZSA9IE1hdGguYXRhbjIoZHksIGR4KTtcbiAgICAgICAgdmFyIG15QW5nbGUgPSAob3JpZ2luYWxBbmdsZSArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogcGkpICUgKDIgKiBwaSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogdGhpcy5mcm9tLnggKyAoZmFjdG9yICogMC41ICsgMC41KSAqIHJhZGl1cyAqIE1hdGguc2luKG15QW5nbGUpLFxuICAgICAgICAgIHk6IHRoaXMuZnJvbS55ICsgKGZhY3RvciAqIDAuNSArIDAuNSkgKiByYWRpdXMgKiBNYXRoLmNvcyhteUFuZ2xlKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImN1cnZlZENDV1wiKSB7XG4gICAgICAgIGR4ID0gdGhpcy50by54IC0gdGhpcy5mcm9tLng7XG4gICAgICAgIGR5ID0gdGhpcy5mcm9tLnkgLSB0aGlzLnRvLnk7XG4gICAgICAgIHZhciBfcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgdmFyIF9waSA9IE1hdGguUEk7XG4gICAgICAgIHZhciBfb3JpZ2luYWxBbmdsZSA9IE1hdGguYXRhbjIoZHksIGR4KTtcbiAgICAgICAgdmFyIF9teUFuZ2xlID0gKF9vcmlnaW5hbEFuZ2xlICsgKC1mYWN0b3IgKiAwLjUgKyAwLjUpICogX3BpKSAlICgyICogX3BpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB0aGlzLmZyb20ueCArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogX3JhZGl1cyAqIE1hdGguc2luKF9teUFuZ2xlKSxcbiAgICAgICAgICB5OiB0aGlzLmZyb20ueSArIChmYWN0b3IgKiAwLjUgKyAwLjUpICogX3JhZGl1cyAqIE1hdGguY29zKF9teUFuZ2xlKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29udGludW91c1xuICAgICAgICB2YXIgX3N0ZXBYMztcbiAgICAgICAgdmFyIF9zdGVwWTM7XG4gICAgICAgIGlmIChkeCA8PSBkeSkge1xuICAgICAgICAgIF9zdGVwWDMgPSBfc3RlcFkzID0gZmFjdG9yICogZHk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3N0ZXBYMyA9IF9zdGVwWTMgPSBmYWN0b3IgKiBkeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5mcm9tLnggPiB0aGlzLnRvLngpIHtcbiAgICAgICAgICBfc3RlcFgzID0gLV9zdGVwWDM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZnJvbS55ID49IHRoaXMudG8ueSkge1xuICAgICAgICAgIF9zdGVwWTMgPSAtX3N0ZXBZMztcbiAgICAgICAgfVxuICAgICAgICB2YXIgX3hWaWEgPSB0aGlzLmZyb20ueCArIF9zdGVwWDM7XG4gICAgICAgIHZhciBfeVZpYSA9IHRoaXMuZnJvbS55ICsgX3N0ZXBZMztcbiAgICAgICAgaWYgKGR4IDw9IGR5KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZnJvbS54IDw9IHRoaXMudG8ueCkge1xuICAgICAgICAgICAgX3hWaWEgPSB0aGlzLnRvLnggPCBfeFZpYSA/IHRoaXMudG8ueCA6IF94VmlhO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfeFZpYSA9IHRoaXMudG8ueCA+IF94VmlhID8gdGhpcy50by54IDogX3hWaWE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmZyb20ueSA+PSB0aGlzLnRvLnkpIHtcbiAgICAgICAgICAgIF95VmlhID0gdGhpcy50by55ID4gX3lWaWEgPyB0aGlzLnRvLnkgOiBfeVZpYTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3lWaWEgPSB0aGlzLnRvLnkgPCBfeVZpYSA/IHRoaXMudG8ueSA6IF95VmlhO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IF94VmlhLFxuICAgICAgICAgIHk6IF95VmlhXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9maW5kQm9yZGVyUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyKG5lYXJOb2RlLCBjdHgsIG9wdGlvbnMudmlhKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldERpc3RhbmNlVG9FZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXREaXN0YW5jZVRvRWRnZSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgICB2YXIgdmlhTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKTtcbiAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9CZXppZXJFZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYU5vZGUpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludChwb3NpdGlvbikge1xuICAgICAgdmFyIHZpYU5vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgICB2YXIgdCA9IHBvc2l0aW9uO1xuICAgICAgdmFyIHggPSBNYXRoLnBvdygxIC0gdCwgMikgKiB0aGlzLmZyb21Qb2ludC54ICsgMiAqIHQgKiAoMSAtIHQpICogdmlhTm9kZS54ICsgTWF0aC5wb3codCwgMikgKiB0aGlzLnRvUG9pbnQueDtcbiAgICAgIHZhciB5ID0gTWF0aC5wb3coMSAtIHQsIDIpICogdGhpcy5mcm9tUG9pbnQueSArIDIgKiB0ICogKDEgLSB0KSAqIHZpYU5vZGUueSArIE1hdGgucG93KHQsIDIpICogdGhpcy50b1BvaW50Lnk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQmV6aWVyRWRnZVN0YXRpYztcbn0oQmV6aWVyRWRnZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkNihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ2KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDYoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXHJcbiAqIEEgQmFzZSBDbGFzcyBmb3IgYWxsIEN1YmljIEJlemllciBFZGdlcy4gQmV6aWVyIGN1cnZlcyBhcmUgdXNlZCB0byBtb2RlbFxyXG4gKiBzbW9vdGggZ3JhZHVhbCBjdXJ2ZXMgaW4gcGF0aHMgYmV0d2VlbiBub2Rlcy5cclxuICpcclxuICogQGF1Z21lbnRzIEJlemllckVkZ2VCYXNlXHJcbiAqL1xudmFyIEN1YmljQmV6aWVyRWRnZUJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CZXppZXJFZGdlQmFzZSkge1xuICBfaW5oZXJpdHMoQ3ViaWNCZXppZXJFZGdlQmFzZSwgX0JlemllckVkZ2VCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ2KEN1YmljQmV6aWVyRWRnZUJhc2UpO1xuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBvZiBnaXZlbiBlZGdlLlxyXG4gICAqIEBwYXJhbSBib2R5IC0gVGhlIGJvZHkgb2YgdGhlIG5ldHdvcmsuXHJcbiAgICogQHBhcmFtIGxhYmVsTW9kdWxlIC0gTGFiZWwgbW9kdWxlLlxyXG4gICAqL1xuICBmdW5jdGlvbiBDdWJpY0JlemllckVkZ2VCYXNlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1YmljQmV6aWVyRWRnZUJhc2UpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGEgcG9pbnQgKHgzLHkzKSBhbmQgYSBsaW5lIHNlZ21lbnQgZnJvbSAoeDEseTEpIHRvICh4Mix5MikuXHJcbiAgICpcclxuICAgKiBAcmVtYXJrc1xyXG4gICAqIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODQ5MjExL3Nob3J0ZXN0LWRpc3RhbmNhZS1iZXR3ZWVuLWEtcG9pbnQtYW5kLWEtbGluZS1zZWdtZW50XHJcbiAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQiVDMyVBOXppZXJfY3VydmVcclxuICAgKiBAcGFyYW0geDEgLSBGaXJzdCBlbmQgb2YgdGhlIGxpbmUgc2VnbWVudCBvbiB0aGUgeCBheGlzLlxyXG4gICAqIEBwYXJhbSB5MSAtIEZpcnN0IGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICogQHBhcmFtIHgyIC0gU2Vjb25kIGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB4IGF4aXMuXHJcbiAgICogQHBhcmFtIHkyIC0gU2Vjb25kIGVuZCBvZiB0aGUgbGluZSBzZWdtZW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICogQHBhcmFtIHgzIC0gUG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXMuXHJcbiAgICogQHBhcmFtIHkzIC0gUG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXMuXHJcbiAgICogQHBhcmFtIHZpYTEgLSBUaGUgZmlyc3QgcG9pbnQgdGhpcyBlZGdlIHBhc3NlcyB0aHJvdWdoLlxyXG4gICAqIEBwYXJhbSB2aWEyIC0gVGhlIHNlY29uZCBwb2ludCB0aGlzIGVkZ2UgcGFzc2VzIHRocm91Z2guXHJcbiAgICogQHJldHVybnMgVGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGxpbmUgc2VnbWVudCBhbmQgdGhlIHBvaW50LlxyXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoQ3ViaWNCZXppZXJFZGdlQmFzZSwgW3tcbiAgICBrZXk6IFwiX2dldERpc3RhbmNlVG9CZXppZXJFZGdlMlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlzdGFuY2VUb0JlemllckVkZ2UyKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHZpYTEsIHZpYTIpIHtcbiAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgdmFyIG1pbkRpc3RhbmNlID0gMWU5O1xuICAgICAgdmFyIGxhc3RYID0geDE7XG4gICAgICB2YXIgbGFzdFkgPSB5MTtcbiAgICAgIHZhciB2ZWMgPSBbMCwgMCwgMCwgMF07XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgdmFyIHQgPSAwLjEgKiBpO1xuICAgICAgICB2ZWNbMF0gPSBNYXRoLnBvdygxIC0gdCwgMyk7XG4gICAgICAgIHZlY1sxXSA9IDMgKiB0ICogTWF0aC5wb3coMSAtIHQsIDIpO1xuICAgICAgICB2ZWNbMl0gPSAzICogTWF0aC5wb3codCwgMikgKiAoMSAtIHQpO1xuICAgICAgICB2ZWNbM10gPSBNYXRoLnBvdyh0LCAzKTtcbiAgICAgICAgdmFyIHggPSB2ZWNbMF0gKiB4MSArIHZlY1sxXSAqIHZpYTEueCArIHZlY1syXSAqIHZpYTIueCArIHZlY1szXSAqIHgyO1xuICAgICAgICB2YXIgeSA9IHZlY1swXSAqIHkxICsgdmVjWzFdICogdmlhMS55ICsgdmVjWzJdICogdmlhMi55ICsgdmVjWzNdICogeTI7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHRoaXMuX2dldERpc3RhbmNlVG9MaW5lKGxhc3RYLCBsYXN0WSwgeCwgeSwgeDMsIHkzKTtcbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlIDwgbWluRGlzdGFuY2UgPyBkaXN0YW5jZSA6IG1pbkRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RYID0geDtcbiAgICAgICAgbGFzdFkgPSB5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1pbkRpc3RhbmNlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ3ViaWNCZXppZXJFZGdlQmFzZTtcbn0oQmV6aWVyRWRnZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkNShEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ1KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDUoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXHJcbiAqIEEgQ3ViaWMgQmV6aWVyIEVkZ2UuIEJlemllciBjdXJ2ZXMgYXJlIHVzZWQgdG8gbW9kZWwgc21vb3RoIGdyYWR1YWwgY3VydmVzIGluIHBhdGhzIGJldHdlZW4gbm9kZXMuXHJcbiAqL1xudmFyIEN1YmljQmV6aWVyRWRnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0N1YmljQmV6aWVyRWRnZUJhc2UpIHtcbiAgX2luaGVyaXRzKEN1YmljQmV6aWVyRWRnZSwgX0N1YmljQmV6aWVyRWRnZUJhc2UpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDUoQ3ViaWNCZXppZXJFZGdlKTtcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3Qgb2YgZ2l2ZW4gZWRnZS5cclxuICAgKiBAcGFyYW0gYm9keSAtIFRoZSBib2R5IG9mIHRoZSBuZXR3b3JrLlxyXG4gICAqIEBwYXJhbSBsYWJlbE1vZHVsZSAtIExhYmVsIG1vZHVsZS5cclxuICAgKi9cbiAgZnVuY3Rpb24gQ3ViaWNCZXppZXJFZGdlKG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEN1YmljQmV6aWVyRWRnZSk7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMsIGJvZHksIGxhYmVsTW9kdWxlKTtcbiAgfVxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgX2NyZWF0ZUNsYXNzKEN1YmljQmV6aWVyRWRnZSwgW3tcbiAgICBrZXk6IFwiX2xpbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xpbmUoY3R4LCB2YWx1ZXMsIHZpYU5vZGVzKSB7XG4gICAgICAvLyBnZXQgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBzdXBwb3J0IHBvaW50cy5cbiAgICAgIHZhciB2aWExID0gdmlhTm9kZXNbMF07XG4gICAgICB2YXIgdmlhMiA9IHZpYU5vZGVzWzFdO1xuICAgICAgdGhpcy5fYmV6aWVyQ3VydmUoY3R4LCB2YWx1ZXMsIHZpYTEsIHZpYTIpO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIENvbXB1dGUgdGhlIGFkZGl0aW9uYWwgcG9pbnRzIHRoZSBlZGdlIHBhc3NlcyB0aHJvdWdoLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIENhcnRlc2lhbiBjb29yZGluYXRlcyBvZiB0aGUgcG9pbnRzIHRoZSBlZGdlIHBhc3NlcyB0aHJvdWdoLlxyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFZpYUNvb3JkaW5hdGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRWaWFDb29yZGluYXRlcygpIHtcbiAgICAgIHZhciBkeCA9IHRoaXMuZnJvbS54IC0gdGhpcy50by54O1xuICAgICAgdmFyIGR5ID0gdGhpcy5mcm9tLnkgLSB0aGlzLnRvLnk7XG4gICAgICB2YXIgeDE7XG4gICAgICB2YXIgeTE7XG4gICAgICB2YXIgeDI7XG4gICAgICB2YXIgeTI7XG4gICAgICB2YXIgcm91bmRuZXNzID0gdGhpcy5vcHRpb25zLnNtb290aC5yb3VuZG5lc3M7XG4gICAgICAvLyBob3Jpem9udGFsIGlmIHggPiB5IG9yIGlmIGRpcmVjdGlvbiBpcyBmb3JjZWQgb3IgaWYgZGlyZWN0aW9uIGlzIGhvcml6b250YWxcbiAgICAgIGlmICgoTWF0aC5hYnMoZHgpID4gTWF0aC5hYnMoZHkpIHx8IHRoaXMub3B0aW9ucy5zbW9vdGguZm9yY2VEaXJlY3Rpb24gPT09IHRydWUgfHwgdGhpcy5vcHRpb25zLnNtb290aC5mb3JjZURpcmVjdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpICYmIHRoaXMub3B0aW9ucy5zbW9vdGguZm9yY2VEaXJlY3Rpb24gIT09IFwidmVydGljYWxcIikge1xuICAgICAgICB5MSA9IHRoaXMuZnJvbS55O1xuICAgICAgICB5MiA9IHRoaXMudG8ueTtcbiAgICAgICAgeDEgPSB0aGlzLmZyb20ueCAtIHJvdW5kbmVzcyAqIGR4O1xuICAgICAgICB4MiA9IHRoaXMudG8ueCArIHJvdW5kbmVzcyAqIGR4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeTEgPSB0aGlzLmZyb20ueSAtIHJvdW5kbmVzcyAqIGR5O1xuICAgICAgICB5MiA9IHRoaXMudG8ueSArIHJvdW5kbmVzcyAqIGR5O1xuICAgICAgICB4MSA9IHRoaXMuZnJvbS54O1xuICAgICAgICB4MiA9IHRoaXMudG8ueDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbe1xuICAgICAgICB4OiB4MSxcbiAgICAgICAgeTogeTFcbiAgICAgIH0sIHtcbiAgICAgICAgeDogeDIsXG4gICAgICAgIHk6IHkyXG4gICAgICB9XTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VmlhTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWFOb2RlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFZpYUNvb3JkaW5hdGVzKCk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9maW5kQm9yZGVyUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmRCb3JkZXJQb3NpdGlvbihuZWFyTm9kZSwgY3R4KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmluZEJvcmRlclBvc2l0aW9uQmV6aWVyKG5lYXJOb2RlLCBjdHgpO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RGlzdGFuY2VUb0VkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDYgJiYgYXJndW1lbnRzWzZdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNl0gOiB0aGlzLl9nZXRWaWFDb29yZGluYXRlcygpLFxuICAgICAgICBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICB2aWExID0gX3JlZjJbMF0sXG4gICAgICAgIHZpYTIgPSBfcmVmMlsxXTtcbiAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9CZXppZXJFZGdlMih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB2aWExLCB2aWEyKTtcbiAgICB9XG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9pbnQocG9zaXRpb24pIHtcbiAgICAgIHZhciBfcmVmMyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5fZ2V0VmlhQ29vcmRpbmF0ZXMoKSxcbiAgICAgICAgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICAgIHZpYTEgPSBfcmVmNFswXSxcbiAgICAgICAgdmlhMiA9IF9yZWY0WzFdO1xuICAgICAgdmFyIHQgPSBwb3NpdGlvbjtcbiAgICAgIHZhciB2ZWMgPSBbTWF0aC5wb3coMSAtIHQsIDMpLCAzICogdCAqIE1hdGgucG93KDEgLSB0LCAyKSwgMyAqIE1hdGgucG93KHQsIDIpICogKDEgLSB0KSwgTWF0aC5wb3codCwgMyldO1xuICAgICAgdmFyIHggPSB2ZWNbMF0gKiB0aGlzLmZyb21Qb2ludC54ICsgdmVjWzFdICogdmlhMS54ICsgdmVjWzJdICogdmlhMi54ICsgdmVjWzNdICogdGhpcy50b1BvaW50Lng7XG4gICAgICB2YXIgeSA9IHZlY1swXSAqIHRoaXMuZnJvbVBvaW50LnkgKyB2ZWNbMV0gKiB2aWExLnkgKyB2ZWNbMl0gKiB2aWEyLnkgKyB2ZWNbM10gKiB0aGlzLnRvUG9pbnQueTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDdWJpY0JlemllckVkZ2U7XG59KEN1YmljQmV6aWVyRWRnZUJhc2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkNChEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IF9SZWZsZWN0JGNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDQoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXHJcbiAqIEEgU3RyYWlnaHQgRWRnZS5cclxuICovXG52YXIgU3RyYWlnaHRFZGdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRnZUJhc2UpIHtcbiAgX2luaGVyaXRzKFN0cmFpZ2h0RWRnZSwgX0VkZ2VCYXNlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQ0KFN0cmFpZ2h0RWRnZSk7XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IG9mIGdpdmVuIGVkZ2UuXHJcbiAgICogQHBhcmFtIGJvZHkgLSBUaGUgYm9keSBvZiB0aGUgbmV0d29yay5cclxuICAgKiBAcGFyYW0gbGFiZWxNb2R1bGUgLSBMYWJlbCBtb2R1bGUuXHJcbiAgICovXG4gIGZ1bmN0aW9uIFN0cmFpZ2h0RWRnZShvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJhaWdodEVkZ2UpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBsYWJlbE1vZHVsZSk7XG4gIH1cbiAgLyoqIEBpbmhlcml0RG9jICovXG4gIF9jcmVhdGVDbGFzcyhTdHJhaWdodEVkZ2UsIFt7XG4gICAga2V5OiBcIl9saW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9saW5lKGN0eCwgdmFsdWVzKSB7XG4gICAgICAvLyBkcmF3IGEgc3RyYWlnaHQgbGluZVxuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyh0aGlzLmZyb21Qb2ludC54LCB0aGlzLmZyb21Qb2ludC55KTtcbiAgICAgIGN0eC5saW5lVG8odGhpcy50b1BvaW50LngsIHRoaXMudG9Qb2ludC55KTtcbiAgICAgIC8vIGRyYXcgc2hhZG93IGlmIGVuYWJsZWRcbiAgICAgIHRoaXMuZW5hYmxlU2hhZG93KGN0eCwgdmFsdWVzKTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIHRoaXMuZGlzYWJsZVNoYWRvdyhjdHgsIHZhbHVlcyk7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFZpYU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VmlhTm9kZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50KHBvc2l0aW9uKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAoMSAtIHBvc2l0aW9uKSAqIHRoaXMuZnJvbVBvaW50LnggKyBwb3NpdGlvbiAqIHRoaXMudG9Qb2ludC54LFxuICAgICAgICB5OiAoMSAtIHBvc2l0aW9uKSAqIHRoaXMuZnJvbVBvaW50LnkgKyBwb3NpdGlvbiAqIHRoaXMudG9Qb2ludC55XG4gICAgICB9O1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZmluZEJvcmRlclBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kQm9yZGVyUG9zaXRpb24obmVhck5vZGUsIGN0eCkge1xuICAgICAgdmFyIG5vZGUxID0gdGhpcy50bztcbiAgICAgIHZhciBub2RlMiA9IHRoaXMuZnJvbTtcbiAgICAgIGlmIChuZWFyTm9kZS5pZCA9PT0gdGhpcy5mcm9tLmlkKSB7XG4gICAgICAgIG5vZGUxID0gdGhpcy5mcm9tO1xuICAgICAgICBub2RlMiA9IHRoaXMudG87XG4gICAgICB9XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKG5vZGUxLnkgLSBub2RlMi55LCBub2RlMS54IC0gbm9kZTIueCk7XG4gICAgICB2YXIgZHggPSBub2RlMS54IC0gbm9kZTIueDtcbiAgICAgIHZhciBkeSA9IG5vZGUxLnkgLSBub2RlMi55O1xuICAgICAgdmFyIGVkZ2VTZWdtZW50TGVuZ3RoID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIHZhciB0b0JvcmRlckRpc3QgPSBuZWFyTm9kZS5kaXN0YW5jZVRvQm9yZGVyKGN0eCwgYW5nbGUpO1xuICAgICAgdmFyIHRvQm9yZGVyUG9pbnQgPSAoZWRnZVNlZ21lbnRMZW5ndGggLSB0b0JvcmRlckRpc3QpIC8gZWRnZVNlZ21lbnRMZW5ndGg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAoMSAtIHRvQm9yZGVyUG9pbnQpICogbm9kZTIueCArIHRvQm9yZGVyUG9pbnQgKiBub2RlMS54LFxuICAgICAgICB5OiAoMSAtIHRvQm9yZGVyUG9pbnQpICogbm9kZTIueSArIHRvQm9yZGVyUG9pbnQgKiBub2RlMS55LFxuICAgICAgICB0OiAwXG4gICAgICB9O1xuICAgIH1cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RGlzdGFuY2VUb0VkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9FZGdlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIC8vIHgzLHkzIGlzIHRoZSBwb2ludFxuICAgICAgcmV0dXJuIHRoaXMuX2dldERpc3RhbmNlVG9MaW5lKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3RyYWlnaHRFZGdlO1xufShFZGdlQmFzZSk7XG5cbi8qKlxuICogQW4gZWRnZSBjb25uZWN0cyB0d28gbm9kZXMgYW5kIGhhcyBhIHNwZWNpZmljIGRpcmVjdGlvbi5cbiAqL1xudmFyIEVkZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgICAgICAgIHZhbHVlcyBzcGVjaWZpYyB0byB0aGlzIGVkZ2UsIG11c3QgY29udGFpbiBhdCBsZWFzdCAnZnJvbScgYW5kICd0bydcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHkgICAgICAgICAgIHNoYXJlZCBzdGF0ZSBmcm9tIE5ldHdvcmsgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOZXR3b3JrLkltYWdlc30gaW1hZ2VsaXN0ICBBIGxpc3Qgd2l0aCBpbWFnZXMuIE9ubHkgbmVlZGVkIHdoZW4gdGhlIGVkZ2UgaGFzIGltYWdlIGFycm93cy5cbiAgICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbE9wdGlvbnMgIG9wdGlvbnMgZnJvbSB0aGUgRWRnZXNIYW5kbGVyIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkZWZhdWx0T3B0aW9ucyBkZWZhdWx0IG9wdGlvbnMgZnJvbSB0aGUgRWRnZUhhbmRsZXIgaW5zdGFuY2UuIFZhbHVlIGFuZCByZWZlcmVuY2UgYXJlIGNvbnN0YW50XG4gICAqL1xuICBmdW5jdGlvbiBFZGdlKG9wdGlvbnMsIGJvZHksIGltYWdlbGlzdCwgZ2xvYmFsT3B0aW9ucywgZGVmYXVsdE9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZSk7XG4gICAgaWYgKGJvZHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYm9keSBwcm92aWRlZFwiKTtcbiAgICB9XG5cbiAgICAvLyBTaW5jZSBnbG9iYWxPcHRpb25zIGlzIGNvbnN0YW50IGluIHZhbHVlcyBhcyB3ZWxsIGFzIHJlZmVyZW5jZSxcbiAgICAvLyBGb2xsb3dpbmcgbmVlZHMgdG8gYmUgZG9uZSBvbmx5IG9uY2UuXG5cbiAgICB0aGlzLm9wdGlvbnMgPSBicmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucyk7XG4gICAgdGhpcy5nbG9iYWxPcHRpb25zID0gZ2xvYmFsT3B0aW9ucztcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmltYWdlbGlzdCA9IGltYWdlbGlzdDtcblxuICAgIC8vIGluaXRpYWxpemUgdmFyaWFibGVzXG4gICAgdGhpcy5pZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZyb21JZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvSWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zZWxlY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuaG92ZXIgPSBmYWxzZTtcbiAgICB0aGlzLmxhYmVsRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuYmFzZVdpZHRoID0gdGhpcy5vcHRpb25zLndpZHRoO1xuICAgIHRoaXMuYmFzZUZvbnRTaXplID0gdGhpcy5vcHRpb25zLmZvbnQuc2l6ZTtcbiAgICB0aGlzLmZyb20gPSB1bmRlZmluZWQ7IC8vIGEgbm9kZVxuICAgIHRoaXMudG8gPSB1bmRlZmluZWQ7IC8vIGEgbm9kZVxuXG4gICAgdGhpcy5lZGdlVHlwZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMubGFiZWxNb2R1bGUgPSBuZXcgTGFiZWwodGhpcy5ib2R5LCB0aGlzLm9wdGlvbnMsIHRydWUgLyogSXQncyBhbiBlZGdlIGxhYmVsICovKTtcblxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgb3Igb3ZlcndyaXRlIG9wdGlvbnMgZm9yIHRoZSBlZGdlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICBhbiBvYmplY3Qgd2l0aCBvcHRpb25zXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR8Ym9vbGVhbn0gdW5kZWZpbmVkIGlmIG5vIG9wdGlvbnMsIHRydWUgaWYgbGF5b3V0IGFmZmVjdGluZyBkYXRhIGNoYW5nZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhFZGdlLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gRm9sbG93aW5nIG9wdGlvbnMgaWYgY2hhbmdlZCBhZmZlY3QgdGhlIGxheW91dC5cbiAgICAgIHZhciBhZmZlY3RzTGF5b3V0ID0gdHlwZW9mIG9wdGlvbnMucGh5c2ljcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0aGlzLm9wdGlvbnMucGh5c2ljcyAhPT0gb3B0aW9ucy5waHlzaWNzIHx8IHR5cGVvZiBvcHRpb25zLmhpZGRlbiAhPT0gXCJ1bmRlZmluZWRcIiAmJiAodGhpcy5vcHRpb25zLmhpZGRlbiB8fCBmYWxzZSkgIT09IChvcHRpb25zLmhpZGRlbiB8fCBmYWxzZSkgfHwgdHlwZW9mIG9wdGlvbnMuZnJvbSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0aGlzLm9wdGlvbnMuZnJvbSAhPT0gb3B0aW9ucy5mcm9tIHx8IHR5cGVvZiBvcHRpb25zLnRvICE9PSBcInVuZGVmaW5lZFwiICYmIHRoaXMub3B0aW9ucy50byAhPT0gb3B0aW9ucy50bztcbiAgICAgIEVkZ2UucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgdHJ1ZSwgdGhpcy5nbG9iYWxPcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5pZCA9IG9wdGlvbnMuaWQ7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5mcm9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5mcm9tSWQgPSBvcHRpb25zLmZyb207XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy50byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudG9JZCA9IG9wdGlvbnMudG87XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy50aXRsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudGl0bGUgPSBvcHRpb25zLnRpdGxlO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLnZhbHVlID0gX3BhcnNlRmxvYXQkMShvcHRpb25zLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBwaWxlID0gW29wdGlvbnMsIHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9uc107XG4gICAgICB0aGlzLmNob29zZXIgPSBjaG9vc2lmeShcImVkZ2VcIiwgcGlsZSk7XG5cbiAgICAgIC8vIHVwZGF0ZSBsYWJlbCBNb2R1bGVcbiAgICAgIHRoaXMudXBkYXRlTGFiZWxNb2R1bGUob3B0aW9ucyk7XG5cbiAgICAgIC8vIFVwZGF0ZSBlZGdlIHR5cGUsIHRoaXMgaWYgY2hhbmdlZCBhZmZlY3RzIHRoZSBsYXlvdXQuXG4gICAgICBhZmZlY3RzTGF5b3V0ID0gdGhpcy51cGRhdGVFZGdlVHlwZSgpIHx8IGFmZmVjdHNMYXlvdXQ7XG5cbiAgICAgIC8vIGlmIGFueXRoaW5nIGhhcyBiZWVuIHVwZGF0ZXMsIHJlc2V0IHRoZSBzZWxlY3Rpb24gd2lkdGggYW5kIHRoZSBob3ZlciB3aWR0aFxuICAgICAgdGhpcy5fc2V0SW50ZXJhY3Rpb25XaWR0aHMoKTtcblxuICAgICAgLy8gQSBub2RlIGlzIGNvbm5lY3RlZCB3aGVuIGl0IGhhcyBhIGZyb20gYW5kIHRvIG5vZGUgdGhhdCBib3RoIGV4aXN0IGluIHRoZSBuZXR3b3JrLmJvZHkubm9kZXMuXG4gICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgIHJldHVybiBhZmZlY3RzTGF5b3V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gbmV3T3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FsbG93RGVsZXRpb249ZmFsc2VdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtnbG9iYWxPcHRpb25zPXt9XVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvcHlGcm9tR2xvYmFscz1mYWxzZV1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRGb3JtYXR0aW5nVmFsdWVzXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyb3dPcHRpb25zfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZvcm1hdHRpbmdWYWx1ZXMoKSB7XG4gICAgICB2YXIgdG9BcnJvdyA9IHRoaXMub3B0aW9ucy5hcnJvd3MudG8gPT09IHRydWUgfHwgdGhpcy5vcHRpb25zLmFycm93cy50by5lbmFibGVkID09PSB0cnVlO1xuICAgICAgdmFyIGZyb21BcnJvdyA9IHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbSA9PT0gdHJ1ZSB8fCB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uZW5hYmxlZCA9PT0gdHJ1ZTtcbiAgICAgIHZhciBtaWRkbGVBcnJvdyA9IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlID09PSB0cnVlIHx8IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLmVuYWJsZWQgPT09IHRydWU7XG4gICAgICB2YXIgaW5oZXJpdHNDb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5pbmhlcml0O1xuICAgICAgdmFyIHZhbHVlcyA9IHtcbiAgICAgICAgdG9BcnJvdzogdG9BcnJvdyxcbiAgICAgICAgdG9BcnJvd1NjYWxlOiB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLnNjYWxlRmFjdG9yLFxuICAgICAgICB0b0Fycm93VHlwZTogdGhpcy5vcHRpb25zLmFycm93cy50by50eXBlLFxuICAgICAgICB0b0Fycm93U3JjOiB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLnNyYyxcbiAgICAgICAgdG9BcnJvd0ltYWdlV2lkdGg6IHRoaXMub3B0aW9ucy5hcnJvd3MudG8uaW1hZ2VXaWR0aCxcbiAgICAgICAgdG9BcnJvd0ltYWdlSGVpZ2h0OiB0aGlzLm9wdGlvbnMuYXJyb3dzLnRvLmltYWdlSGVpZ2h0LFxuICAgICAgICBtaWRkbGVBcnJvdzogbWlkZGxlQXJyb3csXG4gICAgICAgIG1pZGRsZUFycm93U2NhbGU6IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLnNjYWxlRmFjdG9yLFxuICAgICAgICBtaWRkbGVBcnJvd1R5cGU6IHRoaXMub3B0aW9ucy5hcnJvd3MubWlkZGxlLnR5cGUsXG4gICAgICAgIG1pZGRsZUFycm93U3JjOiB0aGlzLm9wdGlvbnMuYXJyb3dzLm1pZGRsZS5zcmMsXG4gICAgICAgIG1pZGRsZUFycm93SW1hZ2VXaWR0aDogdGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuaW1hZ2VXaWR0aCxcbiAgICAgICAgbWlkZGxlQXJyb3dJbWFnZUhlaWdodDogdGhpcy5vcHRpb25zLmFycm93cy5taWRkbGUuaW1hZ2VIZWlnaHQsXG4gICAgICAgIGZyb21BcnJvdzogZnJvbUFycm93LFxuICAgICAgICBmcm9tQXJyb3dTY2FsZTogdGhpcy5vcHRpb25zLmFycm93cy5mcm9tLnNjYWxlRmFjdG9yLFxuICAgICAgICBmcm9tQXJyb3dUeXBlOiB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20udHlwZSxcbiAgICAgICAgZnJvbUFycm93U3JjOiB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uc3JjLFxuICAgICAgICBmcm9tQXJyb3dJbWFnZVdpZHRoOiB0aGlzLm9wdGlvbnMuYXJyb3dzLmZyb20uaW1hZ2VXaWR0aCxcbiAgICAgICAgZnJvbUFycm93SW1hZ2VIZWlnaHQ6IHRoaXMub3B0aW9ucy5hcnJvd3MuZnJvbS5pbWFnZUhlaWdodCxcbiAgICAgICAgYXJyb3dTdHJpa2V0aHJvdWdoOiB0aGlzLm9wdGlvbnMuYXJyb3dTdHJpa2V0aHJvdWdoLFxuICAgICAgICBjb2xvcjogaW5oZXJpdHNDb2xvciA/IHVuZGVmaW5lZCA6IHRoaXMub3B0aW9ucy5jb2xvci5jb2xvcixcbiAgICAgICAgaW5oZXJpdHNDb2xvcjogaW5oZXJpdHNDb2xvcixcbiAgICAgICAgb3BhY2l0eTogdGhpcy5vcHRpb25zLmNvbG9yLm9wYWNpdHksXG4gICAgICAgIGhpZGRlbjogdGhpcy5vcHRpb25zLmhpZGRlbixcbiAgICAgICAgbGVuZ3RoOiB0aGlzLm9wdGlvbnMubGVuZ3RoLFxuICAgICAgICBzaGFkb3c6IHRoaXMub3B0aW9ucy5zaGFkb3cuZW5hYmxlZCxcbiAgICAgICAgc2hhZG93Q29sb3I6IHRoaXMub3B0aW9ucy5zaGFkb3cuY29sb3IsXG4gICAgICAgIHNoYWRvd1NpemU6IHRoaXMub3B0aW9ucy5zaGFkb3cuc2l6ZSxcbiAgICAgICAgc2hhZG93WDogdGhpcy5vcHRpb25zLnNoYWRvdy54LFxuICAgICAgICBzaGFkb3dZOiB0aGlzLm9wdGlvbnMuc2hhZG93LnksXG4gICAgICAgIGRhc2hlczogdGhpcy5vcHRpb25zLmRhc2hlcyxcbiAgICAgICAgd2lkdGg6IHRoaXMub3B0aW9ucy53aWR0aCxcbiAgICAgICAgYmFja2dyb3VuZDogdGhpcy5vcHRpb25zLmJhY2tncm91bmQuZW5hYmxlZCxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLm9wdGlvbnMuYmFja2dyb3VuZC5jb2xvcixcbiAgICAgICAgYmFja2dyb3VuZFNpemU6IHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kLnNpemUsXG4gICAgICAgIGJhY2tncm91bmREYXNoZXM6IHRoaXMub3B0aW9ucy5iYWNrZ3JvdW5kLmRhc2hlc1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkIHx8IHRoaXMuaG92ZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hvb3NlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRXaWR0aCA9IHRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0ZWRXaWR0aCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy53aWR0aCA9IHNlbGVjdGVkV2lkdGgodmFsdWVzLndpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlbGVjdGVkV2lkdGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgdmFsdWVzLndpZHRoICs9IHNlbGVjdGVkV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXMud2lkdGggPSBNYXRoLm1heCh2YWx1ZXMud2lkdGgsIDAuMyAvIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgICAgICAgIHZhbHVlcy5jb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5oaWdobGlnaHQ7XG4gICAgICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5ob3Zlcikge1xuICAgICAgICAgICAgdmFyIGhvdmVyV2lkdGggPSB0aGlzLm9wdGlvbnMuaG92ZXJXaWR0aDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaG92ZXJXaWR0aCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIHZhbHVlcy53aWR0aCA9IGhvdmVyV2lkdGgodmFsdWVzLndpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGhvdmVyV2lkdGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgdmFsdWVzLndpZHRoICs9IGhvdmVyV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXMud2lkdGggPSBNYXRoLm1heCh2YWx1ZXMud2lkdGgsIDAuMyAvIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgICAgICAgIHZhbHVlcy5jb2xvciA9IHRoaXMub3B0aW9ucy5jb2xvci5ob3ZlcjtcbiAgICAgICAgICAgIHZhbHVlcy5zaGFkb3cgPSB0aGlzLm9wdGlvbnMuc2hhZG93LmVuYWJsZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLmNob29zZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRoaXMuY2hvb3Nlcih2YWx1ZXMsIHRoaXMub3B0aW9ucy5pZCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5ob3Zlcik7XG4gICAgICAgICAgaWYgKHZhbHVlcy5jb2xvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZXMuaW5oZXJpdHNDb2xvciA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWVzLnNoYWRvdyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMuc2hhZG93Q29sb3IgIT09IHRoaXMub3B0aW9ucy5zaGFkb3cuY29sb3IgfHwgdmFsdWVzLnNoYWRvd1NpemUgIT09IHRoaXMub3B0aW9ucy5zaGFkb3cuc2l6ZSB8fCB2YWx1ZXMuc2hhZG93WCAhPT0gdGhpcy5vcHRpb25zLnNoYWRvdy54IHx8IHZhbHVlcy5zaGFkb3dZICE9PSB0aGlzLm9wdGlvbnMuc2hhZG93LnkpIHtcbiAgICAgICAgICAgICAgdmFsdWVzLnNoYWRvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXMuc2hhZG93ID0gdGhpcy5vcHRpb25zLnNoYWRvdy5lbmFibGVkO1xuICAgICAgICB2YWx1ZXMud2lkdGggPSBNYXRoLm1heCh2YWx1ZXMud2lkdGgsIDAuMyAvIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIHRoZSBvcHRpb25zIGluIHRoZSBsYWJlbCBtb2R1bGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlTGFiZWxNb2R1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlTGFiZWxNb2R1bGUob3B0aW9ucykge1xuICAgICAgdmFyIHBpbGUgPSBbb3B0aW9ucywgdGhpcy5vcHRpb25zLCB0aGlzLmdsb2JhbE9wdGlvbnMsXG4gICAgICAvLyBDdXJyZW50bHkgc2V0IGdsb2JhbCBlZGdlIG9wdGlvbnNcbiAgICAgIHRoaXMuZGVmYXVsdE9wdGlvbnNdO1xuICAgICAgdGhpcy5sYWJlbE1vZHVsZS51cGRhdGUodGhpcy5vcHRpb25zLCBwaWxlKTtcbiAgICAgIGlmICh0aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5iYXNlRm9udFNpemUgPSB0aGlzLmxhYmVsTW9kdWxlLmJhc2VTaXplO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgZWRnZSB0eXBlLCBzZXQgdGhlIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUVkZ2VUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUVkZ2VUeXBlKCkge1xuICAgICAgdmFyIHNtb290aCA9IHRoaXMub3B0aW9ucy5zbW9vdGg7XG4gICAgICB2YXIgZGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciBjaGFuZ2VJblR5cGUgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuZWRnZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIEJlemllckVkZ2VEeW5hbWljICYmIHNtb290aC5lbmFibGVkID09PSB0cnVlICYmIHNtb290aC50eXBlID09PSBcImR5bmFtaWNcIiB8fCB0aGlzLmVkZ2VUeXBlIGluc3RhbmNlb2YgQ3ViaWNCZXppZXJFZGdlICYmIHNtb290aC5lbmFibGVkID09PSB0cnVlICYmIHNtb290aC50eXBlID09PSBcImN1YmljQmV6aWVyXCIgfHwgdGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIEJlemllckVkZ2VTdGF0aWMgJiYgc21vb3RoLmVuYWJsZWQgPT09IHRydWUgJiYgc21vb3RoLnR5cGUgIT09IFwiZHluYW1pY1wiICYmIHNtb290aC50eXBlICE9PSBcImN1YmljQmV6aWVyXCIgfHwgdGhpcy5lZGdlVHlwZSBpbnN0YW5jZW9mIFN0cmFpZ2h0RWRnZSAmJiBzbW9vdGgudHlwZS5lbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgIGNoYW5nZUluVHlwZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VJblR5cGUgPT09IHRydWUpIHtcbiAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRoaXMuY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2hhbmdlSW5UeXBlID09PSB0cnVlKSB7XG4gICAgICAgIGlmIChzbW9vdGguZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmIChzbW9vdGgudHlwZSA9PT0gXCJkeW5hbWljXCIpIHtcbiAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZWRnZVR5cGUgPSBuZXcgQmV6aWVyRWRnZUR5bmFtaWModGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc21vb3RoLnR5cGUgPT09IFwiY3ViaWNCZXppZXJcIikge1xuICAgICAgICAgICAgdGhpcy5lZGdlVHlwZSA9IG5ldyBDdWJpY0JlemllckVkZ2UodGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVkZ2VUeXBlID0gbmV3IEJlemllckVkZ2VTdGF0aWModGhpcy5vcHRpb25zLCB0aGlzLmJvZHksIHRoaXMubGFiZWxNb2R1bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVkZ2VUeXBlID0gbmV3IFN0cmFpZ2h0RWRnZSh0aGlzLm9wdGlvbnMsIHRoaXMuYm9keSwgdGhpcy5sYWJlbE1vZHVsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIG5vdGhpbmcgY2hhbmdlcywgd2UganVzdCBzZXQgdGhlIG9wdGlvbnMuXG4gICAgICAgIHRoaXMuZWRnZVR5cGUuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFDaGFuZ2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgYW4gZWRnZSB0byBpdHMgbm9kZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjb25uZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLmZyb21JZF0gfHwgdW5kZWZpbmVkO1xuICAgICAgdGhpcy50byA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRvSWRdIHx8IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuY29ubmVjdGVkID0gdGhpcy5mcm9tICE9PSB1bmRlZmluZWQgJiYgdGhpcy50byAhPT0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZnJvbS5hdHRhY2hFZGdlKHRoaXMpO1xuICAgICAgICB0aGlzLnRvLmF0dGFjaEVkZ2UodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5mcm9tKSB7XG4gICAgICAgICAgdGhpcy5mcm9tLmRldGFjaEVkZ2UodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudG8pIHtcbiAgICAgICAgICB0aGlzLnRvLmRldGFjaEVkZ2UodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZWRnZVR5cGUuY29ubmVjdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgYW4gZWRnZSBmcm9tIGl0cyBub2Rlc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRpc2Nvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzY29ubmVjdCgpIHtcbiAgICAgIGlmICh0aGlzLmZyb20pIHtcbiAgICAgICAgdGhpcy5mcm9tLmRldGFjaEVkZ2UodGhpcyk7XG4gICAgICAgIHRoaXMuZnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRvKSB7XG4gICAgICAgIHRoaXMudG8uZGV0YWNoRWRnZSh0aGlzKTtcbiAgICAgICAgdGhpcy50byA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSB0aXRsZSBvZiB0aGlzIGVkZ2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSB0aXRsZSAgICBUaGUgdGl0bGUgb2YgdGhlIGVkZ2UsIG9yIHVuZGVmaW5lZCB3aGVuIG5vIHRpdGxlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBoYXMgYmVlbiBzZXQuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGl0bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy50aXRsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjaGVjayBpZiB0aGlzIG5vZGUgaXMgc2VsZWN0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHNlbGVjdGVkICAgVHJ1ZSBpZiBub2RlIGlzIHNlbGVjdGVkLCBlbHNlIGZhbHNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTZWxlY3RlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1NlbGVjdGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIHZhbHVlIG9mIHRoZSBlZGdlLiBDYW4gYmUgdW5kZWZpbmVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB2YWx1ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFZhbHVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGp1c3QgdGhlIHZhbHVlIHJhbmdlIG9mIHRoZSBlZGdlLiBUaGUgZWRnZSB3aWxsIGFkanVzdCBpdCdzIHdpZHRoXG4gICAgICogYmFzZWQgb24gaXRzIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG90YWxcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRWYWx1ZVJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlUmFuZ2UobWluLCBtYXgsIHRvdGFsKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5vcHRpb25zLnNjYWxpbmcuY3VzdG9tU2NhbGluZ0Z1bmN0aW9uKG1pbiwgbWF4LCB0b3RhbCwgdGhpcy5vcHRpb25zLnZhbHVlKTtcbiAgICAgICAgdmFyIHdpZHRoRGlmZiA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLm1heCAtIHRoaXMub3B0aW9ucy5zY2FsaW5nLm1pbjtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgZm9udERpZmYgPSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5tYXggLSB0aGlzLm9wdGlvbnMuc2NhbGluZy5sYWJlbC5taW47XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMub3B0aW9ucy5zY2FsaW5nLmxhYmVsLm1pbiArIHNjYWxlICogZm9udERpZmY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zLndpZHRoID0gdGhpcy5vcHRpb25zLnNjYWxpbmcubWluICsgc2NhbGUgKiB3aWR0aERpZmY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wdGlvbnMud2lkdGggPSB0aGlzLmJhc2VXaWR0aDtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZvbnQuc2l6ZSA9IHRoaXMuYmFzZUZvbnRTaXplO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0SW50ZXJhY3Rpb25XaWR0aHMoKTtcbiAgICAgIHRoaXMudXBkYXRlTGFiZWxNb2R1bGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldEludGVyYWN0aW9uV2lkdGhzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRJbnRlcmFjdGlvbldpZHRocygpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmhvdmVyV2lkdGggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLmhvdmVyV2lkdGggPSB0aGlzLm9wdGlvbnMuaG92ZXJXaWR0aCh0aGlzLm9wdGlvbnMud2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5ob3ZlcldpZHRoID0gdGhpcy5vcHRpb25zLmhvdmVyV2lkdGggKyB0aGlzLm9wdGlvbnMud2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zZWxlY3Rpb25XaWR0aCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMuZWRnZVR5cGUuc2VsZWN0aW9uV2lkdGggPSB0aGlzLm9wdGlvbnMuc2VsZWN0aW9uV2lkdGgodGhpcy5vcHRpb25zLndpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZWRnZVR5cGUuc2VsZWN0aW9uV2lkdGggPSB0aGlzLm9wdGlvbnMuc2VsZWN0aW9uV2lkdGggKyB0aGlzLm9wdGlvbnMud2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkcmF3IGEgZWRnZVxuICAgICAqIERyYXcgdGhpcyBlZGdlIGluIHRoZSBnaXZlbiBjYW52YXNcbiAgICAgKiBUaGUgMmQgY29udGV4dCBvZiBhIEhUTUwgY2FudmFzIGNhbiBiZSByZXRyaWV2ZWQgYnkgY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgIGN0eFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhdyhjdHgpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLmdldEZvcm1hdHRpbmdWYWx1ZXMoKTtcbiAgICAgIGlmICh2YWx1ZXMuaGlkZGVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IHRoZSB2aWEgbm9kZSBmcm9tIHRoZSBlZGdlIHR5cGVcbiAgICAgIHZhciB2aWFOb2RlID0gdGhpcy5lZGdlVHlwZS5nZXRWaWFOb2RlKCk7XG5cbiAgICAgIC8vIGRyYXcgbGluZSBhbmQgbGFiZWxcbiAgICAgIHRoaXMuZWRnZVR5cGUuZHJhd0xpbmUoY3R4LCB2YWx1ZXMsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHZpYU5vZGUpO1xuICAgICAgdGhpcy5kcmF3TGFiZWwoY3R4LCB2aWFOb2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgYXJyb3dzXG4gICAgICogRHJhdyB0aGlzIGFycm93cyBpbiB0aGUgZ2l2ZW4gY2FudmFzXG4gICAgICogVGhlIDJkIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhcyBjYW4gYmUgcmV0cmlldmVkIGJ5IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkcmF3QXJyb3dzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdBcnJvd3MoY3R4KSB7XG4gICAgICB2YXIgdmFsdWVzID0gdGhpcy5nZXRGb3JtYXR0aW5nVmFsdWVzKCk7XG4gICAgICBpZiAodmFsdWVzLmhpZGRlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCB0aGUgdmlhIG5vZGUgZnJvbSB0aGUgZWRnZSB0eXBlXG4gICAgICB2YXIgdmlhTm9kZSA9IHRoaXMuZWRnZVR5cGUuZ2V0VmlhTm9kZSgpO1xuICAgICAgdmFyIGFycm93RGF0YSA9IHt9O1xuXG4gICAgICAvLyByZXN0b3JlIGVkZ2UgdGFyZ2V0cyB0byBkZWZhdWx0c1xuICAgICAgdGhpcy5lZGdlVHlwZS5mcm9tUG9pbnQgPSB0aGlzLmVkZ2VUeXBlLmZyb207XG4gICAgICB0aGlzLmVkZ2VUeXBlLnRvUG9pbnQgPSB0aGlzLmVkZ2VUeXBlLnRvO1xuXG4gICAgICAvLyBmcm9tIGFuZCB0byBhcnJvd3MgZ2l2ZSBhIGRpZmZlcmVudCBlbmQgcG9pbnQgZm9yIGVkZ2VzLiB3ZSBzZXQgdGhlbSBoZXJlXG4gICAgICBpZiAodmFsdWVzLmZyb21BcnJvdykge1xuICAgICAgICBhcnJvd0RhdGEuZnJvbSA9IHRoaXMuZWRnZVR5cGUuZ2V0QXJyb3dEYXRhKGN0eCwgXCJmcm9tXCIsIHZpYU5vZGUsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHZhbHVlcyk7XG4gICAgICAgIGlmICh2YWx1ZXMuYXJyb3dTdHJpa2V0aHJvdWdoID09PSBmYWxzZSkgdGhpcy5lZGdlVHlwZS5mcm9tUG9pbnQgPSBhcnJvd0RhdGEuZnJvbS5jb3JlO1xuICAgICAgICBpZiAodmFsdWVzLmZyb21BcnJvd1NyYykge1xuICAgICAgICAgIGFycm93RGF0YS5mcm9tLmltYWdlID0gdGhpcy5pbWFnZWxpc3QubG9hZCh2YWx1ZXMuZnJvbUFycm93U3JjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVzLmZyb21BcnJvd0ltYWdlV2lkdGgpIHtcbiAgICAgICAgICBhcnJvd0RhdGEuZnJvbS5pbWFnZVdpZHRoID0gdmFsdWVzLmZyb21BcnJvd0ltYWdlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcy5mcm9tQXJyb3dJbWFnZUhlaWdodCkge1xuICAgICAgICAgIGFycm93RGF0YS5mcm9tLmltYWdlSGVpZ2h0ID0gdmFsdWVzLmZyb21BcnJvd0ltYWdlSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVzLnRvQXJyb3cpIHtcbiAgICAgICAgYXJyb3dEYXRhLnRvID0gdGhpcy5lZGdlVHlwZS5nZXRBcnJvd0RhdGEoY3R4LCBcInRvXCIsIHZpYU5vZGUsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIHZhbHVlcyk7XG4gICAgICAgIGlmICh2YWx1ZXMuYXJyb3dTdHJpa2V0aHJvdWdoID09PSBmYWxzZSkgdGhpcy5lZGdlVHlwZS50b1BvaW50ID0gYXJyb3dEYXRhLnRvLmNvcmU7XG4gICAgICAgIGlmICh2YWx1ZXMudG9BcnJvd1NyYykge1xuICAgICAgICAgIGFycm93RGF0YS50by5pbWFnZSA9IHRoaXMuaW1hZ2VsaXN0LmxvYWQodmFsdWVzLnRvQXJyb3dTcmMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZXMudG9BcnJvd0ltYWdlV2lkdGgpIHtcbiAgICAgICAgICBhcnJvd0RhdGEudG8uaW1hZ2VXaWR0aCA9IHZhbHVlcy50b0Fycm93SW1hZ2VXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVzLnRvQXJyb3dJbWFnZUhlaWdodCkge1xuICAgICAgICAgIGFycm93RGF0YS50by5pbWFnZUhlaWdodCA9IHZhbHVlcy50b0Fycm93SW1hZ2VIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gdGhlIG1pZGRsZSBhcnJvdyBkZXBlbmRzIG9uIHRoZSBsaW5lLCB3aGljaCBjYW4gZGVwZW5kIG9uIHRoZSB0byBhbmQgZnJvbSBhcnJvd3Mgc28gd2UgZG8gdGhpcyBvbmUgbGFzdGx5LlxuICAgICAgaWYgKHZhbHVlcy5taWRkbGVBcnJvdykge1xuICAgICAgICBhcnJvd0RhdGEubWlkZGxlID0gdGhpcy5lZGdlVHlwZS5nZXRBcnJvd0RhdGEoY3R4LCBcIm1pZGRsZVwiLCB2aWFOb2RlLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCB2YWx1ZXMpO1xuICAgICAgICBpZiAodmFsdWVzLm1pZGRsZUFycm93U3JjKSB7XG4gICAgICAgICAgYXJyb3dEYXRhLm1pZGRsZS5pbWFnZSA9IHRoaXMuaW1hZ2VsaXN0LmxvYWQodmFsdWVzLm1pZGRsZUFycm93U3JjKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVzLm1pZGRsZUFycm93SW1hZ2VXaWR0aCkge1xuICAgICAgICAgIGFycm93RGF0YS5taWRkbGUuaW1hZ2VXaWR0aCA9IHZhbHVlcy5taWRkbGVBcnJvd0ltYWdlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcy5taWRkbGVBcnJvd0ltYWdlSGVpZ2h0KSB7XG4gICAgICAgICAgYXJyb3dEYXRhLm1pZGRsZS5pbWFnZUhlaWdodCA9IHZhbHVlcy5taWRkbGVBcnJvd0ltYWdlSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVzLmZyb21BcnJvdykge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLmRyYXdBcnJvd0hlYWQoY3R4LCB2YWx1ZXMsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIGFycm93RGF0YS5mcm9tKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZXMubWlkZGxlQXJyb3cpIHtcbiAgICAgICAgdGhpcy5lZGdlVHlwZS5kcmF3QXJyb3dIZWFkKGN0eCwgdmFsdWVzLCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBhcnJvd0RhdGEubWlkZGxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZXMudG9BcnJvdykge1xuICAgICAgICB0aGlzLmVkZ2VUeXBlLmRyYXdBcnJvd0hlYWQoY3R4LCB2YWx1ZXMsIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIsIGFycm93RGF0YS50byk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHBhcmFtIHtOb2RlfSB2aWFOb2RlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0xhYmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdMYWJlbChjdHgsIHZpYU5vZGUpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGFiZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBzZXQgc3R5bGVcbiAgICAgICAgdmFyIG5vZGUxID0gdGhpcy5mcm9tO1xuICAgICAgICB2YXIgbm9kZTIgPSB0aGlzLnRvO1xuICAgICAgICBpZiAodGhpcy5sYWJlbE1vZHVsZS5kaWZmZXJlbnRTdGF0ZSh0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyKSkge1xuICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZ2V0VGV4dFNpemUoY3R4LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9pbnQ7XG4gICAgICAgIGlmIChub2RlMS5pZCAhPSBub2RlMi5pZCkge1xuICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUucG9pbnRUb1NlbGYgPSBmYWxzZTtcbiAgICAgICAgICBwb2ludCA9IHRoaXMuZWRnZVR5cGUuZ2V0UG9pbnQoMC41LCB2aWFOb2RlKTtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIHZhciByb3RhdGlvblBvaW50ID0gdGhpcy5fZ2V0Um90YXRpb24oY3R4KTtcbiAgICAgICAgICBpZiAocm90YXRpb25Qb2ludC5hbmdsZSAhPSAwKSB7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHJvdGF0aW9uUG9pbnQueCwgcm90YXRpb25Qb2ludC55KTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUocm90YXRpb25Qb2ludC5hbmdsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZHJhdyB0aGUgbGFiZWxcbiAgICAgICAgICB0aGlzLmxhYmVsTW9kdWxlLmRyYXcoY3R4LCBwb2ludC54LCBwb2ludC55LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyKTtcblxuICAgICAgICAgIC8qXG4gICAgICAgICAgLy8gVXNlZnVsIGRlYnVnIGNvZGU6IGRyYXcgYSBib3JkZXIgYXJvdW5kIHRoZSBsYWJlbFxuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkICoqbm90KiogYmUgZW5hYmxlZCBpbiBwcm9kdWN0aW9uIVxuICAgICAgICAgIHZhciBzaXplID0gdGhpcy5sYWJlbE1vZHVsZS5nZXRTaXplKCk7OyAvLyA7OyBpbnRlbnRpb25hbCBzbyBsaW50IGNhdGNoZXMgaXRcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIiNmZjAwMDBcIjtcbiAgICAgICAgICBjdHguc3Ryb2tlUmVjdChzaXplLmxlZnQsIHNpemUudG9wLCBzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG4gICAgICAgICAgLy8gRW5kICBkZWJ1ZyBjb2RlXG4gICAgICAgICAgKi9cblxuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWdub3JlIHRoZSBvcmllbnRhdGlvbnMuXG4gICAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5wb2ludFRvU2VsZiA9IHRydWU7XG5cbiAgICAgICAgICAvLyBnZXQgY2lyY2xlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gZ2V0U2VsZlJlZkNvb3JkaW5hdGVzKGN0eCwgdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUsIHRoaXMub3B0aW9ucy5zZWxmUmVmZXJlbmNlLnNpemUsIG5vZGUxKTtcbiAgICAgICAgICBwb2ludCA9IHRoaXMuX3BvaW50T25DaXJjbGUoY29vcmRpbmF0ZXMueCwgY29vcmRpbmF0ZXMueSwgdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2Uuc2l6ZSwgdGhpcy5vcHRpb25zLnNlbGZSZWZlcmVuY2UuYW5nbGUpO1xuICAgICAgICAgIHRoaXMubGFiZWxNb2R1bGUuZHJhdyhjdHgsIHBvaW50LngsIHBvaW50LnksIHRoaXMuc2VsZWN0ZWQsIHRoaXMuaG92ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGFsbCB2aXN1YWwgZWxlbWVudHMgb2YgdGhpcyBlZGdlIGluc3RhbmNlLCBpbiB3aGljaCB0aGUgZ2l2ZW5cbiAgICAgKiBwb2ludCBmYWxscyB3aXRoaW4gdGhlIGJvdW5kaW5nIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtwb2ludH0gcG9pbnRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPGVkZ2VDbGlja0l0ZW18ZWRnZUxhYmVsQ2xpY2tJdGVtPn0gbGlzdCB3aXRoIHRoZSBpdGVtcyB3aGljaCBhcmUgb24gdGhlIHBvaW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SXRlbXNPblBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEl0ZW1zT25Qb2ludChwb2ludCkge1xuICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgaWYgKHRoaXMubGFiZWxNb2R1bGUudmlzaWJsZSgpKSB7XG4gICAgICAgIHZhciByb3RhdGlvblBvaW50ID0gdGhpcy5fZ2V0Um90YXRpb24oKTtcbiAgICAgICAgaWYgKHBvaW50SW5SZWN0KHRoaXMubGFiZWxNb2R1bGUuZ2V0U2l6ZSgpLCBwb2ludCwgcm90YXRpb25Qb2ludCkpIHtcbiAgICAgICAgICByZXQucHVzaCh7XG4gICAgICAgICAgICBlZGdlSWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBsYWJlbElkOiAwXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBvYmogPSB7XG4gICAgICAgIGxlZnQ6IHBvaW50LngsXG4gICAgICAgIHRvcDogcG9pbnQueVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmlzT3ZlcmxhcHBpbmdXaXRoKG9iaikpIHtcbiAgICAgICAgcmV0LnB1c2goe1xuICAgICAgICAgIGVkZ2VJZDogdGhpcy5pZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhpcyBvYmplY3QgaXMgb3ZlcmxhcHBpbmcgd2l0aCB0aGUgcHJvdmlkZWQgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqICAgYW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3BcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gICAgIFRydWUgaWYgbG9jYXRpb24gaXMgbG9jYXRlZCBvbiB0aGUgZWRnZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImlzT3ZlcmxhcHBpbmdXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzT3ZlcmxhcHBpbmdXaXRoKG9iaikge1xuICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgICAgIHZhciBkaXN0TWF4ID0gMTA7XG4gICAgICAgIHZhciB4RnJvbSA9IHRoaXMuZnJvbS54O1xuICAgICAgICB2YXIgeUZyb20gPSB0aGlzLmZyb20ueTtcbiAgICAgICAgdmFyIHhUbyA9IHRoaXMudG8ueDtcbiAgICAgICAgdmFyIHlUbyA9IHRoaXMudG8ueTtcbiAgICAgICAgdmFyIHhPYmogPSBvYmoubGVmdDtcbiAgICAgICAgdmFyIHlPYmogPSBvYmoudG9wO1xuICAgICAgICB2YXIgZGlzdCA9IHRoaXMuZWRnZVR5cGUuZ2V0RGlzdGFuY2VUb0VkZ2UoeEZyb20sIHlGcm9tLCB4VG8sIHlUbywgeE9iaiwgeU9iaik7XG4gICAgICAgIHJldHVybiBkaXN0IDwgZGlzdE1heDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIHJvdGF0aW9uIHBvaW50LCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gW2N0eF0gaWYgcGFzc2VkLCBkbyBhIHJlY2FsY3VsYXRpb24gb2YgdGhlIGxhYmVsIHNpemVcbiAgICAgKiBAcmV0dXJucyB7cm90YXRpb25Qb2ludH0gdGhlIHBvaW50IHRvIHJvdGF0ZSBhcm91bmQgYW5kIHRoZSBhbmdsZSBpbiByYWRpYW5zIHRvIHJvdGF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFJvdGF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRSb3RhdGlvbihjdHgpIHtcbiAgICAgIHZhciB2aWFOb2RlID0gdGhpcy5lZGdlVHlwZS5nZXRWaWFOb2RlKCk7XG4gICAgICB2YXIgcG9pbnQgPSB0aGlzLmVkZ2VUeXBlLmdldFBvaW50KDAuNSwgdmlhTm9kZSk7XG4gICAgICBpZiAoY3R4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5sYWJlbE1vZHVsZS5jYWxjdWxhdGVMYWJlbFNpemUoY3R4LCB0aGlzLnNlbGVjdGVkLCB0aGlzLmhvdmVyLCBwb2ludC54LCBwb2ludC55KTtcbiAgICAgIH1cbiAgICAgIHZhciByZXQgPSB7XG4gICAgICAgIHg6IHBvaW50LngsXG4gICAgICAgIHk6IHRoaXMubGFiZWxNb2R1bGUuc2l6ZS55TGluZSxcbiAgICAgICAgYW5nbGU6IDBcbiAgICAgIH07XG4gICAgICBpZiAoIXRoaXMubGFiZWxNb2R1bGUudmlzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybiByZXQ7IC8vIERvbid0IGV2ZW4gYm90aGVyIGRvaW5nIHRoZSBhdGFuMiwgdGhlcmUncyBub3RoaW5nIHRvIGRyYXdcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb250LmFsaWduID09PSBcImhvcml6b250YWxcIikge1xuICAgICAgICByZXR1cm4gcmV0OyAvLyBObyBuZWVkIHRvIGNhbGN1bGF0ZSBhbmdsZVxuICAgICAgfVxuXG4gICAgICB2YXIgZHkgPSB0aGlzLmZyb20ueSAtIHRoaXMudG8ueTtcbiAgICAgIHZhciBkeCA9IHRoaXMuZnJvbS54IC0gdGhpcy50by54O1xuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihkeSwgZHgpOyAvLyByYWRpYW5zXG5cbiAgICAgIC8vIHJvdGF0ZSBzbyB0aGF0IGxhYmVsIGlzIHJlYWRhYmxlXG4gICAgICBpZiAoYW5nbGUgPCAtMSAmJiBkeCA8IDAgfHwgYW5nbGUgPiAwICYmIGR4IDwgMCkge1xuICAgICAgICBhbmdsZSArPSBNYXRoLlBJO1xuICAgICAgfVxuICAgICAgcmV0LmFuZ2xlID0gYW5nbGU7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHBvaW50IG9uIGEgY2lyY2xlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHBvaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcG9pbnRPbkNpcmNsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcG9pbnRPbkNpcmNsZSh4LCB5LCByYWRpdXMsIGFuZ2xlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICB5OiB5IC0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgc2VsZWN0ZWQgc3RhdGUgdG8gdHJ1ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3QoKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGVkIHN0YXRlIHRvIGZhbHNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidW5zZWxlY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zZWxlY3QoKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2xlYW5zIGFsbCByZXF1aXJlZCB0aGluZ3Mgb24gZGVsZXRlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbGVhbnVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lZGdlVHlwZS5jbGVhbnVwKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGVkZ2UgZnJvbSB0aGUgbGlzdCBhbmQgcGVyZm9ybSBuZWNlc3NhcnkgY2xlYW51cC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5pZF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYm90aCBjb25uZWN0aW5nIG5vZGVzIGV4aXN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJlbmRQb2ludHNWYWxpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRQb2ludHNWYWxpZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmJvZHkubm9kZXNbdGhpcy5mcm9tSWRdICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ib2R5Lm5vZGVzW3RoaXMudG9JZF0gIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJwYXJzZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMpIHtcbiAgICAgIHZhciBhbGxvd0RlbGV0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICAgIHZhciBnbG9iYWxPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB7fTtcbiAgICAgIHZhciBjb3B5RnJvbUdsb2JhbHMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuICAgICAgdmFyIGZpZWxkcyA9IFtcImVuZFBvaW50T2Zmc2V0XCIsIFwiYXJyb3dTdHJpa2V0aHJvdWdoXCIsIFwiaWRcIiwgXCJmcm9tXCIsIFwiaGlkZGVuXCIsIFwiaG92ZXJXaWR0aFwiLCBcImxhYmVsSGlnaGxpZ2h0Qm9sZFwiLCBcImxlbmd0aFwiLCBcImxpbmVcIiwgXCJvcGFjaXR5XCIsIFwicGh5c2ljc1wiLCBcInNjYWxpbmdcIiwgXCJzZWxlY3Rpb25XaWR0aFwiLCBcInNlbGZSZWZlcmVuY2VTaXplXCIsIFwic2VsZlJlZmVyZW5jZVwiLCBcInRvXCIsIFwidGl0bGVcIiwgXCJ2YWx1ZVwiLCBcIndpZHRoXCIsIFwiZm9udFwiLCBcImNob3NlblwiLCBcIndpZHRoQ29uc3RyYWludFwiXTtcblxuICAgICAgLy8gb25seSBkZWVwIGV4dGVuZCB0aGUgaXRlbXMgaW4gdGhlIGZpZWxkIGFycmF5LiBUaGVzZSBkbyBub3QgaGF2ZSBzaG9ydGhhbmQuXG4gICAgICBzZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgcGFyZW50T3B0aW9ucywgbmV3T3B0aW9ucywgYWxsb3dEZWxldGlvbik7XG5cbiAgICAgIC8vIE9ubHkgdXNlIGVuZFBvaW50T2Zmc2V0IHZhbHVlcyAoZnJvbSBhbmQgdG8pIGlmIGl0J3MgdmFsaWQgdmFsdWVzXG4gICAgICBpZiAobmV3T3B0aW9ucy5lbmRQb2ludE9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChfTnVtYmVyJGlzRmluaXRlKG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQuZnJvbSkpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb20gPSBuZXdPcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb207XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyZW50T3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tID0gZ2xvYmFsT3B0aW9ucy5lbmRQb2ludE9mZnNldC5mcm9tICE9PSB1bmRlZmluZWQgPyBnbG9iYWxPcHRpb25zLmVuZFBvaW50T2Zmc2V0LmZyb20gOiAwO1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJlbmRQb2ludE9mZnNldC5mcm9tIGlzIG5vdCBhIHZhbGlkIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5ld09wdGlvbnMuZW5kUG9pbnRPZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLmVuZFBvaW50T2Zmc2V0LnRvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKF9OdW1iZXIkaXNGaW5pdGUobmV3T3B0aW9ucy5lbmRQb2ludE9mZnNldC50bykpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmVuZFBvaW50T2Zmc2V0LnRvID0gbmV3T3B0aW9ucy5lbmRQb2ludE9mZnNldC50bztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmVuZFBvaW50T2Zmc2V0LnRvID0gZ2xvYmFsT3B0aW9ucy5lbmRQb2ludE9mZnNldC50byAhPT0gdW5kZWZpbmVkID8gZ2xvYmFsT3B0aW9ucy5lbmRQb2ludE9mZnNldC50byA6IDA7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcImVuZFBvaW50T2Zmc2V0LnRvIGlzIG5vdCBhIHZhbGlkIG51bWJlclwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPbmx5IGNvcHkgbGFiZWwgaWYgaXQncyBhIGxlZ2FsIHZhbHVlLlxuICAgICAgaWYgKGlzVmFsaWRMYWJlbChuZXdPcHRpb25zLmxhYmVsKSkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmxhYmVsID0gbmV3T3B0aW9ucy5sYWJlbDtcbiAgICAgIH0gZWxzZSBpZiAoIWlzVmFsaWRMYWJlbChwYXJlbnRPcHRpb25zLmxhYmVsKSkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmxhYmVsID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgbWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIFwic21vb3RoXCIsIGdsb2JhbE9wdGlvbnMpO1xuICAgICAgbWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIFwic2hhZG93XCIsIGdsb2JhbE9wdGlvbnMpO1xuICAgICAgbWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMsIG5ld09wdGlvbnMsIFwiYmFja2dyb3VuZFwiLCBnbG9iYWxPcHRpb25zKTtcbiAgICAgIGlmIChuZXdPcHRpb25zLmRhc2hlcyAhPT0gdW5kZWZpbmVkICYmIG5ld09wdGlvbnMuZGFzaGVzICE9PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuZGFzaGVzID0gbmV3T3B0aW9ucy5kYXNoZXM7XG4gICAgICB9IGVsc2UgaWYgKGFsbG93RGVsZXRpb24gPT09IHRydWUgJiYgbmV3T3B0aW9ucy5kYXNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5kYXNoZXMgPSBfT2JqZWN0JGNyZWF0ZSQxKGdsb2JhbE9wdGlvbnMuZGFzaGVzKTsgLy8gdGhpcyBzZXRzIHRoZSBwb2ludGVyIG9mIHRoZSBvcHRpb24gYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbi5cbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHRoZSBzY2FsaW5nIG5ld09wdGlvbnNcbiAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXdPcHRpb25zLnNjYWxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5ld09wdGlvbnMuc2NhbGluZy5taW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuc2NhbGluZy5taW4gPSBuZXdPcHRpb25zLnNjYWxpbmcubWluO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdPcHRpb25zLnNjYWxpbmcubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLnNjYWxpbmcubWF4ID0gbmV3T3B0aW9ucy5zY2FsaW5nLm1heDtcbiAgICAgICAgfVxuICAgICAgICBtZXJnZU9wdGlvbnMocGFyZW50T3B0aW9ucy5zY2FsaW5nLCBuZXdPcHRpb25zLnNjYWxpbmcsIFwibGFiZWxcIiwgZ2xvYmFsT3B0aW9ucy5zY2FsaW5nKTtcbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLnNjYWxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5zY2FsaW5nID0gX09iamVjdCRjcmVhdGUkMShnbG9iYWxPcHRpb25zLnNjYWxpbmcpOyAvLyB0aGlzIHNldHMgdGhlIHBvaW50ZXIgb2YgdGhlIG9wdGlvbiBiYWNrIHRvIHRoZSBnbG9iYWwgb3B0aW9uLlxuICAgICAgfVxuXG4gICAgICAvLyBoYW5kbGUgbXVsdGlwbGUgaW5wdXQgY2FzZXMgZm9yIGFycm93c1xuICAgICAgaWYgKG5ld09wdGlvbnMuYXJyb3dzICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5hcnJvd3MgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdPcHRpb25zLmFycm93cyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHZhciBhcnJvd3MgPSBuZXdPcHRpb25zLmFycm93cy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHBhcmVudE9wdGlvbnMuYXJyb3dzLnRvLmVuYWJsZWQgPSBfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoYXJyb3dzKS5jYWxsKGFycm93cywgXCJ0b1wiKSAhPSAtMTtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cy5taWRkbGUuZW5hYmxlZCA9IF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eShhcnJvd3MpLmNhbGwoYXJyb3dzLCBcIm1pZGRsZVwiKSAhPSAtMTtcbiAgICAgICAgICBwYXJlbnRPcHRpb25zLmFycm93cy5mcm9tLmVuYWJsZWQgPSBfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoYXJyb3dzKS5jYWxsKGFycm93cywgXCJmcm9tXCIpICE9IC0xO1xuICAgICAgICB9IGVsc2UgaWYgKF90eXBlb2YobmV3T3B0aW9ucy5hcnJvd3MpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgbWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMuYXJyb3dzLCBuZXdPcHRpb25zLmFycm93cywgXCJ0b1wiLCBnbG9iYWxPcHRpb25zLmFycm93cyk7XG4gICAgICAgICAgbWVyZ2VPcHRpb25zKHBhcmVudE9wdGlvbnMuYXJyb3dzLCBuZXdPcHRpb25zLmFycm93cywgXCJtaWRkbGVcIiwgZ2xvYmFsT3B0aW9ucy5hcnJvd3MpO1xuICAgICAgICAgIG1lcmdlT3B0aW9ucyhwYXJlbnRPcHRpb25zLmFycm93cywgbmV3T3B0aW9ucy5hcnJvd3MsIFwiZnJvbVwiLCBnbG9iYWxPcHRpb25zLmFycm93cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGFycm93IG5ld09wdGlvbnMgY2FuIG9ubHkgYmUgYW4gb2JqZWN0IG9yIGEgc3RyaW5nLiBSZWZlciB0byB0aGUgZG9jdW1lbnRhdGlvbi4gWW91IHVzZWQ6XCIgKyBfSlNPTiRzdHJpbmdpZnkobmV3T3B0aW9ucy5hcnJvd3MpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuYXJyb3dzID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuYXJyb3dzID0gX09iamVjdCRjcmVhdGUkMShnbG9iYWxPcHRpb25zLmFycm93cyk7IC8vIHRoaXMgc2V0cyB0aGUgcG9pbnRlciBvZiB0aGUgb3B0aW9uIGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb24uXG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSBtdWx0aXBsZSBpbnB1dCBjYXNlcyBmb3IgY29sb3JcbiAgICAgIGlmIChuZXdPcHRpb25zLmNvbG9yICE9PSB1bmRlZmluZWQgJiYgbmV3T3B0aW9ucy5jb2xvciAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZnJvbUNvbG9yID0gaXNTdHJpbmcobmV3T3B0aW9ucy5jb2xvcikgPyB7XG4gICAgICAgICAgY29sb3I6IG5ld09wdGlvbnMuY29sb3IsXG4gICAgICAgICAgaGlnaGxpZ2h0OiBuZXdPcHRpb25zLmNvbG9yLFxuICAgICAgICAgIGhvdmVyOiBuZXdPcHRpb25zLmNvbG9yLFxuICAgICAgICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgICAgICAgIG9wYWNpdHk6IDFcbiAgICAgICAgfSA6IG5ld09wdGlvbnMuY29sb3I7XG4gICAgICAgIHZhciB0b0NvbG9yID0gcGFyZW50T3B0aW9ucy5jb2xvcjtcblxuICAgICAgICAvLyBJZiBwYXNzZWQsIGZpbGwgaW4gdmFsdWVzIGZyb20gZGVmYXVsdCBvcHRpb25zIC0gcmVxdWlyZWQgaW4gdGhlIGNhc2Ugb2Ygbm8gcHJvdG90eXBlIGJyaWRnaW5nXG4gICAgICAgIGlmIChjb3B5RnJvbUdsb2JhbHMpIHtcbiAgICAgICAgICBkZWVwRXh0ZW5kKHRvQ29sb3IsIGdsb2JhbE9wdGlvbnMuY29sb3IsIGZhbHNlLCBhbGxvd0RlbGV0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDbGVhciBsb2NhbCBwcm9wZXJ0aWVzIC0gbmVlZCB0byBkbyBpdCBsaWtlIHRoaXMgaW4gb3JkZXIgdG8gcmV0YWluIHByb3RvdHlwZSBicmlkZ2VzXG4gICAgICAgICAgZm9yICh2YXIgaSBpbiB0b0NvbG9yKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRvQ29sb3IsIGkpKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0b0NvbG9yW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTdHJpbmcodG9Db2xvcikpIHtcbiAgICAgICAgICB0b0NvbG9yLmNvbG9yID0gdG9Db2xvcjtcbiAgICAgICAgICB0b0NvbG9yLmhpZ2hsaWdodCA9IHRvQ29sb3I7XG4gICAgICAgICAgdG9Db2xvci5ob3ZlciA9IHRvQ29sb3I7XG4gICAgICAgICAgdG9Db2xvci5pbmhlcml0ID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGZyb21Db2xvci5vcGFjaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvQ29sb3Iub3BhY2l0eSA9IDEuMDsgLy8gc2V0IGRlZmF1bHRcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbG9yc0RlZmluZWQgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoZnJvbUNvbG9yLmNvbG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRvQ29sb3IuY29sb3IgPSBmcm9tQ29sb3IuY29sb3I7XG4gICAgICAgICAgICBjb2xvcnNEZWZpbmVkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZyb21Db2xvci5oaWdobGlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5oaWdobGlnaHQgPSBmcm9tQ29sb3IuaGlnaGxpZ2h0O1xuICAgICAgICAgICAgY29sb3JzRGVmaW5lZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmcm9tQ29sb3IuaG92ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5ob3ZlciA9IGZyb21Db2xvci5ob3ZlcjtcbiAgICAgICAgICAgIGNvbG9yc0RlZmluZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZnJvbUNvbG9yLmluaGVyaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdG9Db2xvci5pbmhlcml0ID0gZnJvbUNvbG9yLmluaGVyaXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmcm9tQ29sb3Iub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0b0NvbG9yLm9wYWNpdHkgPSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBmcm9tQ29sb3Iub3BhY2l0eSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29sb3JzRGVmaW5lZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdG9Db2xvci5pbmhlcml0ID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0b0NvbG9yLmluaGVyaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0b0NvbG9yLmluaGVyaXQgPSBcImZyb21cIjsgLy8gU2V0IGRlZmF1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWxsb3dEZWxldGlvbiA9PT0gdHJ1ZSAmJiBuZXdPcHRpb25zLmNvbG9yID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudE9wdGlvbnMuY29sb3IgPSBicmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucy5jb2xvcik7IC8vIHNldCB0aGUgb2JqZWN0IGJhY2sgdG8gdGhlIGdsb2JhbCBvcHRpb25zXG4gICAgICB9XG5cbiAgICAgIGlmIChhbGxvd0RlbGV0aW9uID09PSB0cnVlICYmIG5ld09wdGlvbnMuZm9udCA9PT0gbnVsbCkge1xuICAgICAgICBwYXJlbnRPcHRpb25zLmZvbnQgPSBicmlkZ2VPYmplY3QoZ2xvYmFsT3B0aW9ucy5mb250KTsgLy8gc2V0IHRoZSBvYmplY3QgYmFjayB0byB0aGUgZ2xvYmFsIG9wdGlvbnNcbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXdPcHRpb25zLCBcInNlbGZSZWZlcmVuY2VTaXplXCIpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlRoZSBzZWxmUmVmZXJlbmNlU2l6ZSBwcm9wZXJ0eSBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHNlbGZSZWZlcmVuY2UgcHJvcGVydHkgaW5zdGVhZC4gVGhlIHNlbGZSZWZlcmVuY2UgY2FuIGJlIHNldCBsaWtlIHRoaXNlIHNlbGZSZWZlcmVuY2U6e3NpemU6MzAsIGFuZ2xlOk1hdGguUEkgLyA0fVwiKTtcbiAgICAgICAgcGFyZW50T3B0aW9ucy5zZWxmUmVmZXJlbmNlLnNpemUgPSBuZXdPcHRpb25zLnNlbGZSZWZlcmVuY2VTaXplO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRWRnZTtcbn0oKTtcblxuLyoqXG4gKiBIYW5kbGVyIGZvciBFZGdlc1xuICovXG52YXIgRWRnZXNIYW5kbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7QXJyYXkuPEltYWdlPn0gaW1hZ2VzXG4gICAqIEBwYXJhbSB7QXJyYXkuPEdyb3VwPn0gZ3JvdXBzXG4gICAqL1xuICBmdW5jdGlvbiBFZGdlc0hhbmRsZXIoYm9keSwgaW1hZ2VzLCBncm91cHMpIHtcbiAgICB2YXIgX2NvbnRleHQsXG4gICAgICBfdGhpcyA9IHRoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2VzSGFuZGxlcik7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmltYWdlcyA9IGltYWdlcztcbiAgICB0aGlzLmdyb3VwcyA9IGdyb3VwcztcblxuICAgIC8vIGNyZWF0ZSB0aGUgZWRnZSBBUEkgaW4gdGhlIGJvZHkgY29udGFpbmVyXG4gICAgdGhpcy5ib2R5LmZ1bmN0aW9ucy5jcmVhdGVFZGdlID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQgPSB0aGlzLmNyZWF0ZSkuY2FsbChfY29udGV4dCwgdGhpcyk7XG4gICAgdGhpcy5lZGdlc0xpc3RlbmVycyA9IHtcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKGV2ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgX3RoaXMuYWRkKHBhcmFtcy5pdGVtcyk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBfdGhpcy51cGRhdGUocGFyYW1zLml0ZW1zKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShldmVudCwgcGFyYW1zKSB7XG4gICAgICAgIF90aGlzLnJlbW92ZShwYXJhbXMuaXRlbXMpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgIGFycm93czoge1xuICAgICAgICB0bzoge1xuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgIHNjYWxlRmFjdG9yOiAxLFxuICAgICAgICAgIHR5cGU6IFwiYXJyb3dcIlxuICAgICAgICB9LFxuICAgICAgICAvLyBib29sZWFuIC8ge2Fycm93U2NhbGVGYWN0b3I6MX0gLyB7ZW5hYmxlZDogZmFsc2UsIGFycm93U2NhbGVGYWN0b3I6MX1cbiAgICAgICAgbWlkZGxlOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgc2NhbGVGYWN0b3I6IDEsXG4gICAgICAgICAgdHlwZTogXCJhcnJvd1wiXG4gICAgICAgIH0sXG4gICAgICAgIGZyb206IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICBzY2FsZUZhY3RvcjogMSxcbiAgICAgICAgICB0eXBlOiBcImFycm93XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVuZFBvaW50T2Zmc2V0OiB7XG4gICAgICAgIGZyb206IDAsXG4gICAgICAgIHRvOiAwXG4gICAgICB9LFxuICAgICAgYXJyb3dTdHJpa2V0aHJvdWdoOiB0cnVlLFxuICAgICAgY29sb3I6IHtcbiAgICAgICAgY29sb3I6IFwiIzg0ODQ4NFwiLFxuICAgICAgICBoaWdobGlnaHQ6IFwiIzg0ODQ4NFwiLFxuICAgICAgICBob3ZlcjogXCIjODQ4NDg0XCIsXG4gICAgICAgIGluaGVyaXQ6IFwiZnJvbVwiLFxuICAgICAgICBvcGFjaXR5OiAxLjBcbiAgICAgIH0sXG4gICAgICBkYXNoZXM6IGZhbHNlLFxuICAgICAgZm9udDoge1xuICAgICAgICBjb2xvcjogXCIjMzQzNDM0XCIsXG4gICAgICAgIHNpemU6IDE0LFxuICAgICAgICAvLyBweFxuICAgICAgICBmYWNlOiBcImFyaWFsXCIsXG4gICAgICAgIGJhY2tncm91bmQ6IFwibm9uZVwiLFxuICAgICAgICBzdHJva2VXaWR0aDogMixcbiAgICAgICAgLy8gcHhcbiAgICAgICAgc3Ryb2tlQ29sb3I6IFwiI2ZmZmZmZlwiLFxuICAgICAgICBhbGlnbjogXCJob3Jpem9udGFsXCIsXG4gICAgICAgIG11bHRpOiBmYWxzZSxcbiAgICAgICAgdmFkanVzdDogMCxcbiAgICAgICAgYm9sZDoge1xuICAgICAgICAgIG1vZDogXCJib2xkXCJcbiAgICAgICAgfSxcbiAgICAgICAgYm9sZGl0YWw6IHtcbiAgICAgICAgICBtb2Q6IFwiYm9sZCBpdGFsaWNcIlxuICAgICAgICB9LFxuICAgICAgICBpdGFsOiB7XG4gICAgICAgICAgbW9kOiBcIml0YWxpY1wiXG4gICAgICAgIH0sXG4gICAgICAgIG1vbm86IHtcbiAgICAgICAgICBtb2Q6IFwiXCIsXG4gICAgICAgICAgc2l6ZTogMTUsXG4gICAgICAgICAgLy8gcHhcbiAgICAgICAgICBmYWNlOiBcImNvdXJpZXIgbmV3XCIsXG4gICAgICAgICAgdmFkanVzdDogMlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgIGhvdmVyV2lkdGg6IDEuNSxcbiAgICAgIGxhYmVsOiB1bmRlZmluZWQsXG4gICAgICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHRydWUsXG4gICAgICBsZW5ndGg6IHVuZGVmaW5lZCxcbiAgICAgIHBoeXNpY3M6IHRydWUsXG4gICAgICBzY2FsaW5nOiB7XG4gICAgICAgIG1pbjogMSxcbiAgICAgICAgbWF4OiAxNSxcbiAgICAgICAgbGFiZWw6IHtcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgIG1pbjogMTQsXG4gICAgICAgICAgbWF4OiAzMCxcbiAgICAgICAgICBtYXhWaXNpYmxlOiAzMCxcbiAgICAgICAgICBkcmF3VGhyZXNob2xkOiA1XG4gICAgICAgIH0sXG4gICAgICAgIGN1c3RvbVNjYWxpbmdGdW5jdGlvbjogZnVuY3Rpb24gY3VzdG9tU2NhbGluZ0Z1bmN0aW9uKG1pbiwgbWF4LCB0b3RhbCwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgICAgIHJldHVybiAwLjU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IDEgLyAobWF4IC0gbWluKTtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCAodmFsdWUgLSBtaW4pICogc2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNlbGVjdGlvbldpZHRoOiAxLjUsXG4gICAgICBzZWxmUmVmZXJlbmNlOiB7XG4gICAgICAgIHNpemU6IDIwLFxuICAgICAgICBhbmdsZTogTWF0aC5QSSAvIDQsXG4gICAgICAgIHJlbmRlckJlaGluZFRoZU5vZGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiBcInJnYmEoMCwwLDAsMC41KVwiLFxuICAgICAgICBzaXplOiAxMCxcbiAgICAgICAgeDogNSxcbiAgICAgICAgeTogNVxuICAgICAgfSxcbiAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiBcInJnYmEoMTExLDExMSwxMTEsMSlcIixcbiAgICAgICAgc2l6ZTogMTAsXG4gICAgICAgIGRhc2hlczogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzbW9vdGg6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJkeW5hbWljXCIsXG4gICAgICAgIGZvcmNlRGlyZWN0aW9uOiBcIm5vbmVcIixcbiAgICAgICAgcm91bmRuZXNzOiAwLjVcbiAgICAgIH0sXG4gICAgICB0aXRsZTogdW5kZWZpbmVkLFxuICAgICAgd2lkdGg6IDEsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBkZWVwRXh0ZW5kKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhFZGdlc0hhbmRsZXIsIFt7XG4gICAga2V5OiBcImJpbmRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcyxcbiAgICAgICAgX2NvbnRleHQyLFxuICAgICAgICBfY29udGV4dDM7XG4gICAgICAvLyB0aGlzIGFsbG93cyBleHRlcm5hbCBtb2R1bGVzIHRvIGZvcmNlIGFsbCBkeW5hbWljIGN1cnZlcyB0byB0dXJuIHN0YXRpYy5cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2ZvcmNlRGlzYWJsZUR5bmFtaWNDdXJ2ZXNcIiwgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGVtaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICAgIGlmICh0eXBlID09PSBcImR5bmFtaWNcIikge1xuICAgICAgICAgIHR5cGUgPSBcImNvbnRpbnVvdXNcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIF90aGlzMi5ib2R5LmVkZ2VzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfdGhpczIuYm9keS5lZGdlcywgZWRnZUlkKSkge1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSBfdGhpczIuYm9keS5lZGdlc1tlZGdlSWRdO1xuICAgICAgICAgICAgdmFyIGVkZ2VEYXRhID0gX3RoaXMyLmJvZHkuZGF0YS5lZGdlcy5nZXQoZWRnZUlkKTtcblxuICAgICAgICAgICAgLy8gb25seSBmb3JjaWJseSByZW1vdmUgdGhlIHNtb290aCBjdXJ2ZSBpZiB0aGUgZGF0YSBoYXMgYmVlbiBzZXQgb2YgdGhlIGVkZ2UgaGFzIHRoZSBzbW9vdGggY3VydmVzIGRlZmluZWQuXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGJlY2F1c2UgYSBjaGFuZ2UgaW4gdGhlIGdsb2JhbCB3b3VsZCBub3QgYWZmZWN0IHRoZXNlIGN1cnZlcy5cbiAgICAgICAgICAgIGlmIChlZGdlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBzbW9vdGhPcHRpb25zID0gZWRnZURhdGEuc21vb3RoO1xuICAgICAgICAgICAgICBpZiAoc21vb3RoT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNtb290aE9wdGlvbnMuZW5hYmxlZCA9PT0gdHJ1ZSAmJiBzbW9vdGhPcHRpb25zLnR5cGUgPT09IFwiZHluYW1pY1wiKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgc21vb3RoOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2Uuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVtaXQgPT09IHRydWUgJiYgZGF0YUNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBfdGhpczIuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyB0aGlzIGlzIGNhbGxlZCB3aGVuIG9wdGlvbnMgb2YgRVhJU1RJTkcgbm9kZXMgb3IgZWRnZXMgaGF2ZSBjaGFuZ2VkLlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IE5vdCB0cnVlLCBjYWxsZWQgd2hlbiBvcHRpb25zIGhhdmUgTk9UIGNoYW5nZWQsIGZvciBib3RoIGV4aXN0aW5nIGFzIHdlbGwgYXMgbmV3IG5vZGVzLlxuICAgICAgLy8gICAgICAgU2VlIHVwZGF0ZSgpIGZvciBsb2dpYy5cbiAgICAgIC8vIFRPRE86IFZlcmlmeSBhbmQgZXhhbWluZSB0aGUgY29uc2VxdWVuY2VzIG9mIHRoaXMuIEl0IG1pZ2h0IHN0aWxsIHRyaWdnZXIgd2hlblxuICAgICAgLy8gICAgICAgbm9uLW9wdGlvbiBmaWVsZHMgaGF2ZSBjaGFuZ2VkLCBidXQgdGhlbiByZWNvbm5lY3RpbmcgZWRnZXMgaXMgc3RpbGwgdXNlbGVzcy5cbiAgICAgIC8vICAgICAgIEFsdGVybmF0aXZlbHksIGl0IG1pZ2h0IGFsc28gYmUgY2FsbGVkIHdoZW4gZWRnZXMgYXJlIHJlbW92ZWQuXG4gICAgICAvL1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YVVwZGF0ZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIucmVjb25uZWN0RWRnZXMoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyByZWZyZXNoIHRoZSBlZGdlcy4gVXNlZCB3aGVuIHJldmVydGluZyBmcm9tIGhpZXJhcmNoaWNhbCBsYXlvdXRcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVmcmVzaEVkZ2VzXCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MiA9IHRoaXMucmVmcmVzaCkuY2FsbChfY29udGV4dDIsIHRoaXMpKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVmcmVzaFwiLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDMgPSB0aGlzLnJlZnJlc2gpLmNhbGwoX2NvbnRleHQzLCB0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3JFYWNoJDEoX3RoaXMyLmVkZ2VzTGlzdGVuZXJzLCBmdW5jdGlvbiAoY2FsbGJhY2ssIGV2ZW50KSB7XG4gICAgICAgICAgaWYgKF90aGlzMi5ib2R5LmRhdGEuZWRnZXMpIF90aGlzMi5ib2R5LmRhdGEuZWRnZXMub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgX3RoaXMyLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZUVkZ2U7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuZWRnZXNMaXN0ZW5lcnMuYWRkO1xuICAgICAgICBkZWxldGUgX3RoaXMyLmVkZ2VzTGlzdGVuZXJzLnVwZGF0ZTtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5lZGdlc0xpc3RlbmVycy5yZW1vdmU7XG4gICAgICAgIGRlbGV0ZSBfdGhpczIuZWRnZXNMaXN0ZW5lcnM7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gdXNlIHRoZSBwYXJzZXIgZnJvbSB0aGUgRWRnZSBjbGFzcyB0byBmaWxsIGluIGFsbCBzaG9ydGhhbmQgbm90YXRpb25zXG4gICAgICAgIEVkZ2UucGFyc2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgdHJ1ZSwgdGhpcy5kZWZhdWx0T3B0aW9ucywgdHJ1ZSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHNtb290aCBzZXR0aW5ncyBpbiBhbGwgZWRnZXNcbiAgICAgICAgdmFyIGRhdGFDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRpb25zLnNtb290aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuYm9keS5lZGdlcykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkuZWRnZXMsIGVkZ2VJZCkpIHtcbiAgICAgICAgICAgICAgZGF0YUNoYW5nZWQgPSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXS51cGRhdGVFZGdlVHlwZSgpIHx8IGRhdGFDaGFuZ2VkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSBmb250cyBpbiBhbGwgZWRnZXNcbiAgICAgICAgaWYgKG9wdGlvbnMuZm9udCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2VkZ2VJZCBpbiB0aGlzLmJvZHkuZWRnZXMpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5LmVkZ2VzLCBfZWRnZUlkKSkge1xuICAgICAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbX2VkZ2VJZF0udXBkYXRlTGFiZWxNb2R1bGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSB2YXJpYWJsZXMgaWYgbmVlZGVkXG4gICAgICAgIGlmIChvcHRpb25zLmhpZGRlbiAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMucGh5c2ljcyAhPT0gdW5kZWZpbmVkIHx8IGRhdGFDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgZWRnZXMgYnkgcmVhZGluZyB0aGUgZGF0YSB0YWJsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheSB8IERhdGFTZXQgfCBEYXRhVmlld30gZWRnZXMgICAgVGhlIGRhdGEgY29udGFpbmluZyB0aGUgZWRnZXMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZG9Ob3RFbWl0PWZhbHNlXSAtIFN1cHByZXNzIGRhdGEgY2hhbmdlZCBldmVudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGF0YShlZGdlcykge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgZG9Ob3RFbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBvbGRFZGdlc0RhdGEgPSB0aGlzLmJvZHkuZGF0YS5lZGdlcztcbiAgICAgIGlmIChpc0RhdGFWaWV3TGlrZShcImlkXCIsIGVkZ2VzKSkge1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcyA9IGVkZ2VzO1xuICAgICAgfSBlbHNlIGlmIChfQXJyYXkkaXNBcnJheShlZGdlcykpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgICB0aGlzLmJvZHkuZGF0YS5lZGdlcy5hZGQoZWRnZXMpO1xuICAgICAgfSBlbHNlIGlmICghZWRnZXMpIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMgPSBuZXcgRGF0YVNldCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFycmF5IG9yIERhdGFTZXQgZXhwZWN0ZWRcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IGlzIHRoaXMgbnVsbCBvciB1bmRlZmluZWQgb3IgZmFsc2U/XG4gICAgICBpZiAob2xkRWRnZXNEYXRhKSB7XG4gICAgICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gb2xkIGRhdGFzZXRcbiAgICAgICAgZm9yRWFjaCQxKHRoaXMuZWRnZXNMaXN0ZW5lcnMsIGZ1bmN0aW9uIChjYWxsYmFjaywgZXZlbnQpIHtcbiAgICAgICAgICBvbGRFZGdlc0RhdGEub2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgZHJhd24gZWRnZXNcbiAgICAgIHRoaXMuYm9keS5lZGdlcyA9IHt9O1xuXG4gICAgICAvLyBUT0RPOiBpcyB0aGlzIG51bGwgb3IgdW5kZWZpbmVkIG9yIGZhbHNlP1xuICAgICAgaWYgKHRoaXMuYm9keS5kYXRhLmVkZ2VzKSB7XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBuZXcgZGF0YXNldFxuICAgICAgICBmb3JFYWNoJDEodGhpcy5lZGdlc0xpc3RlbmVycywgZnVuY3Rpb24gKGNhbGxiYWNrLCBldmVudCkge1xuICAgICAgICAgIF90aGlzMy5ib2R5LmRhdGEuZWRnZXMub24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZHJhdyBhbGwgbmV3IG5vZGVzXG4gICAgICAgIHZhciBpZHMgPSB0aGlzLmJvZHkuZGF0YS5lZGdlcy5nZXRJZHMoKTtcbiAgICAgICAgdGhpcy5hZGQoaWRzLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfYWRqdXN0RWRnZXNGb3JIaWVyYXJjaGljYWxMYXlvdXRcIik7XG4gICAgICBpZiAoZG9Ob3RFbWl0ID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBlZGdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb05vdEVtaXQ9ZmFsc2VdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKGlkcykge1xuICAgICAgdmFyIGRvTm90RW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgZWRnZXNEYXRhID0gdGhpcy5ib2R5LmRhdGEuZWRnZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWQgPSBpZHNbaV07XG4gICAgICAgIHZhciBvbGRFZGdlID0gZWRnZXNbaWRdO1xuICAgICAgICBpZiAob2xkRWRnZSkge1xuICAgICAgICAgIG9sZEVkZ2UuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gZWRnZXNEYXRhLmdldChpZCwge1xuICAgICAgICAgIHNob3dJbnRlcm5hbElkczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgZWRnZXNbaWRdID0gdGhpcy5jcmVhdGUoZGF0YSk7XG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2FkanVzdEVkZ2VzRm9ySGllcmFyY2hpY2FsTGF5b3V0XCIpO1xuICAgICAgaWYgKGRvTm90RW1pdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZXhpc3RpbmcgZWRnZXMsIG9yIGNyZWF0ZSB0aGVtIHdoZW4gbm90IHlldCBleGlzdGluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXSB8IHN0cmluZ1tdfSBpZHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoaWRzKSB7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgZWRnZXNEYXRhID0gdGhpcy5ib2R5LmRhdGEuZWRnZXM7XG4gICAgICB2YXIgZGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IGlkc1tpXTtcbiAgICAgICAgdmFyIGRhdGEgPSBlZGdlc0RhdGEuZ2V0KGlkKTtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpZF07XG4gICAgICAgIGlmIChlZGdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyB1cGRhdGUgZWRnZVxuICAgICAgICAgIGVkZ2UuZGlzY29ubmVjdCgpO1xuICAgICAgICAgIGRhdGFDaGFuZ2VkID0gZWRnZS5zZXRPcHRpb25zKGRhdGEpIHx8IGRhdGFDaGFuZ2VkOyAvLyBpZiBhIHN1cHBvcnQgbm9kZSBpcyBhZGRlZCwgZGF0YSBjYW4gYmUgY2hhbmdlZC5cbiAgICAgICAgICBlZGdlLmNvbm5lY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjcmVhdGUgZWRnZVxuICAgICAgICAgIHRoaXMuYm9keS5lZGdlc1tpZF0gPSB0aGlzLmNyZWF0ZShkYXRhKTtcbiAgICAgICAgICBkYXRhQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2FkanVzdEVkZ2VzRm9ySGllcmFyY2hpY2FsTGF5b3V0XCIpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhVXBkYXRlZFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXhpc3RpbmcgZWRnZXMuIE5vbiBleGlzdGluZyBpZHMgd2lsbCBiZSBpZ25vcmVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nW119IGlkc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VtaXQ9dHJ1ZV1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoaWRzKSB7XG4gICAgICB2YXIgZW1pdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIGlmIChpZHMubGVuZ3RoID09PSAwKSByZXR1cm47IC8vIGVhcmx5IG91dFxuXG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICBmb3JFYWNoJDEoaWRzLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpZF07XG4gICAgICAgIGlmIChlZGdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlZGdlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIEVkZ2UgSGFuZGxlclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmcmVzaCgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgZm9yRWFjaCQxKHRoaXMuYm9keS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UsIGVkZ2VJZCkge1xuICAgICAgICB2YXIgZGF0YSA9IF90aGlzNC5ib2R5LmRhdGEuZWRnZXMuZ2V0KGVkZ2VJZCk7XG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBlZGdlLnNldE9wdGlvbnMoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJucyB7RWRnZX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiBuZXcgRWRnZShwcm9wZXJ0aWVzLCB0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY29ubmVjdCBhbGwgZWRnZXNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVjb25uZWN0RWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVjb25uZWN0RWRnZXMoKSB7XG4gICAgICB2YXIgaWQ7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICBmb3IgKGlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZXMsIGlkKSkge1xuICAgICAgICAgIG5vZGVzW2lkXS5lZGdlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGlkIGluIGVkZ2VzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZWRnZXMsIGlkKSkge1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbaWRdO1xuICAgICAgICAgIGVkZ2UuZnJvbSA9IG51bGw7XG4gICAgICAgICAgZWRnZS50byA9IG51bGw7XG4gICAgICAgICAgZWRnZS5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWRnZS5pZH0gZWRnZUlkXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldENvbm5lY3RlZE5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbm5lY3RlZE5vZGVzKGVkZ2VJZCkge1xuICAgICAgdmFyIG5vZGVMaXN0ID0gW107XG4gICAgICBpZiAodGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZWRnZSA9IHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdO1xuICAgICAgICBpZiAoZWRnZS5mcm9tSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vZGVMaXN0LnB1c2goZWRnZS5mcm9tSWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlZGdlLnRvSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG5vZGVMaXN0LnB1c2goZWRnZS50b0lkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGVMaXN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZXJlIGlzIG5vIGRpcmVjdCByZWxhdGlvbiBiZXR3ZWVuIHRoZSBub2RlcyBhbmQgdGhlIGVkZ2VzIERhdGFTZXQsXG4gICAgICogc28gdGhlIHJpZ2h0IHBsYWNlIHRvIGRvIGNhbGwgdGhpcyBpcyBpbiB0aGUgaGFuZGxlciBmb3IgZXZlbnQgYF9kYXRhVXBkYXRlZGAuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVTdGF0ZSgpIHtcbiAgICAgIHRoaXMuX2FkZE1pc3NpbmdFZGdlcygpO1xuICAgICAgdGhpcy5fcmVtb3ZlSW52YWxpZEVkZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2NhbiBmb3IgbWlzc2luZyBub2RlcyBhbmQgcmVtb3ZlIGNvcnJlc3BvbmRpbmcgZWRnZXMsIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZUludmFsaWRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlSW52YWxpZEVkZ2VzKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICB2YXIgZWRnZXNUb0RlbGV0ZSA9IFtdO1xuICAgICAgZm9yRWFjaCQxKHRoaXMuYm9keS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UsIGlkKSB7XG4gICAgICAgIHZhciB0b05vZGUgPSBfdGhpczUuYm9keS5ub2Rlc1tlZGdlLnRvSWRdO1xuICAgICAgICB2YXIgZnJvbU5vZGUgPSBfdGhpczUuYm9keS5ub2Rlc1tlZGdlLmZyb21JZF07XG5cbiAgICAgICAgLy8gU2tpcCBjbHVzdGVyaW5nIGVkZ2VzIGhlcmUsIGxldCB0aGUgQ2x1c3RlcmluZyBtb2R1bGUgaGFuZGxlIHRob3NlXG4gICAgICAgIGlmICh0b05vZGUgIT09IHVuZGVmaW5lZCAmJiB0b05vZGUuaXNDbHVzdGVyID09PSB0cnVlIHx8IGZyb21Ob2RlICE9PSB1bmRlZmluZWQgJiYgZnJvbU5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b05vZGUgPT09IHVuZGVmaW5lZCB8fCBmcm9tTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZWRnZXNUb0RlbGV0ZS5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnJlbW92ZShlZGdlc1RvRGVsZXRlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkIGFsbCBlZGdlcyBmcm9tIGRhdGFzZXQgdGhhdCBhcmUgbm90IGluIHRoZSBjYWNoZWQgc3RhdGVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZE1pc3NpbmdFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkTWlzc2luZ0VkZ2VzKCkge1xuICAgICAgdmFyIGVkZ2VzRGF0YSA9IHRoaXMuYm9keS5kYXRhLmVkZ2VzO1xuICAgICAgaWYgKGVkZ2VzRGF0YSA9PT0gdW5kZWZpbmVkIHx8IGVkZ2VzRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47IC8vIE5vIGVkZ2VzIERhdGFTZXQgeWV0OyBjYW4gaGFwcGVuIG9uIHN0YXJ0dXBcbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIGFkZElkcyA9IFtdO1xuICAgICAgX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KGVkZ2VzRGF0YSkuY2FsbChlZGdlc0RhdGEsIGZ1bmN0aW9uIChlZGdlRGF0YSwgZWRnZUlkKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgaWYgKGVkZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFkZElkcy5wdXNoKGVkZ2VJZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5hZGQoYWRkSWRzLCB0cnVlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEVkZ2VzSGFuZGxlcjtcbn0oKTtcblxuLyoqXG4gKiBCYXJuZXMgSHV0IFNvbHZlclxuICovXG52YXIgQmFybmVzSHV0U29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEJhcm5lc0h1dFNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXJuZXNIdXRTb2x2ZXIpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuYmFybmVzSHV0VHJlZTtcbiAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5fcm5nID0gQWxlYShcIkJBUk5FUyBIVVQgU09MVkVSXCIpO1xuXG4gICAgLy8gZGVidWc6IHNob3cgZ3JpZFxuICAgIC8vIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiYWZ0ZXJEcmF3aW5nXCIsIChjdHgpID0+IHt0aGlzLl9kZWJ1ZyhjdHgsJyNmZjAwMDAnKX0pXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhCYXJuZXNIdXRTb2x2ZXIsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgdGhpcy50aGV0YUludmVyc2VkID0gMSAvIHRoaXMub3B0aW9ucy50aGV0YTtcblxuICAgICAgLy8gaWYgMSB0aGVuIG1pbiBkaXN0YW5jZSA9IDAuNSwgaWYgMC41IHRoZW4gbWluIGRpc3RhbmNlID0gMC41ICsgMC41Km5vZGUuc2hhcGUucmFkaXVzXG4gICAgICB0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgPSAxIC0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdGhpcy5vcHRpb25zLmF2b2lkT3ZlcmxhcCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgZm9yY2VzIHRoZSBub2RlcyBhcHBseSBvbiBlYWNoIG90aGVyIGJhc2VkIG9uIGEgZ3Jhdml0YXRpb25hbCBtb2RlbC5cbiAgICAgKiBUaGUgQmFybmVzIEh1dCBtZXRob2QgaXMgdXNlZCB0byBzcGVlZCB1cCB0aGlzIE4tYm9keSBzaW11bGF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ3Jhdml0YXRpb25hbENvbnN0YW50ICE9PSAwICYmIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICAgIHZhciBub2RlQ291bnQgPSBub2RlSW5kaWNlcy5sZW5ndGg7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSB0cmVlXG4gICAgICAgIHZhciBiYXJuZXNIdXRUcmVlID0gdGhpcy5fZm9ybUJhcm5lc0h1dFRyZWUobm9kZXMsIG5vZGVJbmRpY2VzKTtcblxuICAgICAgICAvLyBmb3IgZGVidWdnaW5nXG4gICAgICAgIHRoaXMuYmFybmVzSHV0VHJlZSA9IGJhcm5lc0h1dFRyZWU7XG5cbiAgICAgICAgLy8gcGxhY2UgdGhlIG5vZGVzIG9uZSBieSBvbmUgcmVjdXJzaXZlbHlcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlQ291bnQ7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG4gICAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5tYXNzID4gMCkge1xuICAgICAgICAgICAgLy8gc3RhcnRpbmcgd2l0aCByb290IGlzIGlycmVsZXZhbnQsIGl0IG5ldmVyIHBhc3NlcyB0aGUgQmFybmVzSHV0U29sdmVyIGNvbmRpdGlvblxuICAgICAgICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb25zKGJhcm5lc0h1dFRyZWUucm9vdCwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEZvcmNlQ29udHJpYnV0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Rm9yY2VDb250cmlidXRpb25zKHBhcmVudEJyYW5jaCwgbm9kZSkge1xuICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLk5XLCBub2RlKTtcbiAgICAgIHRoaXMuX2dldEZvcmNlQ29udHJpYnV0aW9uKHBhcmVudEJyYW5jaC5jaGlsZHJlbi5ORSwgbm9kZSk7XG4gICAgICB0aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbihwYXJlbnRCcmFuY2guY2hpbGRyZW4uU1csIG5vZGUpO1xuICAgICAgdGhpcy5fZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLmNoaWxkcmVuLlNFLCBub2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHRyYXZlcnNlcyB0aGUgYmFybmVzSHV0VHJlZS4gSXQgY2hlY2tzIHdoZW4gaXQgY2FuIGFwcHJveGltYXRlIGRpc3RhbnQgbm9kZXMgd2l0aCB0aGVpciBjZW50ZXIgb2YgbWFzcy5cbiAgICAgKiBJZiBhIHJlZ2lvbiBjb250YWlucyBhIHNpbmdsZSBub2RlLCB3ZSBjaGVjayBpZiBpdCBpcyBub3QgaXRzZWxmLCB0aGVuIHdlIGFwcGx5IHRoZSBmb3JjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRGb3JjZUNvbnRyaWJ1dGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Rm9yY2VDb250cmlidXRpb24ocGFyZW50QnJhbmNoLCBub2RlKSB7XG4gICAgICAvLyB3ZSBnZXQgbm8gZm9yY2UgY29udHJpYnV0aW9uIGZyb20gYW4gZW1wdHkgcmVnaW9uXG4gICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPiAwKSB7XG4gICAgICAgIC8vIGdldCB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgY2VudGVyIG9mIG1hc3MgdG8gdGhlIG5vZGUuXG4gICAgICAgIHZhciBkeCA9IHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3MueCAtIG5vZGUueDtcbiAgICAgICAgdmFyIGR5ID0gcGFyZW50QnJhbmNoLmNlbnRlck9mTWFzcy55IC0gbm9kZS55O1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIC8vIEJhcm5lc0h1dFNvbHZlciBjb25kaXRpb25cbiAgICAgICAgLy8gb3JpZ2luYWwgY29uZGl0aW9uIDogcy9kIDwgdGhldGEgPSBwYXNzZWQgID09PSAgZC9zID4gMS90aGV0YSA9IHBhc3NlZFxuICAgICAgICAvLyBjYWxjU2l6ZSA9IDEvcyAtLT4gZCAqIDEvcyA+IDEvdGhldGEgPSBwYXNzZWRcbiAgICAgICAgaWYgKGRpc3RhbmNlICogcGFyZW50QnJhbmNoLmNhbGNTaXplID4gdGhpcy50aGV0YUludmVyc2VkKSB7XG4gICAgICAgICAgdGhpcy5fY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIG5vZGUsIHBhcmVudEJyYW5jaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGlkIG5vdCBwYXNzIHRoZSBjb25kaXRpb24sIGdvIGludG8gY2hpbGRyZW4gaWYgYXZhaWxhYmxlXG4gICAgICAgICAgaWYgKHBhcmVudEJyYW5jaC5jaGlsZHJlbkNvdW50ID09PSA0KSB7XG4gICAgICAgICAgICB0aGlzLl9nZXRGb3JjZUNvbnRyaWJ1dGlvbnMocGFyZW50QnJhbmNoLCBub2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFyZW50QnJhbmNoIG11c3QgaGF2ZSBvbmx5IG9uZSBub2RlLCBpZiBpdCB3YXMgZW1wdHkgd2Ugd291bGRudCBiZSBoZXJlXG4gICAgICAgICAgICBpZiAocGFyZW50QnJhbmNoLmNoaWxkcmVuLmRhdGEuaWQgIT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBub3Qgc2VsZlxuICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgbm9kZSwgcGFyZW50QnJhbmNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHlcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY2FsY3VsYXRlRm9yY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgbm9kZSwgcGFyZW50QnJhbmNoKSB7XG4gICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgZGlzdGFuY2UgPSAwLjE7XG4gICAgICAgIGR4ID0gZGlzdGFuY2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yIDwgMSAmJiBub2RlLnNoYXBlLnJhZGl1cykge1xuICAgICAgICBkaXN0YW5jZSA9IE1hdGgubWF4KDAuMSArIHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciAqIG5vZGUuc2hhcGUucmFkaXVzLCBkaXN0YW5jZSAtIG5vZGUuc2hhcGUucmFkaXVzKTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhlIGRpdmlkaW5nIGJ5IHRoZSBkaXN0YW5jZSBjdWJlZCBpbnN0ZWFkIG9mIHNxdWFyZWQgYWxsb3dzIHVzIHRvIGdldCB0aGUgZnggYW5kIGZ5IGNvbXBvbmVudHMgd2l0aG91dCBzaW5lcyBhbmQgY29zaW5lc1xuICAgICAgLy8gaXQgaXMgc2hvcnRoYW5kIGZvciBncmF2aXR5Zm9yY2Ugd2l0aCBkaXN0YW5jZSBzcXVhcmVkIGFuZCBmeCA9IGR4L2Rpc3RhbmNlICogZ3Jhdml0eUZvcmNlXG4gICAgICB2YXIgZ3Jhdml0eUZvcmNlID0gdGhpcy5vcHRpb25zLmdyYXZpdGF0aW9uYWxDb25zdGFudCAqIHBhcmVudEJyYW5jaC5tYXNzICogbm9kZS5vcHRpb25zLm1hc3MgLyBNYXRoLnBvdyhkaXN0YW5jZSwgMyk7XG4gICAgICB2YXIgZnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIHZhciBmeSA9IGR5ICogZ3Jhdml0eUZvcmNlO1xuICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZS5pZF0ueCArPSBmeDtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUuaWRdLnkgKz0gZnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjb25zdHJ1Y3RzIHRoZSBiYXJuZXNIdXQgdHJlZSByZWN1cnNpdmVseS4gSXQgY3JlYXRlcyB0aGUgcm9vdCwgc3BsaXRzIGl0IGFuZCBzdGFydHMgcGxhY2luZyB0aGUgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBub2RlSW5kaWNlc1xuICAgICAqIEByZXR1cm5zIHt7cm9vdDoge2NlbnRlck9mTWFzczoge3g6IG51bWJlciwgeTogbnVtYmVyfSwgbWFzczogbnVtYmVyLCByYW5nZToge21pblg6IG51bWJlciwgbWF4WDogbnVtYmVyLCBtaW5ZOiBudW1iZXIsIG1heFk6IG51bWJlcn0sIHNpemU6IG51bWJlciwgY2FsY1NpemU6IG51bWJlciwgY2hpbGRyZW46IHtkYXRhOiBudWxsfSwgbWF4V2lkdGg6IG51bWJlciwgbGV2ZWw6IG51bWJlciwgY2hpbGRyZW5Db3VudDogbnVtYmVyfX19IEJhcm5lc0h1dFRyZWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9mb3JtQmFybmVzSHV0VHJlZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZm9ybUJhcm5lc0h1dFRyZWUobm9kZXMsIG5vZGVJbmRpY2VzKSB7XG4gICAgICB2YXIgbm9kZTtcbiAgICAgIHZhciBub2RlQ291bnQgPSBub2RlSW5kaWNlcy5sZW5ndGg7XG4gICAgICB2YXIgbWluWCA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS54O1xuICAgICAgdmFyIG1pblkgPSBub2Rlc1tub2RlSW5kaWNlc1swXV0ueTtcbiAgICAgIHZhciBtYXhYID0gbm9kZXNbbm9kZUluZGljZXNbMF1dLng7XG4gICAgICB2YXIgbWF4WSA9IG5vZGVzW25vZGVJbmRpY2VzWzBdXS55O1xuXG4gICAgICAvLyBnZXQgdGhlIHJhbmdlIG9mIHRoZSBub2Rlc1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBub2RlQ291bnQ7IGkrKykge1xuICAgICAgICB2YXIgX25vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG4gICAgICAgIHZhciB4ID0gX25vZGUueDtcbiAgICAgICAgdmFyIHkgPSBfbm9kZS55O1xuICAgICAgICBpZiAoX25vZGUub3B0aW9ucy5tYXNzID4gMCkge1xuICAgICAgICAgIGlmICh4IDwgbWluWCkge1xuICAgICAgICAgICAgbWluWCA9IHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh4ID4gbWF4WCkge1xuICAgICAgICAgICAgbWF4WCA9IHg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICAgICAgbWluWSA9IHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh5ID4gbWF4WSkge1xuICAgICAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBtYWtlIHRoZSByYW5nZSBhIHNxdWFyZVxuICAgICAgdmFyIHNpemVEaWZmID0gTWF0aC5hYnMobWF4WCAtIG1pblgpIC0gTWF0aC5hYnMobWF4WSAtIG1pblkpOyAvLyBkaWZmZXJlbmNlIGJldHdlZW4gWCBhbmQgWVxuICAgICAgaWYgKHNpemVEaWZmID4gMCkge1xuICAgICAgICBtaW5ZIC09IDAuNSAqIHNpemVEaWZmO1xuICAgICAgICBtYXhZICs9IDAuNSAqIHNpemVEaWZmO1xuICAgICAgfSAvLyB4U2l6ZSA+IHlTaXplXG4gICAgICBlbHNlIHtcbiAgICAgICAgbWluWCArPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgICAgbWF4WCAtPSAwLjUgKiBzaXplRGlmZjtcbiAgICAgIH0gLy8geFNpemUgPCB5U2l6ZVxuXG4gICAgICB2YXIgbWluaW11bVRyZWVTaXplID0gMWUtNTtcbiAgICAgIHZhciByb290U2l6ZSA9IE1hdGgubWF4KG1pbmltdW1UcmVlU2l6ZSwgTWF0aC5hYnMobWF4WCAtIG1pblgpKTtcbiAgICAgIHZhciBoYWxmUm9vdFNpemUgPSAwLjUgKiByb290U2l6ZTtcbiAgICAgIHZhciBjZW50ZXJYID0gMC41ICogKG1pblggKyBtYXhYKSxcbiAgICAgICAgY2VudGVyWSA9IDAuNSAqIChtaW5ZICsgbWF4WSk7XG5cbiAgICAgIC8vIGNvbnN0cnVjdCB0aGUgYmFybmVzSHV0VHJlZVxuICAgICAgdmFyIGJhcm5lc0h1dFRyZWUgPSB7XG4gICAgICAgIHJvb3Q6IHtcbiAgICAgICAgICBjZW50ZXJPZk1hc3M6IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXNzOiAwLFxuICAgICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgICBtaW5YOiBjZW50ZXJYIC0gaGFsZlJvb3RTaXplLFxuICAgICAgICAgICAgbWF4WDogY2VudGVyWCArIGhhbGZSb290U2l6ZSxcbiAgICAgICAgICAgIG1pblk6IGNlbnRlclkgLSBoYWxmUm9vdFNpemUsXG4gICAgICAgICAgICBtYXhZOiBjZW50ZXJZICsgaGFsZlJvb3RTaXplXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaXplOiByb290U2l6ZSxcbiAgICAgICAgICBjYWxjU2l6ZTogMSAvIHJvb3RTaXplLFxuICAgICAgICAgIGNoaWxkcmVuOiB7XG4gICAgICAgICAgICBkYXRhOiBudWxsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXhXaWR0aDogMCxcbiAgICAgICAgICBsZXZlbDogMCxcbiAgICAgICAgICBjaGlsZHJlbkNvdW50OiA0XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLl9zcGxpdEJyYW5jaChiYXJuZXNIdXRUcmVlLnJvb3QpO1xuXG4gICAgICAvLyBwbGFjZSB0aGUgbm9kZXMgb25lIGJ5IG9uZSByZWN1cnNpdmVseVxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVDb3VudDsgX2krKykge1xuICAgICAgICBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbX2ldXTtcbiAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5tYXNzID4gMCkge1xuICAgICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKGJhcm5lc0h1dFRyZWUucm9vdCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBnbG9iYWxcbiAgICAgIHJldHVybiBiYXJuZXNIdXRUcmVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRoaXMgdXBkYXRlcyB0aGUgbWFzcyBvZiBhIGJyYW5jaC4gdGhpcyBpcyBpbmNyZWFzZWQgYnkgYWRkaW5nIGEgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVCcmFuY2hNYXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVCcmFuY2hNYXNzKHBhcmVudEJyYW5jaCwgbm9kZSkge1xuICAgICAgdmFyIGNlbnRlck9mTWFzcyA9IHBhcmVudEJyYW5jaC5jZW50ZXJPZk1hc3M7XG4gICAgICB2YXIgdG90YWxNYXNzID0gcGFyZW50QnJhbmNoLm1hc3MgKyBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgIHZhciB0b3RhbE1hc3NJbnYgPSAxIC8gdG90YWxNYXNzO1xuICAgICAgY2VudGVyT2ZNYXNzLnggPSBjZW50ZXJPZk1hc3MueCAqIHBhcmVudEJyYW5jaC5tYXNzICsgbm9kZS54ICogbm9kZS5vcHRpb25zLm1hc3M7XG4gICAgICBjZW50ZXJPZk1hc3MueCAqPSB0b3RhbE1hc3NJbnY7XG4gICAgICBjZW50ZXJPZk1hc3MueSA9IGNlbnRlck9mTWFzcy55ICogcGFyZW50QnJhbmNoLm1hc3MgKyBub2RlLnkgKiBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgIGNlbnRlck9mTWFzcy55ICo9IHRvdGFsTWFzc0ludjtcbiAgICAgIHBhcmVudEJyYW5jaC5tYXNzID0gdG90YWxNYXNzO1xuICAgICAgdmFyIGJpZ2dlc3RTaXplID0gTWF0aC5tYXgoTWF0aC5tYXgobm9kZS5oZWlnaHQsIG5vZGUucmFkaXVzKSwgbm9kZS53aWR0aCk7XG4gICAgICBwYXJlbnRCcmFuY2gubWF4V2lkdGggPSBwYXJlbnRCcmFuY2gubWF4V2lkdGggPCBiaWdnZXN0U2l6ZSA/IGJpZ2dlc3RTaXplIDogcGFyZW50QnJhbmNoLm1heFdpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRldGVybWluZSBpbiB3aGljaCBicmFuY2ggdGhlIG5vZGUgd2lsbCBiZSBwbGFjZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBza2lwTWFzc1VwZGF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BsYWNlSW5UcmVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wbGFjZUluVHJlZShwYXJlbnRCcmFuY2gsIG5vZGUsIHNraXBNYXNzVXBkYXRlKSB7XG4gICAgICBpZiAoc2tpcE1hc3NVcGRhdGUgIT0gdHJ1ZSB8fCBza2lwTWFzc1VwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgbWFzcyBvZiB0aGUgYnJhbmNoLlxuICAgICAgICB0aGlzLl91cGRhdGVCcmFuY2hNYXNzKHBhcmVudEJyYW5jaCwgbm9kZSk7XG4gICAgICB9XG4gICAgICB2YXIgcmFuZ2UgPSBwYXJlbnRCcmFuY2guY2hpbGRyZW4uTlcucmFuZ2U7XG4gICAgICB2YXIgcmVnaW9uO1xuICAgICAgaWYgKHJhbmdlLm1heFggPiBub2RlLngpIHtcbiAgICAgICAgLy8gaW4gTlcgb3IgU1dcbiAgICAgICAgaWYgKHJhbmdlLm1heFkgPiBub2RlLnkpIHtcbiAgICAgICAgICByZWdpb24gPSBcIk5XXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVnaW9uID0gXCJTV1wiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbiBORSBvciBTRVxuICAgICAgICBpZiAocmFuZ2UubWF4WSA+IG5vZGUueSkge1xuICAgICAgICAgIHJlZ2lvbiA9IFwiTkVcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWdpb24gPSBcIlNFXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3BsYWNlSW5SZWdpb24ocGFyZW50QnJhbmNoLCBub2RlLCByZWdpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFjdHVhbGx5IHBsYWNlIHRoZSBub2RlIGluIGEgcmVnaW9uIChvciBicmFuY2gpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyZW50QnJhbmNoXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHsnTlcnfCAnTkUnIHwgJ1NXJyB8ICdTRSd9IHJlZ2lvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BsYWNlSW5SZWdpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BsYWNlSW5SZWdpb24ocGFyZW50QnJhbmNoLCBub2RlLCByZWdpb24pIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudEJyYW5jaC5jaGlsZHJlbltyZWdpb25dO1xuICAgICAgc3dpdGNoIChjaGlsZHJlbi5jaGlsZHJlbkNvdW50KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAvLyBwbGFjZSBub2RlIGhlcmVcbiAgICAgICAgICBjaGlsZHJlbi5jaGlsZHJlbi5kYXRhID0gbm9kZTtcbiAgICAgICAgICBjaGlsZHJlbi5jaGlsZHJlbkNvdW50ID0gMTtcbiAgICAgICAgICB0aGlzLl91cGRhdGVCcmFuY2hNYXNzKGNoaWxkcmVuLCBub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIC8vIGNvbnZlcnQgaW50byBjaGlsZHJlblxuICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSB0d28gbm9kZXMgZXhhY3RseSBvdmVybGFwcGluZyAob24gaW5pdCwgb24gb3BlbmluZyBvZiBjbHVzdGVyIGV0Yy4pXG4gICAgICAgICAgLy8gd2UgbW92ZSBvbmUgbm9kZSBhIGxpdHRsZSBiaXQgYW5kIHdlIGRvIG5vdCBwdXQgaXQgaW4gdGhlIHRyZWUuXG4gICAgICAgICAgaWYgKGNoaWxkcmVuLmNoaWxkcmVuLmRhdGEueCA9PT0gbm9kZS54ICYmIGNoaWxkcmVuLmNoaWxkcmVuLmRhdGEueSA9PT0gbm9kZS55KSB7XG4gICAgICAgICAgICBub2RlLnggKz0gdGhpcy5fcm5nKCk7XG4gICAgICAgICAgICBub2RlLnkgKz0gdGhpcy5fcm5nKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0QnJhbmNoKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIHRoaXMuX3BsYWNlSW5UcmVlKGNoaWxkcmVuLCBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAvLyBwbGFjZSBpbiBicmFuY2hcbiAgICAgICAgICB0aGlzLl9wbGFjZUluVHJlZShjaGlsZHJlbiwgbm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcyBmdW5jdGlvbiBzcGxpdHMgYSBicmFuY2ggaW50byA0IHN1YiBicmFuY2hlcy4gSWYgdGhlIGJyYW5jaCBjb250YWluZWQgYSBub2RlLCB3ZSBwbGFjZSBpdCBpbiB0aGUgc3ViYnJhbmNoXG4gICAgICogYWZ0ZXIgdGhlIHNwbGl0IGlzIGNvbXBsZXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcmVudEJyYW5jaFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3NwbGl0QnJhbmNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zcGxpdEJyYW5jaChwYXJlbnRCcmFuY2gpIHtcbiAgICAgIC8vIGlmIHRoZSBicmFuY2ggaXMgc2hhZGVkIHdpdGggYSBub2RlLCByZXBsYWNlIHRoZSBub2RlIGluIHRoZSBuZXcgc3Vic2V0LlxuICAgICAgdmFyIGNvbnRhaW5lZE5vZGUgPSBudWxsO1xuICAgICAgaWYgKHBhcmVudEJyYW5jaC5jaGlsZHJlbkNvdW50ID09PSAxKSB7XG4gICAgICAgIGNvbnRhaW5lZE5vZGUgPSBwYXJlbnRCcmFuY2guY2hpbGRyZW4uZGF0YTtcbiAgICAgICAgcGFyZW50QnJhbmNoLm1hc3MgPSAwO1xuICAgICAgICBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnggPSAwO1xuICAgICAgICBwYXJlbnRCcmFuY2guY2VudGVyT2ZNYXNzLnkgPSAwO1xuICAgICAgfVxuICAgICAgcGFyZW50QnJhbmNoLmNoaWxkcmVuQ291bnQgPSA0O1xuICAgICAgcGFyZW50QnJhbmNoLmNoaWxkcmVuLmRhdGEgPSBudWxsO1xuICAgICAgdGhpcy5faW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgXCJOV1wiKTtcbiAgICAgIHRoaXMuX2luc2VydFJlZ2lvbihwYXJlbnRCcmFuY2gsIFwiTkVcIik7XG4gICAgICB0aGlzLl9pbnNlcnRSZWdpb24ocGFyZW50QnJhbmNoLCBcIlNXXCIpO1xuICAgICAgdGhpcy5faW5zZXJ0UmVnaW9uKHBhcmVudEJyYW5jaCwgXCJTRVwiKTtcbiAgICAgIGlmIChjb250YWluZWROb2RlICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcGxhY2VJblRyZWUocGFyZW50QnJhbmNoLCBjb250YWluZWROb2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHN1YmRpdmlkZXMgdGhlIHJlZ2lvbiBpbnRvIGZvdXIgbmV3IHNlZ21lbnRzLlxuICAgICAqIFNwZWNpZmljYWxseSwgdGhpcyBpbnNlcnRzIGEgc2luZ2xlIG5ldyBzZWdtZW50LlxuICAgICAqIEl0IGZpbGxzIHRoZSBjaGlsZHJlbiBzZWN0aW9uIG9mIHRoZSBwYXJlbnRCcmFuY2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICAgKiBAcGFyYW0geydOVyd8ICdORScgfCAnU1cnIHwgJ1NFJ30gcmVnaW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfaW5zZXJ0UmVnaW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbnNlcnRSZWdpb24ocGFyZW50QnJhbmNoLCByZWdpb24pIHtcbiAgICAgIHZhciBtaW5YLCBtYXhYLCBtaW5ZLCBtYXhZO1xuICAgICAgdmFyIGNoaWxkU2l6ZSA9IDAuNSAqIHBhcmVudEJyYW5jaC5zaXplO1xuICAgICAgc3dpdGNoIChyZWdpb24pIHtcbiAgICAgICAgY2FzZSBcIk5XXCI6XG4gICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YO1xuICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWCArIGNoaWxkU2l6ZTtcbiAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblk7XG4gICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTkVcIjpcbiAgICAgICAgICBtaW5YID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblggKyBjaGlsZFNpemU7XG4gICAgICAgICAgbWF4WCA9IHBhcmVudEJyYW5jaC5yYW5nZS5tYXhYO1xuICAgICAgICAgIG1pblkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWTtcbiAgICAgICAgICBtYXhZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblkgKyBjaGlsZFNpemU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJTV1wiOlxuICAgICAgICAgIG1pblggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWluWDtcbiAgICAgICAgICBtYXhYID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblggKyBjaGlsZFNpemU7XG4gICAgICAgICAgbWluWSA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5ZICsgY2hpbGRTaXplO1xuICAgICAgICAgIG1heFkgPSBwYXJlbnRCcmFuY2gucmFuZ2UubWF4WTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlNFXCI6XG4gICAgICAgICAgbWluWCA9IHBhcmVudEJyYW5jaC5yYW5nZS5taW5YICsgY2hpbGRTaXplO1xuICAgICAgICAgIG1heFggPSBwYXJlbnRCcmFuY2gucmFuZ2UubWF4WDtcbiAgICAgICAgICBtaW5ZID0gcGFyZW50QnJhbmNoLnJhbmdlLm1pblkgKyBjaGlsZFNpemU7XG4gICAgICAgICAgbWF4WSA9IHBhcmVudEJyYW5jaC5yYW5nZS5tYXhZO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcGFyZW50QnJhbmNoLmNoaWxkcmVuW3JlZ2lvbl0gPSB7XG4gICAgICAgIGNlbnRlck9mTWFzczoge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LFxuICAgICAgICBtYXNzOiAwLFxuICAgICAgICByYW5nZToge1xuICAgICAgICAgIG1pblg6IG1pblgsXG4gICAgICAgICAgbWF4WDogbWF4WCxcbiAgICAgICAgICBtaW5ZOiBtaW5ZLFxuICAgICAgICAgIG1heFk6IG1heFlcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZTogMC41ICogcGFyZW50QnJhbmNoLnNpemUsXG4gICAgICAgIGNhbGNTaXplOiAyICogcGFyZW50QnJhbmNoLmNhbGNTaXplLFxuICAgICAgICBjaGlsZHJlbjoge1xuICAgICAgICAgIGRhdGE6IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgbWF4V2lkdGg6IDAsXG4gICAgICAgIGxldmVsOiBwYXJlbnRCcmFuY2gubGV2ZWwgKyAxLFxuICAgICAgICBjaGlsZHJlbkNvdW50OiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICBERUJVR0dJTkcgQkVMT1cgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGZvciBkZWJ1Z2dpbmcgcHVycG9zZWQsIGl0IGRyYXdzIHRoZSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RlYnVnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWJ1ZyhjdHgsIGNvbG9yKSB7XG4gICAgICBpZiAodGhpcy5iYXJuZXNIdXRUcmVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgICAgIHRoaXMuX2RyYXdCcmFuY2godGhpcy5iYXJuZXNIdXRUcmVlLnJvb3QsIGN0eCwgY29sb3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy4gSXQgZHJhd3MgdGhlIGJyYW5jaGVzIHJlY3Vyc2l2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGJyYW5jaFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3QnJhbmNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3QnJhbmNoKGJyYW5jaCwgY3R4LCBjb2xvcikge1xuICAgICAgaWYgKGNvbG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29sb3IgPSBcIiNGRjAwMDBcIjtcbiAgICAgIH1cbiAgICAgIGlmIChicmFuY2guY2hpbGRyZW5Db3VudCA9PT0gNCkge1xuICAgICAgICB0aGlzLl9kcmF3QnJhbmNoKGJyYW5jaC5jaGlsZHJlbi5OVywgY3R4KTtcbiAgICAgICAgdGhpcy5fZHJhd0JyYW5jaChicmFuY2guY2hpbGRyZW4uTkUsIGN0eCk7XG4gICAgICAgIHRoaXMuX2RyYXdCcmFuY2goYnJhbmNoLmNoaWxkcmVuLlNFLCBjdHgpO1xuICAgICAgICB0aGlzLl9kcmF3QnJhbmNoKGJyYW5jaC5jaGlsZHJlbi5TVywgY3R4KTtcbiAgICAgIH1cbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1pblkpO1xuICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1pblkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1pblkpO1xuICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWF4WCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1heFkpO1xuICAgICAgY3R4LmxpbmVUbyhicmFuY2gucmFuZ2UubWluWCwgYnJhbmNoLnJhbmdlLm1pblkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAvKlxuICAgICAgIGlmIChicmFuY2gubWFzcyA+IDApIHtcbiAgICAgICBjdHguY2lyY2xlKGJyYW5jaC5jZW50ZXJPZk1hc3MueCwgYnJhbmNoLmNlbnRlck9mTWFzcy55LCAzKmJyYW5jaC5tYXNzKTtcbiAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgfVxuICAgICAgICovXG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBCYXJuZXNIdXRTb2x2ZXI7XG59KCk7XG5cbi8qKlxuICogUmVwdWxzaW9uIFNvbHZlclxuICovXG52YXIgUmVwdWxzaW9uU29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIFJlcHVsc2lvblNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXB1bHNpb25Tb2x2ZXIpO1xuICAgIHRoaXMuX3JuZyA9IEFsZWEoXCJSRVBVTFNJT04gU09MVkVSXCIpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFJlcHVsc2lvblNvbHZlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgdGhlIG5vZGVzIGFwcGx5IG9uIGVhY2ggb3RoZXIgYmFzZWQgb24gYSByZXB1bHNpb24gZmllbGQuXG4gICAgICogVGhpcyBmaWVsZCBpcyBsaW5lYXJseSBhcHByb3hpbWF0ZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNvbHZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvbHZlKCkge1xuICAgICAgdmFyIGR4LCBkeSwgZGlzdGFuY2UsIGZ4LCBmeSwgcmVwdWxzaW5nRm9yY2UsIG5vZGUxLCBub2RlMjtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzO1xuICAgICAgdmFyIGZvcmNlcyA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzO1xuXG4gICAgICAvLyByZXB1bHNpbmcgZm9yY2VzIGJldHdlZW4gbm9kZXNcbiAgICAgIHZhciBub2RlRGlzdGFuY2UgPSB0aGlzLm9wdGlvbnMubm9kZURpc3RhbmNlO1xuXG4gICAgICAvLyBhcHByb3hpbWF0aW9uIGNvbnN0YW50c1xuICAgICAgdmFyIGEgPSAtMiAvIDMgLyBub2RlRGlzdGFuY2U7XG4gICAgICB2YXIgYiA9IDQgLyAzO1xuXG4gICAgICAvLyB3ZSBsb29wIGZyb20gaSBvdmVyIGFsbCBidXQgdGhlIGxhc3QgZW50cmVlIGluIHRoZSBhcnJheVxuICAgICAgLy8gaiBsb29wcyBmcm9tIGkrMSB0byB0aGUgbGFzdC4gVGhpcyB3YXkgd2UgZG8gbm90IGRvdWJsZSBjb3VudCBhbnkgb2YgdGhlIGluZGljZXMsIG5vciBpID09PSBqXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBub2RlMSA9IG5vZGVzW25vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbm9kZUluZGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBub2RlMiA9IG5vZGVzW25vZGVJbmRpY2VzW2pdXTtcbiAgICAgICAgICBkeCA9IG5vZGUyLnggLSBub2RlMS54O1xuICAgICAgICAgIGR5ID0gbm9kZTIueSAtIG5vZGUxLnk7XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgICAgLy8gc2FtZSBjb25kaXRpb24gYXMgQmFybmVzSHV0U29sdmVyLCBtYWtpbmcgc3VyZSBub2RlcyBhcmUgbmV2ZXIgMTAwJSBvdmVybGFwcGluZy5cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gMC4xICogdGhpcy5fcm5nKCk7XG4gICAgICAgICAgICBkeCA9IGRpc3RhbmNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPCAyICogbm9kZURpc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCAwLjUgKiBub2RlRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSAxLjA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IGEgKiBkaXN0YW5jZSArIGI7IC8vIGxpbmVhciBhcHByb3ggb2YgIDEgLyAoMSArIE1hdGguZXhwKChkaXN0YW5jZSAvIG5vZGVEaXN0YW5jZSAtIDEpICogc3RlZXBuZXNzKSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSByZXB1bHNpbmdGb3JjZSAvIGRpc3RhbmNlO1xuICAgICAgICAgICAgZnggPSBkeCAqIHJlcHVsc2luZ0ZvcmNlO1xuICAgICAgICAgICAgZnkgPSBkeSAqIHJlcHVsc2luZ0ZvcmNlO1xuICAgICAgICAgICAgZm9yY2VzW25vZGUxLmlkXS54IC09IGZ4O1xuICAgICAgICAgICAgZm9yY2VzW25vZGUxLmlkXS55IC09IGZ5O1xuICAgICAgICAgICAgZm9yY2VzW25vZGUyLmlkXS54ICs9IGZ4O1xuICAgICAgICAgICAgZm9yY2VzW25vZGUyLmlkXS55ICs9IGZ5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUmVwdWxzaW9uU29sdmVyO1xufSgpO1xuXG4vKipcbiAqIEhpZXJhcmNoaWNhbCBSZXB1bHNpb24gU29sdmVyXG4gKi9cbnZhciBIaWVyYXJjaGljYWxSZXB1bHNpb25Tb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcik7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgIHRoaXMub3ZlcmxhcEF2b2lkYW5jZUZhY3RvciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIHRoaXMub3B0aW9ucy5hdm9pZE92ZXJsYXAgfHwgMCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIHRoZSBub2RlcyBhcHBseSBvbiBlYWNoIG90aGVyIGJhc2VkIG9uIGEgcmVwdWxzaW9uIGZpZWxkLlxuICAgICAqIFRoaXMgZmllbGQgaXMgbGluZWFybHkgYXBwcm94aW1hdGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzO1xuICAgICAgdmFyIGZvcmNlcyA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzO1xuXG4gICAgICAvLyByZXB1bHNpbmcgZm9yY2VzIGJldHdlZW4gbm9kZXNcbiAgICAgIHZhciBub2RlRGlzdGFuY2UgPSB0aGlzLm9wdGlvbnMubm9kZURpc3RhbmNlO1xuXG4gICAgICAvLyB3ZSBsb29wIGZyb20gaSBvdmVyIGFsbCBidXQgdGhlIGxhc3QgZW50cmVlIGluIHRoZSBhcnJheVxuICAgICAgLy8gaiBsb29wcyBmcm9tIGkrMSB0byB0aGUgbGFzdC4gVGhpcyB3YXkgd2UgZG8gbm90IGRvdWJsZSBjb3VudCBhbnkgb2YgdGhlIGluZGljZXMsIG5vciBpID09PSBqXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJbmRpY2VzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB2YXIgbm9kZTEgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG4gICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IG5vZGVJbmRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIG5vZGUyID0gbm9kZXNbbm9kZUluZGljZXNbal1dO1xuXG4gICAgICAgICAgLy8gbm9kZXMgb25seSBhZmZlY3Qgbm9kZXMgb24gdGhlaXIgbGV2ZWxcbiAgICAgICAgICBpZiAobm9kZTEubGV2ZWwgPT09IG5vZGUyLmxldmVsKSB7XG4gICAgICAgICAgICB2YXIgdGhlc2VOb2Rlc0Rpc3RhbmNlID0gbm9kZURpc3RhbmNlICsgdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yICogKChub2RlMS5zaGFwZS5yYWRpdXMgfHwgMCkgLyAyICsgKG5vZGUyLnNoYXBlLnJhZGl1cyB8fCAwKSAvIDIpO1xuICAgICAgICAgICAgdmFyIGR4ID0gbm9kZTIueCAtIG5vZGUxLng7XG4gICAgICAgICAgICB2YXIgZHkgPSBub2RlMi55IC0gbm9kZTEueTtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICB2YXIgc3RlZXBuZXNzID0gMC4wNTtcbiAgICAgICAgICAgIHZhciByZXB1bHNpbmdGb3JjZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA8IHRoZXNlTm9kZXNEaXN0YW5jZSkge1xuICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IC1NYXRoLnBvdyhzdGVlcG5lc3MgKiBkaXN0YW5jZSwgMikgKyBNYXRoLnBvdyhzdGVlcG5lc3MgKiB0aGVzZU5vZGVzRGlzdGFuY2UsIDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVwdWxzaW5nRm9yY2UgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm9ybWFsaXplIGZvcmNlIHdpdGhcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSAhPT0gMCkge1xuICAgICAgICAgICAgICByZXB1bHNpbmdGb3JjZSA9IHJlcHVsc2luZ0ZvcmNlIC8gZGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZnggPSBkeCAqIHJlcHVsc2luZ0ZvcmNlO1xuICAgICAgICAgICAgdmFyIGZ5ID0gZHkgKiByZXB1bHNpbmdGb3JjZTtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueCAtPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMS5pZF0ueSAtPSBmeTtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueCArPSBmeDtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlMi5pZF0ueSArPSBmeTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEhpZXJhcmNoaWNhbFJlcHVsc2lvblNvbHZlcjtcbn0oKTtcblxuLyoqXG4gKiBTcHJpbmcgU29sdmVyXG4gKi9cbnZhciBTcHJpbmdTb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gU3ByaW5nU29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNwcmluZ1NvbHZlcik7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLnBoeXNpY3NCb2R5ID0gcGh5c2ljc0JvZHk7XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoU3ByaW5nU29sdmVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIHNwcmluZ2ZvcmNlcyBvbiB0aGUgbm9kZXMsIGFjY291bnRpbmcgZm9yIHRoZSBzdXBwb3J0IG5vZGVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZSgpIHtcbiAgICAgIHZhciBlZGdlTGVuZ3RoLCBlZGdlO1xuICAgICAgdmFyIGVkZ2VJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzRWRnZUluZGljZXM7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgbm9kZTEsIG5vZGUyLCBub2RlMztcblxuICAgICAgLy8gZm9yY2VzIGNhdXNlZCBieSB0aGUgZWRnZXMsIG1vZGVsbGVkIGFzIHNwcmluZ3NcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW2ldXTtcbiAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlICYmIGVkZ2UudG9JZCAhPT0gZWRnZS5mcm9tSWQpIHtcbiAgICAgICAgICAvLyBvbmx5IGNhbGN1bGF0ZSBmb3JjZXMgaWYgbm9kZXMgYXJlIGluIHRoZSBzYW1lIHNlY3RvclxuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbZWRnZS50b0lkXSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYm9keS5ub2Rlc1tlZGdlLmZyb21JZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGVkZ2UuZWRnZVR5cGUudmlhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZWRnZUxlbmd0aCA9IGVkZ2Uub3B0aW9ucy5sZW5ndGggPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zcHJpbmdMZW5ndGggOiBlZGdlLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICBub2RlMSA9IGVkZ2UudG87XG4gICAgICAgICAgICAgIG5vZGUyID0gZWRnZS5lZGdlVHlwZS52aWE7XG4gICAgICAgICAgICAgIG5vZGUzID0gZWRnZS5mcm9tO1xuICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShub2RlMSwgbm9kZTIsIDAuNSAqIGVkZ2VMZW5ndGgpO1xuICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShub2RlMiwgbm9kZTMsIDAuNSAqIGVkZ2VMZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gdGhlICogMS41IGlzIGhlcmUgc28gdGhlIGVkZ2UgbG9va3MgYXMgbGFyZ2UgYXMgYSBzbW9vdGggZWRnZS4gSXQgZG9lcyBub3QgaW5pdGlhbGx5IGJlY2F1c2UgdGhlIHNtb290aCBlZGdlcyB1c2VcbiAgICAgICAgICAgICAgLy8gdGhlIHN1cHBvcnQgbm9kZXMgd2hpY2ggZXhlcnQgYSByZXB1bHNpdmUgZm9yY2Ugb24gdGhlIHRvIGFuZCBmcm9tIG5vZGVzLCBtYWtpbmcgdGhlIGVkZ2UgYXBwZWFyIGxhcmdlci5cbiAgICAgICAgICAgICAgZWRnZUxlbmd0aCA9IGVkZ2Uub3B0aW9ucy5sZW5ndGggPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zcHJpbmdMZW5ndGggKiAxLjUgOiBlZGdlLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVTcHJpbmdGb3JjZShlZGdlLmZyb20sIGVkZ2UudG8sIGVkZ2VMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIGNvZGUgYWN0dWFsbHkgcGVyZm9ybWluZyB0aGUgY2FsY3VsYXRpb24gZm9yIHRoZSBmdW5jdGlvbiBhYm92ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZTFcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VMZW5ndGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jYWxjdWxhdGVTcHJpbmdGb3JjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlU3ByaW5nRm9yY2Uobm9kZTEsIG5vZGUyLCBlZGdlTGVuZ3RoKSB7XG4gICAgICB2YXIgZHggPSBub2RlMS54IC0gbm9kZTIueDtcbiAgICAgIHZhciBkeSA9IG5vZGUxLnkgLSBub2RlMi55O1xuICAgICAgdmFyIGRpc3RhbmNlID0gTWF0aC5tYXgoTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSwgMC4wMSk7XG5cbiAgICAgIC8vIHRoZSAxL2Rpc3RhbmNlIGlzIHNvIHRoZSBmeCBhbmQgZnkgY2FuIGJlIGNhbGN1bGF0ZWQgd2l0aG91dCBzaW5lIG9yIGNvc2luZS5cbiAgICAgIHZhciBzcHJpbmdGb3JjZSA9IHRoaXMub3B0aW9ucy5zcHJpbmdDb25zdGFudCAqIChlZGdlTGVuZ3RoIC0gZGlzdGFuY2UpIC8gZGlzdGFuY2U7XG4gICAgICB2YXIgZnggPSBkeCAqIHNwcmluZ0ZvcmNlO1xuICAgICAgdmFyIGZ5ID0gZHkgKiBzcHJpbmdGb3JjZTtcblxuICAgICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIG9uZSBub2RlIGlzIG5vdCBwYXJ0IG9mIHRoZSBwaHlzY2lzXG4gICAgICBpZiAodGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTEuaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbbm9kZTEuaWRdLnggKz0gZng7XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUxLmlkXS55ICs9IGZ5O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUyLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUyLmlkXS54IC09IGZ4O1xuICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlMi5pZF0ueSAtPSBmeTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNwcmluZ1NvbHZlcjtcbn0oKTtcblxuLyoqXG4gKiBIaWVyYXJjaGljYWwgU3ByaW5nIFNvbHZlclxuICovXG52YXIgSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7e3BoeXNpY3NOb2RlSW5kaWNlczogQXJyYXksIHBoeXNpY3NFZGdlSW5kaWNlczogQXJyYXksIGZvcmNlczoge30sIHZlbG9jaXRpZXM6IHt9fX0gcGh5c2ljc0JvZHlcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXIpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKEhpZXJhcmNoaWNhbFNwcmluZ1NvbHZlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIHRoZSBzcHJpbmdmb3JjZXMgb24gdGhlIG5vZGVzLCBhY2NvdW50aW5nIGZvciB0aGUgc3VwcG9ydCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICB2YXIgZWRnZUxlbmd0aCwgZWRnZTtcbiAgICAgIHZhciBkeCwgZHksIGZ4LCBmeSwgc3ByaW5nRm9yY2UsIGRpc3RhbmNlO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuICAgICAgdmFyIGZhY3RvciA9IDAuNTtcbiAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzO1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXM7XG4gICAgICB2YXIgZm9yY2VzID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXM7XG5cbiAgICAgIC8vIGluaXRpYWxpemUgdGhlIHNwcmluZyBmb3JjZSBjb3VudGVyc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZUluZGljZXNbaV07XG4gICAgICAgIGZvcmNlc1tub2RlSWRdLnNwcmluZ0Z4ID0gMDtcbiAgICAgICAgZm9yY2VzW25vZGVJZF0uc3ByaW5nRnkgPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBmb3JjZXMgY2F1c2VkIGJ5IHRoZSBlZGdlcywgbW9kZWxsZWQgYXMgc3ByaW5nc1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbX2ldXTtcbiAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgZWRnZUxlbmd0aCA9IGVkZ2Uub3B0aW9ucy5sZW5ndGggPT09IHVuZGVmaW5lZCA/IHRoaXMub3B0aW9ucy5zcHJpbmdMZW5ndGggOiBlZGdlLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgICAgIGR4ID0gZWRnZS5mcm9tLnggLSBlZGdlLnRvLng7XG4gICAgICAgICAgZHkgPSBlZGdlLmZyb20ueSAtIGVkZ2UudG8ueTtcbiAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgZGlzdGFuY2UgPSBkaXN0YW5jZSA9PT0gMCA/IDAuMDEgOiBkaXN0YW5jZTtcblxuICAgICAgICAgIC8vIHRoZSAxL2Rpc3RhbmNlIGlzIHNvIHRoZSBmeCBhbmQgZnkgY2FuIGJlIGNhbGN1bGF0ZWQgd2l0aG91dCBzaW5lIG9yIGNvc2luZS5cbiAgICAgICAgICBzcHJpbmdGb3JjZSA9IHRoaXMub3B0aW9ucy5zcHJpbmdDb25zdGFudCAqIChlZGdlTGVuZ3RoIC0gZGlzdGFuY2UpIC8gZGlzdGFuY2U7XG4gICAgICAgICAgZnggPSBkeCAqIHNwcmluZ0ZvcmNlO1xuICAgICAgICAgIGZ5ID0gZHkgKiBzcHJpbmdGb3JjZTtcbiAgICAgICAgICBpZiAoZWRnZS50by5sZXZlbCAhPSBlZGdlLmZyb20ubGV2ZWwpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS50b0lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGZvcmNlc1tlZGdlLnRvSWRdLnNwcmluZ0Z4IC09IGZ4O1xuICAgICAgICAgICAgICBmb3JjZXNbZWRnZS50b0lkXS5zcHJpbmdGeSAtPSBmeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS5zcHJpbmdGeCArPSBmeDtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS5zcHJpbmdGeSArPSBmeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcmNlc1tlZGdlLnRvSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UudG9JZF0ueCAtPSBmYWN0b3IgKiBmeDtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UudG9JZF0ueSAtPSBmYWN0b3IgKiBmeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JjZXNbZWRnZS5mcm9tSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgZm9yY2VzW2VkZ2UuZnJvbUlkXS54ICs9IGZhY3RvciAqIGZ4O1xuICAgICAgICAgICAgICBmb3JjZXNbZWRnZS5mcm9tSWRdLnkgKz0gZmFjdG9yICogZnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5vcm1hbGl6ZSBzcHJpbmcgZm9yY2VzXG4gICAgICBzcHJpbmdGb3JjZSA9IDE7XG4gICAgICB2YXIgc3ByaW5nRngsIHNwcmluZ0Z5O1xuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZUluZGljZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgX25vZGVJZCA9IG5vZGVJbmRpY2VzW19pMl07XG4gICAgICAgIHNwcmluZ0Z4ID0gTWF0aC5taW4oc3ByaW5nRm9yY2UsIE1hdGgubWF4KC1zcHJpbmdGb3JjZSwgZm9yY2VzW19ub2RlSWRdLnNwcmluZ0Z4KSk7XG4gICAgICAgIHNwcmluZ0Z5ID0gTWF0aC5taW4oc3ByaW5nRm9yY2UsIE1hdGgubWF4KC1zcHJpbmdGb3JjZSwgZm9yY2VzW19ub2RlSWRdLnNwcmluZ0Z5KSk7XG4gICAgICAgIGZvcmNlc1tfbm9kZUlkXS54ICs9IHNwcmluZ0Z4O1xuICAgICAgICBmb3JjZXNbX25vZGVJZF0ueSArPSBzcHJpbmdGeTtcbiAgICAgIH1cblxuICAgICAgLy8gcmV0YWluIGVuZXJneSBiYWxhbmNlXG4gICAgICB2YXIgdG90YWxGeCA9IDA7XG4gICAgICB2YXIgdG90YWxGeSA9IDA7XG4gICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBub2RlSW5kaWNlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgIHZhciBfbm9kZUlkMiA9IG5vZGVJbmRpY2VzW19pM107XG4gICAgICAgIHRvdGFsRnggKz0gZm9yY2VzW19ub2RlSWQyXS54O1xuICAgICAgICB0b3RhbEZ5ICs9IGZvcmNlc1tfbm9kZUlkMl0ueTtcbiAgICAgIH1cbiAgICAgIHZhciBjb3JyZWN0aW9uRnggPSB0b3RhbEZ4IC8gbm9kZUluZGljZXMubGVuZ3RoO1xuICAgICAgdmFyIGNvcnJlY3Rpb25GeSA9IHRvdGFsRnkgLyBub2RlSW5kaWNlcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBub2RlSW5kaWNlcy5sZW5ndGg7IF9pNCsrKSB7XG4gICAgICAgIHZhciBfbm9kZUlkMyA9IG5vZGVJbmRpY2VzW19pNF07XG4gICAgICAgIGZvcmNlc1tfbm9kZUlkM10ueCAtPSBjb3JyZWN0aW9uRng7XG4gICAgICAgIGZvcmNlc1tfbm9kZUlkM10ueSAtPSBjb3JyZWN0aW9uRnk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBIaWVyYXJjaGljYWxTcHJpbmdTb2x2ZXI7XG59KCk7XG5cbi8qKlxuICogQ2VudHJhbCBHcmF2aXR5IFNvbHZlclxuICovXG52YXIgQ2VudHJhbEdyYXZpdHlTb2x2ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gQ2VudHJhbEdyYXZpdHlTb2x2ZXIoYm9keSwgcGh5c2ljc0JvZHksIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2VudHJhbEdyYXZpdHlTb2x2ZXIpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHBoeXNpY3NCb2R5O1xuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKENlbnRyYWxHcmF2aXR5U29sdmVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIGZvcmNlcyBmb3IgZWFjaCBub2RlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29sdmUoKSB7XG4gICAgICB2YXIgZHgsIGR5LCBkaXN0YW5jZSwgbm9kZTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzO1xuICAgICAgdmFyIGZvcmNlcyA9IHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZUluZGljZXNbaV07XG4gICAgICAgIG5vZGUgPSBub2Rlc1tub2RlSWRdO1xuICAgICAgICBkeCA9IC1ub2RlLng7XG4gICAgICAgIGR5ID0gLW5vZGUueTtcbiAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICB0aGlzLl9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgZm9yY2VzLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZHlcbiAgICAgKiBAcGFyYW0ge09iamVjdDxOb2RlLmlkLCB2aXMuTm9kZT59IGZvcmNlc1xuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbGN1bGF0ZUZvcmNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsY3VsYXRlRm9yY2VzKGRpc3RhbmNlLCBkeCwgZHksIGZvcmNlcywgbm9kZSkge1xuICAgICAgdmFyIGdyYXZpdHlGb3JjZSA9IGRpc3RhbmNlID09PSAwID8gMCA6IHRoaXMub3B0aW9ucy5jZW50cmFsR3Jhdml0eSAvIGRpc3RhbmNlO1xuICAgICAgZm9yY2VzW25vZGUuaWRdLnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIGZvcmNlc1tub2RlLmlkXS55ID0gZHkgKiBncmF2aXR5Rm9yY2U7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDZW50cmFsR3Jhdml0eVNvbHZlcjtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDMoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMygpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQzKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBAYXVnbWVudHMgQmFybmVzSHV0U29sdmVyXG4gKi9cbnZhciBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFybmVzSHV0U29sdmVyKSB7XG4gIF9pbmhlcml0cyhGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyLCBfQmFybmVzSHV0U29sdmVyKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQzKEZvcmNlQXRsYXMyQmFzZWRSZXB1bHNpb25Tb2x2ZXIpO1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcihib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcik7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBib2R5LCBwaHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgX3RoaXMuX3JuZyA9IEFsZWEoXCJGT1JDRSBBVExBUyAyIEJBU0VEIFJFUFVMU0lPTiBTT0xWRVJcIik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSB0aGUgZm9yY2VzIGJhc2VkIG9uIHRoZSBkaXN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkeFxuICAgKiBAcGFyYW0ge251bWJlcn0gZHlcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJlbnRCcmFuY2hcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyLCBbe1xuICAgIGtleTogXCJfY2FsY3VsYXRlRm9yY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgbm9kZSwgcGFyZW50QnJhbmNoKSB7XG4gICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgZGlzdGFuY2UgPSAwLjEgKiB0aGlzLl9ybmcoKTtcbiAgICAgICAgZHggPSBkaXN0YW5jZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm92ZXJsYXBBdm9pZGFuY2VGYWN0b3IgPCAxICYmIG5vZGUuc2hhcGUucmFkaXVzKSB7XG4gICAgICAgIGRpc3RhbmNlID0gTWF0aC5tYXgoMC4xICsgdGhpcy5vdmVybGFwQXZvaWRhbmNlRmFjdG9yICogbm9kZS5zaGFwZS5yYWRpdXMsIGRpc3RhbmNlIC0gbm9kZS5zaGFwZS5yYWRpdXMpO1xuICAgICAgfVxuICAgICAgdmFyIGRlZ3JlZSA9IG5vZGUuZWRnZXMubGVuZ3RoICsgMTtcbiAgICAgIC8vIHRoZSBkaXZpZGluZyBieSB0aGUgZGlzdGFuY2UgY3ViZWQgaW5zdGVhZCBvZiBzcXVhcmVkIGFsbG93cyB1cyB0byBnZXQgdGhlIGZ4IGFuZCBmeSBjb21wb25lbnRzIHdpdGhvdXQgc2luZXMgYW5kIGNvc2luZXNcbiAgICAgIC8vIGl0IGlzIHNob3J0aGFuZCBmb3IgZ3Jhdml0eWZvcmNlIHdpdGggZGlzdGFuY2Ugc3F1YXJlZCBhbmQgZnggPSBkeC9kaXN0YW5jZSAqIGdyYXZpdHlGb3JjZVxuICAgICAgdmFyIGdyYXZpdHlGb3JjZSA9IHRoaXMub3B0aW9ucy5ncmF2aXRhdGlvbmFsQ29uc3RhbnQgKiBwYXJlbnRCcmFuY2gubWFzcyAqIG5vZGUub3B0aW9ucy5tYXNzICogZGVncmVlIC8gTWF0aC5wb3coZGlzdGFuY2UsIDIpO1xuICAgICAgdmFyIGZ4ID0gZHggKiBncmF2aXR5Rm9yY2U7XG4gICAgICB2YXIgZnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW25vZGUuaWRdLnggKz0gZng7XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlLmlkXS55ICs9IGZ5O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRm9yY2VBdGxhczJCYXNlZFJlcHVsc2lvblNvbHZlcjtcbn0oQmFybmVzSHV0U29sdmVyKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQyKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBAYXVnbWVudHMgQ2VudHJhbEdyYXZpdHlTb2x2ZXJcbiAqL1xudmFyIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NlbnRyYWxHcmF2aXR5U29sdmVyKSB7XG4gIF9pbmhlcml0cyhGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIsIF9DZW50cmFsR3Jhdml0eVNvbHZlcik7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkMihGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIpO1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHt7cGh5c2ljc05vZGVJbmRpY2VzOiBBcnJheSwgcGh5c2ljc0VkZ2VJbmRpY2VzOiBBcnJheSwgZm9yY2VzOiB7fSwgdmVsb2NpdGllczoge319fSBwaHlzaWNzQm9keVxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgZnVuY3Rpb24gRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyKGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcik7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGJvZHksIHBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGZvcmNlcyBiYXNlZCBvbiB0aGUgZGlzdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICAgKiBAcGFyYW0ge251bWJlcn0gZHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR5XG4gICAqIEBwYXJhbSB7T2JqZWN0PE5vZGUuaWQsIE5vZGU+fSBmb3JjZXNcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoRm9yY2VBdGxhczJCYXNlZENlbnRyYWxHcmF2aXR5U29sdmVyLCBbe1xuICAgIGtleTogXCJfY2FsY3VsYXRlRm9yY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVGb3JjZXMoZGlzdGFuY2UsIGR4LCBkeSwgZm9yY2VzLCBub2RlKSB7XG4gICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgIHZhciBkZWdyZWUgPSBub2RlLmVkZ2VzLmxlbmd0aCArIDE7XG4gICAgICAgIHZhciBncmF2aXR5Rm9yY2UgPSB0aGlzLm9wdGlvbnMuY2VudHJhbEdyYXZpdHkgKiBkZWdyZWUgKiBub2RlLm9wdGlvbnMubWFzcztcbiAgICAgICAgZm9yY2VzW25vZGUuaWRdLnggPSBkeCAqIGdyYXZpdHlGb3JjZTtcbiAgICAgICAgZm9yY2VzW25vZGUuaWRdLnkgPSBkeSAqIGdyYXZpdHlGb3JjZTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZvcmNlQXRsYXMyQmFzZWRDZW50cmFsR3Jhdml0eVNvbHZlcjtcbn0oQ2VudHJhbEdyYXZpdHlTb2x2ZXIpO1xuXG4vKipcbiAqIFRoZSBwaHlzaWNzIGVuZ2luZVxuICovXG52YXIgUGh5c2ljc0VuZ2luZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKi9cbiAgZnVuY3Rpb24gUGh5c2ljc0VuZ2luZShib2R5KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBoeXNpY3NFbmdpbmUpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waHlzaWNzQm9keSA9IHtcbiAgICAgIHBoeXNpY3NOb2RlSW5kaWNlczogW10sXG4gICAgICBwaHlzaWNzRWRnZUluZGljZXM6IFtdLFxuICAgICAgZm9yY2VzOiB7fSxcbiAgICAgIHZlbG9jaXRpZXM6IHt9XG4gICAgfTtcbiAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLnNpbXVsYXRpb25JbnRlcnZhbCA9IDEwMDAgLyA2MDtcbiAgICB0aGlzLnJlcXVpcmVzVGltZW91dCA9IHRydWU7XG4gICAgdGhpcy5wcmV2aW91c1N0YXRlcyA9IHt9O1xuICAgIHRoaXMucmVmZXJlbmNlU3RhdGUgPSB7fTtcbiAgICB0aGlzLmZyZWV6ZUNhY2hlID0ge307XG4gICAgdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHBhcmFtZXRlcnMgZm9yIHRoZSBhZGFwdGl2ZSB0aW1lc3RlcFxuICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcCA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHRpdmVUaW1lc3RlcEVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0aXZlQ291bnRlciA9IDA7XG4gICAgdGhpcy5hZGFwdGl2ZUludGVydmFsID0gMztcbiAgICB0aGlzLnN0YWJpbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucyA9IDA7XG4gICAgdGhpcy5yZWFkeSA9IGZhbHNlOyAvLyB3aWxsIGJlIHNldCB0byB0cnVlIGlmIHRoZSBzdGFiaWxpemVcblxuICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgYmFybmVzSHV0OiB7XG4gICAgICAgIHRoZXRhOiAwLjUsXG4gICAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogLTIwMDAsXG4gICAgICAgIGNlbnRyYWxHcmF2aXR5OiAwLjMsXG4gICAgICAgIHNwcmluZ0xlbmd0aDogOTUsXG4gICAgICAgIHNwcmluZ0NvbnN0YW50OiAwLjA0LFxuICAgICAgICBkYW1waW5nOiAwLjA5LFxuICAgICAgICBhdm9pZE92ZXJsYXA6IDBcbiAgICAgIH0sXG4gICAgICBmb3JjZUF0bGFzMkJhc2VkOiB7XG4gICAgICAgIHRoZXRhOiAwLjUsXG4gICAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogLTUwLFxuICAgICAgICBjZW50cmFsR3Jhdml0eTogMC4wMSxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IDAuMDgsXG4gICAgICAgIHNwcmluZ0xlbmd0aDogMTAwLFxuICAgICAgICBkYW1waW5nOiAwLjQsXG4gICAgICAgIGF2b2lkT3ZlcmxhcDogMFxuICAgICAgfSxcbiAgICAgIHJlcHVsc2lvbjoge1xuICAgICAgICBjZW50cmFsR3Jhdml0eTogMC4yLFxuICAgICAgICBzcHJpbmdMZW5ndGg6IDIwMCxcbiAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IDAuMDUsXG4gICAgICAgIG5vZGVEaXN0YW5jZTogMTAwLFxuICAgICAgICBkYW1waW5nOiAwLjA5LFxuICAgICAgICBhdm9pZE92ZXJsYXA6IDBcbiAgICAgIH0sXG4gICAgICBoaWVyYXJjaGljYWxSZXB1bHNpb246IHtcbiAgICAgICAgY2VudHJhbEdyYXZpdHk6IDAuMCxcbiAgICAgICAgc3ByaW5nTGVuZ3RoOiAxMDAsXG4gICAgICAgIHNwcmluZ0NvbnN0YW50OiAwLjAxLFxuICAgICAgICBub2RlRGlzdGFuY2U6IDEyMCxcbiAgICAgICAgZGFtcGluZzogMC4wOVxuICAgICAgfSxcbiAgICAgIG1heFZlbG9jaXR5OiA1MCxcbiAgICAgIG1pblZlbG9jaXR5OiAwLjc1LFxuICAgICAgLy8gcHgvc1xuICAgICAgc29sdmVyOiBcImJhcm5lc0h1dFwiLFxuICAgICAgc3RhYmlsaXphdGlvbjoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBpdGVyYXRpb25zOiAxMDAwLFxuICAgICAgICAvLyBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb24gdG8gc3RhYmlsaXplXG4gICAgICAgIHVwZGF0ZUludGVydmFsOiA1MCxcbiAgICAgICAgb25seUR5bmFtaWNFZGdlczogZmFsc2UsXG4gICAgICAgIGZpdDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHRpbWVzdGVwOiAwLjUsXG4gICAgICBhZGFwdGl2ZVRpbWVzdGVwOiB0cnVlLFxuICAgICAgd2luZDoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9XG4gICAgfTtcbiAgICBfT2JqZWN0JGFzc2lnbih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMudGltZXN0ZXAgPSAwLjU7XG4gICAgdGhpcy5sYXlvdXRGYWlsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFBoeXNpY3NFbmdpbmUsIFt7XG4gICAga2V5OiBcImJpbmRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UGh5c2ljc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmluaXRQaHlzaWNzKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2xheW91dEZhaWxlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmxheW91dEZhaWxlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVzZXRQaHlzaWNzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuc3RvcFNpbXVsYXRpb24oKTtcbiAgICAgICAgX3RoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkaXNhYmxlUGh5c2ljc1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnBoeXNpY3NFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwicmVzdG9yZVBoeXNpY3NcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zZXRPcHRpb25zKF90aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAoX3RoaXMucmVhZHkgPT09IHRydWUpIHtcbiAgICAgICAgICBfdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInN0YXJ0U2ltdWxhdGlvblwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5yZWFkeSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIF90aGlzLnN0YXJ0U2ltdWxhdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwic3RvcFNpbXVsYXRpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5zdG9wU2ltdWxhdGlvbihmYWxzZSk7XG4gICAgICAgIF90aGlzLmJvZHkuZW1pdHRlci5vZmYoKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUNoYW5nZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBOb2RlcyBhbmQvb3IgZWRnZXMgaGF2ZSBiZWVuIGFkZGVkIG9yIHJlbW92ZWQsIHVwZGF0ZSBzaG9ydGN1dCBsaXN0cy5cbiAgICAgICAgX3RoaXMudXBkYXRlUGh5c2ljc0RhdGEoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBkZWJ1Zzogc2hvdyBmb3JjZXNcbiAgICAgIC8vIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiYWZ0ZXJEcmF3aW5nXCIsIChjdHgpID0+IHt0aGlzLl9kcmF3Rm9yY2VzKGN0eCk7fSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0IHRoZSBwaHlzaWNzIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5zdG9wU2ltdWxhdGlvbigpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5waHlzaWNzRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICBzZWxlY3RpdmVOb3REZWVwRXh0ZW5kKFtcInN0YWJpbGl6YXRpb25cIl0sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgICAgbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgXCJzdGFiaWxpemF0aW9uXCIpO1xuICAgICAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnBoeXNpY3NFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB3aW5kID0gdGhpcy5vcHRpb25zLndpbmQ7XG4gICAgICAgICAgaWYgKHdpbmQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZC54ICE9PSBcIm51bWJlclwiIHx8IF9OdW1iZXIkaXNOYU4od2luZC54KSkge1xuICAgICAgICAgICAgICB3aW5kLnggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kLnkgIT09IFwibnVtYmVyXCIgfHwgX051bWJlciRpc05hTih3aW5kLnkpKSB7XG4gICAgICAgICAgICAgIHdpbmQueSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gc2V0IHRoZSB0aW1lc3RlcFxuICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSB0aGlzLm9wdGlvbnMudGltZXN0ZXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbmZpZ3VyZSB0aGUgZW5naW5lLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImluaXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBvcHRpb25zO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zb2x2ZXIgPT09IFwiZm9yY2VBdGxhczJCYXNlZFwiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuZm9yY2VBdGxhczJCYXNlZDtcbiAgICAgICAgdGhpcy5ub2Rlc1NvbHZlciA9IG5ldyBGb3JjZUF0bGFzMkJhc2VkUmVwdWxzaW9uU29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZWRnZXNTb2x2ZXIgPSBuZXcgU3ByaW5nU29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlciA9IG5ldyBGb3JjZUF0bGFzMkJhc2VkQ2VudHJhbEdyYXZpdHlTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNvbHZlciA9PT0gXCJyZXB1bHNpb25cIikge1xuICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLnJlcHVsc2lvbjtcbiAgICAgICAgdGhpcy5ub2Rlc1NvbHZlciA9IG5ldyBSZXB1bHNpb25Tb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5lZGdlc1NvbHZlciA9IG5ldyBTcHJpbmdTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5ncmF2aXR5U29sdmVyID0gbmV3IENlbnRyYWxHcmF2aXR5U29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zb2x2ZXIgPT09IFwiaGllcmFyY2hpY2FsUmVwdWxzaW9uXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWxSZXB1bHNpb247XG4gICAgICAgIHRoaXMubm9kZXNTb2x2ZXIgPSBuZXcgSGllcmFyY2hpY2FsUmVwdWxzaW9uU29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZWRnZXNTb2x2ZXIgPSBuZXcgSGllcmFyY2hpY2FsU3ByaW5nU29sdmVyKHRoaXMuYm9keSwgdGhpcy5waHlzaWNzQm9keSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ3Jhdml0eVNvbHZlciA9IG5ldyBDZW50cmFsR3Jhdml0eVNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYmFybmVzSHV0XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuYmFybmVzSHV0O1xuICAgICAgICB0aGlzLm5vZGVzU29sdmVyID0gbmV3IEJhcm5lc0h1dFNvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmVkZ2VzU29sdmVyID0gbmV3IFNwcmluZ1NvbHZlcih0aGlzLmJvZHksIHRoaXMucGh5c2ljc0JvZHksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmdyYXZpdHlTb2x2ZXIgPSBuZXcgQ2VudHJhbEdyYXZpdHlTb2x2ZXIodGhpcy5ib2R5LCB0aGlzLnBoeXNpY3NCb2R5LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubW9kZWxPcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBpbml0aWFsaXplIHRoZSBlbmdpbmVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpbml0UGh5c2ljc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0UGh5c2ljcygpIHtcbiAgICAgIGlmICh0aGlzLnBoeXNpY3NFbmFibGVkID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5zdGFiaWxpemUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YWJpbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZml0XCIsIHt9LCB0aGlzLmxheW91dEZhaWxlZCk7IC8vIGlmIHRoZSBsYXlvdXQgZmFpbGVkLCB3ZSB1c2UgdGhlIGFwcHJveGltYXRpb24gZm9yIHRoZSB6b29tXG4gICAgICAgICAgdGhpcy5zdGFydFNpbXVsYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJmaXRcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnQgdGhlIHNpbXVsYXRpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzdGFydFNpbXVsYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRTaW11bGF0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucGh5c2ljc0VuYWJsZWQgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zdGFiaWxpemVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gd2hlbiB2aXNpYmxlLCBhZGFwdGl2aXR5IGlzIGRpc2FibGVkLlxuICAgICAgICB0aGlzLmFkYXB0aXZlVGltZXN0ZXAgPSBmYWxzZTtcblxuICAgICAgICAvLyB0aGlzIHNldHMgdGhlIHdpZHRoIG9mIGFsbCBub2RlcyBpbml0aWFsbHkgd2hpY2ggY291bGQgYmUgcmVxdWlyZWQgZm9yIHRoZSBhdm9pZE92ZXJsYXBcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNpemVOb2Rlc1wiKTtcbiAgICAgICAgaWYgKHRoaXMudmlld0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQ7XG4gICAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dCA9IHRoaXMuc2ltdWxhdGlvblN0ZXApLmNhbGwoX2NvbnRleHQsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdGFydFJlbmRlcmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgc2ltdWxhdGlvbiwgZm9yY2Ugc3RhYmlsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VtaXQ9dHJ1ZV1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzdG9wU2ltdWxhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wU2ltdWxhdGlvbigpIHtcbiAgICAgIHZhciBlbWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgICAgdGhpcy5zdGFiaWxpemVkID0gdHJ1ZTtcbiAgICAgIGlmIChlbWl0ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2VtaXRTdGFiaWxpemVkKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy52aWV3RnVuY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChlbWl0ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9zdG9wUmVuZGVyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHZpZXdGdW5jdGlvbiBpbnNlcnRzIHRoaXMgc3RlcCBpbnRvIGVhY2ggcmVuZGVyIGxvb3AuIEl0IGNhbGxzIHRoZSBwaHlzaWNzIHRpY2sgYW5kIGhhbmRsZXMgdGhlIGNsZWFudXAgYXQgc3RhYmlsaXplZC5cbiAgICAgKlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNpbXVsYXRpb25TdGVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpbXVsYXRpb25TdGVwKCkge1xuICAgICAgLy8gY2hlY2sgaWYgdGhlIHBoeXNpY3MgaGF2ZSBzZXR0bGVkXG4gICAgICB2YXIgc3RhcnRUaW1lID0gX0RhdGUkbm93KCk7XG4gICAgICB0aGlzLnBoeXNpY3NUaWNrKCk7XG4gICAgICB2YXIgcGh5c2ljc1RpbWUgPSBfRGF0ZSRub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgLy8gcnVuIGRvdWJsZSBzcGVlZCBpZiBpdCBpcyBhIGxpdHRsZSBncmFwaFxuICAgICAgaWYgKChwaHlzaWNzVGltZSA8IDAuNCAqIHRoaXMuc2ltdWxhdGlvbkludGVydmFsIHx8IHRoaXMucnVuRG91YmxlU3BlZWQgPT09IHRydWUpICYmIHRoaXMuc3RhYmlsaXplZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5waHlzaWNzVGljaygpO1xuXG4gICAgICAgIC8vIHRoaXMgbWFrZXMgc3VyZSB0aGVyZSBpcyBubyBqaXR0ZXIuIFRoZSBkZWNpc2lvbiBpcyB0YWtlbiBvbmNlIHRvIHJ1biBpdCBhdCBkb3VibGUgc3BlZWQuXG4gICAgICAgIHRoaXMucnVuRG91YmxlU3BlZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc3RhYmlsaXplZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnN0b3BTaW11bGF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdHJpZ2dlciB0aGUgc3RhYmlsaXplZCBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYW1vdW50T2ZJdGVyYXRpb25zPXRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnNdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdFN0YWJpbGl6ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRTdGFiaWxpemVkKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgYW1vdW50T2ZJdGVyYXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zO1xuICAgICAgaWYgKHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPiAxIHx8IHRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgX3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YWJpbGl6ZWRcIiwge1xuICAgICAgICAgICAgaXRlcmF0aW9uczogYW1vdW50T2ZJdGVyYXRpb25zXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX3RoaXMyLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID0gZmFsc2U7XG4gICAgICAgICAgX3RoaXMyLnN0YWJpbGl6YXRpb25JdGVyYXRpb25zID0gMDtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBmb3JjZXMgZm9yIG9uZSBwaHlzaWNzIGl0ZXJhdGlvbiBhbmQgbW92ZSB0aGUgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInBoeXNpY3NTdGVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBoeXNpY3NTdGVwKCkge1xuICAgICAgdGhpcy5ncmF2aXR5U29sdmVyLnNvbHZlKCk7XG4gICAgICB0aGlzLm5vZGVzU29sdmVyLnNvbHZlKCk7XG4gICAgICB0aGlzLmVkZ2VzU29sdmVyLnNvbHZlKCk7XG4gICAgICB0aGlzLm1vdmVOb2RlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2UgZHluYW1pYyBhZGp1c3RtZW50cyB0byB0aGUgdGltZXN0ZXAsIGJhc2VkIG9uIGN1cnJlbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHBoeXNpY3NUaWNrKCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkanVzdFRpbWVTdGVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkanVzdFRpbWVTdGVwKCkge1xuICAgICAgdmFyIGZhY3RvciA9IDEuMjsgLy8gRmFjdG9yIGZvciBpbmNyZWFzaW5nIHRoZSB0aW1lc3RlcCBvbiBzdWNjZXNzLlxuXG4gICAgICAvLyB3ZSBjb21wYXJlIHRoZSB0d28gc3RlcHMuIGlmIGl0IGlzIGFjY2VwdGFibGUgd2UgZG91YmxlIHRoZSBzdGVwLlxuICAgICAgaWYgKHRoaXMuX2V2YWx1YXRlU3RlcFF1YWxpdHkoKSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnRpbWVzdGVwID0gZmFjdG9yICogdGhpcy50aW1lc3RlcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIG5vdCwgd2UgZGVjcmVhc2UgdGhlIHN0ZXAgdG8gYSBtaW5pbXVtIG9mIHRoZSBvcHRpb25zIHRpbWVzdGVwLlxuICAgICAgICAvLyBpZiB0aGUgZGVjcmVhc2VkIHRpbWVzdGVwIGlzIHNtYWxsZXIgdGhhbiB0aGUgb3B0aW9ucyBzdGVwLCB3ZSBkbyBub3QgcmVzZXQgdGhlIGNvdW50ZXJcbiAgICAgICAgLy8gd2UgYXNzdW1lIHRoYXQgdGhlIG9wdGlvbnMgdGltZXN0ZXAgaXMgc3RhYmxlIGVub3VnaC5cbiAgICAgICAgaWYgKHRoaXMudGltZXN0ZXAgLyBmYWN0b3IgPCB0aGlzLm9wdGlvbnMudGltZXN0ZXApIHtcbiAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gdGhpcy5vcHRpb25zLnRpbWVzdGVwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIHRoZSB0aW1lc3RlcCB3YXMgbGFyZ2VyIHRoYW4gMiB0aW1lcyB0aGUgb3B0aW9uIG9uZSB3ZSBjaGVjayB0aGUgYWRhcHRpdml0eSBhZ2FpbiB0byBlbnN1cmVcbiAgICAgICAgICAvLyB0aGF0IGxhcmdlIGluc3RhYmlsaXRpZXMgZG8gbm90IGZvcm0uXG4gICAgICAgICAgdGhpcy5hZGFwdGl2ZUNvdW50ZXIgPSAtMTsgLy8gY2hlY2sgYWdhaW4gbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gTWF0aC5tYXgodGhpcy5vcHRpb25zLnRpbWVzdGVwLCB0aGlzLnRpbWVzdGVwIC8gZmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc2luZ2xlIHNpbXVsYXRpb24gc3RlcCAob3IgJ3RpY2snKSBpbiB0aGUgcGh5c2ljcyBzaW11bGF0aW9uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInBoeXNpY3NUaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBoeXNpY3NUaWNrKCkge1xuICAgICAgdGhpcy5fc3RhcnRTdGFiaWxpemluZygpOyAvLyB0aGlzIGVuc3VyZXMgdGhhdCB0aGVyZSBpcyBubyBzdGFydCBldmVudCB3aGVuIHRoZSBuZXR3b3JrIGlzIGFscmVhZHkgc3RhYmxlLlxuICAgICAgaWYgKHRoaXMuc3RhYmlsaXplZCA9PT0gdHJ1ZSkgcmV0dXJuO1xuXG4gICAgICAvLyBhZGFwdGl2aXR5IG1lYW5zIHRoZSB0aW1lc3RlcCBhZGFwdHMgdG8gdGhlIHNpdHVhdGlvbiwgb25seSBhcHBsaWNhYmxlIGZvciBzdGFiaWxpemF0aW9uXG4gICAgICBpZiAodGhpcy5hZGFwdGl2ZVRpbWVzdGVwID09PSB0cnVlICYmIHRoaXMuYWRhcHRpdmVUaW1lc3RlcEVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gdGltZXN0ZXAgcmVtYWlucyBzdGFibGUgZm9yIFwiaW50ZXJ2YWxcIiBpdGVyYXRpb25zLlxuICAgICAgICB2YXIgZG9BZGFwdGl2ZSA9IHRoaXMuYWRhcHRpdmVDb3VudGVyICUgdGhpcy5hZGFwdGl2ZUludGVydmFsID09PSAwO1xuICAgICAgICBpZiAoZG9BZGFwdGl2ZSkge1xuICAgICAgICAgIC8vIGZpcnN0IHRoZSBiaWcgc3RlcCBhbmQgcmV2ZXJ0LlxuICAgICAgICAgIHRoaXMudGltZXN0ZXAgPSAyICogdGhpcy50aW1lc3RlcDtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NTdGVwKCk7XG4gICAgICAgICAgdGhpcy5yZXZlcnQoKTsgLy8gc2F2ZXMgdGhlIHJlZmVyZW5jZSBzdGF0ZVxuXG4gICAgICAgICAgLy8gbm93IHRoZSBub3JtYWwgc3RlcC4gU2luY2UgdGhpcyBpcyB0aGUgbGFzdCBzdGVwLCBpdCBpcyB0aGUgbW9yZSBzdGFibGUgb25lIGFuZCB3ZSB3aWxsIHRha2UgdGhpcy5cbiAgICAgICAgICB0aGlzLnRpbWVzdGVwID0gMC41ICogdGhpcy50aW1lc3RlcDtcblxuICAgICAgICAgIC8vIHNpbmNlIGl0J3MgaGFsZiB0aGUgc3RlcCwgd2UgZG8gaXQgdHdpY2UuXG4gICAgICAgICAgdGhpcy5waHlzaWNzU3RlcCgpO1xuICAgICAgICAgIHRoaXMucGh5c2ljc1N0ZXAoKTtcbiAgICAgICAgICB0aGlzLmFkanVzdFRpbWVTdGVwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5waHlzaWNzU3RlcCgpOyAvLyBub3JtYWwgc3RlcCwga2VlcGluZyB0aW1lc3RlcCBjb25zdGFudFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGFwdGl2ZUNvdW50ZXIgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNhc2UgZm9yIHRoZSBzdGF0aWMgdGltZXN0ZXAsIHdlIHJlc2V0IGl0IHRvIHRoZSBvbmUgaW4gb3B0aW9ucyBhbmQgdGFrZSBhIG5vcm1hbCBzdGVwLlxuICAgICAgICB0aGlzLnRpbWVzdGVwID0gdGhpcy5vcHRpb25zLnRpbWVzdGVwO1xuICAgICAgICB0aGlzLnBoeXNpY3NTdGVwKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zdGFiaWxpemVkID09PSB0cnVlKSB0aGlzLnJldmVydCgpO1xuICAgICAgdGhpcy5zdGFiaWxpemF0aW9uSXRlcmF0aW9ucysrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vZGVzIGFuZCBlZGdlcyBjYW4gaGF2ZSB0aGUgcGh5c2ljcyB0b2dnbGVzIG9uIG9yIG9mZi4gQSBjb2xsZWN0aW9uIG9mIGluZGljZXMgaXMgY3JlYXRlZCBoZXJlIHNvIHdlIGNhbiBza2lwIHRoZSBjaGVjayBhbGwgdGhlIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVBoeXNpY3NEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVBoeXNpY3NEYXRhKCkge1xuICAgICAgdGhpcy5waHlzaWNzQm9keS5mb3JjZXMgPSB7fTtcbiAgICAgIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzID0gW107XG4gICAgICB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NFZGdlSW5kaWNlcyA9IFtdO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5ib2R5LmVkZ2VzO1xuXG4gICAgICAvLyBnZXQgbm9kZSBpbmRpY2VzIGZvciBwaHlzaWNzXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgIGlmIChub2Rlc1tub2RlSWRdLm9wdGlvbnMucGh5c2ljcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMucHVzaChub2Rlc1tub2RlSWRdLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IGVkZ2UgaW5kaWNlcyBmb3IgcGh5c2ljc1xuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIGVkZ2VzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZWRnZXMsIGVkZ2VJZCkpIHtcbiAgICAgICAgICBpZiAoZWRnZXNbZWRnZUlkXS5vcHRpb25zLnBoeXNpY3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc0VkZ2VJbmRpY2VzLnB1c2goZWRnZXNbZWRnZUlkXS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCB0aGUgdmVsb2NpdHkgYW5kIHRoZSBmb3JjZXMgdmVjdG9yXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGh5c2ljc0JvZHkucGh5c2ljc05vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfbm9kZUlkID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXNbaV07XG4gICAgICAgIHRoaXMucGh5c2ljc0JvZHkuZm9yY2VzW19ub2RlSWRdID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGZvcmNlcyBjYW4gYmUgcmVzZXQgYmVjYXVzZSB0aGV5IGFyZSByZWNhbGN1bGF0ZWQuIFZlbG9jaXRpZXMgaGF2ZSB0byBwZXJzaXN0LlxuICAgICAgICBpZiAodGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW19ub2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXNbX25vZGVJZF0gPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY2xlYW4gZGVsZXRlZCBub2RlcyBmcm9tIHRoZSB2ZWxvY2l0eSB2ZWN0b3JcbiAgICAgIGZvciAodmFyIF9ub2RlSWQyIGluIHRoaXMucGh5c2ljc0JvZHkudmVsb2NpdGllcykge1xuICAgICAgICBpZiAobm9kZXNbX25vZGVJZDJdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW19ub2RlSWQyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydCB0aGUgc2ltdWxhdGlvbiBvbmUgc3RlcC4gVGhpcyBpcyBkb25lIHNvIGFmdGVyIHN0YWJpbGl6YXRpb24sIGV2ZXJ5IG5ldyBzdGFydCBvZiB0aGUgc2ltdWxhdGlvbiB3aWxsIGFsc28gc2F5IHN0YWJpbGl6ZWQuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmV2ZXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJldmVydCgpIHtcbiAgICAgIHZhciBub2RlSWRzID0gX09iamVjdCRrZXlzKHRoaXMucHJldmlvdXNTdGF0ZXMpO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIHZlbG9jaXRpZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnZlbG9jaXRpZXM7XG4gICAgICB0aGlzLnJlZmVyZW5jZVN0YXRlID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGVJZHNbaV07XG4gICAgICAgIGlmIChub2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAobm9kZXNbbm9kZUlkXS5vcHRpb25zLnBoeXNpY3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVmZXJlbmNlU3RhdGVbbm9kZUlkXSA9IHtcbiAgICAgICAgICAgICAgcG9zaXRpb25zOiB7XG4gICAgICAgICAgICAgICAgeDogbm9kZXNbbm9kZUlkXS54LFxuICAgICAgICAgICAgICAgIHk6IG5vZGVzW25vZGVJZF0ueVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmVsb2NpdGllc1tub2RlSWRdLnggPSB0aGlzLnByZXZpb3VzU3RhdGVzW25vZGVJZF0udng7XG4gICAgICAgICAgICB2ZWxvY2l0aWVzW25vZGVJZF0ueSA9IHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXS52eTtcbiAgICAgICAgICAgIG5vZGVzW25vZGVJZF0ueCA9IHRoaXMucHJldmlvdXNTdGF0ZXNbbm9kZUlkXS54O1xuICAgICAgICAgICAgbm9kZXNbbm9kZUlkXS55ID0gdGhpcy5wcmV2aW91c1N0YXRlc1tub2RlSWRdLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnByZXZpb3VzU3RhdGVzW25vZGVJZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGNvbXBhcmVzIHRoZSByZWZlcmVuY2Ugc3RhdGUgdG8gdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2V2YWx1YXRlU3RlcFF1YWxpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V2YWx1YXRlU3RlcFF1YWxpdHkoKSB7XG4gICAgICB2YXIgZHgsIGR5LCBkcG9zO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdmFyIHJlZmVyZW5jZSA9IHRoaXMucmVmZXJlbmNlU3RhdGU7XG4gICAgICB2YXIgcG9zVGhyZXNob2xkID0gMC4zO1xuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMucmVmZXJlbmNlU3RhdGUpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnJlZmVyZW5jZVN0YXRlLCBub2RlSWQpICYmIG5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGR4ID0gbm9kZXNbbm9kZUlkXS54IC0gcmVmZXJlbmNlW25vZGVJZF0ucG9zaXRpb25zLng7XG4gICAgICAgICAgZHkgPSBub2Rlc1tub2RlSWRdLnkgLSByZWZlcmVuY2Vbbm9kZUlkXS5wb3NpdGlvbnMueTtcbiAgICAgICAgICBkcG9zID0gTWF0aC5zcXJ0KE1hdGgucG93KGR4LCAyKSArIE1hdGgucG93KGR5LCAyKSk7XG4gICAgICAgICAgaWYgKGRwb3MgPiBwb3NUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1vdmUgdGhlIG5vZGVzIG9uZSB0aW1lc3RlcCBhbmQgY2hlY2sgaWYgdGhleSBhcmUgc3RhYmlsaXplZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm1vdmVOb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlTm9kZXMoKSB7XG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcztcbiAgICAgIHZhciBtYXhOb2RlVmVsb2NpdHkgPSAwO1xuICAgICAgdmFyIGF2ZXJhZ2VOb2RlVmVsb2NpdHkgPSAwO1xuXG4gICAgICAvLyB0aGUgdmVsb2NpdHkgdGhyZXNob2xkIChlbmVyZ3kgaW4gdGhlIHN5c3RlbSkgZm9yIHRoZSBhZGFwdGl2aXR5IHRvZ2dsZVxuICAgICAgdmFyIHZlbG9jaXR5QWRhcHRpdmVUaHJlc2hvbGQgPSA1O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZUlkID0gbm9kZUluZGljZXNbaV07XG4gICAgICAgIHZhciBub2RlVmVsb2NpdHkgPSB0aGlzLl9wZXJmb3JtU3RlcChub2RlSWQpO1xuICAgICAgICAvLyBzdGFiaWxpemVkIGlzIHRydWUgaWYgc3RhYmlsaXplZCBpcyB0cnVlIGFuZCB2ZWxvY2l0eSBpcyBzbWFsbGVyIHRoYW4gdm1pbiAtLT4gYWxsIG5vZGVzIG11c3QgYmUgc3RhYmlsaXplZFxuICAgICAgICBtYXhOb2RlVmVsb2NpdHkgPSBNYXRoLm1heChtYXhOb2RlVmVsb2NpdHksIG5vZGVWZWxvY2l0eSk7XG4gICAgICAgIGF2ZXJhZ2VOb2RlVmVsb2NpdHkgKz0gbm9kZVZlbG9jaXR5O1xuICAgICAgfVxuXG4gICAgICAvLyBldmFsdWF0aW5nIHRoZSBzdGFiaWxpemVkIGFuZCBhZGFwdGl2ZVRpbWVzdGVwRW5hYmxlZCBjb25kaXRpb25zXG4gICAgICB0aGlzLmFkYXB0aXZlVGltZXN0ZXBFbmFibGVkID0gYXZlcmFnZU5vZGVWZWxvY2l0eSAvIG5vZGVJbmRpY2VzLmxlbmd0aCA8IHZlbG9jaXR5QWRhcHRpdmVUaHJlc2hvbGQ7XG4gICAgICB0aGlzLnN0YWJpbGl6ZWQgPSBtYXhOb2RlVmVsb2NpdHkgPCB0aGlzLm9wdGlvbnMubWluVmVsb2NpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIG5ldyB2ZWxvY2l0eSBmb3IgYSBjb29yZGluYXRlIGRpcmVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHYgIHZlbG9jaXR5IGZvciBjdXJyZW50IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZiAgcmVndWxhciBmb3JjZSBmb3IgY3VycmVudCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG0gIG1hc3Mgb2YgY3VycmVudCBub2RlXG4gICAgICogQHJldHVybnMge251bWJlcn0gbmV3IHZlbG9jaXR5IGZvciBjdXJyZW50IGNvb3JkaW5hdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNhbGN1bGF0ZUNvbXBvbmVudFZlbG9jaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUNvbXBvbmVudFZlbG9jaXR5KHYsIGYsIG0pIHtcbiAgICAgIHZhciBkZiA9IHRoaXMubW9kZWxPcHRpb25zLmRhbXBpbmcgKiB2OyAvLyBkYW1waW5nIGZvcmNlXG4gICAgICB2YXIgYSA9IChmIC0gZGYpIC8gbTsgLy8gYWNjZWxlcmF0aW9uXG5cbiAgICAgIHYgKz0gYSAqIHRoaXMudGltZXN0ZXA7XG5cbiAgICAgIC8vIFB1dCBhIGxpbWl0IG9uIHRoZSB2ZWxvY2l0aWVzIGlmIGl0IGlzIHJlYWxseSBoaWdoXG4gICAgICB2YXIgbWF4ViA9IHRoaXMub3B0aW9ucy5tYXhWZWxvY2l0eSB8fCAxZTk7XG4gICAgICBpZiAoTWF0aC5hYnModikgPiBtYXhWKSB7XG4gICAgICAgIHYgPSB2ID4gMCA/IG1heFYgOiAtbWF4VjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gdGhlIGFjdHVhbCBzdGVwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBuZXcgdmVsb2NpdHkgb2YgZ2l2ZW4gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BlcmZvcm1TdGVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtU3RlcChub2RlSWQpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICB2YXIgZm9yY2UgPSB0aGlzLnBoeXNpY3NCb2R5LmZvcmNlc1tub2RlSWRdO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy53aW5kKSB7XG4gICAgICAgIGZvcmNlLnggKz0gdGhpcy5vcHRpb25zLndpbmQueDtcbiAgICAgICAgZm9yY2UueSArPSB0aGlzLm9wdGlvbnMud2luZC55O1xuICAgICAgfVxuICAgICAgdmFyIHZlbG9jaXR5ID0gdGhpcy5waHlzaWNzQm9keS52ZWxvY2l0aWVzW25vZGVJZF07XG5cbiAgICAgIC8vIHN0b3JlIHRoZSBzdGF0ZSBzbyB3ZSBjYW4gcmV2ZXJ0XG4gICAgICB0aGlzLnByZXZpb3VzU3RhdGVzW25vZGVJZF0gPSB7XG4gICAgICAgIHg6IG5vZGUueCxcbiAgICAgICAgeTogbm9kZS55LFxuICAgICAgICB2eDogdmVsb2NpdHkueCxcbiAgICAgICAgdnk6IHZlbG9jaXR5LnlcbiAgICAgIH07XG4gICAgICBpZiAobm9kZS5vcHRpb25zLmZpeGVkLnggPT09IGZhbHNlKSB7XG4gICAgICAgIHZlbG9jaXR5LnggPSB0aGlzLmNhbGN1bGF0ZUNvbXBvbmVudFZlbG9jaXR5KHZlbG9jaXR5LngsIGZvcmNlLngsIG5vZGUub3B0aW9ucy5tYXNzKTtcbiAgICAgICAgbm9kZS54ICs9IHZlbG9jaXR5LnggKiB0aGlzLnRpbWVzdGVwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yY2UueCA9IDA7XG4gICAgICAgIHZlbG9jaXR5LnggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUub3B0aW9ucy5maXhlZC55ID09PSBmYWxzZSkge1xuICAgICAgICB2ZWxvY2l0eS55ID0gdGhpcy5jYWxjdWxhdGVDb21wb25lbnRWZWxvY2l0eSh2ZWxvY2l0eS55LCBmb3JjZS55LCBub2RlLm9wdGlvbnMubWFzcyk7XG4gICAgICAgIG5vZGUueSArPSB2ZWxvY2l0eS55ICogdGhpcy50aW1lc3RlcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcmNlLnkgPSAwO1xuICAgICAgICB2ZWxvY2l0eS55ID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciB0b3RhbFZlbG9jaXR5ID0gTWF0aC5zcXJ0KE1hdGgucG93KHZlbG9jaXR5LngsIDIpICsgTWF0aC5wb3codmVsb2NpdHkueSwgMikpO1xuICAgICAgcmV0dXJuIHRvdGFsVmVsb2NpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBpbml0aWFsaXppbmcgYW5kIHN0YWJpbGl6aW5nLCB3ZSBjYW4gZnJlZXplIG5vZGVzIHdpdGggYSBwcmVkZWZpbmVkIHBvc2l0aW9uLlxuICAgICAqIFRoaXMgZ3JlYXRseSBzcGVlZHMgdXAgc3RhYmlsaXphdGlvbiBiZWNhdXNlIG9ubHkgdGhlIHN1cHBvcnRub2RlcyBmb3IgdGhlIHNtb290aEN1cnZlcyBoYXZlIHRvIHNldHRsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZyZWV6ZU5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9mcmVlemVOb2RlcygpIHtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIGZvciAodmFyIGlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZXMsIGlkKSkge1xuICAgICAgICAgIGlmIChub2Rlc1tpZF0ueCAmJiBub2Rlc1tpZF0ueSkge1xuICAgICAgICAgICAgdmFyIGZpeGVkID0gbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQ7XG4gICAgICAgICAgICB0aGlzLmZyZWV6ZUNhY2hlW2lkXSA9IHtcbiAgICAgICAgICAgICAgeDogZml4ZWQueCxcbiAgICAgICAgICAgICAgeTogZml4ZWQueVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZpeGVkLnggPSB0cnVlO1xuICAgICAgICAgICAgZml4ZWQueSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5mcmVlemVzIHRoZSBub2RlcyB0aGF0IGhhdmUgYmVlbiBmcm96ZW4gYnkgX2ZyZWV6ZURlZmluZWROb2Rlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc3RvcmVGcm96ZW5Ob2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzdG9yZUZyb3plbk5vZGVzKCkge1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgZm9yICh2YXIgaWQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2RlcywgaWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZnJlZXplQ2FjaGVbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGVzW2lkXS5vcHRpb25zLmZpeGVkLnggPSB0aGlzLmZyZWV6ZUNhY2hlW2lkXS54O1xuICAgICAgICAgICAgbm9kZXNbaWRdLm9wdGlvbnMuZml4ZWQueSA9IHRoaXMuZnJlZXplQ2FjaGVbaWRdLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmZyZWV6ZUNhY2hlID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIHN0YWJsZSBwb3NpdGlvbiBmb3IgYWxsIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2l0ZXJhdGlvbnM9dGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uaXRlcmF0aW9uc11cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzdGFiaWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhYmlsaXplKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uaXRlcmF0aW9ucztcbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0aW9ucyAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICBpdGVyYXRpb25zID0gdGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uaXRlcmF0aW9ucztcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRoZSBzdGFiaWxpemUgbWV0aG9kIG5lZWRzIGEgbnVtZXJpYyBhbW91bnQgb2YgaXRlcmF0aW9ucy4gU3dpdGNoaW5nIHRvIGRlZmF1bHQ6IFwiLCBpdGVyYXRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBoeXNpY3NCb2R5LnBoeXNpY3NOb2RlSW5kaWNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gZW5hYmxlIGFkYXB0aXZlIHRpbWVzdGVwc1xuICAgICAgdGhpcy5hZGFwdGl2ZVRpbWVzdGVwID0gdGhpcy5vcHRpb25zLmFkYXB0aXZlVGltZXN0ZXA7XG5cbiAgICAgIC8vIHRoaXMgc2V0cyB0aGUgd2lkdGggb2YgYWxsIG5vZGVzIGluaXRpYWxseSB3aGljaCBjb3VsZCBiZSByZXF1aXJlZCBmb3IgdGhlIGF2b2lkT3ZlcmxhcFxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNpemVOb2Rlc1wiKTtcbiAgICAgIHRoaXMuc3RvcFNpbXVsYXRpb24oKTsgLy8gc3RvcCB0aGUgcmVuZGVyIGxvb3BcbiAgICAgIHRoaXMuc3RhYmlsaXplZCA9IGZhbHNlO1xuXG4gICAgICAvLyBibG9jayByZWRyYXcgcmVxdWVzdHNcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfYmxvY2tSZWRyYXdcIik7XG4gICAgICB0aGlzLnRhcmdldEl0ZXJhdGlvbnMgPSBpdGVyYXRpb25zO1xuXG4gICAgICAvLyBzdGFydCB0aGUgc3RhYmlsaXphdGlvblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGFiaWxpemF0aW9uLm9ubHlEeW5hbWljRWRnZXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fZnJlZXplTm9kZXMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMgPSAwO1xuICAgICAgX3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMzLl9zdGFiaWxpemF0aW9uQmF0Y2goKTtcbiAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIG5vdCBhbHJlYWR5IHN0YWJpbGl6aW5nLCBzdGFydCBpdCBhbmQgZW1pdCBhIHN0YXJ0IGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgc3RhYmlsaXphdGlvbiBzdGFydGVkIHdpdGggdGhpcyBjYWxsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfc3RhcnRTdGFiaWxpemluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhcnRTdGFiaWxpemluZygpIHtcbiAgICAgIGlmICh0aGlzLnN0YXJ0ZWRTdGFiaWxpemF0aW9uID09PSB0cnVlKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTdGFiaWxpemluZ1wiKTtcbiAgICAgIHRoaXMuc3RhcnRlZFN0YWJpbGl6YXRpb24gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT25lIGJhdGNoIG9mIHN0YWJpbGl6YXRpb25cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0YWJpbGl6YXRpb25CYXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3RhYmlsaXphdGlvbkJhdGNoKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICB2YXIgcnVubmluZyA9IGZ1bmN0aW9uIHJ1bm5pbmcoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuc3RhYmlsaXplZCA9PT0gZmFsc2UgJiYgX3RoaXM0LnN0YWJpbGl6YXRpb25JdGVyYXRpb25zIDwgX3RoaXM0LnRhcmdldEl0ZXJhdGlvbnM7XG4gICAgICB9O1xuICAgICAgdmFyIHNlbmRQcm9ncmVzcyA9IGZ1bmN0aW9uIHNlbmRQcm9ncmVzcygpIHtcbiAgICAgICAgX3RoaXM0LmJvZHkuZW1pdHRlci5lbWl0KFwic3RhYmlsaXphdGlvblByb2dyZXNzXCIsIHtcbiAgICAgICAgICBpdGVyYXRpb25zOiBfdGhpczQuc3RhYmlsaXphdGlvbkl0ZXJhdGlvbnMsXG4gICAgICAgICAgdG90YWw6IF90aGlzNC50YXJnZXRJdGVyYXRpb25zXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLl9zdGFydFN0YWJpbGl6aW5nKCkpIHtcbiAgICAgICAgc2VuZFByb2dyZXNzKCk7IC8vIEVuc3VyZSB0aGF0IHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBzdGFydCBldmVudC5cbiAgICAgIH1cblxuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIHdoaWxlIChydW5uaW5nKCkgJiYgY291bnQgPCB0aGlzLm9wdGlvbnMuc3RhYmlsaXphdGlvbi51cGRhdGVJbnRlcnZhbCkge1xuICAgICAgICB0aGlzLnBoeXNpY3NUaWNrKCk7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgICBzZW5kUHJvZ3Jlc3MoKTtcbiAgICAgIGlmIChydW5uaW5nKCkpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MjtcbiAgICAgICAgX3NldFRpbWVvdXQoX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQyID0gdGhpcy5fc3RhYmlsaXphdGlvbkJhdGNoKS5jYWxsKF9jb250ZXh0MiwgdGhpcyksIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZmluYWxpemVTdGFiaWxpemF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV3JhcCB1cCB0aGUgc3RhYmlsaXphdGlvbiwgZml0IGFuZCBlbWl0IHRoZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9maW5hbGl6ZVN0YWJpbGl6YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmFsaXplU3RhYmlsaXphdGlvbigpIHtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfYWxsb3dSZWRyYXdcIik7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24uZml0ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJmaXRcIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnN0YWJpbGl6YXRpb24ub25seUR5bmFtaWNFZGdlcyA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9yZXN0b3JlRnJvemVuTm9kZXMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFiaWxpemF0aW9uSXRlcmF0aW9uc0RvbmVcIik7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICBpZiAodGhpcy5zdGFiaWxpemVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuX2VtaXRTdGFiaWxpemVkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0YXJ0U2ltdWxhdGlvbigpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIERFQlVHR0lORyBCRUxPVyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqIERlYnVnIGZ1bmN0aW9uIHRoYXQgZGlzcGxheSBhcnJvd3MgZm9yIHRoZSBmb3JjZXMgY3VycmVudGx5IGFjdGl2ZSBpbiB0aGUgbmV0d29yay5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIHdoZW4gZGVidWdnaW5nIG9ubHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZHJhd0ZvcmNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd0ZvcmNlcyhjdHgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5waHlzaWNzQm9keS5waHlzaWNzTm9kZUluZGljZXNbaV07XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW2luZGV4XTtcbiAgICAgICAgdmFyIGZvcmNlID0gdGhpcy5waHlzaWNzQm9keS5mb3JjZXNbaW5kZXhdO1xuICAgICAgICB2YXIgZmFjdG9yID0gMjA7XG4gICAgICAgIHZhciBjb2xvckZhY3RvciA9IDAuMDM7XG4gICAgICAgIHZhciBmb3JjZVNpemUgPSBNYXRoLnNxcnQoTWF0aC5wb3coZm9yY2UueCwgMikgKyBNYXRoLnBvdyhmb3JjZS54LCAyKSk7XG4gICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oTWF0aC5tYXgoNSwgZm9yY2VTaXplKSwgMTUpO1xuICAgICAgICB2YXIgYXJyb3dTaXplID0gMyAqIHNpemU7XG4gICAgICAgIHZhciBjb2xvciA9IEhTVlRvSGV4KCgxODAgLSBNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBjb2xvckZhY3RvciAqIGZvcmNlU2l6ZSkpICogMTgwKSAvIDM2MCwgMSwgMSk7XG4gICAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgICB4OiBub2RlLnggKyBmYWN0b3IgKiBmb3JjZS54LFxuICAgICAgICAgIHk6IG5vZGUueSArIGZhY3RvciAqIGZvcmNlLnlcbiAgICAgICAgfTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHNpemU7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8obm9kZS54LCBub2RlLnkpO1xuICAgICAgICBjdHgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoZm9yY2UueSwgZm9yY2UueCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgRW5kUG9pbnRzLmRyYXcoY3R4LCB7XG4gICAgICAgICAgdHlwZTogXCJhcnJvd1wiLFxuICAgICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgICBhbmdsZTogYW5nbGUsXG4gICAgICAgICAgbGVuZ3RoOiBhcnJvd1NpemVcbiAgICAgICAgfSk7XG4gICAgICAgIF9maWxsSW5zdGFuY2VQcm9wZXJ0eShjdHgpLmNhbGwoY3R4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFBoeXNpY3NFbmdpbmU7XG59KCk7XG5cbi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxubGV0IGdldFJhbmRvbVZhbHVlcztcbmNvbnN0IHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZnVuY3Rpb24gcm5nKCkge1xuICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uXG4gICAgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKTtcblxuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59XG5cbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuXG5jb25zdCBieXRlVG9IZXggPSBbXTtcblxuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc2xpY2UoMSkpO1xufVxuXG5mdW5jdGlvbiB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICByZXR1cm4gYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV07XG59XG5cbmNvbnN0IHJhbmRvbVVVSUQgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tVVVJRCAmJiBjcnlwdG8ucmFuZG9tVVVJRC5iaW5kKGNyeXB0byk7XG52YXIgbmF0aXZlID0ge1xuICByYW5kb21VVUlEXG59O1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBpZiAobmF0aXZlLnJhbmRvbVVVSUQgJiYgIWJ1ZiAmJiAhb3B0aW9ucykge1xuICAgIHJldHVybiBuYXRpdmUucmFuZG9tVVVJRCgpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cbiAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDsgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG5cbiAgaWYgKGJ1Zikge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICByZXR1cm4gdW5zYWZlU3RyaW5naWZ5KHJuZHMpO1xufVxuXG4vKipcbiAqIFV0aWxpdHkgQ2xhc3NcbiAqL1xudmFyIE5ldHdvcmtVdGlsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIE5ldHdvcmtVdGlsKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOZXR3b3JrVXRpbCk7XG4gIH1cblxuICAvKipcbiAgICogRmluZCB0aGUgY2VudGVyIHBvc2l0aW9uIG9mIHRoZSBuZXR3b3JrIGNvbnNpZGVyaW5nIHRoZSBib3VuZGluZyBib3hlc1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gYWxsTm9kZXNcbiAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IFtzcGVjaWZpY05vZGVzPVtdXVxuICAgKiBAcmV0dXJucyB7e21pblg6IG51bWJlciwgbWF4WDogbnVtYmVyLCBtaW5ZOiBudW1iZXIsIG1heFk6IG51bWJlcn19XG4gICAqIEBzdGF0aWNcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhOZXR3b3JrVXRpbCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZ2V0UmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2UoYWxsTm9kZXMpIHtcbiAgICAgIHZhciBzcGVjaWZpY05vZGVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTtcbiAgICAgIHZhciBtaW5ZID0gMWU5LFxuICAgICAgICBtYXhZID0gLTFlOSxcbiAgICAgICAgbWluWCA9IDFlOSxcbiAgICAgICAgbWF4WCA9IC0xZTksXG4gICAgICAgIG5vZGU7XG4gICAgICBpZiAoc3BlY2lmaWNOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BlY2lmaWNOb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGUgPSBhbGxOb2Rlc1tzcGVjaWZpY05vZGVzW2ldXTtcbiAgICAgICAgICBpZiAobWluWCA+IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gubGVmdCkge1xuICAgICAgICAgICAgbWluWCA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gubGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1heFggPCBub2RlLnNoYXBlLmJvdW5kaW5nQm94LnJpZ2h0KSB7XG4gICAgICAgICAgICBtYXhYID0gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5yaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1pblkgPiBub2RlLnNoYXBlLmJvdW5kaW5nQm94LnRvcCkge1xuICAgICAgICAgICAgbWluWSA9IG5vZGUuc2hhcGUuYm91bmRpbmdCb3gudG9wO1xuICAgICAgICAgIH0gLy8gdG9wIGlzIG5lZ2F0aXZlLCBib3R0b20gaXMgcG9zaXRpdmVcbiAgICAgICAgICBpZiAobWF4WSA8IG5vZGUuc2hhcGUuYm91bmRpbmdCb3guYm90dG9tKSB7XG4gICAgICAgICAgICBtYXhZID0gbm9kZS5zaGFwZS5ib3VuZGluZ0JveC5ib3R0b207XG4gICAgICAgICAgfSAvLyB0b3AgaXMgbmVnYXRpdmUsIGJvdHRvbSBpcyBwb3NpdGl2ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW5YID09PSAxZTkgJiYgbWF4WCA9PT0gLTFlOSAmJiBtaW5ZID09PSAxZTkgJiYgbWF4WSA9PT0gLTFlOSkge1xuICAgICAgICBtaW5ZID0gMCwgbWF4WSA9IDAsIG1pblggPSAwLCBtYXhYID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pblg6IG1pblgsXG4gICAgICAgIG1heFg6IG1heFgsXG4gICAgICAgIG1pblk6IG1pblksXG4gICAgICAgIG1heFk6IG1heFlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgY2VudGVyIHBvc2l0aW9uIG9mIHRoZSBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gYWxsTm9kZXNcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gW3NwZWNpZmljTm9kZXM9W11dXG4gICAgICogQHJldHVybnMge3ttaW5YOiBudW1iZXIsIG1heFg6IG51bWJlciwgbWluWTogbnVtYmVyLCBtYXhZOiBudW1iZXJ9fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRSYW5nZUNvcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2VDb3JlKGFsbE5vZGVzKSB7XG4gICAgICB2YXIgc3BlY2lmaWNOb2RlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgICB2YXIgbWluWSA9IDFlOSxcbiAgICAgICAgbWF4WSA9IC0xZTksXG4gICAgICAgIG1pblggPSAxZTksXG4gICAgICAgIG1heFggPSAtMWU5LFxuICAgICAgICBub2RlO1xuICAgICAgaWYgKHNwZWNpZmljTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwZWNpZmljTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gYWxsTm9kZXNbc3BlY2lmaWNOb2Rlc1tpXV07XG4gICAgICAgICAgaWYgKG1pblggPiBub2RlLngpIHtcbiAgICAgICAgICAgIG1pblggPSBub2RlLng7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXhYIDwgbm9kZS54KSB7XG4gICAgICAgICAgICBtYXhYID0gbm9kZS54O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWluWSA+IG5vZGUueSkge1xuICAgICAgICAgICAgbWluWSA9IG5vZGUueTtcbiAgICAgICAgICB9IC8vIHRvcCBpcyBuZWdhdGl2ZSwgYm90dG9tIGlzIHBvc2l0aXZlXG4gICAgICAgICAgaWYgKG1heFkgPCBub2RlLnkpIHtcbiAgICAgICAgICAgIG1heFkgPSBub2RlLnk7XG4gICAgICAgICAgfSAvLyB0b3AgaXMgbmVnYXRpdmUsIGJvdHRvbSBpcyBwb3NpdGl2ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtaW5YID09PSAxZTkgJiYgbWF4WCA9PT0gLTFlOSAmJiBtaW5ZID09PSAxZTkgJiYgbWF4WSA9PT0gLTFlOSkge1xuICAgICAgICBtaW5ZID0gMCwgbWF4WSA9IDAsIG1pblggPSAwLCBtYXhYID0gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pblg6IG1pblgsXG4gICAgICAgIG1heFg6IG1heFgsXG4gICAgICAgIG1pblk6IG1pblksXG4gICAgICAgIG1heFk6IG1heFlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHJhbmdlID0ge21pblg6IG1pblgsIG1heFg6IG1heFgsIG1pblk6IG1pblksIG1heFk6IG1heFl9O1xuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmaW5kQ2VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRDZW50ZXIocmFuZ2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IDAuNSAqIChyYW5nZS5tYXhYICsgcmFuZ2UubWluWCksXG4gICAgICAgIHk6IDAuNSAqIChyYW5nZS5tYXhZICsgcmFuZ2UubWluWSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyByZXR1cm5zIGEgY2xvbmUgb2YgdGhlIG9wdGlvbnMgb3Igb3B0aW9ucyBvZiB0aGUgZWRnZSBvciBub2RlIHRvIGJlIHVzZWQgZm9yIGNvbnN0cnVjdGlvbiBvZiBuZXcgZWRnZXMgb3IgY2hlY2sgZnVuY3Rpb25zIGZvciBuZXcgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5JdGVtfSBpdGVtXG4gICAgICogQHBhcmFtIHsnbm9kZSd8dW5kZWZpbmVkfSB0eXBlXG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqIEBzdGF0aWNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbG9uZU9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmVPcHRpb25zKGl0ZW0sIHR5cGUpIHtcbiAgICAgIHZhciBjbG9uZWRPcHRpb25zID0ge307XG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwibm9kZVwiKSB7XG4gICAgICAgIGRlZXBFeHRlbmQoY2xvbmVkT3B0aW9ucywgaXRlbS5vcHRpb25zLCB0cnVlKTtcbiAgICAgICAgY2xvbmVkT3B0aW9ucy54ID0gaXRlbS54O1xuICAgICAgICBjbG9uZWRPcHRpb25zLnkgPSBpdGVtLnk7XG4gICAgICAgIGNsb25lZE9wdGlvbnMuYW1vdW50T2ZDb25uZWN0aW9ucyA9IGl0ZW0uZWRnZXMubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVlcEV4dGVuZChjbG9uZWRPcHRpb25zLCBpdGVtLm9wdGlvbnMsIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lZE9wdGlvbnM7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOZXR3b3JrVXRpbDtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDEoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMSgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBfUmVmbGVjdCRjb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIV9SZWZsZWN0JGNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoX1JlZmxlY3QkY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKF9SZWZsZWN0JGNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLyoqXG4gKiBBIENsdXN0ZXIgaXMgYSBzcGVjaWFsIE5vZGUgdGhhdCBhbGxvd3MgYSBncm91cCBvZiBOb2RlcyBwb3NpdGlvbmVkIGNsb3NlbHkgdG9nZXRoZXJcbiAqIHRvIGJlIHJlcHJlc2VudGVkIGJ5IGEgc2luZ2xlIENsdXN0ZXIgTm9kZS5cbiAqXG4gKiBAYXVnbWVudHMgTm9kZVxuICovXG52YXIgQ2x1c3RlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGUpIHtcbiAgX2luaGVyaXRzKENsdXN0ZXIsIF9Ob2RlKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQxKENsdXN0ZXIpO1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtBcnJheS48SFRNTEltYWdlRWxlbWVudD59aW1hZ2VsaXN0XG4gICAqIEBwYXJhbSB7QXJyYXl9IGdyb3VwbGlzdFxuICAgKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsT3B0aW9uc1xuICAgKiBAcGFyYW0ge29iamVjdH0gZGVmYXVsdE9wdGlvbnMgICAgIEdsb2JhbCBkZWZhdWx0IG9wdGlvbnMgZm9yIG5vZGVzXG4gICAqL1xuICBmdW5jdGlvbiBDbHVzdGVyKG9wdGlvbnMsIGJvZHksIGltYWdlbGlzdCwgZ3JvdXBsaXN0LCBnbG9iYWxPcHRpb25zLCBkZWZhdWx0T3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2x1c3Rlcik7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zLCBib2R5LCBpbWFnZWxpc3QsIGdyb3VwbGlzdCwgZ2xvYmFsT3B0aW9ucywgZGVmYXVsdE9wdGlvbnMpO1xuICAgIF90aGlzLmlzQ2x1c3RlciA9IHRydWU7XG4gICAgX3RoaXMuY29udGFpbmVkTm9kZXMgPSB7fTtcbiAgICBfdGhpcy5jb250YWluZWRFZGdlcyA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2ZlciBjaGlsZCBjbHVzdGVyIGRhdGEgdG8gY3VycmVudCBhbmQgZGlzY29ubmVjdCB0aGUgY2hpbGQgY2x1c3Rlci5cbiAgICpcbiAgICogUGxlYXNlIGNvbnN1bHQgdGhlIGhlYWRlciBjb21tZW50IGluICdDbHVzdGVyaW5nLmpzJyBmb3IgdGhlIGZpZWxkcyBzZXQgaGVyZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBjaGlsZENsdXN0ZXJJZCAgaWQgb2YgY2hpbGQgY2x1c3RlciB0byBvcGVuXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoQ2x1c3RlciwgW3tcbiAgICBrZXk6IFwiX29wZW5DaGlsZENsdXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29wZW5DaGlsZENsdXN0ZXIoY2hpbGRDbHVzdGVySWQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIGNoaWxkQ2x1c3RlciA9IHRoaXMuYm9keS5ub2Rlc1tjaGlsZENsdXN0ZXJJZF07XG4gICAgICBpZiAodGhpcy5jb250YWluZWROb2Rlc1tjaGlsZENsdXN0ZXJJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub2RlIHdpdGggaWQ6IFwiICsgY2hpbGRDbHVzdGVySWQgKyBcIiBub3QgaW4gY3VycmVudCBjbHVzdGVyXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFjaGlsZENsdXN0ZXIuaXNDbHVzdGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vZGUgd2l0aCBpZDogXCIgKyBjaGlsZENsdXN0ZXJJZCArIFwiIGlzIG5vdCBhIGNsdXN0ZXJcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIERpc2Nvbm5lY3QgY2hpbGQgY2x1c3RlciBmcm9tIGN1cnJlbnQgY2x1c3RlclxuICAgICAgZGVsZXRlIHRoaXMuY29udGFpbmVkTm9kZXNbY2hpbGRDbHVzdGVySWRdO1xuICAgICAgZm9yRWFjaCQxKGNoaWxkQ2x1c3Rlci5lZGdlcywgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgZGVsZXRlIF90aGlzMi5jb250YWluZWRFZGdlc1tlZGdlLmlkXTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUcmFuc2ZlciBub2RlcyBhbmQgZWRnZXNcbiAgICAgIGZvckVhY2gkMShjaGlsZENsdXN0ZXIuY29udGFpbmVkTm9kZXMsIGZ1bmN0aW9uIChub2RlLCBub2RlSWQpIHtcbiAgICAgICAgX3RoaXMyLmNvbnRhaW5lZE5vZGVzW25vZGVJZF0gPSBub2RlO1xuICAgICAgfSk7XG4gICAgICBjaGlsZENsdXN0ZXIuY29udGFpbmVkTm9kZXMgPSB7fTtcbiAgICAgIGZvckVhY2gkMShjaGlsZENsdXN0ZXIuY29udGFpbmVkRWRnZXMsIGZ1bmN0aW9uIChlZGdlLCBlZGdlSWQpIHtcbiAgICAgICAgX3RoaXMyLmNvbnRhaW5lZEVkZ2VzW2VkZ2VJZF0gPSBlZGdlO1xuICAgICAgfSk7XG4gICAgICBjaGlsZENsdXN0ZXIuY29udGFpbmVkRWRnZXMgPSB7fTtcblxuICAgICAgLy8gVHJhbnNmZXIgZWRnZXMgd2l0aGluIGNsdXN0ZXIgZWRnZXMgd2hpY2ggYXJlIGNsdXN0ZXJlZFxuICAgICAgZm9yRWFjaCQxKGNoaWxkQ2x1c3Rlci5lZGdlcywgZnVuY3Rpb24gKGNsdXN0ZXJFZGdlKSB7XG4gICAgICAgIGZvckVhY2gkMShfdGhpczIuZWRnZXMsIGZ1bmN0aW9uIChwYXJlbnRDbHVzdGVyRWRnZSkge1xuICAgICAgICAgIHZhciBfY29udGV4dCwgX2NvbnRleHQyO1xuICAgICAgICAgIC8vIEFzc3VtcHRpb246IGEgY2x1c3RlcmVkIGVkZ2UgY2FuIG9ubHkgYmUgcHJlc2VudCBpbiBhIHNpbmdsZSBjbHVzdGVyaW5nIGVkZ2VcbiAgICAgICAgICAvLyBOb3QgdGVzdGVkIGhlcmVcbiAgICAgICAgICB2YXIgaW5kZXggPSBfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQgPSBwYXJlbnRDbHVzdGVyRWRnZS5jbHVzdGVyaW5nRWRnZVJlcGxhY2luZ0lkcykuY2FsbChfY29udGV4dCwgY2x1c3RlckVkZ2UuaWQpO1xuICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybjtcbiAgICAgICAgICBmb3JFYWNoJDEoY2x1c3RlckVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMsIGZ1bmN0aW9uIChzcmNJZCkge1xuICAgICAgICAgICAgcGFyZW50Q2x1c3RlckVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMucHVzaChzcmNJZCk7XG5cbiAgICAgICAgICAgIC8vIE1haW50YWluIGNvcnJlY3QgYm9va2tlZXBpbmcgZm9yIHRyYW5zZmVycmVkIGVkZ2VcbiAgICAgICAgICAgIF90aGlzMi5ib2R5LmVkZ2VzW3NyY0lkXS5lZGdlUmVwbGFjZWRCeUlkID0gcGFyZW50Q2x1c3RlckVkZ2UuaWQ7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBSZW1vdmUgY2x1c3RlciBlZGdlIGZyb20gcGFyZW50IGNsdXN0ZXIgZWRnZVxuICAgICAgICAgIF9zcGxpY2VJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MiA9IHBhcmVudENsdXN0ZXJFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzKS5jYWxsKF9jb250ZXh0MiwgaW5kZXgsIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY2hpbGRDbHVzdGVyLmVkZ2VzID0gW107XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDbHVzdGVyO1xufShOb2RlKTtcblxuLyoqXG4gKiBUaGUgY2x1c3RlcmluZyBlbmdpbmVcbiAqL1xudmFyIENsdXN0ZXJFbmdpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICovXG4gIGZ1bmN0aW9uIENsdXN0ZXJFbmdpbmUoYm9keSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsdXN0ZXJFbmdpbmUpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5jbHVzdGVyZWROb2RlcyA9IHt9OyAvLyBrZXk6IG5vZGUgaWQsIHZhbHVlOiB7IGNsdXN0ZXJJZDogPGlkIG9mIGNsdXN0ZXI+LCBub2RlOiA8bm9kZSBpbnN0YW5jZT59XG4gICAgdGhpcy5jbHVzdGVyZWRFZGdlcyA9IHt9OyAvLyBrZXk6IGVkZ2UgaWQsIHZhbHVlOiByZXN0b3JlIGluZm9ybWF0aW9uIGZvciBnaXZlbiBlZGdlXG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge307XG4gICAgX09iamVjdCRhc3NpZ24odGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZXNldERhdGFcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuY2x1c3RlcmVkTm9kZXMgPSB7fTtcbiAgICAgIF90aGlzLmNsdXN0ZXJlZEVkZ2VzID0ge307XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGh1YnNpemVcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhDbHVzdGVyRW5naW5lLCBbe1xuICAgIGtleTogXCJjbHVzdGVyQnlIdWJzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXJCeUh1YnNpemUoaHVic2l6ZSwgb3B0aW9ucykge1xuICAgICAgaWYgKGh1YnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBodWJzaXplID0gdGhpcy5fZ2V0SHViU2l6ZSgpO1xuICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKGh1YnNpemUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9jaGVja09wdGlvbnMoaHVic2l6ZSk7XG4gICAgICAgIGh1YnNpemUgPSB0aGlzLl9nZXRIdWJTaXplKCk7XG4gICAgICB9XG4gICAgICB2YXIgbm9kZXNUb0NsdXN0ZXIgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV07XG4gICAgICAgIGlmIChub2RlLmVkZ2VzLmxlbmd0aCA+PSBodWJzaXplKSB7XG4gICAgICAgICAgbm9kZXNUb0NsdXN0ZXIucHVzaChub2RlLmlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGVzVG9DbHVzdGVyLmxlbmd0aDsgX2krKykge1xuICAgICAgICB0aGlzLmNsdXN0ZXJCeUNvbm5lY3Rpb24obm9kZXNUb0NsdXN0ZXJbX2ldLCBvcHRpb25zLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbG9vcCBvdmVyIGFsbCBub2RlcywgY2hlY2sgaWYgdGhleSBhZGhlcmUgdG8gdGhlIGNvbmRpdGlvbiBhbmQgY2x1c3RlciBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlZnJlc2hEYXRhPXRydWVdXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2x1c3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgY2x1c3RlckJ5Tm9kZURhdGEgd2l0aG91dCBhIGpvaW5Db25kaXRpb24gZnVuY3Rpb24gaW4gdGhlIG9wdGlvbnMuXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBpZiB0aGUgb3B0aW9ucyBvYmplY3QgaXMgZmluZSwgYXBwZW5kIGlmIG5lZWRlZFxuICAgICAgb3B0aW9ucyA9IHRoaXMuX2NoZWNrT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgIHZhciBjaGlsZE5vZGVzT2JqID0ge307XG4gICAgICB2YXIgY2hpbGRFZGdlc09iaiA9IHt9O1xuXG4gICAgICAvLyBjb2xsZWN0IHRoZSBub2RlcyB0aGF0IHdpbGwgYmUgaW4gdGhlIGNsdXN0ZXJcbiAgICAgIGZvckVhY2gkMSh0aGlzLmJvZHkubm9kZXMsIGZ1bmN0aW9uIChub2RlLCBub2RlSWQpIHtcbiAgICAgICAgaWYgKG5vZGUub3B0aW9ucyAmJiBvcHRpb25zLmpvaW5Db25kaXRpb24obm9kZS5vcHRpb25zKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNoaWxkTm9kZXNPYmpbbm9kZUlkXSA9IG5vZGU7XG5cbiAgICAgICAgICAvLyBjb2xsZWN0IHRoZSBlZGdlcyB0aGF0IHdpbGwgYmUgaW4gdGhlIGNsdXN0ZXJcbiAgICAgICAgICBmb3JFYWNoJDEobm9kZS5lZGdlcywgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczIuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9jbHVzdGVyKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIG9wdGlvbnMsIHJlZnJlc2hEYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbHVzdGVyIGFsbCBub2RlcyBpbiB0aGUgbmV0d29yayB0aGF0IGhhdmUgb25seSBYIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZWRnZUNvdW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWZyZXNoRGF0YT10cnVlXVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsdXN0ZXJCeUVkZ2VDb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyQnlFZGdlQ291bnQoZWRnZUNvdW50LCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLl9jaGVja09wdGlvbnMob3B0aW9ucyk7XG4gICAgICB2YXIgY2x1c3RlcnMgPSBbXTtcbiAgICAgIHZhciB1c2VkTm9kZXMgPSB7fTtcbiAgICAgIHZhciBlZGdlLCBlZGdlcywgcmVsZXZhbnRFZGdlQ291bnQ7XG4gICAgICAvLyBjb2xsZWN0IHRoZSBub2RlcyB0aGF0IHdpbGwgYmUgaW4gdGhlIGNsdXN0ZXJcbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICB2YXIgY2hpbGROb2Rlc09iaiA9IHt9O1xuICAgICAgICB2YXIgY2hpbGRFZGdlc09iaiA9IHt9O1xuICAgICAgICB2YXIgbm9kZUlkID0gX3RoaXMzLmJvZHkubm9kZUluZGljZXNbaV07XG4gICAgICAgIHZhciBub2RlID0gX3RoaXMzLmJvZHkubm9kZXNbbm9kZUlkXTtcblxuICAgICAgICAvLyBpZiB0aGlzIG5vZGUgaXMgYWxyZWFkeSB1c2VkIGluIGFub3RoZXIgY2x1c3RlciB0aGlzIHNlc3Npb24sIHdlIGRvIG5vdCBoYXZlIHRvIHJlLWV2YWx1YXRlIGl0LlxuICAgICAgICBpZiAodXNlZE5vZGVzW25vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJlbGV2YW50RWRnZUNvdW50ID0gMDtcbiAgICAgICAgICBlZGdlcyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZWRnZSA9IG5vZGUuZWRnZXNbal07XG4gICAgICAgICAgICBpZiAoX3RoaXMzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGVkZ2UudG9JZCAhPT0gZWRnZS5mcm9tSWQpIHtcbiAgICAgICAgICAgICAgICByZWxldmFudEVkZ2VDb3VudCsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdGhpcyBub2RlIHF1YWxpZmllcywgd2UgY29sbGVjdCBpdHMgbmVpZ2hib3VycyB0byBzdGFydCB0aGUgY2x1c3RlcmluZyBwcm9jZXNzLlxuICAgICAgICAgIGlmIChyZWxldmFudEVkZ2VDb3VudCA9PT0gZWRnZUNvdW50KSB7XG4gICAgICAgICAgICB2YXIgY2hlY2tKb2luQ29uZGl0aW9uID0gZnVuY3Rpb24gY2hlY2tKb2luQ29uZGl0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuam9pbkNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuam9pbkNvbmRpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKG5vZGUpO1xuICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5qb2luQ29uZGl0aW9uKGNsb25lZE9wdGlvbnMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBnYXRoZXJpbmdTdWNjZXNzZnVsID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBlZGdlcy5sZW5ndGg7IF9qKyspIHtcbiAgICAgICAgICAgICAgZWRnZSA9IGVkZ2VzW19qXTtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkTm9kZUlkID0gX3RoaXMzLl9nZXRDb25uZWN0ZWRJZChlZGdlLCBub2RlSWQpO1xuICAgICAgICAgICAgICAvLyBhZGQgdGhlIG5vZGVzIHRvIHRoZSBsaXN0IGJ5IHRoZSBqb2luIGNvbmRpdGlvbi5cbiAgICAgICAgICAgICAgaWYgKGNoZWNrSm9pbkNvbmRpdGlvbihub2RlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNPYmpbbm9kZUlkXSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgY2hpbGROb2Rlc09ialtjaGlsZE5vZGVJZF0gPSBfdGhpczMuYm9keS5ub2Rlc1tjaGlsZE5vZGVJZF07XG4gICAgICAgICAgICAgICAgdXNlZE5vZGVzW25vZGVJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgbm9kZSBkb2VzIG5vdCBxdWFsaWZ5IGFmdGVyIGFsbC5cbiAgICAgICAgICAgICAgICBnYXRoZXJpbmdTdWNjZXNzZnVsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWRkIHRvIHRoZSBjbHVzdGVyIHF1ZXVlXG4gICAgICAgICAgICBpZiAoX09iamVjdCRrZXlzKGNoaWxkTm9kZXNPYmopLmxlbmd0aCA+IDAgJiYgX09iamVjdCRrZXlzKGNoaWxkRWRnZXNPYmopLmxlbmd0aCA+IDAgJiYgZ2F0aGVyaW5nU3VjY2Vzc2Z1bCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogU2VhcmNoIGZvciBjbHVzdGVyIGRhdGEgdGhhdCBjb250YWlucyBhbnkgb2YgdGhlIG5vZGUgaWQnc1xuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBubyBqb2luQ29uZGl0aW9uLCBvdGhlcndpc2UgcmV0dXJuIHZhbHVlIG9mIGpvaW5Db25kaXRpb25cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIHZhciBmaW5kQ2x1c3RlckRhdGEgPSBmdW5jdGlvbiBmaW5kQ2x1c3RlckRhdGEoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBjbHVzdGVycy5sZW5ndGg7ICsrbikge1xuICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIGZvciBhIGNsdXN0ZXIgY29udGFpbmluZyBhbnkgb2YgdGhlIG5vZGUgaWQnc1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbSBpbiBjaGlsZE5vZGVzT2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjbHVzdGVyc1tuXS5ub2Rlc1ttXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsdXN0ZXJzW25dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgLy8gSWYgYW55IG9mIHRoZSBmb3VuZCBub2RlcyBpcyBwYXJ0IG9mIGEgY2x1c3RlciBmb3VuZCBpbiB0aGlzIG1ldGhvZCxcbiAgICAgICAgICAgICAgLy8gYWRkIHRoZSBjdXJyZW50IHZhbHVlcyB0byB0aGF0IGNsdXN0ZXJcbiAgICAgICAgICAgICAgdmFyIGZvdW5kQ2x1c3RlciA9IGZpbmRDbHVzdGVyRGF0YSgpO1xuICAgICAgICAgICAgICBpZiAoZm91bmRDbHVzdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgbm9kZXMgdG8gZm91bmQgY2x1c3RlciBpZiBub3QgcHJlc2VudFxuICAgICAgICAgICAgICAgIGZvciAodmFyIG0gaW4gY2hpbGROb2Rlc09iaikge1xuICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kQ2x1c3Rlci5ub2Rlc1ttXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kQ2x1c3Rlci5ub2Rlc1ttXSA9IGNoaWxkTm9kZXNPYmpbbV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGVkZ2VzIHRvIGZvdW5kIGNsdXN0ZXIsIGlmIG5vdCBwcmVzZW50XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX20gaW4gY2hpbGRFZGdlc09iaikge1xuICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kQ2x1c3Rlci5lZGdlc1tfbV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZENsdXN0ZXIuZWRnZXNbX21dID0gY2hpbGRFZGdlc09ialtfbV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjbHVzdGVyIGdyb3VwXG4gICAgICAgICAgICAgICAgY2x1c3RlcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICBub2RlczogY2hpbGROb2Rlc09iaixcbiAgICAgICAgICAgICAgICAgIGVkZ2VzOiBjaGlsZEVkZ2VzT2JqXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfbG9vcCgpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgY2x1c3RlcnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB0aGlzLl9jbHVzdGVyKGNsdXN0ZXJzW19pMl0ubm9kZXMsIGNsdXN0ZXJzW19pMl0uZWRnZXMsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWZyZXNoRGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsdXN0ZXIgYWxsIG5vZGVzIGluIHRoZSBuZXR3b3JrIHRoYXQgaGF2ZSBvbmx5IDEgZWRnZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWZyZXNoRGF0YT10cnVlXVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsdXN0ZXJPdXRsaWVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbHVzdGVyT3V0bGllcnMob3B0aW9ucykge1xuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgdGhpcy5jbHVzdGVyQnlFZGdlQ291bnQoMSwgb3B0aW9ucywgcmVmcmVzaERhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsdXN0ZXIgYWxsIG5vZGVzIGluIHRoZSBuZXR3b3JrIHRoYXQgaGF2ZSBvbmx5IDIgZWRnZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWZyZXNoRGF0YT10cnVlXVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsdXN0ZXJCcmlkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXJCcmlkZ2VzKG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHRoaXMuY2x1c3RlckJ5RWRnZUNvdW50KDIsIG9wdGlvbnMsIHJlZnJlc2hEYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdWNrIGFsbCBjb25uZWN0ZWQgbm9kZXMgb2YgYSBub2RlIGludG8gdGhlIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVmcmVzaERhdGE9dHJ1ZV1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbHVzdGVyQnlDb25uZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsdXN0ZXJCeUNvbm5lY3Rpb24obm9kZUlkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX2NvbnRleHQ7XG4gICAgICB2YXIgcmVmcmVzaERhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgICAvLyBraWxsIGNvbmRpdGlvbnNcbiAgICAgIGlmIChub2RlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBub2RlSWQgc3VwcGxpZWQgdG8gY2x1c3RlckJ5Q29ubmVjdGlvbiFcIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbm9kZUlkIGdpdmVuIHRvIGNsdXN0ZXJCeUNvbm5lY3Rpb24gZG9lcyBub3QgZXhpc3QhXCIpO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLl9jaGVja09wdGlvbnMob3B0aW9ucywgbm9kZSk7XG4gICAgICBpZiAob3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMueCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnggPSBub2RlLng7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMueSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnkgPSBub2RlLnk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMuZml4ZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5maXhlZCA9IHt9O1xuICAgICAgICBvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcy5maXhlZC54ID0gbm9kZS5vcHRpb25zLmZpeGVkLng7XG4gICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmZpeGVkLnkgPSBub2RlLm9wdGlvbnMuZml4ZWQueTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZE5vZGVzT2JqID0ge307XG4gICAgICB2YXIgY2hpbGRFZGdlc09iaiA9IHt9O1xuICAgICAgdmFyIHBhcmVudE5vZGVJZCA9IG5vZGUuaWQ7XG4gICAgICB2YXIgcGFyZW50Q2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhub2RlKTtcbiAgICAgIGNoaWxkTm9kZXNPYmpbcGFyZW50Tm9kZUlkXSA9IG5vZGU7XG5cbiAgICAgIC8vIGNvbGxlY3QgdGhlIG5vZGVzIHRoYXQgd2lsbCBiZSBpbiB0aGUgY2x1c3RlclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gbm9kZS5lZGdlc1tpXTtcbiAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBjaGlsZE5vZGVJZCA9IHRoaXMuX2dldENvbm5lY3RlZElkKGVkZ2UsIHBhcmVudE5vZGVJZCk7XG5cbiAgICAgICAgICAvLyBpZiB0aGUgY2hpbGQgbm9kZSBpcyBub3QgaW4gYSBjbHVzdGVyXG4gICAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkTm9kZXNbY2hpbGROb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVJZCAhPT0gcGFyZW50Tm9kZUlkKSB7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLmpvaW5Db25kaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlSWRdID0gdGhpcy5ib2R5Lm5vZGVzW2NoaWxkTm9kZUlkXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjbG9uZSB0aGUgb3B0aW9ucyBhbmQgaW5zZXJ0IHNvbWUgYWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRoYXQgY291bGQgYmUgaW50ZXJlc3RpbmcuXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkQ2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyh0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5qb2luQ29uZGl0aW9uKHBhcmVudENsb25lZE9wdGlvbnMsIGNoaWxkQ2xvbmVkT3B0aW9ucykgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkRWRnZXNPYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlc09ialtjaGlsZE5vZGVJZF0gPSB0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gc3dhbGxvdyB0aGUgZWRnZSBpZiBpdCBpcyBzZWxmLXJlZmVyZW5jaW5nLlxuICAgICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2VkZ2UuaWRdID0gZWRnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZE5vZGVJRHMgPSBfbWFwSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dCA9IF9PYmplY3Qka2V5cyhjaGlsZE5vZGVzT2JqKSkuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKGNoaWxkTm9kZSkge1xuICAgICAgICByZXR1cm4gY2hpbGROb2Rlc09ialtjaGlsZE5vZGVdLmlkO1xuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBjaGlsZE5vZGVLZXkgaW4gY2hpbGROb2Rlc09iaikge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjaGlsZE5vZGVzT2JqLCBjaGlsZE5vZGVLZXkpKSBjb250aW51ZTtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNPYmpbY2hpbGROb2RlS2V5XTtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjaGlsZE5vZGUuZWRnZXMubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICB2YXIgY2hpbGRFZGdlID0gY2hpbGROb2RlLmVkZ2VzW3ldO1xuICAgICAgICAgIGlmIChfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoY2hpbGROb2RlSURzKS5jYWxsKGNoaWxkTm9kZUlEcywgdGhpcy5fZ2V0Q29ubmVjdGVkSWQoY2hpbGRFZGdlLCBjaGlsZE5vZGUuaWQpKSA+IC0xKSB7XG4gICAgICAgICAgICBjaGlsZEVkZ2VzT2JqW2NoaWxkRWRnZS5pZF0gPSBjaGlsZEVkZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jbHVzdGVyKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIG9wdGlvbnMsIHJlZnJlc2hEYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgdGhlIGVkZ2VzIHRoYXQgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgY2x1c3RlclxuICAgICAqIEl0IGxvb2tzIGZvciBlZGdlcyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gdGhlIG5vZGVzIGZyb20gdGhlIFwib3V0c2lkZScgb2YgdGhlIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3tOb2RlLmlkOiB2aXMuTm9kZX19IGNoaWxkTm9kZXNPYmpcbiAgICAgKiBAcGFyYW0ge3t2aXMuRWRnZS5pZDogdmlzLkVkZ2V9fSBjaGlsZEVkZ2VzT2JqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNsdXN0ZXJOb2RlUHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjbHVzdGVyRWRnZVByb3BlcnRpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVDbHVzdGVyRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUNsdXN0ZXJFZGdlcyhjaGlsZE5vZGVzT2JqLCBjaGlsZEVkZ2VzT2JqLCBjbHVzdGVyTm9kZVByb3BlcnRpZXMsIGNsdXN0ZXJFZGdlUHJvcGVydGllcykge1xuICAgICAgdmFyIGVkZ2UsIGNoaWxkTm9kZUlkLCBjaGlsZE5vZGUsIHRvSWQsIGZyb21JZCwgb3RoZXJOb2RlSWQ7XG5cbiAgICAgIC8vIGxvb3Agb3ZlciBhbGwgY2hpbGQgbm9kZXMgYW5kIHRoZWlyIGVkZ2VzIHRvIGZpbmQgZWRnZXMgZ29pbmcgb3V0IG9mIHRoZSBjbHVzdGVyXG4gICAgICAvLyB0aGVzZSBlZGdlcyB3aWxsIGJlIHJlcGxhY2VkIGJ5IGNsdXN0ZXJFZGdlcy5cbiAgICAgIHZhciBjaGlsZEtleXMgPSBfT2JqZWN0JGtleXMoY2hpbGROb2Rlc09iaik7XG4gICAgICB2YXIgY3JlYXRlRWRnZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkTm9kZUlkID0gY2hpbGRLZXlzW2ldO1xuICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzT2JqW2NoaWxkTm9kZUlkXTtcblxuICAgICAgICAvLyBjb25zdHJ1Y3QgbmV3IGVkZ2VzIGZyb20gdGhlIGNsdXN0ZXIgdG8gb3RoZXJzXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hpbGROb2RlLmVkZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZWRnZSA9IGNoaWxkTm9kZS5lZGdlc1tqXTtcbiAgICAgICAgICAvLyB3ZSBvbmx5IGhhbmRsZSBlZGdlcyB0aGF0IGFyZSB2aXNpYmxlIHRvIHRoZSBzeXN0ZW0sIG5vdCB0aGUgZGlzYWJsZWQgb25lcyBmcm9tIHRoZSBjbHVzdGVyaW5nIHByb2Nlc3MuXG4gICAgICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gc2VsZi1yZWZlcmVuY2luZyBlZGdlcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBcImhpZGRlblwiIGxpc3RcbiAgICAgICAgICAgIGlmIChlZGdlLnRvSWQgPT0gZWRnZS5mcm9tSWQpIHtcbiAgICAgICAgICAgICAgY2hpbGRFZGdlc09ialtlZGdlLmlkXSA9IGVkZ2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBzZXQgdXAgdGhlIGZyb20gYW5kIHRvLlxuICAgICAgICAgICAgICBpZiAoZWRnZS50b0lkID09IGNoaWxkTm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIGRvdWJsZSBlcXVhbHMgYmVjYXVzZSBpbnRzIGFuZCBzdHJpbmdzIGNhbiBiZSBpbnRlcmNoYW5nZWQgaGVyZS5cbiAgICAgICAgICAgICAgICB0b0lkID0gY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkO1xuICAgICAgICAgICAgICAgIGZyb21JZCA9IGVkZ2UuZnJvbUlkO1xuICAgICAgICAgICAgICAgIG90aGVyTm9kZUlkID0gZnJvbUlkO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvSWQgPSBlZGdlLnRvSWQ7XG4gICAgICAgICAgICAgICAgZnJvbUlkID0gY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkO1xuICAgICAgICAgICAgICAgIG90aGVyTm9kZUlkID0gdG9JZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPbmx5IGVkZ2VzIGZyb20gdGhlIGNsdXN0ZXIgb3V0d2FyZHMgYXJlIGJlaW5nIHJlcGxhY2VkLlxuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXNPYmpbb3RoZXJOb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY3JlYXRlRWRnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZWRnZTogZWRnZSxcbiAgICAgICAgICAgICAgICBmcm9tSWQ6IGZyb21JZCxcbiAgICAgICAgICAgICAgICB0b0lkOiB0b0lkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL1xuICAgICAgLy8gSGVyZSB3ZSBhY3R1YWxseSBjcmVhdGUgdGhlIHJlcGxhY2VtZW50IGVkZ2VzLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIGNvdWxkIG5vdCBkbyB0aGlzIGluIHRoZSBsb29wIGFib3ZlIGFzIHRoZSBjcmVhdGlvbiBwcm9jZXNzXG4gICAgICAvLyB3b3VsZCBhZGQgYW4gZWRnZSB0byB0aGUgZWRnZXMgYXJyYXkgd2UgYXJlIGl0ZXJhdGluZyBvdmVyLlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IGEgY2x1c3RlcmVkIGVkZ2UgY2FuIGhhdmUgbXVsdGlwbGUgYmFzZSBlZGdlcyFcbiAgICAgIC8vXG4gICAgICB2YXIgbmV3RWRnZXMgPSBbXTtcblxuICAgICAgLyoqXG4gICAgICAgKiBGaW5kIGEgY2x1c3RlciBlZGdlIHdoaWNoIG1hdGNoZXMgdGhlIGdpdmVuIGNyZWF0ZWQgZWRnZS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlfSBjcmVhdGVkRWRnZVxuICAgICAgICogQHJldHVybnMge3Zpcy5FZGdlfVxuICAgICAgICovXG4gICAgICB2YXIgZ2V0TmV3RWRnZSA9IGZ1bmN0aW9uIGdldE5ld0VkZ2UoY3JlYXRlZEVkZ2UpIHtcbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgbmV3RWRnZXMubGVuZ3RoOyBfajIrKykge1xuICAgICAgICAgIHZhciBuZXdFZGdlID0gbmV3RWRnZXNbX2oyXTtcblxuICAgICAgICAgIC8vIFdlIHJlcGxhY2UgYm90aCB0byBhbmQgZnJvbSBlZGdlcyB3aXRoIGEgc2luZ2xlIGNsdXN0ZXIgZWRnZVxuICAgICAgICAgIHZhciBtYXRjaFRvRGlyZWN0aW9uID0gY3JlYXRlZEVkZ2UuZnJvbUlkID09PSBuZXdFZGdlLmZyb21JZCAmJiBjcmVhdGVkRWRnZS50b0lkID09PSBuZXdFZGdlLnRvSWQ7XG4gICAgICAgICAgdmFyIG1hdGNoRnJvbURpcmVjdGlvbiA9IGNyZWF0ZWRFZGdlLmZyb21JZCA9PT0gbmV3RWRnZS50b0lkICYmIGNyZWF0ZWRFZGdlLnRvSWQgPT09IG5ld0VkZ2UuZnJvbUlkO1xuICAgICAgICAgIGlmIChtYXRjaFRvRGlyZWN0aW9uIHx8IG1hdGNoRnJvbURpcmVjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ld0VkZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIGZvciAodmFyIF9qMyA9IDA7IF9qMyA8IGNyZWF0ZUVkZ2VzLmxlbmd0aDsgX2ozKyspIHtcbiAgICAgICAgdmFyIGNyZWF0ZWRFZGdlID0gY3JlYXRlRWRnZXNbX2ozXTtcbiAgICAgICAgdmFyIF9lZGdlID0gY3JlYXRlZEVkZ2UuZWRnZTtcbiAgICAgICAgdmFyIG5ld0VkZ2UgPSBnZXROZXdFZGdlKGNyZWF0ZWRFZGdlKTtcbiAgICAgICAgaWYgKG5ld0VkZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBDcmVhdGUgYSBjbHVzdGVyZWQgZWRnZSBmb3IgdGhpcyBjb25uZWN0aW9uXG4gICAgICAgICAgbmV3RWRnZSA9IHRoaXMuX2NyZWF0ZUNsdXN0ZXJlZEVkZ2UoY3JlYXRlZEVkZ2UuZnJvbUlkLCBjcmVhdGVkRWRnZS50b0lkLCBfZWRnZSwgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKTtcbiAgICAgICAgICBuZXdFZGdlcy5wdXNoKG5ld0VkZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0VkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMucHVzaChfZWRnZS5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbHNvIHJlZmVyZW5jZSB0aGUgbmV3IGVkZ2UgaW4gdGhlIG9sZCBlZGdlXG4gICAgICAgIHRoaXMuYm9keS5lZGdlc1tfZWRnZS5pZF0uZWRnZVJlcGxhY2VkQnlJZCA9IG5ld0VkZ2UuaWQ7XG5cbiAgICAgICAgLy8gaGlkZSB0aGUgcmVwbGFjZWQgZWRnZVxuICAgICAgICB0aGlzLl9iYWNrdXBFZGdlT3B0aW9ucyhfZWRnZSk7XG4gICAgICAgIF9lZGdlLnNldE9wdGlvbnMoe1xuICAgICAgICAgIHBoeXNpY3M6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2hlY2tzIHRoZSBvcHRpb25zIHRoYXQgY2FuIGJlIHN1cHBsaWVkIHRvIHRoZSBkaWZmZXJlbnQgY2x1c3RlciBmdW5jdGlvbnNcbiAgICAgKiBmb3IgY2VydGFpbiBmaWVsZHMgYW5kIGluc2VydHMgZGVmYXVsdHMgaWYgbmVlZGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NoZWNrT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tPcHRpb25zKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgaWYgKG9wdGlvbnMuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5jbHVzdGVyRWRnZVByb3BlcnRpZXMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLmNsdXN0ZXJOb2RlUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAgICBjaGlsZE5vZGVzT2JqICAgICAgICAgfCBvYmplY3Qgd2l0aCBub2RlIG9iamVjdHMsIGlkIGFzIGtleXMsIHNhbWUgYXMgY2hpbGROb2RlcyBleGNlcHQgaXQgYWxzbyBjb250YWlucyBhIHNvdXJjZSBub2RlXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICAgIGNoaWxkRWRnZXNPYmogICAgICAgICB8IG9iamVjdCB3aXRoIGVkZ2Ugb2JqZWN0cywgaWQgYXMga2V5c1xuICAgICAqIEBwYXJhbSB7QXJyYXl9ICAgICBvcHRpb25zICAgICAgICAgICAgICAgfCBvYmplY3Qgd2l0aCB7Y2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMsIHByb2Nlc3NQcm9wZXJ0aWVzfVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gICByZWZyZXNoRGF0YSB8IHdoZW4gdHJ1ZSwgZG8gbm90IHdyYXAgdXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jbHVzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbHVzdGVyKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZWZyZXNoRGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgICAgIC8vIFJlbW92ZSBub2RlcyB3aGljaCBhcmUgYWxyZWFkeSBjbHVzdGVyZWRcbiAgICAgIHZhciB0bXBOb2Rlc1RvUmVtb3ZlID0gW107XG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gY2hpbGROb2Rlc09iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNoaWxkTm9kZXNPYmosIG5vZGVJZCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyZWROb2Rlc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRtcE5vZGVzVG9SZW1vdmUucHVzaChub2RlSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0bXBOb2Rlc1RvUmVtb3ZlLmxlbmd0aDsgKytuKSB7XG4gICAgICAgIGRlbGV0ZSBjaGlsZE5vZGVzT2JqW3RtcE5vZGVzVG9SZW1vdmVbbl1dO1xuICAgICAgfVxuXG4gICAgICAvLyBraWxsIGNvbmRpdGlvbjogbm8gbm9kZXMgZG9uJ3QgYm90aGVyXG4gICAgICBpZiAoX09iamVjdCRrZXlzKGNoaWxkTm9kZXNPYmopLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYWxsb3cgY2x1c3RlcnMgb2YgMSBpZiBvcHRpb25zIGFsbG93XG4gICAgICBpZiAoX09iamVjdCRrZXlzKGNoaWxkTm9kZXNPYmopLmxlbmd0aCA9PSAxICYmIG9wdGlvbnMuY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmFsbG93U2luZ2xlTm9kZUNsdXN0ZXIgIT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzID0gZGVlcEV4dGVuZCh7fSwgb3B0aW9ucy5jbHVzdGVyTm9kZVByb3BlcnRpZXMpO1xuXG4gICAgICAvLyBjb25zdHJ1Y3QgdGhlIGNsdXN0ZXJOb2RlUHJvcGVydGllc1xuICAgICAgaWYgKG9wdGlvbnMucHJvY2Vzc1Byb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBnZXQgdGhlIGNoaWxkTm9kZSBvcHRpb25zXG4gICAgICAgIHZhciBjaGlsZE5vZGVzT3B0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfbm9kZUlkIGluIGNoaWxkTm9kZXNPYmopIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNoaWxkTm9kZXNPYmosIF9ub2RlSWQpKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmVkT3B0aW9ucyA9IE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhjaGlsZE5vZGVzT2JqW19ub2RlSWRdKTtcbiAgICAgICAgICAgIGNoaWxkTm9kZXNPcHRpb25zLnB1c2goY2xvbmVkT3B0aW9ucyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGNsdXN0ZXIgcHJvcGVydGllcyBiYXNlZCBvbiBjaGlsZE5vZGVzXG4gICAgICAgIHZhciBjaGlsZEVkZ2VzT3B0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBlZGdlSWQgaW4gY2hpbGRFZGdlc09iaikge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2hpbGRFZGdlc09iaiwgZWRnZUlkKSkge1xuICAgICAgICAgICAgLy8gdGhlc2UgY2x1c3RlciBlZGdlcyB3aWxsIGJlIHJlbW92ZWQgb24gY3JlYXRpb24gb2YgdGhlIGNsdXN0ZXIuXG4gICAgICAgICAgICBpZiAoZWRnZUlkLnN1YnN0cigwLCAxMikgIT09IFwiY2x1c3RlckVkZ2U6XCIpIHtcbiAgICAgICAgICAgICAgdmFyIF9jbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKGNoaWxkRWRnZXNPYmpbZWRnZUlkXSwgXCJlZGdlXCIpO1xuICAgICAgICAgICAgICBjaGlsZEVkZ2VzT3B0aW9ucy5wdXNoKF9jbG9uZWRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzID0gb3B0aW9ucy5wcm9jZXNzUHJvcGVydGllcyhjbHVzdGVyTm9kZVByb3BlcnRpZXMsIGNoaWxkTm9kZXNPcHRpb25zLCBjaGlsZEVkZ2VzT3B0aW9ucyk7XG4gICAgICAgIGlmICghY2x1c3Rlck5vZGVQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHByb2Nlc3NQcm9wZXJ0aWVzIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBwcm9wZXJ0aWVzIVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBpZiB3ZSBoYXZlIGFuIHVuaXF1ZSBpZDtcbiAgICAgIGlmIChjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMuaWQgPSBcImNsdXN0ZXI6XCIgKyB2NCgpO1xuICAgICAgfVxuICAgICAgdmFyIGNsdXN0ZXJJZCA9IGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZDtcbiAgICAgIGlmIChjbHVzdGVyTm9kZVByb3BlcnRpZXMubGFiZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbHVzdGVyTm9kZVByb3BlcnRpZXMubGFiZWwgPSBcImNsdXN0ZXJcIjtcbiAgICAgIH1cblxuICAgICAgLy8gZ2l2ZSB0aGUgY2x1c3Rlck5vZGUgYSBwb3NpdGlvbiBpZiBpdCBkb2VzIG5vdCBoYXZlIG9uZS5cbiAgICAgIHZhciBwb3MgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb3MgPSB0aGlzLl9nZXRDbHVzdGVyUG9zaXRpb24oY2hpbGROb2Rlc09iaik7XG4gICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy54ID0gcG9zLng7XG4gICAgICB9XG4gICAgICBpZiAoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocG9zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwb3MgPSB0aGlzLl9nZXRDbHVzdGVyUG9zaXRpb24oY2hpbGROb2Rlc09iaik7XG4gICAgICAgIH1cbiAgICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLnkgPSBwb3MueTtcbiAgICAgIH1cblxuICAgICAgLy8gZm9yY2UgdGhlIElEIHRvIHJlbWFpbiB0aGUgc2FtZVxuICAgICAgY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkID0gY2x1c3RlcklkO1xuXG4gICAgICAvLyBjcmVhdGUgdGhlIGNsdXN0ZXIgTm9kZVxuICAgICAgLy8gTm90ZSB0aGF0IGFsbG93U2luZ2xlTm9kZUNsdXN0ZXIsIGlmIHByZXNlbnQsIGlzIHN0b3JlZCBpbiB0aGUgb3B0aW9ucyBhcyB3ZWxsXG4gICAgICB2YXIgY2x1c3Rlck5vZGUgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUoY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLCBDbHVzdGVyKTtcbiAgICAgIGNsdXN0ZXJOb2RlLmNvbnRhaW5lZE5vZGVzID0gY2hpbGROb2Rlc09iajtcbiAgICAgIGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzID0gY2hpbGRFZGdlc09iajtcbiAgICAgIC8vIGNhY2hlIGEgY29weSBmcm9tIHRoZSBjbHVzdGVyIGVkZ2UgcHJvcGVydGllcyBpZiB3ZSBoYXZlIHRvIHJlY29ubmVjdCBvdGhlcnMgbGF0ZXIgb25cbiAgICAgIGNsdXN0ZXJOb2RlLmNsdXN0ZXJFZGdlUHJvcGVydGllcyA9IG9wdGlvbnMuY2x1c3RlckVkZ2VQcm9wZXJ0aWVzO1xuXG4gICAgICAvLyBmaW5hbGx5IHB1dCB0aGUgY2x1c3RlciBub2RlIGludG8gZ2xvYmFsXG4gICAgICB0aGlzLmJvZHkubm9kZXNbY2x1c3Rlck5vZGVQcm9wZXJ0aWVzLmlkXSA9IGNsdXN0ZXJOb2RlO1xuICAgICAgdGhpcy5fY2x1c3RlckVkZ2VzKGNoaWxkTm9kZXNPYmosIGNoaWxkRWRnZXNPYmosIGNsdXN0ZXJOb2RlUHJvcGVydGllcywgb3B0aW9ucy5jbHVzdGVyRWRnZVByb3BlcnRpZXMpO1xuXG4gICAgICAvLyBzZXQgSUQgdG8gdW5kZWZpbmVkIHNvIG5vIGR1cGxpY2F0ZXMgYXJpc2VcbiAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllcy5pZCA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gd3JhcCB1cFxuICAgICAgaWYgKHJlZnJlc2hEYXRhID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YUNoYW5nZWRcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VkZ2V9IGVkZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9iYWNrdXBFZGdlT3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmFja3VwRWRnZU9wdGlvbnMoZWRnZSkge1xuICAgICAgaWYgKHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmNsdXN0ZXJlZEVkZ2VzW2VkZ2UuaWRdID0ge1xuICAgICAgICAgIHBoeXNpY3M6IGVkZ2Uub3B0aW9ucy5waHlzaWNzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VkZ2V9IGVkZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9yZXN0b3JlRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzdG9yZUVkZ2UoZWRnZSkge1xuICAgICAgdmFyIG9yaWdpbmFsT3B0aW9ucyA9IHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF07XG4gICAgICBpZiAob3JpZ2luYWxPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWRnZS5zZXRPcHRpb25zKHtcbiAgICAgICAgICBwaHlzaWNzOiBvcmlnaW5hbE9wdGlvbnMucGh5c2ljc1xuICAgICAgICB9KTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2x1c3RlcmVkRWRnZXNbZWRnZS5pZF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBub2RlIGlzIGEgY2x1c3Rlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNDbHVzdGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQ2x1c3Rlcihub2RlSWQpIHtcbiAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXS5pc0NsdXN0ZXIgPT09IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTm9kZSBkb2VzIG5vdCBleGlzdC5cIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBnZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjbHVzdGVyIG5vZGUgYmFzZWQgb24gd2hhdCdzIGluc2lkZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNoaWxkTm9kZXNPYmogICAgfCBvYmplY3Qgd2l0aCBub2RlIG9iamVjdHMsIGlkIGFzIGtleXNcbiAgICAgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDbHVzdGVyUG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENsdXN0ZXJQb3NpdGlvbihjaGlsZE5vZGVzT2JqKSB7XG4gICAgICB2YXIgY2hpbGRLZXlzID0gX09iamVjdCRrZXlzKGNoaWxkTm9kZXNPYmopO1xuICAgICAgdmFyIG1pblggPSBjaGlsZE5vZGVzT2JqW2NoaWxkS2V5c1swXV0ueDtcbiAgICAgIHZhciBtYXhYID0gY2hpbGROb2Rlc09ialtjaGlsZEtleXNbMF1dLng7XG4gICAgICB2YXIgbWluWSA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzWzBdXS55O1xuICAgICAgdmFyIG1heFkgPSBjaGlsZE5vZGVzT2JqW2NoaWxkS2V5c1swXV0ueTtcbiAgICAgIHZhciBub2RlO1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjaGlsZEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IGNoaWxkTm9kZXNPYmpbY2hpbGRLZXlzW2ldXTtcbiAgICAgICAgbWluWCA9IG5vZGUueCA8IG1pblggPyBub2RlLnggOiBtaW5YO1xuICAgICAgICBtYXhYID0gbm9kZS54ID4gbWF4WCA/IG5vZGUueCA6IG1heFg7XG4gICAgICAgIG1pblkgPSBub2RlLnkgPCBtaW5ZID8gbm9kZS55IDogbWluWTtcbiAgICAgICAgbWF4WSA9IG5vZGUueSA+IG1heFkgPyBub2RlLnkgOiBtYXhZO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogMC41ICogKG1pblggKyBtYXhYKSxcbiAgICAgICAgeTogMC41ICogKG1pblkgKyBtYXhZKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIGEgY2x1c3RlciBieSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlLmlkfSAgY2x1c3Rlck5vZGVJZCB8IHRoZSBJRCBvZiB0aGUgY2x1c3RlciBub2RlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlZnJlc2hEYXRhIHwgd3JhcCB1cCBhZnRlcndhcmRzIGlmIG5vdCB0cnVlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwib3BlbkNsdXN0ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbkNsdXN0ZXIoY2x1c3Rlck5vZGVJZCwgb3B0aW9ucykge1xuICAgICAgdmFyIHJlZnJlc2hEYXRhID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICAgICAgLy8ga2lsbCBjb25kaXRpb25zXG4gICAgICBpZiAoY2x1c3Rlck5vZGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNsdXN0ZXJOb2RlSWQgc3VwcGxpZWQgdG8gb3BlbkNsdXN0ZXIuXCIpO1xuICAgICAgfVxuICAgICAgdmFyIGNsdXN0ZXJOb2RlID0gdGhpcy5ib2R5Lm5vZGVzW2NsdXN0ZXJOb2RlSWRdO1xuICAgICAgaWYgKGNsdXN0ZXJOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGNsdXN0ZXJOb2RlSWQgc3VwcGxpZWQgdG8gb3BlbkNsdXN0ZXIgZG9lcyBub3QgZXhpc3QuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGNsdXN0ZXJOb2RlLmlzQ2x1c3RlciAhPT0gdHJ1ZSB8fCBjbHVzdGVyTm9kZS5jb250YWluZWROb2RlcyA9PT0gdW5kZWZpbmVkIHx8IGNsdXN0ZXJOb2RlLmNvbnRhaW5lZEVkZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIG5vZGU6XCIgKyBjbHVzdGVyTm9kZUlkICsgXCIgaXMgbm90IGEgdmFsaWQgY2x1c3Rlci5cIik7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGlmIGN1cnJlbnQgY2x1c3RlciBpcyBjbHVzdGVyZWQgaXRzZWxmXG4gICAgICB2YXIgc3RhY2sgPSB0aGlzLmZpbmROb2RlKGNsdXN0ZXJOb2RlSWQpO1xuICAgICAgdmFyIHBhcmVudEluZGV4ID0gX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KHN0YWNrKS5jYWxsKHN0YWNrLCBjbHVzdGVyTm9kZUlkKSAtIDE7XG4gICAgICBpZiAocGFyZW50SW5kZXggPj0gMCkge1xuICAgICAgICAvLyBDdXJyZW50IGNsdXN0ZXIgaXMgY2x1c3RlcmVkOyB0cmFuc2ZlciBjb250YWluZWQgbm9kZXMgYW5kIGVkZ2VzIHRvIHBhcmVudFxuICAgICAgICB2YXIgcGFyZW50Q2x1c3Rlck5vZGVJZCA9IHN0YWNrW3BhcmVudEluZGV4XTtcbiAgICAgICAgdmFyIHBhcmVudENsdXN0ZXJOb2RlID0gdGhpcy5ib2R5Lm5vZGVzW3BhcmVudENsdXN0ZXJOb2RlSWRdO1xuXG4gICAgICAgIC8vIGNsdXN0ZXJpbmcuY2x1c3RlcmVkTm9kZXMgYW5kIGNsdXN0ZXJpbmcuY2x1c3RlcmVkRWRnZXMgcmVtYWluIHVuY2hhbmdlZFxuICAgICAgICBwYXJlbnRDbHVzdGVyTm9kZS5fb3BlbkNoaWxkQ2x1c3RlcihjbHVzdGVyTm9kZUlkKTtcblxuICAgICAgICAvLyBBbGwgY29tcG9uZW50cyBvZiBjaGlsZCBjbHVzdGVyIG5vZGUgaGF2ZSBiZWVuIHRyYW5zZmVycmVkLiBJdCBjYW4gZGllIG5vdy5cbiAgICAgICAgZGVsZXRlIHRoaXMuYm9keS5ub2Rlc1tjbHVzdGVyTm9kZUlkXTtcbiAgICAgICAgaWYgKHJlZnJlc2hEYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIG1haW4gYm9keVxuICAgICAgdmFyIGNvbnRhaW5lZE5vZGVzID0gY2x1c3Rlck5vZGUuY29udGFpbmVkTm9kZXM7XG4gICAgICB2YXIgY29udGFpbmVkRWRnZXMgPSBjbHVzdGVyTm9kZS5jb250YWluZWRFZGdlcztcblxuICAgICAgLy8gYWxsb3cgdGhlIHVzZXIgdG8gcG9zaXRpb24gdGhlIG5vZGVzIGFmdGVyIHJlbGVhc2UuXG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMucmVsZWFzZUZ1bmN0aW9uICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMucmVsZWFzZUZ1bmN0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgY2x1c3RlclBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IGNsdXN0ZXJOb2RlLngsXG4gICAgICAgICAgeTogY2x1c3Rlck5vZGUueVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gY29udGFpbmVkTm9kZXMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnRhaW5lZE5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVkTm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgcG9zaXRpb25zW25vZGVJZF0gPSB7XG4gICAgICAgICAgICAgIHg6IGNvbnRhaW5lZE5vZGUueCxcbiAgICAgICAgICAgICAgeTogY29udGFpbmVkTm9kZS55XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3UG9zaXRpb25zID0gb3B0aW9ucy5yZWxlYXNlRnVuY3Rpb24oY2x1c3RlclBvc2l0aW9uLCBwb3NpdGlvbnMpO1xuICAgICAgICBmb3IgKHZhciBfbm9kZUlkMiBpbiBjb250YWluZWROb2Rlcykge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGFpbmVkTm9kZXMsIF9ub2RlSWQyKSkge1xuICAgICAgICAgICAgdmFyIF9jb250YWluZWROb2RlID0gdGhpcy5ib2R5Lm5vZGVzW19ub2RlSWQyXTtcbiAgICAgICAgICAgIGlmIChuZXdQb3NpdGlvbnNbX25vZGVJZDJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgX2NvbnRhaW5lZE5vZGUueCA9IG5ld1Bvc2l0aW9uc1tfbm9kZUlkMl0ueCA9PT0gdW5kZWZpbmVkID8gY2x1c3Rlck5vZGUueCA6IG5ld1Bvc2l0aW9uc1tfbm9kZUlkMl0ueDtcbiAgICAgICAgICAgICAgX2NvbnRhaW5lZE5vZGUueSA9IG5ld1Bvc2l0aW9uc1tfbm9kZUlkMl0ueSA9PT0gdW5kZWZpbmVkID8gY2x1c3Rlck5vZGUueSA6IG5ld1Bvc2l0aW9uc1tfbm9kZUlkMl0ueTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvcHkgdGhlIHBvc2l0aW9uIGZyb20gdGhlIGNsdXN0ZXJcbiAgICAgICAgZm9yRWFjaCQxKGNvbnRhaW5lZE5vZGVzLCBmdW5jdGlvbiAoY29udGFpbmVkTm9kZSkge1xuICAgICAgICAgIC8vIGluaGVyaXQgcG9zaXRpb25cbiAgICAgICAgICBpZiAoY29udGFpbmVkTm9kZS5vcHRpb25zLmZpeGVkLnggPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250YWluZWROb2RlLnggPSBjbHVzdGVyTm9kZS54O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29udGFpbmVkTm9kZS5vcHRpb25zLmZpeGVkLnkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250YWluZWROb2RlLnkgPSBjbHVzdGVyTm9kZS55O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbGVhc2Ugbm9kZXNcbiAgICAgIGZvciAodmFyIF9ub2RlSWQzIGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGFpbmVkTm9kZXMsIF9ub2RlSWQzKSkge1xuICAgICAgICAgIHZhciBfY29udGFpbmVkTm9kZTIgPSB0aGlzLmJvZHkubm9kZXNbX25vZGVJZDNdO1xuXG4gICAgICAgICAgLy8gaW5oZXJpdCBzcGVlZFxuICAgICAgICAgIF9jb250YWluZWROb2RlMi52eCA9IGNsdXN0ZXJOb2RlLnZ4O1xuICAgICAgICAgIF9jb250YWluZWROb2RlMi52eSA9IGNsdXN0ZXJOb2RlLnZ5O1xuICAgICAgICAgIF9jb250YWluZWROb2RlMi5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgIHBoeXNpY3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5jbHVzdGVyZWROb2Rlc1tfbm9kZUlkM107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY29weSB0aGUgY2x1c3Rlck5vZGUgZWRnZXMgYmVjYXVzZSB3ZSBjYW5ub3QgaXRlcmF0ZSBvdmVyIGFuIG9iamVjdCB0aGF0IHdlIGFkZCBvciByZW1vdmUgZnJvbS5cbiAgICAgIHZhciBlZGdlc1RvQmVEZWxldGVkID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsdXN0ZXJOb2RlLmVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVkZ2VzVG9CZURlbGV0ZWQucHVzaChjbHVzdGVyTm9kZS5lZGdlc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGFjdHVhbGx5IGhhbmRsaW5nIHRoZSBkZWxldGluZy5cbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGVkZ2VzVG9CZURlbGV0ZWQubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzVG9CZURlbGV0ZWRbX2kzXTtcbiAgICAgICAgdmFyIG90aGVyTm9kZUlkID0gdGhpcy5fZ2V0Q29ubmVjdGVkSWQoZWRnZSwgY2x1c3Rlck5vZGVJZCk7XG4gICAgICAgIHZhciBvdGhlck5vZGUgPSB0aGlzLmNsdXN0ZXJlZE5vZGVzW290aGVyTm9kZUlkXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgdmFyIHRyYW5zZmVySWQgPSBlZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzW2pdO1xuICAgICAgICAgIHZhciB0cmFuc2ZlckVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbdHJhbnNmZXJJZF07XG4gICAgICAgICAgaWYgKHRyYW5zZmVyRWRnZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcblxuICAgICAgICAgIC8vIGlmIHRoZSBvdGhlciBub2RlIGlzIGluIGFub3RoZXIgY2x1c3Rlciwgd2UgdHJhbnNmZXIgb3duZXJzaGlwIG9mIHRoaXMgZWRnZSB0byB0aGUgb3RoZXIgY2x1c3RlclxuICAgICAgICAgIGlmIChvdGhlck5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gdHJhbnNmZXIgb3duZXJzaGlwOlxuICAgICAgICAgICAgdmFyIG90aGVyQ2x1c3RlciA9IHRoaXMuYm9keS5ub2Rlc1tvdGhlck5vZGUuY2x1c3RlcklkXTtcbiAgICAgICAgICAgIG90aGVyQ2x1c3Rlci5jb250YWluZWRFZGdlc1t0cmFuc2ZlckVkZ2UuaWRdID0gdHJhbnNmZXJFZGdlO1xuXG4gICAgICAgICAgICAvLyBkZWxldGUgbG9jYWwgcmVmZXJlbmNlXG4gICAgICAgICAgICBkZWxldGUgY29udGFpbmVkRWRnZXNbdHJhbnNmZXJFZGdlLmlkXTtcblxuICAgICAgICAgICAgLy8gZ2V0IHRvIGFuZCBmcm9tXG4gICAgICAgICAgICB2YXIgZnJvbUlkID0gdHJhbnNmZXJFZGdlLmZyb21JZDtcbiAgICAgICAgICAgIHZhciB0b0lkID0gdHJhbnNmZXJFZGdlLnRvSWQ7XG4gICAgICAgICAgICBpZiAodHJhbnNmZXJFZGdlLnRvSWQgPT0gb3RoZXJOb2RlSWQpIHtcbiAgICAgICAgICAgICAgdG9JZCA9IG90aGVyTm9kZS5jbHVzdGVySWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tSWQgPSBvdGhlck5vZGUuY2x1c3RlcklkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjcmVhdGUgbmV3IGNsdXN0ZXIgZWRnZSBmcm9tIHRoZSBvdGhlckNsdXN0ZXJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUNsdXN0ZXJlZEVkZ2UoZnJvbUlkLCB0b0lkLCB0cmFuc2ZlckVkZ2UsIG90aGVyQ2x1c3Rlci5jbHVzdGVyRWRnZVByb3BlcnRpZXMsIHtcbiAgICAgICAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgICAgICAgcGh5c2ljczogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3RvcmVFZGdlKHRyYW5zZmVyRWRnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVkZ2UucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSB0aGUgcmVsZWFzaW5nIG9mIHRoZSBlZGdlc1xuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIGNvbnRhaW5lZEVkZ2VzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29udGFpbmVkRWRnZXMsIGVkZ2VJZCkpIHtcbiAgICAgICAgICB0aGlzLl9yZXN0b3JlRWRnZShjb250YWluZWRFZGdlc1tlZGdlSWRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgY2x1c3Rlck5vZGVcbiAgICAgIGRlbGV0ZSB0aGlzLmJvZHkubm9kZXNbY2x1c3Rlck5vZGVJZF07XG4gICAgICBpZiAocmVmcmVzaERhdGEgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2x1c3Rlci5pZH0gY2x1c3RlcklkXG4gICAgICogQHJldHVybnMge0FycmF5LjxOb2RlLmlkPn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXROb2Rlc0luQ2x1c3RlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2Rlc0luQ2x1c3RlcihjbHVzdGVySWQpIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gW107XG4gICAgICBpZiAodGhpcy5pc0NsdXN0ZXIoY2x1c3RlcklkKSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgY29udGFpbmVkTm9kZXMgPSB0aGlzLmJvZHkubm9kZXNbY2x1c3RlcklkXS5jb250YWluZWROb2RlcztcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIGNvbnRhaW5lZE5vZGVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb250YWluZWROb2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgICAgbm9kZXNBcnJheS5wdXNoKHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub2Rlc0FycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc3RhY2sgY2x1c3RlcklkJ3MgdGhhdCBhIGNlcnRhaW4gbm9kZSByZXNpZGVzIGluLiBjbHVzdGVyIEEgLT4gY2x1c3RlciBCIC0+IGNsdXN0ZXIgQyAtPiBub2RlXG4gICAgICpcbiAgICAgKiBJZiBhIG5vZGUgY2FuJ3QgYmUgZm91bmQgaW4gdGhlIGNoYWluLCByZXR1cm4gYW4gZW1wdHkgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmaW5kTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kTm9kZShub2RlSWQpIHtcbiAgICAgIHZhciBzdGFjayA9IFtdO1xuICAgICAgdmFyIG1heCA9IDEwMDtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHZhciBub2RlO1xuICAgICAgd2hpbGUgKHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXSAhPT0gdW5kZWZpbmVkICYmIGNvdW50ZXIgPCBtYXgpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gICAgICAgIHN0YWNrLnB1c2gobm9kZS5pZCk7XG4gICAgICAgIG5vZGVJZCA9IHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXS5jbHVzdGVySWQ7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHJldHVybiBbXTtcbiAgICAgIHN0YWNrLnB1c2gobm9kZS5pZCk7XG4gICAgICBfcmV2ZXJzZUluc3RhbmNlUHJvcGVydHkoc3RhY2spLmNhbGwoc3RhY2spO1xuICAgICAgcmV0dXJuIHN0YWNrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVzaW5nIGEgY2x1c3RlcmVkIG5vZGVJZCwgdXBkYXRlIHdpdGggdGhlIG5ldyBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IGNsdXN0ZXJlZE5vZGVJZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdPcHRpb25zXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQ2x1c3RlcmVkTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVDbHVzdGVyZWROb2RlKGNsdXN0ZXJlZE5vZGVJZCwgbmV3T3B0aW9ucykge1xuICAgICAgaWYgKGNsdXN0ZXJlZE5vZGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNsdXN0ZXJlZE5vZGVJZCBzdXBwbGllZCB0byB1cGRhdGVDbHVzdGVyZWROb2RlLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdPcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbmV3T3B0aW9ucyBzdXBwbGllZCB0byB1cGRhdGVDbHVzdGVyZWROb2RlLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbY2x1c3RlcmVkTm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBjbHVzdGVyZWROb2RlSWQgc3VwcGxpZWQgdG8gdXBkYXRlQ2x1c3RlcmVkTm9kZSBkb2VzIG5vdCBleGlzdC5cIik7XG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkubm9kZXNbY2x1c3RlcmVkTm9kZUlkXS5zZXRPcHRpb25zKG5ld09wdGlvbnMpO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2luZyBhIGJhc2UgZWRnZUlkLCB1cGRhdGUgYWxsIHJlbGF0ZWQgY2x1c3RlcmVkIGVkZ2VzIHdpdGggdGhlIG5ldyBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlLmlkfSBzdGFydEVkZ2VJZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdPcHRpb25zXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVFZGdlKHN0YXJ0RWRnZUlkLCBuZXdPcHRpb25zKSB7XG4gICAgICBpZiAoc3RhcnRFZGdlSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdGFydEVkZ2VJZCBzdXBwbGllZCB0byB1cGRhdGVFZGdlLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdPcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbmV3T3B0aW9ucyBzdXBwbGllZCB0byB1cGRhdGVFZGdlLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmJvZHkuZWRnZXNbc3RhcnRFZGdlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0YXJ0RWRnZUlkIHN1cHBsaWVkIHRvIHVwZGF0ZUVkZ2UgZG9lcyBub3QgZXhpc3QuXCIpO1xuICAgICAgfVxuICAgICAgdmFyIGFsbEVkZ2VJZHMgPSB0aGlzLmdldENsdXN0ZXJlZEVkZ2VzKHN0YXJ0RWRnZUlkKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsRWRnZUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IHRoaXMuYm9keS5lZGdlc1thbGxFZGdlSWRzW2ldXTtcbiAgICAgICAgZWRnZS5zZXRPcHRpb25zKG5ld09wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhQ2hhbmdlZFwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzdGFjayBvZiBjbHVzdGVyRWRnZUlkJ3MgKCtiYXNlIGVkZ2VpZCkgdGhhdCBhIGJhc2UgZWRnZSBpcyB0aGUgc2FtZSBhcy4gY2x1c3RlciBlZGdlIEMgLT4gY2x1c3RlciBlZGdlIEIgLT4gY2x1c3RlciBlZGdlIEEgLT4gYmFzZSBlZGdlKGVkZ2VJZClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dmlzLkVkZ2UuaWR9IGVkZ2VJZFxuICAgICAqIEByZXR1cm5zIHtBcnJheS48dmlzLkVkZ2UuaWQ+fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldENsdXN0ZXJlZEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsdXN0ZXJlZEVkZ2VzKGVkZ2VJZCkge1xuICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICB2YXIgbWF4ID0gMTAwO1xuICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgd2hpbGUgKGVkZ2VJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdICE9PSB1bmRlZmluZWQgJiYgY291bnRlciA8IG1heCkge1xuICAgICAgICBzdGFjay5wdXNoKHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdLmlkKTtcbiAgICAgICAgZWRnZUlkID0gdGhpcy5ib2R5LmVkZ2VzW2VkZ2VJZF0uZWRnZVJlcGxhY2VkQnlJZDtcbiAgICAgICAgY291bnRlcisrO1xuICAgICAgfVxuICAgICAgX3JldmVyc2VJbnN0YW5jZVByb3BlcnR5KHN0YWNrKS5jYWxsKHN0YWNrKTtcbiAgICAgIHJldHVybiBzdGFjaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJhc2UgZWRnZSBpZCBvZiBjbHVzdGVyRWRnZUlkLiBjbHVzdGVyIGVkZ2UgKGNsdXN0ZXJlZEVkZ2VJZCkgLT4gY2x1c3RlciBlZGdlIEIgLT4gY2x1c3RlciBlZGdlIEMgLT4gYmFzZSBlZGdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlLmlkfSBjbHVzdGVyZWRFZGdlSWRcbiAgICAgKiBAcmV0dXJucyB7dmlzLkVkZ2UuaWR9IGJhc2VFZGdlSWRcbiAgICAgKlxuICAgICAqIFRPRE86IGRlcHJlY2F0ZSBpbiA1LjAuMC4gTWV0aG9kIGdldEJhc2VFZGdlcygpIGlzIHRoZSBjb3JyZWN0IG9uZSB0byB1c2UuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmFzZUVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QmFzZUVkZ2UoY2x1c3RlcmVkRWRnZUlkKSB7XG4gICAgICAvLyBKdXN0IGtsdWRnZSB0aGlzIGJ5IHJldHVybmluZyB0aGUgZmlyc3QgYmFzZSBlZGdlIGlkIGZvdW5kXG4gICAgICByZXR1cm4gdGhpcy5nZXRCYXNlRWRnZXMoY2x1c3RlcmVkRWRnZUlkKVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHJlZ3VsYXIgZWRnZXMgZm9yIHRoaXMgY2x1c3RlcmVkIGVkZ2UgaWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlLmlkfSBjbHVzdGVyZWRFZGdlSWRcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPHZpcy5FZGdlLmlkPn0gYWxsIGJhc2VFZGdlSWQncyB1bmRlciB0aGlzIGNsdXN0ZXJlZCBlZGdlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmFzZUVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJhc2VFZGdlcyhjbHVzdGVyZWRFZGdlSWQpIHtcbiAgICAgIHZhciBJZHNUb0hhbmRsZSA9IFtjbHVzdGVyZWRFZGdlSWRdO1xuICAgICAgdmFyIGRvbmVJZHMgPSBbXTtcbiAgICAgIHZhciBmb3VuZElkcyA9IFtdO1xuICAgICAgdmFyIG1heCA9IDEwMDtcbiAgICAgIHZhciBjb3VudGVyID0gMDtcbiAgICAgIHdoaWxlIChJZHNUb0hhbmRsZS5sZW5ndGggPiAwICYmIGNvdW50ZXIgPCBtYXgpIHtcbiAgICAgICAgdmFyIG5leHRJZCA9IElkc1RvSGFuZGxlLnBvcCgpO1xuICAgICAgICBpZiAobmV4dElkID09PSB1bmRlZmluZWQpIGNvbnRpbnVlOyAvLyBQYXJhbm9pYSBoZXJlIGFuZCBvbndhcmRzXG4gICAgICAgIHZhciBuZXh0RWRnZSA9IHRoaXMuYm9keS5lZGdlc1tuZXh0SWRdO1xuICAgICAgICBpZiAobmV4dEVkZ2UgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG4gICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgdmFyIHJlcGxhY2luZ0lkcyA9IG5leHRFZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzO1xuICAgICAgICBpZiAocmVwbGFjaW5nSWRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBuZXh0SWQgaXMgYSBiYXNlIGlkXG4gICAgICAgICAgZm91bmRJZHMucHVzaChuZXh0SWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFub3RoZXIgY2x1c3RlciBlZGdlLCB1bnJhdmVsIHRoaXMgb25lIGFzIHdlbGxcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcGxhY2luZ0lkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2luZ0lkID0gcmVwbGFjaW5nSWRzW2ldO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBhZGQgaWYgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAgICAgICAvLyBUT0RPOiBuZXZlciB0cmlnZ2VyczsgZmluZCBhIHRlc3QtY2FzZSB3aGljaCBkb2VzXG4gICAgICAgICAgICBpZiAoX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KElkc1RvSGFuZGxlKS5jYWxsKElkc1RvSGFuZGxlLCByZXBsYWNpbmdJZHMpICE9PSAtMSB8fCBfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoZG9uZUlkcykuY2FsbChkb25lSWRzLCByZXBsYWNpbmdJZHMpICE9PSAtMSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIElkc1RvSGFuZGxlLnB1c2gocmVwbGFjaW5nSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkb25lSWRzLnB1c2gobmV4dElkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3VuZElkcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIElkIHRoZSBub2RlIGlzIGNvbm5lY3RlZCB0b1xuICAgICAqXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZX0gZWRnZVxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q29ubmVjdGVkSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENvbm5lY3RlZElkKGVkZ2UsIG5vZGVJZCkge1xuICAgICAgaWYgKGVkZ2UudG9JZCAhPSBub2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2UudG9JZDtcbiAgICAgIH0gZWxzZSBpZiAoZWRnZS5mcm9tSWQgIT0gbm9kZUlkKSB7XG4gICAgICAgIHJldHVybiBlZGdlLmZyb21JZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlZGdlLmZyb21JZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSBkZXRlcm1pbmUgaG93IG1hbnkgY29ubmVjdGlvbnMgZGVub3RlIGFuIGltcG9ydGFudCBodWIuXG4gICAgICogV2UgdGFrZSB0aGUgbWVhbiArIDIqc3RkIGFzIHRoZSBpbXBvcnRhbnQgaHViIHNpemUuIChBc3N1bWluZyBhIG5vcm1hbCBkaXN0cmlidXRpb24gb2YgZGF0YSwgfjIuMiUpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEh1YlNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEh1YlNpemUoKSB7XG4gICAgICB2YXIgYXZlcmFnZSA9IDA7XG4gICAgICB2YXIgYXZlcmFnZVNxdWFyZWQgPSAwO1xuICAgICAgdmFyIGh1YkNvdW50ZXIgPSAwO1xuICAgICAgdmFyIGxhcmdlc3RIdWIgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbdGhpcy5ib2R5Lm5vZGVJbmRpY2VzW2ldXTtcbiAgICAgICAgaWYgKG5vZGUuZWRnZXMubGVuZ3RoID4gbGFyZ2VzdEh1Yikge1xuICAgICAgICAgIGxhcmdlc3RIdWIgPSBub2RlLmVkZ2VzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBhdmVyYWdlICs9IG5vZGUuZWRnZXMubGVuZ3RoO1xuICAgICAgICBhdmVyYWdlU3F1YXJlZCArPSBNYXRoLnBvdyhub2RlLmVkZ2VzLmxlbmd0aCwgMik7XG4gICAgICAgIGh1YkNvdW50ZXIgKz0gMTtcbiAgICAgIH1cbiAgICAgIGF2ZXJhZ2UgPSBhdmVyYWdlIC8gaHViQ291bnRlcjtcbiAgICAgIGF2ZXJhZ2VTcXVhcmVkID0gYXZlcmFnZVNxdWFyZWQgLyBodWJDb3VudGVyO1xuICAgICAgdmFyIHZhcmlhbmNlID0gYXZlcmFnZVNxdWFyZWQgLSBNYXRoLnBvdyhhdmVyYWdlLCAyKTtcbiAgICAgIHZhciBzdGFuZGFyZERldmlhdGlvbiA9IE1hdGguc3FydCh2YXJpYW5jZSk7XG4gICAgICB2YXIgaHViVGhyZXNob2xkID0gTWF0aC5mbG9vcihhdmVyYWdlICsgMiAqIHN0YW5kYXJkRGV2aWF0aW9uKTtcblxuICAgICAgLy8gYWx3YXlzIGhhdmUgYXQgbGVhc3Qgb25lIHRvIGNsdXN0ZXJcbiAgICAgIGlmIChodWJUaHJlc2hvbGQgPiBsYXJnZXN0SHViKSB7XG4gICAgICAgIGh1YlRocmVzaG9sZCA9IGxhcmdlc3RIdWI7XG4gICAgICB9XG4gICAgICByZXR1cm4gaHViVGhyZXNob2xkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBlZGdlIGZvciB0aGUgY2x1c3RlciByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gZnJvbUlkXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSB0b0lkXG4gICAgICogQHBhcmFtIHt2aXMuRWRnZX0gYmFzZUVkZ2VcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY2x1c3RlckVkZ2VQcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGV4dHJhT3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHtFZGdlfSBuZXdseSBjcmVhdGVkIGNsdXN0ZXJlZCBlZGdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQ2x1c3RlcmVkRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQ2x1c3RlcmVkRWRnZShmcm9tSWQsIHRvSWQsIGJhc2VFZGdlLCBjbHVzdGVyRWRnZVByb3BlcnRpZXMsIGV4dHJhT3B0aW9ucykge1xuICAgICAgLy8gY29weSB0aGUgb3B0aW9ucyBvZiB0aGUgZWRnZSB3ZSB3aWxsIHJlcGxhY2VcbiAgICAgIHZhciBjbG9uZWRPcHRpb25zID0gTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKGJhc2VFZGdlLCBcImVkZ2VcIik7XG4gICAgICAvLyBtYWtlIHN1cmUgdGhlIHByb3BlcnRpZXMgb2YgY2x1c3RlckVkZ2VzIGFyZSBzdXBlcmltcG9zZWQgb24gaXRcbiAgICAgIGRlZXBFeHRlbmQoY2xvbmVkT3B0aW9ucywgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKTtcblxuICAgICAgLy8gc2V0IHVwIHRoZSBlZGdlXG4gICAgICBjbG9uZWRPcHRpb25zLmZyb20gPSBmcm9tSWQ7XG4gICAgICBjbG9uZWRPcHRpb25zLnRvID0gdG9JZDtcbiAgICAgIGNsb25lZE9wdGlvbnMuaWQgPSBcImNsdXN0ZXJFZGdlOlwiICsgdjQoKTtcblxuICAgICAgLy8gYXBwbHkgdGhlIGVkZ2Ugc3BlY2lmaWMgb3B0aW9ucyB0byBpdCBpZiBzcGVjaWZpZWRcbiAgICAgIGlmIChleHRyYU9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWVwRXh0ZW5kKGNsb25lZE9wdGlvbnMsIGV4dHJhT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RWRnZSA9IHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlRWRnZShjbG9uZWRPcHRpb25zKTtcbiAgICAgIG5ld0VkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMgPSBbYmFzZUVkZ2UuaWRdO1xuICAgICAgbmV3RWRnZS5jb25uZWN0KCk7XG5cbiAgICAgIC8vIFJlZ2lzdGVyIHRoZSBuZXcgZWRnZVxuICAgICAgdGhpcy5ib2R5LmVkZ2VzW25ld0VkZ2UuaWRdID0gbmV3RWRnZTtcbiAgICAgIHJldHVybiBuZXdFZGdlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgcGFzc2VkIGNoaWxkIG5vZGVzIGFuZCBlZGdlcyB0byB0aGUgZ2l2ZW4gY2x1c3RlciBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3QgfCBOb2RlfSBjaGlsZE5vZGVzICBoYXNoIG9mIG5vZGVzIG9yIHNpbmdsZSBub2RlIHRvIGFkZCBpbiBjbHVzdGVyXG4gICAgICogQHBhcmFtIHtvYmplY3QgfCBFZGdlfSBjaGlsZEVkZ2VzICBoYXNoIG9mIGVkZ2VzIG9yIHNpbmdsZSBlZGdlIHRvIHRha2UgaW50byBhY2NvdW50IHdoZW4gY2x1c3RlcmluZ1xuICAgICAqIEBwYXJhbSB7Tm9kZX0gY2x1c3Rlck5vZGUgIGNsdXN0ZXIgbm9kZSB0byBhZGQgbm9kZXMgYW5kIGVkZ2VzIHRvXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjbHVzdGVyRWRnZVByb3BlcnRpZXNdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY2x1c3RlckVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbHVzdGVyRWRnZXMoY2hpbGROb2RlcywgY2hpbGRFZGdlcywgY2x1c3Rlck5vZGUsIGNsdXN0ZXJFZGdlUHJvcGVydGllcykge1xuICAgICAgaWYgKGNoaWxkRWRnZXMgaW5zdGFuY2VvZiBFZGdlKSB7XG4gICAgICAgIHZhciBlZGdlID0gY2hpbGRFZGdlcztcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgICBvYmpbZWRnZS5pZF0gPSBlZGdlO1xuICAgICAgICBjaGlsZEVkZ2VzID0gb2JqO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkTm9kZXMgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIHZhciBub2RlID0gY2hpbGROb2RlcztcbiAgICAgICAgdmFyIF9vYmogPSB7fTtcbiAgICAgICAgX29ialtub2RlLmlkXSA9IG5vZGU7XG4gICAgICAgIGNoaWxkTm9kZXMgPSBfb2JqO1xuICAgICAgfVxuICAgICAgaWYgKGNsdXN0ZXJOb2RlID09PSB1bmRlZmluZWQgfHwgY2x1c3Rlck5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX2NsdXN0ZXJFZGdlczogcGFyYW1ldGVyIGNsdXN0ZXJOb2RlIHJlcXVpcmVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKGNsdXN0ZXJFZGdlUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFRha2UgdGhlIHJlcXVpcmVkIHByb3BlcnRpZXMgZnJvbSB0aGUgY2x1c3RlciBub2RlXG4gICAgICAgIGNsdXN0ZXJFZGdlUHJvcGVydGllcyA9IGNsdXN0ZXJOb2RlLmNsdXN0ZXJFZGdlUHJvcGVydGllcztcbiAgICAgIH1cblxuICAgICAgLy8gY3JlYXRlIHRoZSBuZXcgZWRnZXMgdGhhdCB3aWxsIGNvbm5lY3QgdG8gdGhlIGNsdXN0ZXIuXG4gICAgICAvLyBBbGwgc2VsZi1yZWZlcmVuY2luZyBlZGdlcyB3aWxsIGJlIGFkZGVkIHRvIGNoaWxkRWRnZXMgaGVyZS5cbiAgICAgIHRoaXMuX2NyZWF0ZUNsdXN0ZXJFZGdlcyhjaGlsZE5vZGVzLCBjaGlsZEVkZ2VzLCBjbHVzdGVyTm9kZSwgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzKTtcblxuICAgICAgLy8gZGlzYWJsZSB0aGUgY2hpbGRFZGdlc1xuICAgICAgZm9yICh2YXIgZWRnZUlkIGluIGNoaWxkRWRnZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjaGlsZEVkZ2VzLCBlZGdlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBfZWRnZTIgPSB0aGlzLmJvZHkuZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICAgIC8vIGNhY2hlIHRoZSBvcHRpb25zIGJlZm9yZSBjaGFuZ2luZ1xuICAgICAgICAgICAgdGhpcy5fYmFja3VwRWRnZU9wdGlvbnMoX2VkZ2UyKTtcbiAgICAgICAgICAgIC8vIGRpc2FibGUgcGh5c2ljcyBhbmQgaGlkZSB0aGUgZWRnZVxuICAgICAgICAgICAgX2VkZ2UyLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICBwaHlzaWNzOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGRpc2FibGUgdGhlIGNoaWxkTm9kZXNcbiAgICAgIGZvciAodmFyIG5vZGVJZCBpbiBjaGlsZE5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY2hpbGROb2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgIHRoaXMuY2x1c3RlcmVkTm9kZXNbbm9kZUlkXSA9IHtcbiAgICAgICAgICAgIGNsdXN0ZXJJZDogY2x1c3Rlck5vZGUuaWQsXG4gICAgICAgICAgICBub2RlOiB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0uc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBwaHlzaWNzOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGluIHdoaWNoIGNsdXN0ZXIgZ2l2ZW4gbm9kZUlkIHJlc2lkZXMuXG4gICAgICpcbiAgICAgKiBJZiBub3QgaW4gY2x1c3RlciwgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIE5PVEU6IElmIHlvdSBrbm93IGEgY2xlYW5lciB3YXkgdG8gZG8gdGhpcywgcGxlYXNlIGVubGlnaHRlbiBtZSAod2ltcmlqbmRlcnMpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7Tm9kZXx1bmRlZmluZWR9IE5vZGUgaW5zdGFuY2UgZm9yIGNsdXN0ZXIsIGlmIHByZXNlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDbHVzdGVyTm9kZUZvck5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENsdXN0ZXJOb2RlRm9yTm9kZShub2RlSWQpIHtcbiAgICAgIGlmIChub2RlSWQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciBjbHVzdGVyZWROb2RlID0gdGhpcy5jbHVzdGVyZWROb2Rlc1tub2RlSWRdO1xuXG4gICAgICAvLyBOT1RFOiBJZiBubyBjbHVzdGVyIGluZm8gZm91bmQsIGl0IHNob3VsZCBhY3R1YWxseSBiZSBhbiBlcnJvclxuICAgICAgaWYgKGNsdXN0ZXJlZE5vZGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHZhciBjbHVzdGVySWQgPSBjbHVzdGVyZWROb2RlLmNsdXN0ZXJJZDtcbiAgICAgIGlmIChjbHVzdGVySWQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzLmJvZHkubm9kZXNbY2x1c3RlcklkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gZm9yIGNvbmRpdGlvbmFsbHkgcmVtb3ZpbmcgaXRlbXMgaW4gYXJyYXlcbiAgICAgKlxuICAgICAqIERvbmUgbGlrZSB0aGlzIGJlY2F1c2UgQXJyYXkuZmlsdGVyKCkgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCBieSBhbGwgSUUncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbHRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmlsdGVyKGFyciwgY2FsbGJhY2spIHtcbiAgICAgIHZhciByZXQgPSBbXTtcbiAgICAgIGZvckVhY2gkMShhcnIsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhpdGVtKSkge1xuICAgICAgICAgIHJldC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2NhbiBhbGwgZWRnZXMgZm9yIGNoYW5nZXMgaW4gY2x1c3RlcmluZyBhbmQgYWRqdXN0IHRoaXMgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogQ2FsbCB0aGlzIChpbnRlcm5hbGx5KSBhZnRlciB0aGVyZSBoYXMgYmVlbiBhIGNoYW5nZSBpbiBub2RlIG9yIGVkZ2UgZGF0YS5cbiAgICAgKlxuICAgICAqIFByZTogU3RhdGVzIG9mIHRoaXMuYm9keS5ub2RlcyBhbmQgdGhpcy5ib2R5LmVkZ2VzIGNvbnNpc3RlbnRcbiAgICAgKiBQcmU6IHRoaXMuY2x1c3RlcmVkTm9kZXMgYW5kIHRoaXMuY2x1c3RlcmVkRWRnZSBjb25zaXN0ZW50IHdpdGggY29udGFpbmVkTm9kZXMgYW5kIGNvbnRhaW5lZEVkZ2VzXG4gICAgICogICAgICBvZiBjbHVzdGVyIG5vZGVzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlU3RhdGUoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIHZhciBub2RlSWQ7XG4gICAgICB2YXIgZGVsZXRlZE5vZGVJZHMgPSBbXTtcbiAgICAgIHZhciBkZWxldGVkRWRnZUlkcyA9IHt9O1xuXG4gICAgICAvKipcbiAgICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGNsdXN0ZXJpbmcgbm9kZXMgb25seVxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGNsdXN0ZXIgbm9kZVxuICAgICAgICovXG4gICAgICB2YXIgZWFjaENsdXN0ZXJOb2RlID0gZnVuY3Rpb24gZWFjaENsdXN0ZXJOb2RlKGNhbGxiYWNrKSB7XG4gICAgICAgIGZvckVhY2gkMShfdGhpczQuYm9keS5ub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvL1xuICAgICAgLy8gUmVtb3ZlIGRlbGV0ZWQgcmVndWxhciBub2RlcyBmcm9tIGNsdXN0ZXJpbmdcbiAgICAgIC8vXG5cbiAgICAgIC8vIERldGVybWluZSB0aGUgZGVsZXRlZCBub2Rlc1xuICAgICAgZm9yIChub2RlSWQgaW4gdGhpcy5jbHVzdGVyZWROb2Rlcykge1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmNsdXN0ZXJlZE5vZGVzLCBub2RlSWQpKSBjb250aW51ZTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZWROb2RlSWRzLnB1c2gobm9kZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgbm9kZXMgZnJvbSBjbHVzdGVyIG5vZGVzXG4gICAgICBlYWNoQ2x1c3Rlck5vZGUoZnVuY3Rpb24gKGNsdXN0ZXJOb2RlKSB7XG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZGVsZXRlZE5vZGVJZHMubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICBkZWxldGUgY2x1c3Rlck5vZGUuY29udGFpbmVkTm9kZXNbZGVsZXRlZE5vZGVJZHNbbl1dO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gUmVtb3ZlIG5vZGVzIGZyb20gY2x1c3RlciBsaXN0XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGRlbGV0ZWROb2RlSWRzLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNsdXN0ZXJlZE5vZGVzW2RlbGV0ZWROb2RlSWRzW25dXTtcbiAgICAgIH1cblxuICAgICAgLy9cbiAgICAgIC8vIFJlbW92ZSBkZWxldGVkIGVkZ2VzIGZyb20gY2x1c3RlcmluZ1xuICAgICAgLy9cblxuICAgICAgLy8gQWRkIHRoZSBkZWxldGVkIGNsdXN0ZXJlZCBlZGdlcyB0byB0aGUgbGlzdFxuICAgICAgZm9yRWFjaCQxKHRoaXMuY2x1c3RlcmVkRWRnZXMsIGZ1bmN0aW9uIChlZGdlSWQpIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBfdGhpczQuYm9keS5lZGdlc1tlZGdlSWRdO1xuICAgICAgICBpZiAoZWRnZSA9PT0gdW5kZWZpbmVkIHx8ICFlZGdlLmVuZFBvaW50c1ZhbGlkKCkpIHtcbiAgICAgICAgICBkZWxldGVkRWRnZUlkc1tlZGdlSWRdID0gZWRnZUlkO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ2x1c3RlciBub2RlcyBjYW4gYWxzbyBjb250YWluIGVkZ2VzIHdoaWNoIGFyZSBub3QgY2x1c3RlcmVkLFxuICAgICAgLy8gaS5lLiBub2RlcyAxLTIgd2l0aGluIGNsdXN0ZXIgd2l0aCBhbiBlZGdlIGluIGJldHdlZW4uXG4gICAgICAvLyBTbyB0aGUgY2x1c3RlciBub2RlcyBhbHNvIG5lZWQgdG8gYmUgc2Nhbm5lZCBmb3IgaW52YWxpZCBlZGdlc1xuICAgICAgZWFjaENsdXN0ZXJOb2RlKGZ1bmN0aW9uIChjbHVzdGVyTm9kZSkge1xuICAgICAgICBmb3JFYWNoJDEoY2x1c3Rlck5vZGUuY29udGFpbmVkRWRnZXMsIGZ1bmN0aW9uIChlZGdlLCBlZGdlSWQpIHtcbiAgICAgICAgICBpZiAoIWVkZ2UuZW5kUG9pbnRzVmFsaWQoKSAmJiAhZGVsZXRlZEVkZ2VJZHNbZWRnZUlkXSkge1xuICAgICAgICAgICAgZGVsZXRlZEVkZ2VJZHNbZWRnZUlkXSA9IGVkZ2VJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFsc28gc2NhbiBmb3IgY2x1c3RlciBlZGdlcyB3aGljaCBuZWVkIHRvIGJlIHJlbW92ZWQgaW4gdGhlIGFjdGl2ZSBsaXN0LlxuICAgICAgLy8gUmVndWxhciBlZGdlcyBoYXZlIGJlZW4gcmVtb3ZlZCBiZWZvcmVoYW5kLCBzbyB0aGlzIG9ubHkgcGlja3MgdXAgdGhlIGNsdXN0ZXIgZWRnZXMuXG4gICAgICBmb3JFYWNoJDEodGhpcy5ib2R5LmVkZ2VzLCBmdW5jdGlvbiAoZWRnZSwgZWRnZUlkKSB7XG4gICAgICAgIC8vIEV4cGxpY2l0bHkgc2NhbiB0aGUgY29udGFpbmVkIGVkZ2VzIGZvciB2YWxpZGl0eVxuICAgICAgICB2YXIgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgIHZhciByZXBsYWNlZElkcyA9IGVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHM7XG4gICAgICAgIGlmIChyZXBsYWNlZElkcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG51bVZhbGlkID0gMDtcbiAgICAgICAgICBmb3JFYWNoJDEocmVwbGFjZWRJZHMsIGZ1bmN0aW9uIChjb250YWluZWRFZGdlSWQpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZWRFZGdlID0gX3RoaXM0LmJvZHkuZWRnZXNbY29udGFpbmVkRWRnZUlkXTtcbiAgICAgICAgICAgIGlmIChjb250YWluZWRFZGdlICE9PSB1bmRlZmluZWQgJiYgY29udGFpbmVkRWRnZS5lbmRQb2ludHNWYWxpZCgpKSB7XG4gICAgICAgICAgICAgIG51bVZhbGlkICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaXNWYWxpZCA9IG51bVZhbGlkID4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVkZ2UuZW5kUG9pbnRzVmFsaWQoKSB8fCAhaXNWYWxpZCkge1xuICAgICAgICAgIGRlbGV0ZWRFZGdlSWRzW2VkZ2VJZF0gPSBlZGdlSWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZW1vdmUgZWRnZXMgZnJvbSBjbHVzdGVyIG5vZGVzXG4gICAgICBlYWNoQ2x1c3Rlck5vZGUoZnVuY3Rpb24gKGNsdXN0ZXJOb2RlKSB7XG4gICAgICAgIGZvckVhY2gkMShkZWxldGVkRWRnZUlkcywgZnVuY3Rpb24gKGRlbGV0ZWRFZGdlSWQpIHtcbiAgICAgICAgICBkZWxldGUgY2x1c3Rlck5vZGUuY29udGFpbmVkRWRnZXNbZGVsZXRlZEVkZ2VJZF07XG4gICAgICAgICAgZm9yRWFjaCQxKGNsdXN0ZXJOb2RlLmVkZ2VzLCBmdW5jdGlvbiAoZWRnZSwgbSkge1xuICAgICAgICAgICAgaWYgKGVkZ2UuaWQgPT09IGRlbGV0ZWRFZGdlSWQpIHtcbiAgICAgICAgICAgICAgY2x1c3Rlck5vZGUuZWRnZXNbbV0gPSBudWxsOyAvLyBEb24ndCB3YW50IHRvIGRpcmVjdGx5IGRlbGV0ZSBoZXJlLCBiZWNhdXNlIGluIHRoZSBsb29wXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVkZ2UuY2x1c3RlcmluZ0VkZ2VSZXBsYWNpbmdJZHMgPSBfdGhpczQuX2ZpbHRlcihlZGdlLmNsdXN0ZXJpbmdFZGdlUmVwbGFjaW5nSWRzLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICFkZWxldGVkRWRnZUlkc1tpZF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIENsZWFuIHVwIHRoZSBudWxsc1xuICAgICAgICAgIGNsdXN0ZXJOb2RlLmVkZ2VzID0gX3RoaXM0Ll9maWx0ZXIoY2x1c3Rlck5vZGUuZWRnZXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbSAhPT0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUmVtb3ZlIGZyb20gY2x1c3RlciBsaXN0XG4gICAgICBmb3JFYWNoJDEoZGVsZXRlZEVkZ2VJZHMsIGZ1bmN0aW9uIChlZGdlSWQpIHtcbiAgICAgICAgZGVsZXRlIF90aGlzNC5jbHVzdGVyZWRFZGdlc1tlZGdlSWRdO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlbW92ZSBjbHVzdGVyIGVkZ2VzIGZyb20gYWN0aXZlIGxpc3QgKHRoaXMuYm9keS5lZGdlcykuXG4gICAgICAvLyBkZWxldGVkRWRnZUlkcyBzdGlsbCBjb250YWlucyBpZCBvZiByZWd1bGFyIGVkZ2VzLCBidXQgdGhlc2Ugc2hvdWxkIGFsbFxuICAgICAgLy8gYmUgZ29uZSB3aGVuIHlvdSByZWFjaCBoZXJlLlxuICAgICAgZm9yRWFjaCQxKGRlbGV0ZWRFZGdlSWRzLCBmdW5jdGlvbiAoZWRnZUlkKSB7XG4gICAgICAgIGRlbGV0ZSBfdGhpczQuYm9keS5lZGdlc1tlZGdlSWRdO1xuICAgICAgfSk7XG5cbiAgICAgIC8vXG4gICAgICAvLyBDaGVjayBjaGFuZ2VkIGNsdXN0ZXIgc3RhdGUgb2YgZWRnZXNcbiAgICAgIC8vXG5cbiAgICAgIC8vIEl0ZXJhdGluZyBvdmVyIGtleXMgaGVyZSwgYmVjYXVzZSBlZGdlcyBtYXkgYmUgcmVtb3ZlZCBpbiB0aGUgbG9vcFxuICAgICAgdmFyIGlkcyA9IF9PYmplY3Qka2V5cyh0aGlzLmJvZHkuZWRnZXMpO1xuICAgICAgZm9yRWFjaCQxKGlkcywgZnVuY3Rpb24gKGVkZ2VJZCkge1xuICAgICAgICB2YXIgZWRnZSA9IF90aGlzNC5ib2R5LmVkZ2VzW2VkZ2VJZF07XG4gICAgICAgIHZhciBzaG91bGRCZUNsdXN0ZXJlZCA9IF90aGlzNC5faXNDbHVzdGVyZWROb2RlKGVkZ2UuZnJvbUlkKSB8fCBfdGhpczQuX2lzQ2x1c3RlcmVkTm9kZShlZGdlLnRvSWQpO1xuICAgICAgICBpZiAoc2hvdWxkQmVDbHVzdGVyZWQgPT09IF90aGlzNC5faXNDbHVzdGVyZWRFZGdlKGVkZ2UuaWQpKSB7XG4gICAgICAgICAgcmV0dXJuOyAvLyBhbGwgaXMgd2VsbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZEJlQ2x1c3RlcmVkKSB7XG4gICAgICAgICAgLy8gYWRkIGVkZ2UgdG8gY2x1c3RlcmluZ1xuICAgICAgICAgIHZhciBjbHVzdGVyRnJvbSA9IF90aGlzNC5fZ2V0Q2x1c3Rlck5vZGVGb3JOb2RlKGVkZ2UuZnJvbUlkKTtcbiAgICAgICAgICBpZiAoY2x1c3RlckZyb20gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXM0Ll9jbHVzdGVyRWRnZXMoX3RoaXM0LmJvZHkubm9kZXNbZWRnZS5mcm9tSWRdLCBlZGdlLCBjbHVzdGVyRnJvbSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBjbHVzdGVyVG8gPSBfdGhpczQuX2dldENsdXN0ZXJOb2RlRm9yTm9kZShlZGdlLnRvSWQpO1xuICAgICAgICAgIGlmIChjbHVzdGVyVG8gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXM0Ll9jbHVzdGVyRWRnZXMoX3RoaXM0LmJvZHkubm9kZXNbZWRnZS50b0lkXSwgZWRnZSwgY2x1c3RlclRvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUT0RPOiBjaGVjayB0aGF0IGl0IHdvcmtzIGZvciBib3RoIGVkZ2VzIGNsdXN0ZXJlZFxuICAgICAgICAgIC8vICAgICAgIChUaGlzIG1pZ2h0IGJlIHBhcmFub2lhKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBfdGhpczQuX2NsdXN0ZXJFZGdlc1tlZGdlSWRdO1xuICAgICAgICAgIF90aGlzNC5fcmVzdG9yZUVkZ2UoZWRnZSk7XG4gICAgICAgICAgLy8gVGhpcyBzaG91bGQgbm90IGJlIGhhcHBlbmluZywgdGhlIHN0YXRlIHNob3VsZFxuICAgICAgICAgIC8vIGJlIHByb3Blcmx5IHVwZGF0ZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIElmIGl0ICppcyogcmVhY2hlZCBkdXJpbmcgbm9ybWFsIG9wZXJhdGlvbiwgdGhlbiB3ZSBoYXZlIHRvIGltcGxlbWVudFxuICAgICAgICAgIC8vIHVuZG8gY2x1c3RlcmluZyBmb3IgdGhpcyBlZGdlIGhlcmUuXG4gICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdyZW1vdmUgZWRnZSBmcm9tIGNsdXN0ZXJpbmcgbm90IGltcGxlbWVudGVkIScpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDbHVzdGVycyBtYXkgYmUgbmVzdGVkIHRvIGFueSBsZXZlbC4gS2VlcCBvbiBvcGVuaW5nIHVudGlsIG5vdGhpbmcgdG8gb3BlblxuICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIHZhciBjb250aW51ZUxvb3AgPSB0cnVlO1xuICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMigpIHtcbiAgICAgICAgdmFyIGNsdXN0ZXJzVG9PcGVuID0gW107XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBpZCdzIG9mIGNsdXN0ZXJzIHRoYXQgbmVlZCBvcGVuaW5nXG4gICAgICAgIGVhY2hDbHVzdGVyTm9kZShmdW5jdGlvbiAoY2x1c3Rlck5vZGUpIHtcbiAgICAgICAgICB2YXIgbnVtTm9kZXMgPSBfT2JqZWN0JGtleXMoY2x1c3Rlck5vZGUuY29udGFpbmVkTm9kZXMpLmxlbmd0aDtcbiAgICAgICAgICB2YXIgYWxsb3dTaW5nbGUgPSBjbHVzdGVyTm9kZS5vcHRpb25zLmFsbG93U2luZ2xlTm9kZUNsdXN0ZXIgPT09IHRydWU7XG4gICAgICAgICAgaWYgKGFsbG93U2luZ2xlICYmIG51bU5vZGVzIDwgMSB8fCAhYWxsb3dTaW5nbGUgJiYgbnVtTm9kZXMgPCAyKSB7XG4gICAgICAgICAgICBjbHVzdGVyc1RvT3Blbi5wdXNoKGNsdXN0ZXJOb2RlLmlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIE9wZW4gdGhlbVxuICAgICAgICBmb3IgKHZhciBfbiA9IDA7IF9uIDwgY2x1c3RlcnNUb09wZW4ubGVuZ3RoOyArK19uKSB7XG4gICAgICAgICAgX3RoaXM0Lm9wZW5DbHVzdGVyKGNsdXN0ZXJzVG9PcGVuW19uXSwge30sIGZhbHNlIC8qIERvbid0IHJlZnJlc2gsIHdlJ3JlIGluIGFuIHJlZnJlc2gvdXBkYXRlIGFscmVhZHkgKi8pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWVMb29wID0gY2x1c3RlcnNUb09wZW4ubGVuZ3RoID4gMDtcbiAgICAgICAgY2hhbmdlZCA9IGNoYW5nZWQgfHwgY29udGludWVMb29wO1xuICAgICAgfTtcbiAgICAgIHdoaWxlIChjb250aW51ZUxvb3ApIHtcbiAgICAgICAgX2xvb3AyKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB0aGlzLl91cGRhdGVTdGF0ZSgpOyAvLyBSZWRvIHRoaXMgbWV0aG9kIChyZWN1cnNpb24gcG9zc2libGUhIHNob3VsZCBiZSBzYWZlKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiBub2RlIHdpdGggZ2l2ZW4gaWQgaXMgcGFydCBvZiBhIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG5vZGVJZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHBhcnQgb2YgYSBjbHVzdGVyLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9pc0NsdXN0ZXJlZE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2lzQ2x1c3RlcmVkTm9kZShub2RlSWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsdXN0ZXJlZE5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgZWRnZSB3aXRoIGdpdmVuIGlkIGlzIG5vdCB2aXNpYmxlIGR1ZSB0byBjbHVzdGVyaW5nLlxuICAgICAqXG4gICAgICogQW4gZWRnZSBpcyBjb25zaWRlcmVkIGNsdXN0ZXJlZCBpZjpcbiAgICAgKiAtIGl0IGlzIGRpcmVjdGx5IHJlcGxhY2VkIGJ5IGEgY2x1c3RlcmluZyBlZGdlXG4gICAgICogLSBhbnkgb2YgaXRzIGNvbm5lY3Rpbmcgbm9kZXMgaXMgaW4gYSBjbHVzdGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3Zpcy5FZGdlLmlkfSBlZGdlSWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBwYXJ0IG9mIGEgY2x1c3Rlci5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfaXNDbHVzdGVyZWRFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pc0NsdXN0ZXJlZEVkZ2UoZWRnZUlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jbHVzdGVyZWRFZGdlc1tlZGdlSWRdICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDbHVzdGVyRW5naW5lO1xufSgpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSB0byBhIHVzYWJsZSBmb3JtLlxuICpcbiAqIFNwZWNpZmljYWxseSwgc2V0IHVwIHRoaXMgbWV0aG9kIGZvciB0aGUgY2FzZSBvZiBydW5uaW5nIG9uIG5vZGUuanMgd2l0aCBqc2RvbSBlbmFibGVkLlxuICpcbiAqIE5PVEVTOlxuICpcbiAqIE9uIG5vZGUuanMsIHdoZW4gY2FsbGluZyB0aGlzIGRpcmVjdGx5IG91dHNpZGUgb2YgdGhpcyBjbGFzcywgYHdpbmRvd2AgaXMgbm90IGRlZmluZWQuXG4gKiAgIFRoaXMgaGFwcGVucyBldmVuIGlmIGpzZG9tIGlzIHVzZWQuXG4gKiBGb3Igbm9kZS5qcyArIGpzZG9tLCBgd2luZG93YCBpcyBhdmFpbGFibGUgYXQgdGhlIG1vbWVudCB0aGUgY29uc3RydWN0b3IgaXMgY2FsbGVkLlxuICogICBGb3IgdGhpcyByZWFzb24sIHRoZSBjYWxsZWQgaXMgcGxhY2VkIHdpdGhpbiB0aGUgY29uc3RydWN0b3IuXG4gKiBFdmVuIHRoZW4sIGB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKClgIGlzIG5vdCBkZWZpbmVkLCBzbyBpdCBzdGlsbCBuZWVkcyB0byBiZSBhZGRlZC5cbiAqIER1cmluZyB1bml0IHRlc3RpbmcsIGl0IGhhcHBlbnMgdGhhdCB0aGUgd2luZG93IG9iamVjdCBpcyByZXNldCBkdXJpbmcgZXhlY3V0aW9uLCBjYXVzaW5nXG4gKiAgIGEgcnVudGltZSBlcnJvciBkdWUgdG8gbWlzc2luZyBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKClgLiBUaGlzIG5lZWRzIHRvIGJlIGNvbXBlbnNhdGVkIGZvcixcbiAqICAgc2VlIGBfcmVxdWVzdE5leHRGcmFtZSgpYC5cbiAqIFNpbmNlIHRoaXMgaXMgYSBnbG9iYWwgb2JqZWN0LCBpdCBtYXkgYWZmZWN0IG90aGVyIG1vZHVsZXMgYmVzaWRlcyBgTmV0d29ya2AuIFdpdGggbm9ybWFsXG4gKiAgIHVzYWdlLCB0aGlzIGRvZXMgbm90IGNhdXNlIGFueSBwcm9ibGVtcy4gRHVyaW5nIHVuaXQgdGVzdGluZywgZXJyb3JzIG1heSBvY2N1ci4gVGhlc2UgaGF2ZVxuICogICBiZWVuIGNvbXBlbnNhdGVkIGZvciwgc2VlIGNvbW1lbnQgYmxvY2sgaW4gX3JlcXVlc3ROZXh0RnJhbWUoKS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfaW5pdFJlcXVlc3RBbmltYXRpb25GcmFtZSgpIHtcbiAgdmFyIGZ1bmM7XG4gIGlmICh3aW5kb3cgIT09IHVuZGVmaW5lZCkge1xuICAgIGZ1bmMgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG4gIH1cbiAgaWYgKGZ1bmMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIHdpbmRvdyBvciBtZXRob2Qgbm90IHByZXNlbnQsIHNldHRpbmcgbW9jayByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAvL2NvbnNvbGUubG9nKFwiQ2FsbGVkIG1vY2sgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGNhbnZhcyByZW5kZXJlclxuICovXG52YXIgQ2FudmFzUmVuZGVyZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKi9cbiAgZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIoYm9keSwgY2FudmFzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbnZhc1JlbmRlcmVyKTtcbiAgICBfaW5pdFJlcXVlc3RBbmltYXRpb25GcmFtZSgpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5yZWRyYXdSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlclRpbWVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlcmluZ0FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyUmVxdWVzdHMgPSAwO1xuICAgIHRoaXMuYWxsb3dSZWRyYXcgPSB0cnVlO1xuICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnpvb21pbmcgPSBmYWxzZTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgaGlkZUVkZ2VzT25EcmFnOiBmYWxzZSxcbiAgICAgIGhpZGVFZGdlc09uWm9vbTogZmFsc2UsXG4gICAgICBoaWRlTm9kZXNPbkRyYWc6IGZhbHNlXG4gICAgfTtcbiAgICBfT2JqZWN0JGFzc2lnbih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMuX2RldGVybWluZUJyb3dzZXJNZXRob2QoKTtcbiAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKENhbnZhc1JlbmRlcmVyLCBbe1xuICAgIGtleTogXCJiaW5kRXZlbnRMaXN0ZW5lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcyxcbiAgICAgICAgX2NvbnRleHQyO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkcmFnU3RhcnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZHJhZ0VuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiem9vbVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnpvb21pbmcgPSB0cnVlO1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KF90aGlzLnpvb21UaW1lb3V0SWQpO1xuICAgICAgICBfdGhpcy56b29tVGltZW91dElkID0gX3NldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBfY29udGV4dDtcbiAgICAgICAgICBfdGhpcy56b29taW5nID0gZmFsc2U7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQgPSBfdGhpcy5fcmVxdWVzdFJlZHJhdykuY2FsbChfY29udGV4dCwgX3RoaXMpKCk7XG4gICAgICAgIH0sIDI1MCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3Jlc2l6ZU5vZGVzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX3Jlc2l6ZU5vZGVzKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX3JlZHJhd1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpcy5yZW5kZXJpbmdBY3RpdmUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgX3RoaXMuX3JlZHJhdygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2Jsb2NrUmVkcmF3XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuYWxsb3dSZWRyYXcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfYWxsb3dSZWRyYXdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5hbGxvd1JlZHJhdyA9IHRydWU7XG4gICAgICAgIF90aGlzLnJlZHJhd1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZXF1ZXN0UmVkcmF3XCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MiA9IHRoaXMuX3JlcXVlc3RSZWRyYXcpLmNhbGwoX2NvbnRleHQyLCB0aGlzKSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9zdGFydFJlbmRlcmluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLnJlbmRlclJlcXVlc3RzICs9IDE7XG4gICAgICAgIF90aGlzLnJlbmRlcmluZ0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIF90aGlzLl9zdGFydFJlbmRlcmluZygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9zdG9wUmVuZGVyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucmVuZGVyUmVxdWVzdHMgLT0gMTtcbiAgICAgICAgX3RoaXMucmVuZGVyaW5nQWN0aXZlID0gX3RoaXMucmVuZGVyUmVxdWVzdHMgPiAwO1xuICAgICAgICBfdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZXN0cm95XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMucmVuZGVyUmVxdWVzdHMgPSAwO1xuICAgICAgICBfdGhpcy5hbGxvd1JlZHJhdyA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5yZW5kZXJpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKF90aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5yZW5kZXJUaW1lcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKF90aGlzLnJlbmRlclRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFtcImhpZGVFZGdlc09uRHJhZ1wiLCBcImhpZGVFZGdlc09uWm9vbVwiLCBcImhpZGVOb2Rlc09uRHJhZ1wiXTtcbiAgICAgICAgc2VsZWN0aXZlRGVlcEV4dGVuZChmaWVsZHMsIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0aGUgZHJhd2luZyBvZiB0aGUgbmV4dCBmcmFtZS5cbiAgICAgKlxuICAgICAqIENhbGxzIHRoZSBjYWxsYmFjayB3aGVuIHRoZSBuZXh0IGZyYW1lIGNhbiBvciB3aWxsIGJlIGRyYXduLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgLSB0aW1lb3V0IGNhc2Ugb25seSwgd2FpdCB0aGlzIG51bWJlciBvZiBtaWxsaXNlY29uZHNcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb24gfCB1bmRlZmluZWR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcmVxdWVzdE5leHRGcmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVxdWVzdE5leHRGcmFtZShjYWxsYmFjaywgZGVsYXkpIHtcbiAgICAgIC8vIER1cmluZyB1bml0IHRlc3RpbmcsIGl0IGhhcHBlbnMgdGhhdCB0aGUgbW9jayB3aW5kb3cgb2JqZWN0IGlzIHJlc2V0IHdoaWxlXG4gICAgICAvLyB0aGUgbmV4dCBmcmFtZSBpcyBzdGlsbCBwZW5kaW5nLiBUaGVuLCBlaXRoZXIgJ3dpbmRvdycgaXMgbm90IHByZXNlbnQsIG9yXG4gICAgICAvLyAncmVxdWVzdEFuaW1hdGlvbkZyYW1lKCknIGlzIG5vdCBwcmVzZW50IGJlY2F1c2UgaXQgaXMgbm90IGRlZmluZWQgb24gdGhlXG4gICAgICAvLyBtb2NrIHdpbmRvdyBvYmplY3QuXG4gICAgICAvL1xuICAgICAgLy8gQXMgYSBjb25zZXF1ZW5jZSwgdW5yZWxhdGVkIHVuaXQgdGVzdHMgbWF5IGFwcGVhciB0byBmYWlsLCBldmVuIGlmIHRoZSBwcm9ibGVtXG4gICAgICAvLyBkZXNjcmliZWQgaGFwcGVucyBpbiB0aGUgY3VycmVudCB1bml0IHRlc3QuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBpcyBub3Qgc29tZXRoaW5nIHRoYXQgd2lsbCBoYXBwZW4gaW4gbm9ybWFsIG9wZXJhdGlvbiwgYnV0IHdlIHN0aWxsIG5lZWRcbiAgICAgIC8vIHRvIHRha2UgaXQgaW50byBhY2NvdW50LlxuICAgICAgLy9cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSByZXR1cm47IC8vIERvaW5nIGBpZiAod2luZG93ID09PSB1bmRlZmluZWQpYCBkb2VzIG5vdCB3b3JrIGhlcmUhXG5cbiAgICAgIHZhciB0aW1lcjtcbiAgICAgIHZhciBteVdpbmRvdyA9IHdpbmRvdzsgLy8gR3JhYiBhIHJlZmVyZW5jZSB0byByZWR1Y2UgdGhlIHBvc3NpYmlsaXR5IHRoYXQgJ3dpbmRvdycgaXMgcmVzZXRcbiAgICAgIC8vIHdoaWxlIHJ1bm5pbmcgdGhpcyBtZXRob2QuXG5cbiAgICAgIGlmICh0aGlzLnJlcXVpcmVzVGltZW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyB3YWl0IGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMgYW5kIHBlcmZvcm0gdGhlIGFuaW1hdGlvbiBzdGVwIGZ1bmN0aW9uXG4gICAgICAgIHRpbWVyID0gX3NldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChteVdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgICAgICB0aW1lciA9IG15V2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aW1lcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3N0YXJ0UmVuZGVyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFydFJlbmRlcmluZygpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmluZ0FjdGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJUaW1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0MztcbiAgICAgICAgICB0aGlzLnJlbmRlclRpbWVyID0gdGhpcy5fcmVxdWVzdE5leHRGcmFtZShfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDMgPSB0aGlzLl9yZW5kZXJTdGVwKS5jYWxsKF9jb250ZXh0MywgdGhpcyksIHRoaXMuc2ltdWxhdGlvbkludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcmVuZGVyU3RlcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyU3RlcCgpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmluZ0FjdGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyByZXNldCB0aGUgcmVuZGVyVGltZXIgc28gYSBuZXcgc2NoZWR1bGVkIGFuaW1hdGlvbiBzdGVwIGNhbiBiZSBzZXRcbiAgICAgICAgdGhpcy5yZW5kZXJUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMucmVxdWlyZXNUaW1lb3V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gdGhpcyBzY2hlZHVsZXMgYSBuZXcgc2ltdWxhdGlvbiBzdGVwXG4gICAgICAgICAgdGhpcy5fc3RhcnRSZW5kZXJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZWRyYXcoKTtcbiAgICAgICAgaWYgKHRoaXMucmVxdWlyZXNUaW1lb3V0ID09PSBmYWxzZSkge1xuICAgICAgICAgIC8vIHRoaXMgc2NoZWR1bGVzIGEgbmV3IHNpbXVsYXRpb24gc3RlcFxuICAgICAgICAgIHRoaXMuX3N0YXJ0UmVuZGVyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgdGhlIG5ldHdvcmsgd2l0aCB0aGUgY3VycmVudCBkYXRhXG4gICAgICogY2hhcnQgd2lsbCBiZSByZXNpemVkIHRvby5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVkcmF3KCkge1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInNldFNpemVcIik7XG4gICAgICB0aGlzLl9yZWRyYXcoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgdGhlIG5ldHdvcmsgd2l0aCB0aGUgY3VycmVudCBkYXRhXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9yZXF1ZXN0UmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXF1ZXN0UmVkcmF3KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5yZWRyYXdSZXF1ZXN0ZWQgIT09IHRydWUgJiYgdGhpcy5yZW5kZXJpbmdBY3RpdmUgPT09IGZhbHNlICYmIHRoaXMuYWxsb3dSZWRyYXcgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5yZWRyYXdSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0TmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIuX3JlZHJhdyhmYWxzZSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhdyB0aGUgbmV0d29yayB3aXRoIHRoZSBjdXJyZW50IGRhdGFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpZGRlbj1mYWxzZV0gfCBVc2VkIHRvIGdldCB0aGUgZmlyc3QgZXN0aW1hdGUgb2YgdGhlIG5vZGUgc2l6ZXMuXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9ubHkgdGhlIG5vZGVzIGFyZSBkcmF3biBhZnRlciB3aGljaCB0aGV5IGFyZSBxdWlja2x5IGRyYXduIG92ZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWRyYXcoKSB7XG4gICAgICB2YXIgaGlkZGVuID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmFsbG93UmVkcmF3ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJpbml0UmVkcmF3XCIpO1xuICAgICAgICB0aGlzLnJlZHJhd1JlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZHJhd0xhdGVyID0ge1xuICAgICAgICAgIGRyYXdFeHRlcm5hbExhYmVsczogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIHdoZW4gdGhlIGNvbnRhaW5lciBkaXYgd2FzIGhpZGRlbiwgdGhpcyBmaXhlcyBpdCBiYWNrIHVwIVxuICAgICAgICBpZiAodGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLndpZHRoID09PSAwIHx8IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICB0aGlzLmNhbnZhcy5zZXRTaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW52YXMuc2V0VHJhbnNmb3JtKCk7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCk7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIGNhbnZhc1xuICAgICAgICB2YXIgdyA9IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgICAgdmFyIGggPSB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuXG4gICAgICAgIC8vIGlmIHRoZSBkaXYgaXMgaGlkZGVuLCB3ZSBzdG9wIHRoZSByZWRyYXcgaGVyZSBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICAgIGlmICh0aGlzLmNhbnZhcy5mcmFtZS5jbGllbnRXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCBzY2FsaW5nIGFuZCB0cmFuc2xhdGlvblxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLngsIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkpO1xuICAgICAgICBjdHguc2NhbGUodGhpcy5ib2R5LnZpZXcuc2NhbGUsIHRoaXMuYm9keS52aWV3LnNjYWxlKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYmVmb3JlRHJhd2luZ1wiLCBjdHgpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGlmIChoaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKCh0aGlzLmRyYWdnaW5nID09PSBmYWxzZSB8fCB0aGlzLmRyYWdnaW5nID09PSB0cnVlICYmIHRoaXMub3B0aW9ucy5oaWRlRWRnZXNPbkRyYWcgPT09IGZhbHNlKSAmJiAodGhpcy56b29taW5nID09PSBmYWxzZSB8fCB0aGlzLnpvb21pbmcgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmhpZGVFZGdlc09uWm9vbSA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3RWRnZXMoY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlIHx8IHRoaXMuZHJhZ2dpbmcgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmhpZGVOb2Rlc09uRHJhZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB2YXIgX3RoaXMkX2RyYXdOb2RlcyA9IHRoaXMuX2RyYXdOb2RlcyhjdHgsIGhpZGRlbiksXG4gICAgICAgICAgICBkcmF3RXh0ZXJuYWxMYWJlbHMgPSBfdGhpcyRfZHJhd05vZGVzLmRyYXdFeHRlcm5hbExhYmVscztcbiAgICAgICAgICBkcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWxzID0gZHJhd0V4dGVybmFsTGFiZWxzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZHJhdyB0aGUgYXJyb3dzIGxhc3Qgc28gdGhleSB3aWxsIGJlIGF0IHRoZSB0b3BcbiAgICAgICAgaWYgKGhpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAoKHRoaXMuZHJhZ2dpbmcgPT09IGZhbHNlIHx8IHRoaXMuZHJhZ2dpbmcgPT09IHRydWUgJiYgdGhpcy5vcHRpb25zLmhpZGVFZGdlc09uRHJhZyA9PT0gZmFsc2UpICYmICh0aGlzLnpvb21pbmcgPT09IGZhbHNlIHx8IHRoaXMuem9vbWluZyA9PT0gdHJ1ZSAmJiB0aGlzLm9wdGlvbnMuaGlkZUVkZ2VzT25ab29tID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdBcnJvd3MoY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICAgIGRyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbHMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuX2RyYXdTZWxlY3Rpb25Cb3goY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJhZnRlckRyYXdpbmdcIiwgY3R4KTtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgc2NhbGluZyBhbmQgdHJhbnNsYXRpb25cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgaWYgKGhpZGRlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdywgaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgYWxsIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gICBjdHhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbHdheXNTaG93XVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2l6ZU5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNpemVOb2RlcygpIHtcbiAgICAgIHRoaXMuY2FudmFzLnNldFRyYW5zZm9ybSgpO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoKTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLngsIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkpO1xuICAgICAgY3R4LnNjYWxlKHRoaXMuYm9keS52aWV3LnNjYWxlLCB0aGlzLmJvZHkudmlldy5zY2FsZSk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbm9kZTtcblxuICAgICAgLy8gcmVzaXplIGFsbCBub2Rlc1xuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIG5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICBub2RlLnJlc2l6ZShjdHgpO1xuICAgICAgICAgIG5vZGUudXBkYXRlQm91bmRpbmdCb3goY3R4LCBub2RlLnNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIHNjYWxpbmcgYW5kIHRyYW5zbGF0aW9uXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBhbGwgbm9kZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggIDJEIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Fsd2F5c1Nob3ddXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBDYWxsYmFja3MgdG8gZHJhdyBsYXRlciBvbiBoaWdoZXIgbGF5ZXJzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3Tm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdOb2RlcyhjdHgpIHtcbiAgICAgIHZhciBhbHdheXNTaG93ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIHZhciBub2RlO1xuICAgICAgdmFyIHNlbGVjdGVkID0gW107XG4gICAgICB2YXIgaG92ZXJlZCA9IFtdO1xuICAgICAgdmFyIG1hcmdpbiA9IDIwO1xuICAgICAgdmFyIHRvcExlZnQgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7XG4gICAgICAgIHg6IC1tYXJnaW4sXG4gICAgICAgIHk6IC1tYXJnaW5cbiAgICAgIH0pO1xuICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe1xuICAgICAgICB4OiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggKyBtYXJnaW4sXG4gICAgICAgIHk6IHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgKyBtYXJnaW5cbiAgICAgIH0pO1xuICAgICAgdmFyIHZpZXdhYmxlQXJlYSA9IHtcbiAgICAgICAgdG9wOiB0b3BMZWZ0LnksXG4gICAgICAgIGxlZnQ6IHRvcExlZnQueCxcbiAgICAgICAgYm90dG9tOiBib3R0b21SaWdodC55LFxuICAgICAgICByaWdodDogYm90dG9tUmlnaHQueFxuICAgICAgfTtcbiAgICAgIHZhciBfZHJhd0V4dGVybmFsTGFiZWxzID0gW107XG5cbiAgICAgIC8vIGRyYXcgdW5zZWxlY3RlZCBub2RlcztcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBub2RlSW5kaWNlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW25vZGVJbmRpY2VzW19pXV07XG4gICAgICAgIC8vIHNldCBzZWxlY3RlZCBhbmQgaG92ZXJlZCBub2RlcyBhc2lkZVxuICAgICAgICBpZiAobm9kZS5ob3Zlcikge1xuICAgICAgICAgIGhvdmVyZWQucHVzaChub2RlSW5kaWNlc1tfaV0pO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuaXNTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgc2VsZWN0ZWQucHVzaChub2RlSW5kaWNlc1tfaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhbHdheXNTaG93ID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgZHJhd0xhdGVyID0gbm9kZS5kcmF3KGN0eCk7XG4gICAgICAgICAgICBpZiAoZHJhd0xhdGVyLmRyYXdFeHRlcm5hbExhYmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgX2RyYXdFeHRlcm5hbExhYmVscy5wdXNoKGRyYXdMYXRlci5kcmF3RXh0ZXJuYWxMYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmlzQm91bmRpbmdCb3hPdmVybGFwcGluZ1dpdGgodmlld2FibGVBcmVhKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9kcmF3TGF0ZXIgPSBub2RlLmRyYXcoY3R4KTtcbiAgICAgICAgICAgIGlmIChfZHJhd0xhdGVyLmRyYXdFeHRlcm5hbExhYmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgX2RyYXdFeHRlcm5hbExhYmVscy5wdXNoKF9kcmF3TGF0ZXIuZHJhd0V4dGVybmFsTGFiZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlLnVwZGF0ZUJvdW5kaW5nQm94KGN0eCwgbm9kZS5zZWxlY3RlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBzZWxlY3RlZExlbmd0aCA9IHNlbGVjdGVkLmxlbmd0aDtcbiAgICAgIHZhciBob3ZlcmVkTGVuZ3RoID0gaG92ZXJlZC5sZW5ndGg7XG5cbiAgICAgIC8vIGRyYXcgdGhlIHNlbGVjdGVkIG5vZGVzIG9uIHRvcFxuICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGVjdGVkTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW3NlbGVjdGVkW2ldXTtcbiAgICAgICAgdmFyIF9kcmF3TGF0ZXIyID0gbm9kZS5kcmF3KGN0eCk7XG4gICAgICAgIGlmIChfZHJhd0xhdGVyMi5kcmF3RXh0ZXJuYWxMYWJlbCAhPSBudWxsKSB7XG4gICAgICAgICAgX2RyYXdFeHRlcm5hbExhYmVscy5wdXNoKF9kcmF3TGF0ZXIyLmRyYXdFeHRlcm5hbExhYmVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBkcmF3IGhvdmVyZWQgbm9kZXMgYWJvdmUgZXZlcnl0aGluZyBlbHNlOiBmaXhlcyBodHRwczovL2dpdGh1Yi5jb20vdmlzanMvdmlzLW5ldHdvcmsvaXNzdWVzLzIyNlxuICAgICAgZm9yIChpID0gMDsgaSA8IGhvdmVyZWRMZW5ndGg7IGkrKykge1xuICAgICAgICBub2RlID0gbm9kZXNbaG92ZXJlZFtpXV07XG4gICAgICAgIHZhciBfZHJhd0xhdGVyMyA9IG5vZGUuZHJhdyhjdHgpO1xuICAgICAgICBpZiAoX2RyYXdMYXRlcjMuZHJhd0V4dGVybmFsTGFiZWwgIT0gbnVsbCkge1xuICAgICAgICAgIF9kcmF3RXh0ZXJuYWxMYWJlbHMucHVzaChfZHJhd0xhdGVyMy5kcmF3RXh0ZXJuYWxMYWJlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRyYXdFeHRlcm5hbExhYmVsczogZnVuY3Rpb24gZHJhd0V4dGVybmFsTGFiZWxzKCkge1xuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9kcmF3RXh0ZXJuYWxMYWJlbHMyID0gX2RyYXdFeHRlcm5hbExhYmVsczsgX2kyIDwgX2RyYXdFeHRlcm5hbExhYmVsczIubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgdmFyIGRyYXcgPSBfZHJhd0V4dGVybmFsTGFiZWxzMltfaTJdO1xuICAgICAgICAgICAgZHJhdygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgYWxsIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4ICAyRCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3RWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdFZGdlcyhjdHgpIHtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMuYm9keS5lZGdlSW5kaWNlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlZGdlSW5kaWNlc1tpXV07XG4gICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGVkZ2UuZHJhdyhjdHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkcmF3IGFsbCBhcnJvd3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggIDJEIGNvbnRleHQgb2YgYSBIVE1MIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYXdBcnJvd3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYXdBcnJvd3MoY3R4KSB7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmJvZHkuZWRnZXM7XG4gICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLmJvZHkuZWRnZUluZGljZXM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbaV1dO1xuICAgICAgICBpZiAoZWRnZS5jb25uZWN0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICBlZGdlLmRyYXdBcnJvd3MoY3R4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBpZiB0aGUgYnJvd3NlciByZXF1aXJlcyBhIHNldFRpbWVvdXQgb3IgYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIFRoaXMgd2FzIHJlcXVpcmVkIGJlY2F1c2VcbiAgICAgKiBzb21lIGltcGxlbWVudGF0aW9ucyAoc2FmYXJpIGFuZCBJRTkpIGRpZCBub3Qgc3VwcG9ydCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RldGVybWluZUJyb3dzZXJNZXRob2RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUJyb3dzZXJNZXRob2QoKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgYnJvd3NlclR5cGUgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRoaXMucmVxdWlyZXNUaW1lb3V0ID0gZmFsc2U7XG4gICAgICAgIGlmIChfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoYnJvd3NlclR5cGUpLmNhbGwoYnJvd3NlclR5cGUsIFwibXNpZSA5LjBcIikgIT0gLTEpIHtcbiAgICAgICAgICAvLyBJRSA5XG4gICAgICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eShicm93c2VyVHlwZSkuY2FsbChicm93c2VyVHlwZSwgXCJzYWZhcmlcIikgIT0gLTEpIHtcbiAgICAgICAgICAvLyBzYWZhcmlcbiAgICAgICAgICBpZiAoX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KGJyb3dzZXJUeXBlKS5jYWxsKGJyb3dzZXJUeXBlLCBcImNocm9tZVwiKSA8PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXF1aXJlc1RpbWVvdXQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhdyBzZWxlY3Rpb24gYm94XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4ICAyRCBjb250ZXh0IG9mIGEgSFRNTCBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9kcmF3U2VsZWN0aW9uQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kcmF3U2VsZWN0aW9uQm94KGN0eCkge1xuICAgICAgaWYgKHRoaXMuYm9keS5zZWxlY3Rpb25Cb3guc2hvdykge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uZW5kLnggLSB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0Lng7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLmVuZC55IC0gdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydC55O1xuICAgICAgICBjdHgucmVjdCh0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0LngsIHRoaXMuYm9keS5zZWxlY3Rpb25Cb3gucG9zaXRpb24uc3RhcnQueSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoMTUxLCAxOTQsIDI1MiwgMC4yKVwiO1xuICAgICAgICBjdHguZmlsbFJlY3QodGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbi5zdGFydC54LCB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0LnksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJnYmEoMTUxLCAxOTQsIDI1MiwgMSlcIjtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ2FudmFzUmVuZGVyZXI7XG59KCk7XG5cbnZhciBwYXRoJDIgPSBwYXRoJHc7XG5cbnZhciBzZXRJbnRlcnZhbCQxID0gcGF0aCQyLnNldEludGVydmFsO1xuXG52YXIgc2V0SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCQxO1xuXG52YXIgX3NldEludGVydmFsID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHNldEludGVydmFsKTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIHRvdWNoIGV2ZW50LCB0YWtpbmcgcGxhY2UgYmVmb3JlIGEgZ2VzdHVyZVxuICpcbiAqIEBwYXJhbSB7SGFtbWVyfSBoYW1tZXIgICAgICAgQSBoYW1tZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrICAgQ2FsbGJhY2ssIGNhbGxlZCBhcyBjYWxsYmFjayhldmVudClcbiAqL1xuZnVuY3Rpb24gb25Ub3VjaChoYW1tZXIsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrLmlucHV0SGFuZGxlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5pc0ZpcnN0KSB7XG4gICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgfVxuICB9O1xuICBoYW1tZXIub24oXCJoYW1tZXIuaW5wdXRcIiwgY2FsbGJhY2suaW5wdXRIYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlciBhIHJlbGVhc2UgZXZlbnQsIHRha2luZyBwbGFjZSBhZnRlciBhIGdlc3R1cmVcbiAqXG4gKiBAcGFyYW0ge0hhbW1lcn0gaGFtbWVyICAgICAgIEEgaGFtbWVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAgIENhbGxiYWNrLCBjYWxsZWQgYXMgY2FsbGJhY2soZXZlbnQpXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gb25SZWxlYXNlKGhhbW1lciwgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2suaW5wdXRIYW5kbGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmlzRmluYWwpIHtcbiAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoYW1tZXIub24oXCJoYW1tZXIuaW5wdXRcIiwgY2FsbGJhY2suaW5wdXRIYW5kbGVyKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgdGhlIG1haW4gZnJhbWUgZm9yIHRoZSBOZXR3b3JrLlxuICogVGhpcyBmdW5jdGlvbiBpcyBleGVjdXRlZCBvbmNlIHdoZW4gYSBOZXR3b3JrIG9iamVjdCBpcyBjcmVhdGVkLiBUaGUgZnJhbWVcbiAqIGNvbnRhaW5zIGEgY2FudmFzLCBhbmQgdGhpcyBjYW52YXMgY29udGFpbnMgYWxsIG9iamVjdHMgbGlrZSB0aGUgYXhpcyBhbmRcbiAqIG5vZGVzLlxuICovXG52YXIgQ2FudmFzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqL1xuICBmdW5jdGlvbiBDYW52YXMoYm9keSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW52YXMpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5waXhlbFJhdGlvID0gMTtcbiAgICB0aGlzLmNhbWVyYVN0YXRlID0ge307XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FudmFzVmlld0NlbnRlciA9IHt9O1xuICAgIHRoaXMuX2NsZWFudXBDYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgYXV0b1Jlc2l6ZTogdHJ1ZSxcbiAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICB3aWR0aDogXCIxMDAlXCJcbiAgICB9O1xuICAgIF9PYmplY3QkYXNzaWduKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhDYW52YXMsIFt7XG4gICAga2V5OiBcImJpbmRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgICBfY29udGV4dDtcbiAgICAgIC8vIGJpbmQgdGhlIGV2ZW50c1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub25jZShcInJlc2l6ZVwiLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIGlmIChvYmoud2lkdGggIT09IDApIHtcbiAgICAgICAgICBfdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCA9IG9iai53aWR0aCAqIDAuNTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqLmhlaWdodCAhPT0gMCkge1xuICAgICAgICAgIF90aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi55ID0gb2JqLmhlaWdodCAqIDAuNTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcInNldFNpemVcIiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQgPSB0aGlzLnNldFNpemUpLmNhbGwoX2NvbnRleHQsIHRoaXMpKTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLmhhbW1lckZyYW1lLmRlc3Ryb3koKTtcbiAgICAgICAgX3RoaXMuaGFtbWVyLmRlc3Ryb3koKTtcbiAgICAgICAgX3RoaXMuX2NsZWFuVXAoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZmllbGRzID0gW1wid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJhdXRvUmVzaXplXCJdO1xuICAgICAgICBzZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgLy8gQXV0b21hdGljYWxseSBhZGFwdCB0byBjaGFuZ2luZyBzaXplIG9mIHRoZSBjb250YWluZXIgZWxlbWVudC5cbiAgICAgIHRoaXMuX2NsZWFuVXAoKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1Jlc2l6ZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgX2NvbnRleHQyO1xuICAgICAgICBpZiAod2luZG93LlJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgICAgLy8gZGVjZW50IGJyb3dzZXJzLCBpbW1lZGlhdGUgcmVhY3Rpb25zXG4gICAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gX3RoaXMyLnNldFNpemUoKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWU7XG4gICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShmcmFtZSk7XG4gICAgICAgICAgdGhpcy5fY2xlYW51cENhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShmcmFtZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSUUxMSwgY29udGlub3VzIHBvbGxpbmdcbiAgICAgICAgICB2YXIgcmVzaXplVGltZXIgPSBfc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSBfdGhpczIuc2V0U2l6ZSgpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgdGhpcy5fY2xlYW51cENhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocmVzaXplVGltZXIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXV0b21hdGljYWxseSBhZGFwdCB0byBjaGFuZ2luZyBzaXplIG9mIHRoZSBicm93c2VyLlxuICAgICAgICB2YXIgcmVzaXplRnVuY3Rpb24gPSBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDIgPSB0aGlzLl9vblJlc2l6ZSkuY2FsbChfY29udGV4dDIsIHRoaXMpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCByZXNpemVGdW5jdGlvbik7XG4gICAgICAgIHRoaXMuX2NsZWFudXBDYWxsYmFja3MucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplRnVuY3Rpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jbGVhblVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhblVwKCkge1xuICAgICAgdmFyIF9jb250ZXh0MywgX2NvbnRleHQ0LCBfY29udGV4dDU7XG4gICAgICBfZm9yRWFjaEluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQzID0gX3JldmVyc2VJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0NCA9IF9zcGxpY2VJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0NSA9IHRoaXMuX2NsZWFudXBDYWxsYmFja3MpLmNhbGwoX2NvbnRleHQ1LCAwKSkuY2FsbChfY29udGV4dDQpKS5jYWxsKF9jb250ZXh0MywgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfb25SZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUmVzaXplKCkge1xuICAgICAgdGhpcy5zZXRTaXplKCk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW5kIHN0b3JlIHRoZSBjYW1lcmFTdGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwaXhlbFJhdGlvPXRoaXMucGl4ZWxSYXRpb11cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRDYW1lcmFTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2FtZXJhU3RhdGUoKSB7XG4gICAgICB2YXIgcGl4ZWxSYXRpbyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5waXhlbFJhdGlvO1xuICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c1dpZHRoID0gdGhpcy5mcmFtZS5jYW52YXMud2lkdGggLyBwaXhlbFJhdGlvO1xuICAgICAgICB0aGlzLmNhbWVyYVN0YXRlLnByZXZpb3VzSGVpZ2h0ID0gdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0IC8gcGl4ZWxSYXRpbztcbiAgICAgICAgdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICB0aGlzLmNhbWVyYVN0YXRlLnBvc2l0aW9uID0gdGhpcy5ET010b0NhbnZhcyh7XG4gICAgICAgICAgeDogMC41ICogdGhpcy5mcmFtZS5jYW52YXMud2lkdGggLyBwaXhlbFJhdGlvLFxuICAgICAgICAgIHk6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAvIHBpeGVsUmF0aW9cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjYW1lcmFTdGF0ZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfc2V0Q2FtZXJhU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldENhbWVyYVN0YXRlKCkge1xuICAgICAgaWYgKHRoaXMuY2FtZXJhU3RhdGUuc2NhbGUgIT09IHVuZGVmaW5lZCAmJiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCAhPT0gMCAmJiB0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgIT09IDAgJiYgdGhpcy5waXhlbFJhdGlvICE9PSAwICYmIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNXaWR0aCA+IDAgJiYgdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c0hlaWdodCA+IDApIHtcbiAgICAgICAgdmFyIHdpZHRoUmF0aW8gPSB0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCAvIHRoaXMucGl4ZWxSYXRpbyAvIHRoaXMuY2FtZXJhU3RhdGUucHJldmlvdXNXaWR0aDtcbiAgICAgICAgdmFyIGhlaWdodFJhdGlvID0gdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0IC8gdGhpcy5waXhlbFJhdGlvIC8gdGhpcy5jYW1lcmFTdGF0ZS5wcmV2aW91c0hlaWdodDtcbiAgICAgICAgdmFyIG5ld1NjYWxlID0gdGhpcy5jYW1lcmFTdGF0ZS5zY2FsZTtcbiAgICAgICAgaWYgKHdpZHRoUmF0aW8gIT0gMSAmJiBoZWlnaHRSYXRpbyAhPSAxKSB7XG4gICAgICAgICAgbmV3U2NhbGUgPSB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlICogMC41ICogKHdpZHRoUmF0aW8gKyBoZWlnaHRSYXRpbyk7XG4gICAgICAgIH0gZWxzZSBpZiAod2lkdGhSYXRpbyAhPSAxKSB7XG4gICAgICAgICAgbmV3U2NhbGUgPSB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlICogd2lkdGhSYXRpbztcbiAgICAgICAgfSBlbHNlIGlmIChoZWlnaHRSYXRpbyAhPSAxKSB7XG4gICAgICAgICAgbmV3U2NhbGUgPSB0aGlzLmNhbWVyYVN0YXRlLnNjYWxlICogaGVpZ2h0UmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSBuZXdTY2FsZTtcbiAgICAgICAgLy8gdGhpcyBjb21lcyBmcm9tIHRoZSB2aWV3IG1vZHVsZS5cbiAgICAgICAgdmFyIGN1cnJlbnRWaWV3Q2VudGVyID0gdGhpcy5ET010b0NhbnZhcyh7XG4gICAgICAgICAgeDogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgeTogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZGlzdGFuY2VGcm9tQ2VudGVyID0ge1xuICAgICAgICAgIC8vIG9mZnNldCBmcm9tIHZpZXcsIGRpc3RhbmNlIHZpZXcgaGFzIHRvIGNoYW5nZSBieSB0aGVzZSB4IGFuZCB5IHRvIGNlbnRlciB0aGUgbm9kZVxuICAgICAgICAgIHg6IGN1cnJlbnRWaWV3Q2VudGVyLnggLSB0aGlzLmNhbWVyYVN0YXRlLnBvc2l0aW9uLngsXG4gICAgICAgICAgeTogY3VycmVudFZpZXdDZW50ZXIueSAtIHRoaXMuY2FtZXJhU3RhdGUucG9zaXRpb24ueVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54ICs9IGRpc3RhbmNlRnJvbUNlbnRlci54ICogdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkgKz0gZGlzdGFuY2VGcm9tQ2VudGVyLnkgKiB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3ByZXBhcmVWYWx1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJlcGFyZVZhbHVlKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSArIFwicHhcIjtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkodmFsdWUpLmNhbGwodmFsdWUsIFwiJVwiKSAhPT0gLTEgfHwgX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KHZhbHVlKS5jYWxsKHZhbHVlLCBcInB4XCIpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkodmFsdWUpLmNhbGwodmFsdWUsIFwiJVwiKSA9PT0gLTEpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCB1c2UgdGhlIHZhbHVlIHN1cHBsaWVkIGZvciB3aWR0aCBvciBoZWlnaHQ6XCIgKyB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBIVE1MXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xuICAgICAgLy8gcmVtb3ZlIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBjb250YWluZXIgZWxlbWVudC5cbiAgICAgIHdoaWxlICh0aGlzLmJvZHkuY29udGFpbmVyLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICB0aGlzLmJvZHkuY29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuYm9keS5jb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMuZnJhbWUuY2xhc3NOYW1lID0gXCJ2aXMtbmV0d29ya1wiO1xuICAgICAgdGhpcy5mcmFtZS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgIHRoaXMuZnJhbWUuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgICAgdGhpcy5mcmFtZS50YWJJbmRleCA9IDA7IC8vIHRhYiBpbmRleCBpcyByZXF1aXJlZCBmb3Iga2V5Y2hhcm0gdG8gYmluZCBrZXlzdHJva2VzIHRvIHRoZSBkaXYgaW5zdGVhZCBvZiB0aGUgd2luZG93XG5cbiAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICB0aGlzLmZyYW1lLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICB0aGlzLmZyYW1lLmNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICAgIHRoaXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZS5jYW52YXMpO1xuICAgICAgaWYgKCF0aGlzLmZyYW1lLmNhbnZhcy5nZXRDb250ZXh0KSB7XG4gICAgICAgIHZhciBub0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIik7XG4gICAgICAgIG5vQ2FudmFzLnN0eWxlLmNvbG9yID0gXCJyZWRcIjtcbiAgICAgICAgbm9DYW52YXMuc3R5bGUuZm9udFdlaWdodCA9IFwiYm9sZFwiO1xuICAgICAgICBub0NhbnZhcy5zdHlsZS5wYWRkaW5nID0gXCIxMHB4XCI7XG4gICAgICAgIG5vQ2FudmFzLmlubmVyVGV4dCA9IFwiRXJyb3I6IHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IEhUTUwgY2FudmFzXCI7XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFwcGVuZENoaWxkKG5vQ2FudmFzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NldFBpeGVsUmF0aW8oKTtcbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHRoZSBmcmFtZSB0byB0aGUgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgIHRoaXMuYm9keS5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5mcmFtZSk7XG4gICAgICB0aGlzLmJvZHkudmlldy5zY2FsZSA9IDE7XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgeDogMC41ICogdGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsXG4gICAgICAgIHk6IDAuNSAqIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodFxuICAgICAgfTtcbiAgICAgIHRoaXMuX2JpbmRIYW1tZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGJpbmRzIGhhbW1lciwgaXQgY2FuIGJlIHJlcGVhdGVkIG92ZXIgYW5kIG92ZXIgZHVlIHRvIHRoZSB1bmlxdWVuZXNzIGNoZWNrLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfYmluZEhhbW1lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZEhhbW1lcigpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuaGFtbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5oYW1tZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5kcmFnID0ge307XG4gICAgICB0aGlzLnBpbmNoID0ge307XG5cbiAgICAgIC8vIGluaXQgaGFtbWVyXG4gICAgICB0aGlzLmhhbW1lciA9IG5ldyBIYW1tZXIodGhpcy5mcmFtZS5jYW52YXMpO1xuICAgICAgdGhpcy5oYW1tZXIuZ2V0KFwicGluY2hcIikuc2V0KHtcbiAgICAgICAgZW5hYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIC8vIGVuYWJsZSB0byBnZXQgYmV0dGVyIHJlc3BvbnNlLCB0b2RvOiB0ZXN0IG9uIG1vYmlsZS5cbiAgICAgIHRoaXMuaGFtbWVyLmdldChcInBhblwiKS5zZXQoe1xuICAgICAgICB0aHJlc2hvbGQ6IDUsXG4gICAgICAgIGRpcmVjdGlvbjogSGFtbWVyLkRJUkVDVElPTl9BTExcbiAgICAgIH0pO1xuICAgICAgb25Ub3VjaCh0aGlzLmhhbW1lciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uVG91Y2goZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInRhcFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25UYXAoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcImRvdWJsZXRhcFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Eb3VibGVUYXAoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInByZXNzXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkhvbGQoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmhhbW1lci5vbihcInBhbnN0YXJ0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWdTdGFydChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwicGFubW92ZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXIub24oXCJwYW5lbmRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRHJhZ0VuZChldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuaGFtbWVyLm9uKFwicGluY2hcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uUGluY2goZXZlbnQpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFRPRE86IG5lYXRseSBjbGVhbnVwIHRoZXNlIGhhbmRsZXJzIHdoZW4gcmUtY3JlYXRpbmcgdGhlIENhbnZhcywgSUYgdGhlc2UgYXJlIGRvbmUgd2l0aCBoYW1tZXIsIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiB3aWxsIG5vdCB3b3JrP1xuICAgICAgdGhpcy5mcmFtZS5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlV2hlZWwoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmZyYW1lLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBfdGhpczMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlTW92ZShldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZnJhbWUuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgX3RoaXMzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Db250ZXh0KGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5oYW1tZXJGcmFtZSA9IG5ldyBIYW1tZXIodGhpcy5mcmFtZSk7XG4gICAgICBvblJlbGVhc2UodGhpcy5oYW1tZXJGcmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIF90aGlzMy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uUmVsZWFzZShldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgYSBuZXcgc2l6ZSBmb3IgdGhlIG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3aWR0aCAgIFdpZHRoIGluIHBpeGVscyBvciBwZXJjZW50YWdlIChmb3IgZXhhbXBsZSAnODAwcHgnXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgb3IgJzUwJScpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhlaWdodCAgSGVpZ2h0IGluIHBpeGVscyBvciBwZXJjZW50YWdlICAoZm9yIGV4YW1wbGUgJzQwMHB4J1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgIG9yICczMCUnKVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2l6ZSgpIHtcbiAgICAgIHZhciB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdGhpcy5vcHRpb25zLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5vcHRpb25zLmhlaWdodDtcbiAgICAgIHdpZHRoID0gdGhpcy5fcHJlcGFyZVZhbHVlKHdpZHRoKTtcbiAgICAgIGhlaWdodCA9IHRoaXMuX3ByZXBhcmVWYWx1ZShoZWlnaHQpO1xuICAgICAgdmFyIGVtaXRFdmVudCA9IGZhbHNlO1xuICAgICAgdmFyIG9sZFdpZHRoID0gdGhpcy5mcmFtZS5jYW52YXMud2lkdGg7XG4gICAgICB2YXIgb2xkSGVpZ2h0ID0gdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0O1xuXG4gICAgICAvLyB1cGRhdGUgdGhlIHBpeGVsIHJhdGlvXG4gICAgICAvL1xuICAgICAgLy8gTk9URTogQ29tbWVudCBpbiBmb2xsb3dpbmcgaXMgcmF0aGVyIGluY29uc2lzdGVudDsgdGhpcyBpcyB0aGUgT05MWSBwbGFjZSBpbiB0aGUgY29kZVxuICAgICAgLy8gICAgICAgd2hlcmUgaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBwaXhlbCByYXRpbyBjb3VsZCBjaGFuZ2UgYXQgcnVudGltZS5cbiAgICAgIC8vICAgICAgIFRoZSBvbmx5IHdheSBJIGNhbiB0aGluayBvZiB0aGlzIGhhcHBlbmluZyBpcyBhIHJvdGF0aW5nIHNjcmVlbiBvciB0YWJsZXQ7IGJ1dCB0aGVuXG4gICAgICAvLyAgICAgICB0aGVyZSBzaG91bGQgYmUgYSBtZWNoYW5pc20gZm9yIHJlbG9hZGluZyB0aGUgZGF0YSAoVE9ETzogY2hlY2sgaWYgdGhpcyBpcyBwcmVzZW50KS5cbiAgICAgIC8vXG4gICAgICAvLyAgICAgICBJZiB0aGUgYXNzdW1wdGlvbiBpcyB0cnVlIChpLmUuIHBpeGVsIHJhdGlvIGNhbiBjaGFuZ2UgYXQgcnVudGltZSksIHRoZW4gKmFsbCogdXNhZ2VcbiAgICAgIC8vICAgICAgIG9mIHBpeGVsIHJhdGlvIG11c3QgYmUgb3ZlcmhhdWxlZCBmb3IgdGhpcy5cbiAgICAgIC8vXG4gICAgICAvLyAgICAgICBGb3IgdGhlIHRpbWUgYmVpbmcsIEkgd2lsbCBodW1vciB0aGUgYXNzdW1wdGlvbiBoZXJlLCBhbmQgaW4gdGhlIHJlc3Qgb2YgdGhlIGNvZGUgYXNzdW1lIGl0IGlzXG4gICAgICAvLyAgICAgICBjb25zdGFudC5cbiAgICAgIHZhciBwcmV2aW91c1JhdGlvID0gdGhpcy5waXhlbFJhdGlvOyAvLyB3ZSBjYWNoZSB0aGlzIGJlY2F1c2UgdGhlIGNhbWVyYSBzdGF0ZSBzdG9yYWdlIG5lZWRzIHRoZSBvbGQgdmFsdWVcbiAgICAgIHRoaXMuX3NldFBpeGVsUmF0aW8oKTtcbiAgICAgIGlmICh3aWR0aCAhPSB0aGlzLm9wdGlvbnMud2lkdGggfHwgaGVpZ2h0ICE9IHRoaXMub3B0aW9ucy5oZWlnaHQgfHwgdGhpcy5mcmFtZS5zdHlsZS53aWR0aCAhPSB3aWR0aCB8fCB0aGlzLmZyYW1lLnN0eWxlLmhlaWdodCAhPSBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5fZ2V0Q2FtZXJhU3RhdGUocHJldmlvdXNSYXRpbyk7XG4gICAgICAgIHRoaXMuZnJhbWUuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5mcmFtZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgIHRoaXMuZnJhbWUuY2FudmFzLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCA9IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIHRoaXMub3B0aW9ucy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLm9wdGlvbnMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmNhbnZhc1ZpZXdDZW50ZXIgPSB7XG4gICAgICAgICAgeDogMC41ICogdGhpcy5mcmFtZS5jbGllbnRXaWR0aCxcbiAgICAgICAgICB5OiAwLjUgKiB0aGlzLmZyYW1lLmNsaWVudEhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBlbWl0RXZlbnQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhpcyB3b3VsZCBhZGFwdCB0aGUgd2lkdGggb2YgdGhlIGNhbnZhcyB0byB0aGUgd2lkdGggZnJvbSAxMDAlIGlmIGFuZCBvbmx5IGlmXG4gICAgICAgIC8vIHRoZXJlIGlzIGEgY2hhbmdlLlxuXG4gICAgICAgIHZhciBuZXdXaWR0aCA9IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGggKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8pO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBjYW1lcmEgaWYgdGhlcmUgaXMgYSBjaGFuZ2UgaW4gc2l6ZS5cbiAgICAgICAgaWYgKHRoaXMuZnJhbWUuY2FudmFzLndpZHRoICE9PSBuZXdXaWR0aCB8fCB0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgIT09IG5ld0hlaWdodCkge1xuICAgICAgICAgIHRoaXMuX2dldENhbWVyYVN0YXRlKHByZXZpb3VzUmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCAhPT0gbmV3V2lkdGgpIHtcbiAgICAgICAgICB0aGlzLmZyYW1lLmNhbnZhcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICAgIGVtaXRFdmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZnJhbWUuY2FudmFzLmhlaWdodCAhPT0gbmV3SGVpZ2h0KSB7XG4gICAgICAgICAgdGhpcy5mcmFtZS5jYW52YXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICAgIGVtaXRFdmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlbWl0RXZlbnQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlc2l6ZVwiLCB7XG4gICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQodGhpcy5mcmFtZS5jYW52YXMud2lkdGggLyB0aGlzLnBpeGVsUmF0aW8pLFxuICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZCh0aGlzLmZyYW1lLmNhbnZhcy5oZWlnaHQgLyB0aGlzLnBpeGVsUmF0aW8pLFxuICAgICAgICAgIG9sZFdpZHRoOiBNYXRoLnJvdW5kKG9sZFdpZHRoIC8gdGhpcy5waXhlbFJhdGlvKSxcbiAgICAgICAgICBvbGRIZWlnaHQ6IE1hdGgucm91bmQob2xkSGVpZ2h0IC8gdGhpcy5waXhlbFJhdGlvKVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZXN0b3JlIHRoZSBjYW1lcmEgb24gY2hhbmdlLlxuICAgICAgICB0aGlzLl9zZXRDYW1lcmFTdGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgaW5pdGlhbGl6ZWQgc28gdGhlIGdldCBhbmQgc2V0IGNhbWVyYSB3aWxsIHdvcmsgZnJvbSBub3cgb24uXG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBlbWl0RXZlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldENvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyYW1lLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBwaXhlbCByYXRpbyBmb3IgdmFyaW91cyBicm93c2Vycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZGV0ZXJtaW5lUGl4ZWxSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0ZXJtaW5lUGl4ZWxSYXRpbygpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmdldENvbnRleHQoKTtcbiAgICAgIGlmIChjdHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IGNhbnZheCBjb250ZXh0XCIpO1xuICAgICAgfVxuICAgICAgdmFyIG51bWVyYXRvciA9IDE7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyAod2luZG93ICE9PSB1bmRlZmluZWQpIGRvZXNuJ3Qgd29yayBoZXJlIVxuICAgICAgICAvLyBQcm90ZWN0aW9uIGR1cmluZyB1bml0IHRlc3RzLCB3aGVyZSAnd2luZG93JyBjYW4gYmUgbWlzc2luZ1xuICAgICAgICBudW1lcmF0b3IgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgICAgfVxuICAgICAgdmFyIGRlbm9taW5hdG9yID0gY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgIHJldHVybiBudW1lcmF0b3IgLyBkZW5vbWluYXRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMYXp5IGRldGVybWluYXRpb24gb2YgcGl4ZWwgcmF0aW8uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zZXRQaXhlbFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRQaXhlbFJhdGlvKCkge1xuICAgICAgdGhpcy5waXhlbFJhdGlvID0gdGhpcy5fZGV0ZXJtaW5lUGl4ZWxSYXRpbygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdHJhbnNmb3JtIGluIHRoZSBjb250YWluZWQgY29udGV4dCwgYmFzZWQgb24gaXRzIHBpeGVsUmF0aW9cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRUcmFuc2Zvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VHJhbnNmb3JtKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuZ2V0Q29udGV4dCgpO1xuICAgICAgaWYgKGN0eCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBnZXQgY2FudmF4IGNvbnRleHRcIik7XG4gICAgICB9XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKHRoaXMucGl4ZWxSYXRpbywgMCwgMCwgdGhpcy5waXhlbFJhdGlvLCAwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBYIGNvb3JkaW5hdGUgaW4gRE9NLXNwYWNlIChjb29yZGluYXRlIHBvaW50IGluIGJyb3dzZXIgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciBkaXYpIHRvXG4gICAgICogdGhlIFggY29vcmRpbmF0ZSBpbiBjYW52YXMtc3BhY2UgKHRoZSBzaW11bGF0aW9uIHNhbmRib3gsIHdoaWNoIHRoZSBjYW1lcmEgbG9va3MgdXBvbilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9YY29udmVydERPTXRvQ2FudmFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9YY29udmVydERPTXRvQ2FudmFzKHgpIHtcbiAgICAgIHJldHVybiAoeCAtIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLngpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgWCBjb29yZGluYXRlIGluIGNhbnZhcy1zcGFjZSAodGhlIHNpbXVsYXRpb24gc2FuZGJveCwgd2hpY2ggdGhlIGNhbWVyYSBsb29rcyB1cG9uKSB0b1xuICAgICAqIHRoZSBYIGNvb3JkaW5hdGUgaW4gRE9NLXNwYWNlIChjb29yZGluYXRlIHBvaW50IGluIGJyb3dzZXIgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciBkaXYpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfWGNvbnZlcnRDYW52YXNUb0RPTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfWGNvbnZlcnRDYW52YXNUb0RPTSh4KSB7XG4gICAgICByZXR1cm4geCAqIHRoaXMuYm9keS52aWV3LnNjYWxlICsgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBZIGNvb3JkaW5hdGUgaW4gRE9NLXNwYWNlIChjb29yZGluYXRlIHBvaW50IGluIGJyb3dzZXIgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciBkaXYpIHRvXG4gICAgICogdGhlIFkgY29vcmRpbmF0ZSBpbiBjYW52YXMtc3BhY2UgKHRoZSBzaW11bGF0aW9uIHNhbmRib3gsIHdoaWNoIHRoZSBjYW1lcmEgbG9va3MgdXBvbilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9ZY29udmVydERPTXRvQ2FudmFzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ZY29udmVydERPTXRvQ2FudmFzKHkpIHtcbiAgICAgIHJldHVybiAoeSAtIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkpIC8gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgWSBjb29yZGluYXRlIGluIGNhbnZhcy1zcGFjZSAodGhlIHNpbXVsYXRpb24gc2FuZGJveCwgd2hpY2ggdGhlIGNhbWVyYSBsb29rcyB1cG9uKSB0b1xuICAgICAqIHRoZSBZIGNvb3JkaW5hdGUgaW4gRE9NLXNwYWNlIChjb29yZGluYXRlIHBvaW50IGluIGJyb3dzZXIgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciBkaXYpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfWWNvbnZlcnRDYW52YXNUb0RPTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfWWNvbnZlcnRDYW52YXNUb0RPTSh5KSB7XG4gICAgICByZXR1cm4geSAqIHRoaXMuYm9keS52aWV3LnNjYWxlICsgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3BvaW50fSBwb3NcbiAgICAgKiBAcmV0dXJucyB7cG9pbnR9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FudmFzVG9ET01cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FudmFzVG9ET00ocG9zKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0aGlzLl9YY29udmVydENhbnZhc1RvRE9NKHBvcy54KSxcbiAgICAgICAgeTogdGhpcy5fWWNvbnZlcnRDYW52YXNUb0RPTShwb3MueSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3BvaW50fSBwb3NcbiAgICAgKiBAcmV0dXJucyB7cG9pbnR9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiRE9NdG9DYW52YXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gRE9NdG9DYW52YXMocG9zKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB0aGlzLl9YY29udmVydERPTXRvQ2FudmFzKHBvcy54KSxcbiAgICAgICAgeTogdGhpcy5fWWNvbnZlcnRET010b0NhbnZhcyhwb3MueSlcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBDYW52YXM7XG59KCk7XG5cbi8qKlxyXG4gKiBWYWxpZGF0ZSB0aGUgZml0IG9wdGlvbnMsIHJlcGxhY2UgbWlzc2luZyBvcHRpb25hbCB2YWx1ZXMgYnkgZGVmYXVsdHMgZXRjLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmF3T3B0aW9ucyAtIFRoZSByYXcgb3B0aW9ucy5cclxuICogQHBhcmFtIGFsbE5vZGVJZHMgLSBBbGwgbm9kZSBpZHMgdGhhdCB3aWxsIGJlIHVzZWQgaWYgbm9kZXMgYXJlIG9taXR0ZWQgaW5cclxuICogdGhlIHJhdyBvcHRpb25zLlxyXG4gKiBAcmV0dXJucyBPcHRpb25zIHdpdGggZXZlcnl0aGluZyBmaWxsZWQgaW4gYW5kIHZhbGlkYXRlZC5cclxuICovXG5mdW5jdGlvbiBub3JtYWxpemVGaXRPcHRpb25zKHJhd09wdGlvbnMsIGFsbE5vZGVJZHMpIHtcbiAgdmFyIG9wdGlvbnMgPSBfT2JqZWN0JGFzc2lnbih7XG4gICAgbm9kZXM6IGFsbE5vZGVJZHMsXG4gICAgbWluWm9vbUxldmVsOiBOdW1iZXIuTUlOX1ZBTFVFLFxuICAgIG1heFpvb21MZXZlbDogMVxuICB9LCByYXdPcHRpb25zICE9PSBudWxsICYmIHJhd09wdGlvbnMgIT09IHZvaWQgMCA/IHJhd09wdGlvbnMgOiB7fSk7XG4gIGlmICghX0FycmF5JGlzQXJyYXkob3B0aW9ucy5ub2RlcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm9kZXMgaGFzIHRvIGJlIGFuIGFycmF5IG9mIGlkcy5cIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMubm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgb3B0aW9ucy5ub2RlcyA9IGFsbE5vZGVJZHM7XG4gIH1cbiAgaWYgKCEodHlwZW9mIG9wdGlvbnMubWluWm9vbUxldmVsID09PSBcIm51bWJlclwiICYmIG9wdGlvbnMubWluWm9vbUxldmVsID4gMCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWluIHpvb20gbGV2ZWwgaGFzIHRvIGJlIGEgbnVtYmVyIGhpZ2hlciB0aGFuIHplcm8uXCIpO1xuICB9XG4gIGlmICghKHR5cGVvZiBvcHRpb25zLm1heFpvb21MZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBvcHRpb25zLm1pblpvb21MZXZlbCA8PSBvcHRpb25zLm1heFpvb21MZXZlbCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWF4IHpvb20gbGV2ZWwgaGFzIHRvIGJlIGEgbnVtYmVyIGhpZ2hlciB0aGFuIG1pbiB6b29tIGxldmVsLlwiKTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBUaGUgdmlld1xuICovXG52YXIgVmlldyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gICAqL1xuICBmdW5jdGlvbiBWaWV3KGJvZHksIGNhbnZhcykge1xuICAgIHZhciBfY29udGV4dCxcbiAgICAgIF90aGlzID0gdGhpcyxcbiAgICAgIF9jb250ZXh0MjtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmlldyk7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gMSAvIHRoaXMucmVuZGVyUmVmcmVzaFJhdGU7XG4gICAgdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbiA9IFwiZWFzZUluT3V0UXVpbnRcIjtcbiAgICB0aGlzLmVhc2luZ1RpbWUgPSAwO1xuICAgIHRoaXMuc291cmNlU2NhbGUgPSAwO1xuICAgIHRoaXMudGFyZ2V0U2NhbGUgPSAwO1xuICAgIHRoaXMuc291cmNlVHJhbnNsYXRpb24gPSAwO1xuICAgIHRoaXMudGFyZ2V0VHJhbnNsYXRpb24gPSAwO1xuICAgIHRoaXMubG9ja2VkT25Ob2RlSWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sb2NrZWRPbk5vZGVPZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3VjaFRpbWUgPSAwO1xuICAgIHRoaXMudmlld0Z1bmN0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZml0XCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0ID0gdGhpcy5maXQpLmNhbGwoX2NvbnRleHQsIHRoaXMpKTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImFuaW1hdGlvbkZpbmlzaGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0b3BSZW5kZXJpbmdcIik7XG4gICAgfSk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJ1bmxvY2tOb2RlXCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MiA9IHRoaXMucmVsZWFzZU5vZGUpLmNhbGwoX2NvbnRleHQyLCB0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zPXt9XVxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFZpZXcsIFt7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB6b29tcyBvdXQgdG8gZml0IGFsbCBkYXRhIG9uIHNjcmVlbiBiYXNlZCBvbiBhbW91bnQgb2Ygbm9kZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9ucz17e25vZGVzPUFycmF5fX1dXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0aWFsWm9vbT1mYWxzZV0gIHwgem9vbSBiYXNlZCBvbiBmaXR0ZWQgZm9ybXVsYSBvciByYW5nZSwgdHJ1ZSA9IGZpdHRlZCwgZGVmYXVsdCA9IGZhbHNlO1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXQob3B0aW9ucykge1xuICAgICAgdmFyIGluaXRpYWxab29tID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIG9wdGlvbnMgPSBub3JtYWxpemVGaXRPcHRpb25zKG9wdGlvbnMsIHRoaXMuYm9keS5ub2RlSW5kaWNlcyk7XG4gICAgICB2YXIgY2FudmFzV2lkdGggPSB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICB2YXIgY2FudmFzSGVpZ2h0ID0gdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodDtcbiAgICAgIHZhciByYW5nZTtcbiAgICAgIHZhciB6b29tTGV2ZWw7XG4gICAgICBpZiAoY2FudmFzV2lkdGggPT09IDAgfHwgY2FudmFzSGVpZ2h0ID09PSAwKSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gcG9pbnQgaW4gdHJ5aW5nIHRvIGZpdCBpbnRvIHplcm8gc2l6ZWQgY2FudmFzLiBUaGlzIGNvdWxkXG4gICAgICAgIC8vIHBvdGVudGlhbGx5IGV2ZW4gcmVzdWx0IGluIGludmFsaWQgdmFsdWVzIGJlaW5nIGNvbXB1dGVkLiBGb3IgZXhhbXBsZVxuICAgICAgICAvLyBmb3IgbmV0d29yayB3aXRob3V0IG5vZGVzIGFuZCB6ZXJvIHNpemVkIGNhbnZhcyB0aGUgem9vbSBsZXZlbCB3b3VsZFxuICAgICAgICAvLyBlbmQgdXAgYmVpbmcgY29tcHV0ZWQgYXMgMC8wIHdoaWNoIHJlc3VsdHMgaW4gTmFOLiBJbiBhbnkgb3RoZXIgY2FzZVxuICAgICAgICAvLyB0aGlzIHdvdWxkIGJlIDAvc29tZXRoaW5nIHdoaWNoIGlzIGFnYWluIHBvaW50bGVzcyB0byBjb21wdXRlLlxuICAgICAgICB6b29tTGV2ZWwgPSAxO1xuICAgICAgICByYW5nZSA9IE5ldHdvcmtVdGlsLmdldFJhbmdlKHRoaXMuYm9keS5ub2Rlcywgb3B0aW9ucy5ub2Rlcyk7XG4gICAgICB9IGVsc2UgaWYgKGluaXRpYWxab29tID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIG1vcmUgdGhhbiBoYWxmIG9mIHRoZSBub2RlcyBoYXZlIGEgcHJlZGVmaW5lZCBwb3NpdGlvbi4gSWYgc28sIHdlIHVzZSB0aGUgcmFuZ2UsIG5vdCB0aGUgYXBwcm94aW1hdGlvbi5cbiAgICAgICAgdmFyIHBvc2l0aW9uRGVmaW5lZCA9IDA7XG4gICAgICAgIGZvciAodmFyIG5vZGVJZCBpbiB0aGlzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIGlmIChub2RlLnByZWRlZmluZWRQb3NpdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBwb3NpdGlvbkRlZmluZWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uRGVmaW5lZCA+IDAuNSAqIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmZpdChvcHRpb25zLCBmYWxzZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlID0gTmV0d29ya1V0aWwuZ2V0UmFuZ2UodGhpcy5ib2R5Lm5vZGVzLCBvcHRpb25zLm5vZGVzKTtcbiAgICAgICAgdmFyIG51bWJlck9mTm9kZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoO1xuICAgICAgICB6b29tTGV2ZWwgPSAxMi42NjIgLyAobnVtYmVyT2ZOb2RlcyArIDcuNDE0NykgKyAwLjA5NjQ4MjI7IC8vIHRoaXMgaXMgb2J0YWluZWQgZnJvbSBmaXR0aW5nIGEgZGF0YXNldCBmcm9tIDUgcG9pbnRzIHdpdGggc2NhbGUgbGV2ZWxzIHRoYXQgbG9va2VkIGdvb2QuXG5cbiAgICAgICAgLy8gY29ycmVjdCBmb3IgbGFyZ2VyIGNhbnZhc3Nlcy5cbiAgICAgICAgdmFyIGZhY3RvciA9IE1hdGgubWluKGNhbnZhc1dpZHRoIC8gNjAwLCBjYW52YXNIZWlnaHQgLyA2MDApO1xuICAgICAgICB6b29tTGV2ZWwgKj0gZmFjdG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNpemVOb2Rlc1wiKTtcbiAgICAgICAgcmFuZ2UgPSBOZXR3b3JrVXRpbC5nZXRSYW5nZSh0aGlzLmJvZHkubm9kZXMsIG9wdGlvbnMubm9kZXMpO1xuICAgICAgICB2YXIgeERpc3RhbmNlID0gTWF0aC5hYnMocmFuZ2UubWF4WCAtIHJhbmdlLm1pblgpICogMS4xO1xuICAgICAgICB2YXIgeURpc3RhbmNlID0gTWF0aC5hYnMocmFuZ2UubWF4WSAtIHJhbmdlLm1pblkpICogMS4xO1xuICAgICAgICB2YXIgeFpvb21MZXZlbCA9IGNhbnZhc1dpZHRoIC8geERpc3RhbmNlO1xuICAgICAgICB2YXIgeVpvb21MZXZlbCA9IGNhbnZhc0hlaWdodCAvIHlEaXN0YW5jZTtcbiAgICAgICAgem9vbUxldmVsID0geFpvb21MZXZlbCA8PSB5Wm9vbUxldmVsID8geFpvb21MZXZlbCA6IHlab29tTGV2ZWw7XG4gICAgICB9XG4gICAgICBpZiAoem9vbUxldmVsID4gb3B0aW9ucy5tYXhab29tTGV2ZWwpIHtcbiAgICAgICAgem9vbUxldmVsID0gb3B0aW9ucy5tYXhab29tTGV2ZWw7XG4gICAgICB9IGVsc2UgaWYgKHpvb21MZXZlbCA8IG9wdGlvbnMubWluWm9vbUxldmVsKSB7XG4gICAgICAgIHpvb21MZXZlbCA9IG9wdGlvbnMubWluWm9vbUxldmVsO1xuICAgICAgfVxuICAgICAgdmFyIGNlbnRlciA9IE5ldHdvcmtVdGlsLmZpbmRDZW50ZXIocmFuZ2UpO1xuICAgICAgdmFyIGFuaW1hdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBjZW50ZXIsXG4gICAgICAgIHNjYWxlOiB6b29tTGV2ZWwsXG4gICAgICAgIGFuaW1hdGlvbjogb3B0aW9ucy5hbmltYXRpb25cbiAgICAgIH07XG4gICAgICB0aGlzLm1vdmVUbyhhbmltYXRpb25PcHRpb25zKTtcbiAgICB9XG5cbiAgICAvLyBhbmltYXRpb25cblxuICAgIC8qKlxuICAgICAqIENlbnRlciBhIG5vZGUgaW4gdmlldy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBub2RlSWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnNdXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZm9jdXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9jdXMobm9kZUlkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdLngsXG4gICAgICAgICAgeTogdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF0ueVxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zLnBvc2l0aW9uID0gbm9kZVBvc2l0aW9uO1xuICAgICAgICBvcHRpb25zLmxvY2tlZE9uTm9kZSA9IG5vZGVJZDtcbiAgICAgICAgdGhpcy5tb3ZlVG8ob3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiTm9kZTogXCIgKyBub2RlSWQgKyBcIiBjYW5ub3QgYmUgZm91bmQuXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgIHwgIG9wdGlvbnMub2Zmc2V0ICAgPSB7eDpudW1iZXIsIHk6bnVtYmVyfSAgIC8vIG9mZnNldCBmcm9tIHRoZSBjZW50ZXIgaW4gRE9NIHBpeGVsc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnNjYWxlICAgID0gbnVtYmVyICAgICAgICAgICAgICAgICAvLyBzY2FsZSB0byBtb3ZlIHRvXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMucG9zaXRpb24gPSB7eDpudW1iZXIsIHk6bnVtYmVyfSAgIC8vIHBvc2l0aW9uIHRvIG1vdmUgdG9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5hbmltYXRpb24gPSB7ZHVyYXRpb246bnVtYmVyLCBlYXNpbmdGdW5jdGlvbjpTdHJpbmd9IHx8IEJvb2xlYW4gICAvLyBwb3NpdGlvbiB0byBtb3ZlIHRvXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibW92ZVRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVUbyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0LnggIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvZXJjZSBhbmQgdmVyaWZ5IHRoYXQgeCBpcyB2YWxpZC5cbiAgICAgICAgICBvcHRpb25zLm9mZnNldC54ID0gK29wdGlvbnMub2Zmc2V0Lng7XG4gICAgICAgICAgaWYgKCFfTnVtYmVyJGlzRmluaXRlKG9wdGlvbnMub2Zmc2V0LngpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgb3B0aW9uIFwib2Zmc2V0LnhcIiBoYXMgdG8gYmUgYSBmaW5pdGUgbnVtYmVyLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLm9mZnNldC54ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vZmZzZXQueSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29lcmNlIGFuZCB2ZXJpZnkgdGhhdCB5IGlzIHZhbGlkLlxuICAgICAgICAgIG9wdGlvbnMub2Zmc2V0LnkgPSArb3B0aW9ucy5vZmZzZXQueTtcbiAgICAgICAgICBpZiAoIV9OdW1iZXIkaXNGaW5pdGUob3B0aW9ucy5vZmZzZXQueSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBvcHRpb24gXCJvZmZzZXQueVwiIGhhcyB0byBiZSBhIGZpbml0ZSBudW1iZXIuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMub2Zmc2V0LnggPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLm9mZnNldCA9IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24ueCAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29lcmNlIGFuZCB2ZXJpZnkgdGhhdCB4IGlzIHZhbGlkLlxuICAgICAgICAgIG9wdGlvbnMucG9zaXRpb24ueCA9ICtvcHRpb25zLnBvc2l0aW9uLng7XG4gICAgICAgICAgaWYgKCFfTnVtYmVyJGlzRmluaXRlKG9wdGlvbnMucG9zaXRpb24ueCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBvcHRpb24gXCJwb3NpdGlvbi54XCIgaGFzIHRvIGJlIGEgZmluaXRlIG51bWJlci4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbi54ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbi55ICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBDb2VyY2UgYW5kIHZlcmlmeSB0aGF0IHkgaXMgdmFsaWQuXG4gICAgICAgICAgb3B0aW9ucy5wb3NpdGlvbi55ID0gK29wdGlvbnMucG9zaXRpb24ueTtcbiAgICAgICAgICBpZiAoIV9OdW1iZXIkaXNGaW5pdGUob3B0aW9ucy5wb3NpdGlvbi55KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9wdGlvbiBcInBvc2l0aW9uLnlcIiBoYXMgdG8gYmUgYSBmaW5pdGUgbnVtYmVyLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLnBvc2l0aW9uLnggPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnBvc2l0aW9uID0gdGhpcy5nZXRWaWV3UG9zaXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNjYWxlICE9IG51bGwpIHtcbiAgICAgICAgLy8gQ29lcmNlIGFuZCB2ZXJpZnkgdGhhdCB0aGUgc2NhbGUgaXMgdmFsaWQuXG4gICAgICAgIG9wdGlvbnMuc2NhbGUgPSArb3B0aW9ucy5zY2FsZTtcbiAgICAgICAgaWYgKCEob3B0aW9ucy5zY2FsZSA+IDApKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9wdGlvbiBcInNjYWxlXCIgaGFzIHRvIGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiB6ZXJvLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHtcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uID09PSBmYWxzZSkge1xuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbiA9IHtcbiAgICAgICAgICBkdXJhdGlvbjogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uID0ge307XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24uZHVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRpb25zLmFuaW1hdGlvbi5kdXJhdGlvbiA9IDEwMDA7XG4gICAgICB9IC8vIGRlZmF1bHQgZHVyYXRpb25cbiAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbi5lYXNpbmdGdW5jdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uID0gXCJlYXNlSW5PdXRRdWFkXCI7XG4gICAgICB9IC8vIGRlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uXG5cbiAgICAgIHRoaXMuYW5pbWF0ZVZpZXcob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAgfCAgb3B0aW9ucy5vZmZzZXQgICA9IHt4Om51bWJlciwgeTpudW1iZXJ9ICAgLy8gb2Zmc2V0IGZyb20gdGhlIGNlbnRlciBpbiBET00gcGl4ZWxzXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMudGltZSAgICAgPSBudW1iZXIgICAgICAgICAgICAgICAgIC8vIGFuaW1hdGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kc1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBvcHRpb25zLnNjYWxlICAgID0gbnVtYmVyICAgICAgICAgICAgICAgICAvLyBzY2FsZSB0byBhbmltYXRlIHRvXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgIG9wdGlvbnMucG9zaXRpb24gPSB7eDpudW1iZXIsIHk6bnVtYmVyfSAgIC8vIHBvc2l0aW9uIHRvIGFuaW1hdGUgdG9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgb3B0aW9ucy5lYXNpbmdGdW5jdGlvbiA9IFN0cmluZyAgICAgICAgICAgLy8gbGluZWFyLCBlYXNlSW5RdWFkLCBlYXNlT3V0UXVhZCwgZWFzZUluT3V0UXVhZCxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWFzZUluQ3ViaWMsIGVhc2VPdXRDdWJpYywgZWFzZUluT3V0Q3ViaWMsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVhc2VJblF1YXJ0LCBlYXNlT3V0UXVhcnQsIGVhc2VJbk91dFF1YXJ0LFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlYXNlSW5RdWludCwgZWFzZU91dFF1aW50LCBlYXNlSW5PdXRRdWludFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVWaWV3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVWaWV3KG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hbmltYXRpb25FYXNpbmdGdW5jdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uLmVhc2luZ0Z1bmN0aW9uO1xuICAgICAgLy8gcmVsZWFzZSBpZiBzb21ldGhpbmcgZm9jdXNzZWQgb24gdGhlIG5vZGVcbiAgICAgIHRoaXMucmVsZWFzZU5vZGUoKTtcbiAgICAgIGlmIChvcHRpb25zLmxvY2tlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmxvY2tlZE9uTm9kZUlkID0gb3B0aW9ucy5sb2NrZWRPbk5vZGU7XG4gICAgICAgIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIC8vIGZvcmNlZnVsbHkgY29tcGxldGUgdGhlIG9sZCBhbmltYXRpb24gaWYgaXQgd2FzIHN0aWxsIHJ1bm5pbmdcbiAgICAgIGlmICh0aGlzLmVhc2luZ1RpbWUgIT0gMCkge1xuICAgICAgICB0aGlzLl90cmFuc2l0aW9uUmVkcmF3KHRydWUpOyAvLyBieSBzZXR0aW5nIGVhc2luZ3RpbWUgdG8gMSwgd2UgZmluaXNoIHRoZSBhbmltYXRpb24uXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc291cmNlU2NhbGUgPSB0aGlzLmJvZHkudmlldy5zY2FsZTtcbiAgICAgIHRoaXMuc291cmNlVHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcbiAgICAgIHRoaXMudGFyZ2V0U2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuXG4gICAgICAvLyBzZXQgdGhlIHNjYWxlIHNvIHRoZSB2aWV3Q2VudGVyIGlzIGJhc2VkIG9uIHRoZSBjb3JyZWN0IHpvb20gbGV2ZWwuIFRoaXMgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgdHJhbnNpdGlvblJlZHJhd1xuICAgICAgLy8gYnV0IGF0IGxlYXN0IHRoZW4gd2UnbGwgaGF2ZSB0aGUgdGFyZ2V0IHRyYW5zaXRpb25cbiAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gdGhpcy50YXJnZXRTY2FsZTtcbiAgICAgIHZhciB2aWV3Q2VudGVyID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXMoe1xuICAgICAgICB4OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50V2lkdGgsXG4gICAgICAgIHk6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHRcbiAgICAgIH0pO1xuICAgICAgdmFyIGRpc3RhbmNlRnJvbUNlbnRlciA9IHtcbiAgICAgICAgLy8gb2Zmc2V0IGZyb20gdmlldywgZGlzdGFuY2UgdmlldyBoYXMgdG8gY2hhbmdlIGJ5IHRoZXNlIHggYW5kIHkgdG8gY2VudGVyIHRoZSBub2RlXG4gICAgICAgIHg6IHZpZXdDZW50ZXIueCAtIG9wdGlvbnMucG9zaXRpb24ueCxcbiAgICAgICAgeTogdmlld0NlbnRlci55IC0gb3B0aW9ucy5wb3NpdGlvbi55XG4gICAgICB9O1xuICAgICAgdGhpcy50YXJnZXRUcmFuc2xhdGlvbiA9IHtcbiAgICAgICAgeDogdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi54ICsgZGlzdGFuY2VGcm9tQ2VudGVyLnggKiB0aGlzLnRhcmdldFNjYWxlICsgb3B0aW9ucy5vZmZzZXQueCxcbiAgICAgICAgeTogdGhpcy5zb3VyY2VUcmFuc2xhdGlvbi55ICsgZGlzdGFuY2VGcm9tQ2VudGVyLnkgKiB0aGlzLnRhcmdldFNjYWxlICsgb3B0aW9ucy5vZmZzZXQueVxuICAgICAgfTtcblxuICAgICAgLy8gaWYgdGhlIHRpbWUgaXMgc2V0IHRvIDAsIGRvbid0IGRvIGFuIGFuaW1hdGlvblxuICAgICAgaWYgKG9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uID09PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLmxvY2tlZE9uTm9kZUlkICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBfY29udGV4dDM7XG4gICAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDMgPSB0aGlzLl9sb2NrZWRSZWRyYXcpLmNhbGwoX2NvbnRleHQzLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gdGhpcy50YXJnZXRTY2FsZTtcbiAgICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHRoaXMudGFyZ2V0VHJhbnNsYXRpb247XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2NvbnRleHQ0O1xuICAgICAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gMSAvICg2MCAqIG9wdGlvbnMuYW5pbWF0aW9uLmR1cmF0aW9uICogMC4wMDEpIHx8IDEgLyA2MDsgLy8gNjAgZm9yIDYwIHNlY29uZHMsIDAuMDAxIGZvciBtaWxsaSdzXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRWFzaW5nRnVuY3Rpb24gPSBvcHRpb25zLmFuaW1hdGlvbi5lYXNpbmdGdW5jdGlvbjtcbiAgICAgICAgdGhpcy52aWV3RnVuY3Rpb24gPSBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDQgPSB0aGlzLl90cmFuc2l0aW9uUmVkcmF3KS5jYWxsKF9jb250ZXh0NCwgdGhpcyk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RhcnRSZW5kZXJpbmdcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXNlZCB0byBhbmltYXRlIHNtb290aGx5IGJ5IGhpamFja2luZyB0aGUgcmVkcmF3IGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfbG9ja2VkUmVkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2NrZWRSZWRyYXcoKSB7XG4gICAgICB2YXIgbm9kZVBvc2l0aW9uID0ge1xuICAgICAgICB4OiB0aGlzLmJvZHkubm9kZXNbdGhpcy5sb2NrZWRPbk5vZGVJZF0ueCxcbiAgICAgICAgeTogdGhpcy5ib2R5Lm5vZGVzW3RoaXMubG9ja2VkT25Ob2RlSWRdLnlcbiAgICAgIH07XG4gICAgICB2YXIgdmlld0NlbnRlciA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHtcbiAgICAgICAgeDogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoLFxuICAgICAgICB5OiAwLjUgKiB0aGlzLmNhbnZhcy5mcmFtZS5jYW52YXMuY2xpZW50SGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIHZhciBkaXN0YW5jZUZyb21DZW50ZXIgPSB7XG4gICAgICAgIC8vIG9mZnNldCBmcm9tIHZpZXcsIGRpc3RhbmNlIHZpZXcgaGFzIHRvIGNoYW5nZSBieSB0aGVzZSB4IGFuZCB5IHRvIGNlbnRlciB0aGUgbm9kZVxuICAgICAgICB4OiB2aWV3Q2VudGVyLnggLSBub2RlUG9zaXRpb24ueCxcbiAgICAgICAgeTogdmlld0NlbnRlci55IC0gbm9kZVBvc2l0aW9uLnlcbiAgICAgIH07XG4gICAgICB2YXIgc291cmNlVHJhbnNsYXRpb24gPSB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbjtcbiAgICAgIHZhciB0YXJnZXRUcmFuc2xhdGlvbiA9IHtcbiAgICAgICAgeDogc291cmNlVHJhbnNsYXRpb24ueCArIGRpc3RhbmNlRnJvbUNlbnRlci54ICogdGhpcy5ib2R5LnZpZXcuc2NhbGUgKyB0aGlzLmxvY2tlZE9uTm9kZU9mZnNldC54LFxuICAgICAgICB5OiBzb3VyY2VUcmFuc2xhdGlvbi55ICsgZGlzdGFuY2VGcm9tQ2VudGVyLnkgKiB0aGlzLmJvZHkudmlldy5zY2FsZSArIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0LnlcbiAgICAgIH07XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHRhcmdldFRyYW5zbGF0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBzdGF0ZSBvZiBhIGxvY2tlZCBvbiBOb2RlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVsZWFzZU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVsZWFzZU5vZGUoKSB7XG4gICAgICBpZiAodGhpcy5sb2NrZWRPbk5vZGVJZCAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmlld0Z1bmN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub2ZmKFwiaW5pdFJlZHJhd1wiLCB0aGlzLnZpZXdGdW5jdGlvbik7XG4gICAgICAgIHRoaXMubG9ja2VkT25Ob2RlSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubG9ja2VkT25Ob2RlT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZpbmlzaGVkPWZhbHNlXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3RyYW5zaXRpb25SZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYW5zaXRpb25SZWRyYXcoKSB7XG4gICAgICB2YXIgZmluaXNoZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgICAgdGhpcy5lYXNpbmdUaW1lICs9IHRoaXMuYW5pbWF0aW9uU3BlZWQ7XG4gICAgICB0aGlzLmVhc2luZ1RpbWUgPSBmaW5pc2hlZCA9PT0gdHJ1ZSA/IDEuMCA6IHRoaXMuZWFzaW5nVGltZTtcbiAgICAgIHZhciBwcm9ncmVzcyA9IGVhc2luZ0Z1bmN0aW9uc1t0aGlzLmFuaW1hdGlvbkVhc2luZ0Z1bmN0aW9uXSh0aGlzLmVhc2luZ1RpbWUpO1xuICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSB0aGlzLnNvdXJjZVNjYWxlICsgKHRoaXMudGFyZ2V0U2NhbGUgLSB0aGlzLnNvdXJjZVNjYWxlKSAqIHByb2dyZXNzO1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgIHg6IHRoaXMuc291cmNlVHJhbnNsYXRpb24ueCArICh0aGlzLnRhcmdldFRyYW5zbGF0aW9uLnggLSB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLngpICogcHJvZ3Jlc3MsXG4gICAgICAgIHk6IHRoaXMuc291cmNlVHJhbnNsYXRpb24ueSArICh0aGlzLnRhcmdldFRyYW5zbGF0aW9uLnkgLSB0aGlzLnNvdXJjZVRyYW5zbGF0aW9uLnkpICogcHJvZ3Jlc3NcbiAgICAgIH07XG5cbiAgICAgIC8vIGNsZWFudXBcbiAgICAgIGlmICh0aGlzLmVhc2luZ1RpbWUgPj0gMS4wKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZihcImluaXRSZWRyYXdcIiwgdGhpcy52aWV3RnVuY3Rpb24pO1xuICAgICAgICB0aGlzLmVhc2luZ1RpbWUgPSAwO1xuICAgICAgICBpZiAodGhpcy5sb2NrZWRPbk5vZGVJZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQ1O1xuICAgICAgICAgIHRoaXMudmlld0Z1bmN0aW9uID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQ1ID0gdGhpcy5fbG9ja2VkUmVkcmF3KS5jYWxsKF9jb250ZXh0NSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJpbml0UmVkcmF3XCIsIHRoaXMudmlld0Z1bmN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYW5pbWF0aW9uRmluaXNoZWRcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNjYWxlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Vmlld1Bvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpZXdQb3NpdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyh7XG4gICAgICAgIHg6IDAuNSAqIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRXaWR0aCxcbiAgICAgICAgeTogMC41ICogdGhpcy5jYW52YXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodFxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBWaWV3O1xufSgpO1xuXG4vKipcclxuICogQ3JlYXRlZCBieSBBbGV4IG9uIDExLzYvMjAxNC5cclxuICovXHJcbmZ1bmN0aW9uIGtleWNoYXJtKG9wdGlvbnMpIHtcclxuICB2YXIgcHJldmVudERlZmF1bHQgPSBvcHRpb25zICYmIG9wdGlvbnMucHJldmVudERlZmF1bHQgfHwgZmFsc2U7XHJcblxyXG4gIHZhciBjb250YWluZXIgPSBvcHRpb25zICYmIG9wdGlvbnMuY29udGFpbmVyIHx8IHdpbmRvdztcclxuXHJcbiAgdmFyIF9leHBvcnRGdW5jdGlvbnMgPSB7fTtcclxuICB2YXIgX2JvdW5kID0ge2tleWRvd246e30sIGtleXVwOnt9fTtcclxuICB2YXIgX2tleXMgPSB7fTtcclxuICB2YXIgaTtcclxuXHJcbiAgLy8gYSAtIHpcclxuICBmb3IgKGkgPSA5NzsgaSA8PSAxMjI7IGkrKykge19rZXlzW1N0cmluZy5mcm9tQ2hhckNvZGUoaSldID0ge2NvZGU6NjUgKyAoaSAtIDk3KSwgc2hpZnQ6IGZhbHNlfTt9XHJcbiAgLy8gQSAtIFpcclxuICBmb3IgKGkgPSA2NTsgaSA8PSA5MDsgaSsrKSB7X2tleXNbU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSB7Y29kZTppLCBzaGlmdDogdHJ1ZX07fVxyXG4gIC8vIDAgLSA5XHJcbiAgZm9yIChpID0gMDsgIGkgPD0gOTsgICBpKyspIHtfa2V5c1snJyArIGldID0ge2NvZGU6NDggKyBpLCBzaGlmdDogZmFsc2V9O31cclxuICAvLyBGMSAtIEYxMlxyXG4gIGZvciAoaSA9IDE7ICBpIDw9IDEyOyAgIGkrKykge19rZXlzWydGJyArIGldID0ge2NvZGU6MTExICsgaSwgc2hpZnQ6IGZhbHNlfTt9XHJcbiAgLy8gbnVtMCAtIG51bTlcclxuICBmb3IgKGkgPSAwOyAgaSA8PSA5OyAgIGkrKykge19rZXlzWydudW0nICsgaV0gPSB7Y29kZTo5NiArIGksIHNoaWZ0OiBmYWxzZX07fVxyXG5cclxuICAvLyBudW1wYWQgbWlzY1xyXG4gIF9rZXlzWydudW0qJ10gPSB7Y29kZToxMDYsIHNoaWZ0OiBmYWxzZX07XHJcbiAgX2tleXNbJ251bSsnXSA9IHtjb2RlOjEwNywgc2hpZnQ6IGZhbHNlfTtcclxuICBfa2V5c1snbnVtLSddID0ge2NvZGU6MTA5LCBzaGlmdDogZmFsc2V9O1xyXG4gIF9rZXlzWydudW0vJ10gPSB7Y29kZToxMTEsIHNoaWZ0OiBmYWxzZX07XHJcbiAgX2tleXNbJ251bS4nXSA9IHtjb2RlOjExMCwgc2hpZnQ6IGZhbHNlfTtcclxuICAvLyBhcnJvd3NcclxuICBfa2V5c1snbGVmdCddICA9IHtjb2RlOjM3LCBzaGlmdDogZmFsc2V9O1xyXG4gIF9rZXlzWyd1cCddICAgID0ge2NvZGU6MzgsIHNoaWZ0OiBmYWxzZX07XHJcbiAgX2tleXNbJ3JpZ2h0J10gPSB7Y29kZTozOSwgc2hpZnQ6IGZhbHNlfTtcclxuICBfa2V5c1snZG93biddICA9IHtjb2RlOjQwLCBzaGlmdDogZmFsc2V9O1xyXG4gIC8vIGV4dHJhIGtleXNcclxuICBfa2V5c1snc3BhY2UnXSA9IHtjb2RlOjMyLCBzaGlmdDogZmFsc2V9O1xyXG4gIF9rZXlzWydlbnRlciddID0ge2NvZGU6MTMsIHNoaWZ0OiBmYWxzZX07XHJcbiAgX2tleXNbJ3NoaWZ0J10gPSB7Y29kZToxNiwgc2hpZnQ6IHVuZGVmaW5lZH07XHJcbiAgX2tleXNbJ2VzYyddICAgPSB7Y29kZToyNywgc2hpZnQ6IGZhbHNlfTtcclxuICBfa2V5c1snYmFja3NwYWNlJ10gPSB7Y29kZTo4LCBzaGlmdDogZmFsc2V9O1xyXG4gIF9rZXlzWyd0YWInXSAgICAgICA9IHtjb2RlOjksIHNoaWZ0OiBmYWxzZX07XHJcbiAgX2tleXNbJ2N0cmwnXSAgICAgID0ge2NvZGU6MTcsIHNoaWZ0OiBmYWxzZX07XHJcbiAgX2tleXNbJ2FsdCddICAgICAgID0ge2NvZGU6MTgsIHNoaWZ0OiBmYWxzZX07XHJcbiAgX2tleXNbJ2RlbGV0ZSddICAgID0ge2NvZGU6NDYsIHNoaWZ0OiBmYWxzZX07XHJcbiAgX2tleXNbJ3BhZ2V1cCddICAgID0ge2NvZGU6MzMsIHNoaWZ0OiBmYWxzZX07XHJcbiAgX2tleXNbJ3BhZ2Vkb3duJ10gID0ge2NvZGU6MzQsIHNoaWZ0OiBmYWxzZX07XHJcbiAgLy8gc3ltYm9sc1xyXG4gIF9rZXlzWyc9J10gICAgID0ge2NvZGU6MTg3LCBzaGlmdDogZmFsc2V9O1xyXG4gIF9rZXlzWyctJ10gICAgID0ge2NvZGU6MTg5LCBzaGlmdDogZmFsc2V9O1xyXG4gIF9rZXlzWyddJ10gICAgID0ge2NvZGU6MjIxLCBzaGlmdDogZmFsc2V9O1xyXG4gIF9rZXlzWydbJ10gICAgID0ge2NvZGU6MjE5LCBzaGlmdDogZmFsc2V9O1xyXG5cclxuXHJcblxyXG4gIHZhciBkb3duID0gZnVuY3Rpb24oZXZlbnQpIHtoYW5kbGVFdmVudChldmVudCwna2V5ZG93bicpO307XHJcbiAgdmFyIHVwID0gZnVuY3Rpb24oZXZlbnQpIHtoYW5kbGVFdmVudChldmVudCwna2V5dXAnKTt9O1xyXG5cclxuICAvLyBoYW5kbGUgdGhlIGFjdHVhbHkgYm91bmQga2V5IHdpdGggdGhlIGV2ZW50XHJcbiAgdmFyIGhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsdHlwZSkge1xyXG4gICAgaWYgKF9ib3VuZFt0eXBlXVtldmVudC5rZXlDb2RlXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHZhciBib3VuZCA9IF9ib3VuZFt0eXBlXVtldmVudC5rZXlDb2RlXTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChib3VuZFtpXS5zaGlmdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBib3VuZFtpXS5mbihldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGJvdW5kW2ldLnNoaWZ0ID09IHRydWUgJiYgZXZlbnQuc2hpZnRLZXkgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgYm91bmRbaV0uZm4oZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChib3VuZFtpXS5zaGlmdCA9PSBmYWxzZSAmJiBldmVudC5zaGlmdEtleSA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgYm91bmRbaV0uZm4oZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHByZXZlbnREZWZhdWx0ID09IHRydWUpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gYmluZCBhIGtleSB0byBhIGNhbGxiYWNrXHJcbiAgX2V4cG9ydEZ1bmN0aW9ucy5iaW5kID0gZnVuY3Rpb24oa2V5LCBjYWxsYmFjaywgdHlwZSkge1xyXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0eXBlID0gJ2tleWRvd24nO1xyXG4gICAgfVxyXG4gICAgaWYgKF9rZXlzW2tleV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXk6IFwiICsga2V5KTtcclxuICAgIH1cclxuICAgIGlmIChfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdID0gW107XHJcbiAgICB9XHJcbiAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXS5wdXNoKHtmbjpjYWxsYmFjaywgc2hpZnQ6X2tleXNba2V5XS5zaGlmdH0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvLyBiaW5kIGFsbCBrZXlzIHRvIGEgY2FsbCBiYWNrIChkZW1vIHB1cnBvc2VzKVxyXG4gIF9leHBvcnRGdW5jdGlvbnMuYmluZEFsbCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0eXBlKSB7XHJcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHR5cGUgPSAna2V5ZG93bic7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBrZXkgaW4gX2tleXMpIHtcclxuICAgICAgaWYgKF9rZXlzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICBfZXhwb3J0RnVuY3Rpb25zLmJpbmQoa2V5LGNhbGxiYWNrLHR5cGUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gZ2V0IHRoZSBrZXkgbGFiZWwgZnJvbSBhbiBldmVudFxyXG4gIF9leHBvcnRGdW5jdGlvbnMuZ2V0S2V5ID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBfa2V5cykge1xyXG4gICAgICBpZiAoX2tleXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG4gICAgICAgIGlmIChldmVudC5zaGlmdEtleSA9PSB0cnVlICYmIF9rZXlzW2tleV0uc2hpZnQgPT0gdHJ1ZSAmJiBldmVudC5rZXlDb2RlID09IF9rZXlzW2tleV0uY29kZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuc2hpZnRLZXkgPT0gZmFsc2UgJiYgX2tleXNba2V5XS5zaGlmdCA9PSBmYWxzZSAmJiBldmVudC5rZXlDb2RlID09IF9rZXlzW2tleV0uY29kZSkge1xyXG4gICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PSBfa2V5c1trZXldLmNvZGUgJiYga2V5ID09ICdzaGlmdCcpIHtcclxuICAgICAgICAgIHJldHVybiBrZXk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXCJ1bmtub3duIGtleSwgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWRcIjtcclxuICB9O1xyXG5cclxuICAvLyB1bmJpbmQgZWl0aGVyIGEgc3BlY2lmaWMgY2FsbGJhY2sgZnJvbSBhIGtleSBvciBhbGwgb2YgdGhlbSAoYnkgbGVhdmluZyBjYWxsYmFjayB1bmRlZmluZWQpXHJcbiAgX2V4cG9ydEZ1bmN0aW9ucy51bmJpbmQgPSBmdW5jdGlvbihrZXksIGNhbGxiYWNrLCB0eXBlKSB7XHJcbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHR5cGUgPSAna2V5ZG93bic7XHJcbiAgICB9XHJcbiAgICBpZiAoX2tleXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGtleTogXCIgKyBrZXkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdmFyIG5ld0JpbmRpbmdzID0gW107XHJcbiAgICAgIHZhciBib3VuZCA9IF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdO1xyXG4gICAgICBpZiAoYm91bmQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGlmICghKGJvdW5kW2ldLmZuID09IGNhbGxiYWNrICYmIGJvdW5kW2ldLnNoaWZ0ID09IF9rZXlzW2tleV0uc2hpZnQpKSB7XHJcbiAgICAgICAgICAgIG5ld0JpbmRpbmdzLnB1c2goX2JvdW5kW3R5cGVdW19rZXlzW2tleV0uY29kZV1baV0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBfYm91bmRbdHlwZV1bX2tleXNba2V5XS5jb2RlXSA9IG5ld0JpbmRpbmdzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIF9ib3VuZFt0eXBlXVtfa2V5c1trZXldLmNvZGVdID0gW107XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gcmVzZXQgYWxsIGJvdW5kIHZhcmlhYmxlcy5cclxuICBfZXhwb3J0RnVuY3Rpb25zLnJlc2V0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfYm91bmQgPSB7a2V5ZG93bjp7fSwga2V5dXA6e319O1xyXG4gIH07XHJcblxyXG4gIC8vIHVuYmluZCBhbGwgbGlzdGVuZXJzIGFuZCByZXNldCBhbGwgdmFyaWFibGVzLlxyXG4gIF9leHBvcnRGdW5jdGlvbnMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX2JvdW5kID0ge2tleWRvd246e30sIGtleXVwOnt9fTtcclxuICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93biwgdHJ1ZSk7XHJcbiAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5dXAnLCB1cCwgdHJ1ZSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gY3JlYXRlIGxpc3RlbmVycy5cclxuICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsZG93bix0cnVlKTtcclxuICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLHVwLHRydWUpO1xyXG5cclxuICAvLyByZXR1cm4gdGhlIHB1YmxpYyBmdW5jdGlvbnMuXHJcbiAgcmV0dXJuIF9leHBvcnRGdW5jdGlvbnM7XHJcbn1cblxuLyoqXG4gKiBOYXZpZ2F0aW9uIEhhbmRsZXJcbiAqL1xudmFyIE5hdmlnYXRpb25IYW5kbGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICovXG4gIGZ1bmN0aW9uIE5hdmlnYXRpb25IYW5kbGVyKGJvZHksIGNhbnZhcykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5hdmlnYXRpb25IYW5kbGVyKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuaWNvbnNDcmVhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycyA9IFtdO1xuICAgIHRoaXMuYm91bmRGdW5jdGlvbnMgPSB7fTtcbiAgICB0aGlzLnRvdWNoVGltZSA9IDA7XG4gICAgdGhpcy5hY3RpdmF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImFjdGl2YXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmFjdGl2YXRlZCA9IHRydWU7XG4gICAgICBfdGhpcy5jb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCk7XG4gICAgfSk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJkZWFjdGl2YXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmFjdGl2YXRlZCA9IGZhbHNlO1xuICAgICAgX3RoaXMuY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5ncygpO1xuICAgIH0pO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiZGVzdHJveVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMua2V5Y2hhcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBfdGhpcy5rZXljaGFybS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vcHRpb25zID0ge307XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhOYXZpZ2F0aW9uSGFuZGxlciwgW3tcbiAgICBrZXk6IFwic2V0T3B0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jcmVhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG9yIHJlZnJlc2hlcyBuYXZpZ2F0aW9uIGFuZCBzZXRzIGtleSBiaW5kaW5nc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLm5hdmlnYXRpb25CdXR0b25zID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLmljb25zQ3JlYXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmxvYWROYXZpZ2F0aW9uRWxlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmljb25zQ3JlYXRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmNsZWFuTmF2aWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgdGhpcy5jb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIHByZXZpb3VzIG5hdmlnYXRpb24gaXRlbXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbGVhbk5hdmlnYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW5OYXZpZ2F0aW9uKCkge1xuICAgICAgLy8gY2xlYW4gaGFtbWVyIGJpbmRpbmdzXG4gICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5sZW5ndGggIT0gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubmF2aWdhdGlvbkhhbW1lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzID0gW107XG4gICAgICB9XG5cbiAgICAgIC8vIGNsZWFuIHVwIHByZXZpb3VzIG5hdmlnYXRpb24gaXRlbXNcbiAgICAgIGlmICh0aGlzLm5hdmlnYXRpb25ET00gJiYgdGhpcy5uYXZpZ2F0aW9uRE9NW1wid3JhcHBlclwiXSAmJiB0aGlzLm5hdmlnYXRpb25ET01bXCJ3cmFwcGVyXCJdLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NW1wid3JhcHBlclwiXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMubmF2aWdhdGlvbkRPTVtcIndyYXBwZXJcIl0pO1xuICAgICAgfVxuICAgICAgdGhpcy5pY29uc0NyZWF0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGlvbiBvZiB0aGUgbmF2aWdhdGlvbiBjb250cm9scyBub2Rlcy4gVGhleSBhcmUgZHJhd24gb3ZlciB0aGUgcmVzdCBvZiB0aGUgbm9kZXMgYW5kIGFyZSBub3QgYWZmZWN0ZWQgYnkgc2NhbGUgYW5kIHRyYW5zbGF0aW9uXG4gICAgICogdGhleSBoYXZlIGEgdHJpZ2dlckZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBvbiBjbGljay4gSWYgdGhlIHBvc2l0aW9uIG9mIHRoZSBuYXZpZ2F0aW9uIGNvbnRyb2xzIGlzIGRlcGVuZGVudFxuICAgICAqIG9uIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudFdpZHRoIG9yIHRoaXMuZnJhbWUuY2FudmFzLmNsaWVudEhlaWdodCwgd2UgZmxhZyBob3Jpem9udGFsQWxpZ25MZWZ0IGFuZCB2ZXJ0aWNhbEFsaWduVG9wIGZhbHNlLlxuICAgICAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgbG9jYXRpb24gd2lsbCBiZSBjb3JyZWN0ZWQgYnkgdGhlIF9yZWxvY2F0ZU5hdmlnYXRpb24gZnVuY3Rpb24gb24gYSBzaXplIGNoYW5nZSBvZiB0aGUgY2FudmFzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJsb2FkTmF2aWdhdGlvbkVsZW1lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWROYXZpZ2F0aW9uRWxlbWVudHMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHRoaXMuY2xlYW5OYXZpZ2F0aW9uKCk7XG4gICAgICB0aGlzLm5hdmlnYXRpb25ET00gPSB7fTtcbiAgICAgIHZhciBuYXZpZ2F0aW9uRGl2cyA9IFtcInVwXCIsIFwiZG93blwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcInpvb21JblwiLCBcInpvb21PdXRcIiwgXCJ6b29tRXh0ZW5kc1wiXTtcbiAgICAgIHZhciBuYXZpZ2F0aW9uRGl2QWN0aW9ucyA9IFtcIl9tb3ZlVXBcIiwgXCJfbW92ZURvd25cIiwgXCJfbW92ZUxlZnRcIiwgXCJfbW92ZVJpZ2h0XCIsIFwiX3pvb21JblwiLCBcIl96b29tT3V0XCIsIFwiX2ZpdFwiXTtcbiAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVtcIndyYXBwZXJcIl0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NW1wid3JhcHBlclwiXS5jbGFzc05hbWUgPSBcInZpcy1uYXZpZ2F0aW9uXCI7XG4gICAgICB0aGlzLmNhbnZhcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm5hdmlnYXRpb25ET01bXCJ3cmFwcGVyXCJdKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmF2aWdhdGlvbkRpdnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uRE9NW25hdmlnYXRpb25EaXZzW2ldXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkRPTVtuYXZpZ2F0aW9uRGl2c1tpXV0uY2xhc3NOYW1lID0gXCJ2aXMtYnV0dG9uIHZpcy1cIiArIG5hdmlnYXRpb25EaXZzW2ldO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb25ET01bXCJ3cmFwcGVyXCJdLmFwcGVuZENoaWxkKHRoaXMubmF2aWdhdGlvbkRPTVtuYXZpZ2F0aW9uRGl2c1tpXV0pO1xuICAgICAgICB2YXIgaGFtbWVyID0gbmV3IEhhbW1lcih0aGlzLm5hdmlnYXRpb25ET01bbmF2aWdhdGlvbkRpdnNbaV1dKTtcbiAgICAgICAgaWYgKG5hdmlnYXRpb25EaXZBY3Rpb25zW2ldID09PSBcIl9maXRcIikge1xuICAgICAgICAgIHZhciBfY29udGV4dDtcbiAgICAgICAgICBvblRvdWNoKGhhbW1lciwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQgPSB0aGlzLl9maXQpLmNhbGwoX2NvbnRleHQsIHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQyO1xuICAgICAgICAgIG9uVG91Y2goaGFtbWVyLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDIgPSB0aGlzLmJpbmRUb1JlZHJhdykuY2FsbChfY29udGV4dDIsIHRoaXMsIG5hdmlnYXRpb25EaXZBY3Rpb25zW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFtbWVycy5wdXNoKGhhbW1lcik7XG4gICAgICB9XG5cbiAgICAgIC8vIHVzZSBhIGhhbW1lciBmb3IgdGhlIHJlbGVhc2Ugc28gd2UgZG8gbm90IHJlcXVpcmUgdGhlIG9uZSB1c2VkIGluIHRoZSByZXN0IG9mIHRoZSBuZXR3b3JrXG4gICAgICAvLyB0aGUgb25lIHRoZSByZXN0IHVzZXMgY2FuIGJlIG92ZXJsb2FkZWQgYnkgdGhlIG1hbmlwdWxhdGlvbiBzeXN0ZW0uXG4gICAgICB2YXIgaGFtbWVyRnJhbWUgPSBuZXcgSGFtbWVyKHRoaXMuY2FudmFzLmZyYW1lKTtcbiAgICAgIG9uUmVsZWFzZShoYW1tZXJGcmFtZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuX3N0b3BNb3ZlbWVudCgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm5hdmlnYXRpb25IYW1tZXJzLnB1c2goaGFtbWVyRnJhbWUpO1xuICAgICAgdGhpcy5pY29uc0NyZWF0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImJpbmRUb1JlZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kVG9SZWRyYXcoYWN0aW9uKSB7XG4gICAgICBpZiAodGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MztcbiAgICAgICAgdGhpcy5ib3VuZEZ1bmN0aW9uc1thY3Rpb25dID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQzID0gdGhpc1thY3Rpb25dKS5jYWxsKF9jb250ZXh0MywgdGhpcyk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiaW5pdFJlZHJhd1wiLCB0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl0pO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0YXJ0UmVuZGVyaW5nXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVuYmluZEZyb21SZWRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kRnJvbVJlZHJhdyhhY3Rpb24pIHtcbiAgICAgIGlmICh0aGlzLmJvdW5kRnVuY3Rpb25zW2FjdGlvbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoXCJpbml0UmVkcmF3XCIsIHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXSk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfc3RvcFJlbmRlcmluZ1wiKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuYm91bmRGdW5jdGlvbnNbYWN0aW9uXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0aGlzIHN0b3BzIGFsbCBtb3ZlbWVudCBpbmR1Y2VkIGJ5IHRoZSBuYXZpZ2F0aW9uIGJ1dHRvbnNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZml0KCkge1xuICAgICAgaWYgKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy50b3VjaFRpbWUgPiA3MDApIHtcbiAgICAgICAgLy8gVE9ETzogZml4IHVnbHkgaGFjayB0byBhdm9pZCBoYW1tZXIncyBkb3VibGUgZmlyZWluZyBvZiBldmVudCAoYmVjYXVzZSB3ZSB1c2UgcmVsZWFzZT8pXG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJmaXRcIiwge1xuICAgICAgICAgIGR1cmF0aW9uOiA3MDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcyBzdG9wcyBhbGwgbW92ZW1lbnQgaW5kdWNlZCBieSB0aGUgbmF2aWdhdGlvbiBidXR0b25zXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zdG9wTW92ZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0b3BNb3ZlbWVudCgpIHtcbiAgICAgIGZvciAodmFyIGJvdW5kQWN0aW9uIGluIHRoaXMuYm91bmRGdW5jdGlvbnMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvdW5kRnVuY3Rpb25zLCBib3VuZEFjdGlvbikpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5vZmYoXCJpbml0UmVkcmF3XCIsIHRoaXMuYm91bmRGdW5jdGlvbnNbYm91bmRBY3Rpb25dKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3N0b3BSZW5kZXJpbmdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYm91bmRGdW5jdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9tb3ZlVXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVVcCgpIHtcbiAgICAgIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uLnkgKz0gdGhpcy5vcHRpb25zLmtleWJvYXJkLnNwZWVkLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfbW92ZURvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVEb3duKCkge1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueSAtPSB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9tb3ZlTGVmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZUxlZnQoKSB7XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbi54ICs9IHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC54O1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX21vdmVSaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbW92ZVJpZ2h0KCkge1xuICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24ueCAtPSB0aGlzLm9wdGlvbnMua2V5Ym9hcmQuc3BlZWQueDtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl96b29tSW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3pvb21JbigpIHtcbiAgICAgIHZhciBzY2FsZU9sZCA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGUgKiAoMSArIHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC56b29tKTtcbiAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uO1xuICAgICAgdmFyIHNjYWxlRnJhYyA9IHNjYWxlIC8gc2NhbGVPbGQ7XG4gICAgICB2YXIgdHggPSAoMSAtIHNjYWxlRnJhYykgKiB0aGlzLmNhbnZhcy5jYW52YXNWaWV3Q2VudGVyLnggKyB0cmFuc2xhdGlvbi54ICogc2NhbGVGcmFjO1xuICAgICAgdmFyIHR5ID0gKDEgLSBzY2FsZUZyYWMpICogdGhpcy5jYW52YXMuY2FudmFzVmlld0NlbnRlci55ICsgdHJhbnNsYXRpb24ueSAqIHNjYWxlRnJhYztcbiAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gc2NhbGU7XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgeDogdHgsXG4gICAgICAgIHk6IHR5XG4gICAgICB9O1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInpvb21cIiwge1xuICAgICAgICBkaXJlY3Rpb246IFwiK1wiLFxuICAgICAgICBzY2FsZTogdGhpcy5ib2R5LnZpZXcuc2NhbGUsXG4gICAgICAgIHBvaW50ZXI6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfem9vbU91dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfem9vbU91dCgpIHtcbiAgICAgIHZhciBzY2FsZU9sZCA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGUgLyAoMSArIHRoaXMub3B0aW9ucy5rZXlib2FyZC5zcGVlZC56b29tKTtcbiAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uO1xuICAgICAgdmFyIHNjYWxlRnJhYyA9IHNjYWxlIC8gc2NhbGVPbGQ7XG4gICAgICB2YXIgdHggPSAoMSAtIHNjYWxlRnJhYykgKiB0aGlzLmNhbnZhcy5jYW52YXNWaWV3Q2VudGVyLnggKyB0cmFuc2xhdGlvbi54ICogc2NhbGVGcmFjO1xuICAgICAgdmFyIHR5ID0gKDEgLSBzY2FsZUZyYWMpICogdGhpcy5jYW52YXMuY2FudmFzVmlld0NlbnRlci55ICsgdHJhbnNsYXRpb24ueSAqIHNjYWxlRnJhYztcbiAgICAgIHRoaXMuYm9keS52aWV3LnNjYWxlID0gc2NhbGU7XG4gICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgeDogdHgsXG4gICAgICAgIHk6IHR5XG4gICAgICB9O1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInpvb21cIiwge1xuICAgICAgICBkaXJlY3Rpb246IFwiLVwiLFxuICAgICAgICBzY2FsZTogdGhpcy5ib2R5LnZpZXcuc2NhbGUsXG4gICAgICAgIHBvaW50ZXI6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGJpbmQgYWxsIGtleXMgdXNpbmcga2V5Y2hhcm0uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY29uZmlndXJlS2V5Ym9hcmRCaW5kaW5nc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25maWd1cmVLZXlib2FyZEJpbmRpbmdzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5rZXljaGFybSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMua2V5Y2hhcm0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZXlib2FyZC5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2V5Ym9hcmQuYmluZFRvV2luZG93ID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5rZXljaGFybSA9IGtleWNoYXJtKHtcbiAgICAgICAgICAgIGNvbnRhaW5lcjogd2luZG93LFxuICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmtleWNoYXJtID0ga2V5Y2hhcm0oe1xuICAgICAgICAgICAgY29udGFpbmVyOiB0aGlzLmNhbnZhcy5mcmFtZSxcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXljaGFybS5yZXNldCgpO1xuICAgICAgICBpZiAodGhpcy5hY3RpdmF0ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQ0LCBfY29udGV4dDUsIF9jb250ZXh0NiwgX2NvbnRleHQ3LCBfY29udGV4dDgsIF9jb250ZXh0OSwgX2NvbnRleHQxMCwgX2NvbnRleHQxMSwgX2NvbnRleHQxMiwgX2NvbnRleHQxMywgX2NvbnRleHQxNCwgX2NvbnRleHQxNSwgX2NvbnRleHQxNiwgX2NvbnRleHQxNywgX2NvbnRleHQxOCwgX2NvbnRleHQxOSwgX2NvbnRleHQyMCwgX2NvbnRleHQyMSwgX2NvbnRleHQyMiwgX2NvbnRleHQyMywgX2NvbnRleHQyNCwgX2NvbnRleHQyNSwgX2NvbnRleHQyNiwgX2NvbnRleHQyNztcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDQgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0NCwgXCJ1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX21vdmVVcFwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQ1ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDUsIFwiZG93blwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMuYmluZFRvUmVkcmF3KFwiX21vdmVEb3duXCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDYgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0NiwgXCJsZWZ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfbW92ZUxlZnRcIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0NyA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQ3LCBcInJpZ2h0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfbW92ZVJpZ2h0XCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDggPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0OCwgXCI9XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDkgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0OSwgXCJudW0rXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDEwID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDEwLCBcIm51bS1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDExID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDExLCBcIi1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDEyID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDEyLCBcIltcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDEzID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDEzLCBcIl1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLmJpbmRUb1JlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgfSwgXCJrZXlkb3duXCIpO1xuICAgICAgICAgIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MTQgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MTQsIFwicGFnZXVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5ZG93blwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDE1ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDE1LCBcInBhZ2Vkb3duXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5iaW5kVG9SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleWRvd25cIik7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxNiA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQxNiwgXCJ1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl9tb3ZlVXBcIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDE3ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDE3LCBcImRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfbW92ZURvd25cIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDE4ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDE4LCBcImxlZnRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfbW92ZUxlZnRcIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDE5ID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDE5LCBcInJpZ2h0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX21vdmVSaWdodFwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MjAgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjAsIFwiPVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tSW5cIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDIxID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDIxLCBcIm51bStcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbUluXCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQyMiA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQyMiwgXCJudW0tXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21PdXRcIik7XG4gICAgICAgICAgfSwgXCJrZXl1cFwiKTtcbiAgICAgICAgICBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDIzID0gdGhpcy5rZXljaGFybSkuY2FsbChfY29udGV4dDIzLCBcIi1cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MjQgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjQsIFwiW1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczMudW5iaW5kRnJvbVJlZHJhdyhcIl96b29tT3V0XCIpO1xuICAgICAgICAgIH0sIFwia2V5dXBcIik7XG4gICAgICAgICAgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQyNSA9IHRoaXMua2V5Y2hhcm0pLmNhbGwoX2NvbnRleHQyNSwgXCJdXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MjYgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjYsIFwicGFnZXVwXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy51bmJpbmRGcm9tUmVkcmF3KFwiX3pvb21JblwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICAgIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MjcgPSB0aGlzLmtleWNoYXJtKS5jYWxsKF9jb250ZXh0MjcsIFwicGFnZWRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMzLnVuYmluZEZyb21SZWRyYXcoXCJfem9vbU91dFwiKTtcbiAgICAgICAgICB9LCBcImtleXVwXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBOYXZpZ2F0aW9uSGFuZGxlcjtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgX1N5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBfZ2V0SXRlcmF0b3JNZXRob2QobykgfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKF9BcnJheSRpc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ0KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ0KG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQxNTsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDQobywgbWluTGVuKTsgdmFyIG4gPSBfc2xpY2VJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MTUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQxNSwgOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gX0FycmF5JGZyb20kMShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ0KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDQoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cblxuLyoqXG4gKiBIYW5kbGVyIGZvciBpbnRlcmFjdGlvbnNcbiAqL1xudmFyIEludGVyYWN0aW9uSGFuZGxlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gICAqIEBwYXJhbSB7U2VsZWN0aW9uSGFuZGxlcn0gc2VsZWN0aW9uSGFuZGxlclxuICAgKi9cbiAgZnVuY3Rpb24gSW50ZXJhY3Rpb25IYW5kbGVyKGJvZHksIGNhbnZhcywgc2VsZWN0aW9uSGFuZGxlcikge1xuICAgIHZhciBfY29udGV4dCwgX2NvbnRleHQyLCBfY29udGV4dDMsIF9jb250ZXh0NCwgX2NvbnRleHQ1LCBfY29udGV4dDYsIF9jb250ZXh0NywgX2NvbnRleHQ4LCBfY29udGV4dDksIF9jb250ZXh0MTAsIF9jb250ZXh0MTEsIF9jb250ZXh0MTIsIF9jb250ZXh0MTM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEludGVyYWN0aW9uSGFuZGxlcik7XG4gICAgdGhpcy5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIgPSBzZWxlY3Rpb25IYW5kbGVyO1xuICAgIHRoaXMubmF2aWdhdGlvbkhhbmRsZXIgPSBuZXcgTmF2aWdhdGlvbkhhbmRsZXIoYm9keSwgY2FudmFzKTtcblxuICAgIC8vIGJpbmQgdGhlIGV2ZW50cyBmcm9tIGhhbW1lciB0byBmdW5jdGlvbnMgaW4gdGhpcyBvYmplY3RcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25UYXAgPSBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dCA9IHRoaXMub25UYXApLmNhbGwoX2NvbnRleHQsIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vblRvdWNoID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQyID0gdGhpcy5vblRvdWNoKS5jYWxsKF9jb250ZXh0MiwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uRG91YmxlVGFwID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQzID0gdGhpcy5vbkRvdWJsZVRhcCkuY2FsbChfY29udGV4dDMsIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkhvbGQgPSBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDQgPSB0aGlzLm9uSG9sZCkuY2FsbChfY29udGV4dDQsIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbkRyYWdTdGFydCA9IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0NSA9IHRoaXMub25EcmFnU3RhcnQpLmNhbGwoX2NvbnRleHQ1LCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQ2ID0gdGhpcy5vbkRyYWcpLmNhbGwoX2NvbnRleHQ2LCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25EcmFnRW5kID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQ3ID0gdGhpcy5vbkRyYWdFbmQpLmNhbGwoX2NvbnRleHQ3LCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25Nb3VzZVdoZWVsID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQ4ID0gdGhpcy5vbk1vdXNlV2hlZWwpLmNhbGwoX2NvbnRleHQ4LCB0aGlzKTtcbiAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnMub25QaW5jaCA9IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0OSA9IHRoaXMub25QaW5jaCkuY2FsbChfY29udGV4dDksIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vbk1vdXNlTW92ZSA9IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MTAgPSB0aGlzLm9uTW91c2VNb3ZlKS5jYWxsKF9jb250ZXh0MTAsIHRoaXMpO1xuICAgIHRoaXMuYm9keS5ldmVudExpc3RlbmVycy5vblJlbGVhc2UgPSBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDExID0gdGhpcy5vblJlbGVhc2UpLmNhbGwoX2NvbnRleHQxMSwgdGhpcyk7XG4gICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzLm9uQ29udGV4dCA9IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MTIgPSB0aGlzLm9uQ29udGV4dCkuY2FsbChfY29udGV4dDEyLCB0aGlzKTtcbiAgICB0aGlzLnRvdWNoVGltZSA9IDA7XG4gICAgdGhpcy5kcmFnID0ge307XG4gICAgdGhpcy5waW5jaCA9IHt9O1xuICAgIHRoaXMucG9wdXAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3B1cE9iaiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvcHVwVGltZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyID0gX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxMyA9IHRoaXMuZ2V0UG9pbnRlcikuY2FsbChfY29udGV4dDEzLCB0aGlzKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgZHJhZ05vZGVzOiB0cnVlLFxuICAgICAgZHJhZ1ZpZXc6IHRydWUsXG4gICAgICBob3ZlcjogZmFsc2UsXG4gICAgICBrZXlib2FyZDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgc3BlZWQ6IHtcbiAgICAgICAgICB4OiAxMCxcbiAgICAgICAgICB5OiAxMCxcbiAgICAgICAgICB6b29tOiAwLjAyXG4gICAgICAgIH0sXG4gICAgICAgIGJpbmRUb1dpbmRvdzogdHJ1ZSxcbiAgICAgICAgYXV0b0ZvY3VzOiB0cnVlXG4gICAgICB9LFxuICAgICAgbmF2aWdhdGlvbkJ1dHRvbnM6IGZhbHNlLFxuICAgICAgdG9vbHRpcERlbGF5OiAzMDAsXG4gICAgICB6b29tVmlldzogdHJ1ZSxcbiAgICAgIHpvb21TcGVlZDogMVxuICAgIH07XG4gICAgX09iamVjdCRhc3NpZ24odGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB0aGlzLmJpbmRFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIGV2ZW50IGxpc3RlbmVyc1xuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKEludGVyYWN0aW9uSGFuZGxlciwgW3tcbiAgICBrZXk6IFwiYmluZEV2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMucG9wdXBUaW1lcik7XG4gICAgICAgIGRlbGV0ZSBfdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGV4dGVuZCBhbGwgYnV0IHRoZSB2YWx1ZXMgaW4gZmllbGRzXG4gICAgICAgIHZhciBmaWVsZHMgPSBbXCJoaWRlRWRnZXNPbkRyYWdcIiwgXCJoaWRlRWRnZXNPblpvb21cIiwgXCJoaWRlTm9kZXNPbkRyYWdcIiwgXCJrZXlib2FyZFwiLCBcIm11bHRpc2VsZWN0XCIsIFwic2VsZWN0YWJsZVwiLCBcInNlbGVjdENvbm5lY3RlZEVkZ2VzXCJdO1xuICAgICAgICBzZWxlY3RpdmVOb3REZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBtZXJnZSB0aGUga2V5Ym9hcmQgb3B0aW9ucyBpbi5cbiAgICAgICAgbWVyZ2VPcHRpb25zKHRoaXMub3B0aW9ucywgb3B0aW9ucywgXCJrZXlib2FyZFwiKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudG9vbHRpcCkge1xuICAgICAgICAgIF9PYmplY3QkYXNzaWduKHRoaXMub3B0aW9ucy50b29sdGlwLCBvcHRpb25zLnRvb2x0aXApO1xuICAgICAgICAgIGlmIChvcHRpb25zLnRvb2x0aXAuY29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy50b29sdGlwLmNvbG9yID0gcGFyc2VDb2xvcihvcHRpb25zLnRvb2x0aXAuY29sb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5uYXZpZ2F0aW9uSGFuZGxlci5zZXRPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwb2ludGVyIGxvY2F0aW9uIGZyb20gYSB0b3VjaCBsb2NhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSB0b3VjaFxuICAgICAqIEByZXR1cm5zIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvaW50ZXIodG91Y2gpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRvdWNoLnggLSBnZXRBYnNvbHV0ZUxlZnQodGhpcy5jYW52YXMuZnJhbWUuY2FudmFzKSxcbiAgICAgICAgeTogdG91Y2gueSAtIGdldEFic29sdXRlVG9wKHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT24gc3RhcnQgb2YgYSB0b3VjaCBnZXN0dXJlLCBzdG9yZSB0aGUgcG9pbnRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50ICAgVGhlIGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvblRvdWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uVG91Y2goZXZlbnQpIHtcbiAgICAgIGlmIChuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMudG91Y2hUaW1lID4gNTApIHtcbiAgICAgICAgdGhpcy5kcmFnLnBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgICAgdGhpcy5kcmFnLnBpbmNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5waW5jaC5zY2FsZSA9IHRoaXMuYm9keS52aWV3LnNjYWxlO1xuICAgICAgICAvLyB0byBhdm9pZCBkb3VibGUgZmlyZWluZyBvZiB0aGlzIGV2ZW50IGJlY2F1c2Ugd2UgaGF2ZSB0d28gaGFtbWVyIGluc3RhbmNlcy4gKG9uIGNhbnZhcyBhbmQgb24gZnJhbWUpXG4gICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIHRhcC9jbGljayBldmVudDogc2VsZWN0L3Vuc2VsZWN0IGEgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm9uVGFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uVGFwKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdmFyIG11bHRpc2VsZWN0ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLm9wdGlvbnMubXVsdGlzZWxlY3QgJiYgKGV2ZW50LmNoYW5nZWRQb2ludGVyc1swXS5jdHJsS2V5IHx8IGV2ZW50LmNoYW5nZWRQb2ludGVyc1swXS5tZXRhS2V5KTtcbiAgICAgIHRoaXMuY2hlY2tTZWxlY3Rpb25DaGFuZ2VzKHBvaW50ZXIsIG11bHRpc2VsZWN0KTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5jb21taXRBbmRFbWl0KHBvaW50ZXIsIGV2ZW50KTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJjbGlja1wiLCBldmVudCwgcG9pbnRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIGRvdWJsZXRhcCBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm9uRG91YmxlVGFwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRG91YmxlVGFwKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRvdWJsZUNsaWNrXCIsIGV2ZW50LCBwb2ludGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbG9uZyB0YXAgZXZlbnQ6IG11bHRpIHNlbGVjdCBub2Rlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm9uSG9sZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkhvbGQoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB2YXIgbXVsdGlzZWxlY3QgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIub3B0aW9ucy5tdWx0aXNlbGVjdDtcbiAgICAgIHRoaXMuY2hlY2tTZWxlY3Rpb25DaGFuZ2VzKHBvaW50ZXIsIG11bHRpc2VsZWN0KTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5jb21taXRBbmRFbWl0KHBvaW50ZXIsIGV2ZW50KTtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJjbGlja1wiLCBldmVudCwgcG9pbnRlcik7XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiaG9sZFwiLCBldmVudCwgcG9pbnRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIHRoZSByZWxlYXNlIG9mIHRoZSBzY3JlZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvblJlbGVhc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25SZWxlYXNlKGV2ZW50KSB7XG4gICAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLnRvdWNoVGltZSA+IDEwKSB7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJyZWxlYXNlXCIsIGV2ZW50LCBwb2ludGVyKTtcbiAgICAgICAgLy8gdG8gYXZvaWQgZG91YmxlIGZpcmVpbmcgb2YgdGhpcyBldmVudCBiZWNhdXNlIHdlIGhhdmUgdHdvIGhhbW1lciBpbnN0YW5jZXMuIChvbiBjYW52YXMgYW5kIG9uIGZyYW1lKVxuICAgICAgICB0aGlzLnRvdWNoVGltZSA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvbkNvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Db250ZXh0KGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcih7XG4gICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgIHk6IGV2ZW50LmNsaWVudFlcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcIm9uY29udGV4dFwiLCBldmVudCwgcG9pbnRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGFuZCBkZXNlbGVjdCBub2RlcyBkZXBlbmRpbmcgY3VycmVudCBzZWxlY3Rpb24gY2hhbmdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYWRkPWZhbHNlXVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNoZWNrU2VsZWN0aW9uQ2hhbmdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1NlbGVjdGlvbkNoYW5nZXMocG9pbnRlcikge1xuICAgICAgdmFyIGFkZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICBpZiAoYWRkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RBZGRpdGlvbmFsT25Qb2ludChwb2ludGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RPblBvaW50KHBvaW50ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgbm9kZSBhbmQgZWRnZSBpZCdzIGZyb20gdGhlIGZpcnN0IHNldCB0aGF0IGFyZSBwcmVzZW50IGluIHRoZSBzZWNvbmQgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7bm9kZXM6IEFycmF5LjxOb2RlPiwgZWRnZXM6IEFycmF5Ljx2aXMuRWRnZT59fSBmaXJzdFNldFxuICAgICAqIEBwYXJhbSB7e25vZGVzOiBBcnJheS48Tm9kZT4sIGVkZ2VzOiBBcnJheS48dmlzLkVkZ2U+fX0gc2Vjb25kU2V0XG4gICAgICogQHJldHVybnMge3tub2RlczogQXJyYXkuPE5vZGU+LCBlZGdlczogQXJyYXkuPHZpcy5FZGdlPn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZGV0ZXJtaW5lRGlmZmVyZW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0ZXJtaW5lRGlmZmVyZW5jZShmaXJzdFNldCwgc2Vjb25kU2V0KSB7XG4gICAgICB2YXIgYXJyYXlEaWZmID0gZnVuY3Rpb24gYXJyYXlEaWZmKGZpcnN0QXJyLCBzZWNvbmRBcnIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0QXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZmlyc3RBcnJbaV07XG4gICAgICAgICAgaWYgKF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eShzZWNvbmRBcnIpLmNhbGwoc2Vjb25kQXJyLCB2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZXM6IGFycmF5RGlmZihmaXJzdFNldC5ub2Rlcywgc2Vjb25kU2V0Lm5vZGVzKSxcbiAgICAgICAgZWRnZXM6IGFycmF5RGlmZihmaXJzdFNldC5lZGdlcywgc2Vjb25kU2V0LmVkZ2VzKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSBvbkRyYWdTdGFydC5cbiAgICAgKiBJdCBpcyBzZXBhcmF0ZWQgb3V0IGJlY2F1c2Ugd2UgY2FuIHRoZW4gb3ZlcmxvYWQgaXQgZm9yIHRoZSBkYXRhbWFuaXB1bGF0aW9uIHN5c3RlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvbkRyYWdTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWdTdGFydChldmVudCkge1xuICAgICAgLy8gaWYgYWxyZWFkeSBkcmFnZ2luZywgZG8gbm90IHN0YXJ0XG4gICAgICAvLyB0aGlzIGNhbiBoYXBwZW4gb24gdG91Y2ggc2NyZWVucyB3aXRoIG11bHRpcGxlIGZpbmdlcnNcbiAgICAgIGlmICh0aGlzLmRyYWcuZHJhZ2dpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvL2luIGNhc2UgdGhlIHRvdWNoIGV2ZW50IHdhcyB0cmlnZ2VyZWQgb24gYW4gZXh0ZXJuYWwgZGl2LCBkbyB0aGUgaW5pdGlhbCB0b3VjaCBub3cuXG4gICAgICBpZiAodGhpcy5kcmFnLnBvaW50ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm9uVG91Y2goZXZlbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBub3RlOiBkcmFnLnBvaW50ZXIgaXMgc2V0IGluIG9uVG91Y2ggdG8gZ2V0IHRoZSBpbml0aWFsIHRvdWNoIGxvY2F0aW9uXG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQodGhpcy5kcmFnLnBvaW50ZXIpO1xuICAgICAgdGhpcy5kcmFnLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuZHJhZy5zZWxlY3Rpb24gPSBbXTtcbiAgICAgIHRoaXMuZHJhZy50cmFuc2xhdGlvbiA9IF9PYmplY3QkYXNzaWduKHt9LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbik7IC8vIGNvcHkgdGhlIG9iamVjdFxuICAgICAgdGhpcy5kcmFnLm5vZGVJZCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChldmVudC5zcmNFdmVudC5zaGlmdEtleSkge1xuICAgICAgICB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnNob3cgPSB0cnVlO1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLnN0YXJ0ID0ge1xuICAgICAgICAgIHg6IHRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueCksXG4gICAgICAgICAgeTogdGhpcy5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci55KVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLmVuZCA9IHtcbiAgICAgICAgICB4OiB0aGlzLmNhbnZhcy5fWGNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLngpLFxuICAgICAgICAgIHk6IHRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMub3B0aW9ucy5kcmFnTm9kZXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5kcmFnLm5vZGVJZCA9IG5vZGUuaWQ7XG4gICAgICAgIC8vIHNlbGVjdCB0aGUgY2xpY2tlZCBub2RlIGlmIG5vdCB5ZXQgc2VsZWN0ZWRcbiAgICAgICAgaWYgKG5vZGUuaXNTZWxlY3RlZCgpID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZXRTZWxlY3Rpb24oe1xuICAgICAgICAgICAgbm9kZXM6IFtub2RlLmlkXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWZ0ZXIgc2VsZWN0IHRvIGNvbnRhaW4gdGhlIG5vZGVcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdTdGFydFwiLCBldmVudCwgdGhpcy5kcmFnLnBvaW50ZXIpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhbiBhcnJheSB3aXRoIHRoZSBzZWxlY3RlZCBub2RlcyBhbmQgdGhlaXIgb3JpZ2luYWwgbG9jYXRpb24gYW5kIHN0YXR1c1xuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNCh0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWROb2RlcygpKSxcbiAgICAgICAgICBfc3RlcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIF9ub2RlID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgcyA9IHtcbiAgICAgICAgICAgICAgaWQ6IF9ub2RlLmlkLFxuICAgICAgICAgICAgICBub2RlOiBfbm9kZSxcbiAgICAgICAgICAgICAgLy8gc3RvcmUgb3JpZ2luYWwgeCwgeSwgeEZpeGVkIGFuZCB5Rml4ZWQsIG1ha2UgdGhlIG5vZGUgdGVtcG9yYXJpbHkgRml4ZWRcbiAgICAgICAgICAgICAgeDogX25vZGUueCxcbiAgICAgICAgICAgICAgeTogX25vZGUueSxcbiAgICAgICAgICAgICAgeEZpeGVkOiBfbm9kZS5vcHRpb25zLmZpeGVkLngsXG4gICAgICAgICAgICAgIHlGaXhlZDogX25vZGUub3B0aW9ucy5maXhlZC55XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX25vZGUub3B0aW9ucy5maXhlZC54ID0gdHJ1ZTtcbiAgICAgICAgICAgIF9ub2RlLm9wdGlvbnMuZml4ZWQueSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRyYWcuc2VsZWN0aW9uLnB1c2gocyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZhbGxiYWNrIGlmIG5vIG5vZGUgaXMgc2VsZWN0ZWQgYW5kIHRodXMgdGhlIHZpZXcgaXMgZHJhZ2dlZC5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdTdGFydFwiLCBldmVudCwgdGhpcy5kcmFnLnBvaW50ZXIsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaGFuZGxlIGRyYWcgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvbkRyYWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EcmFnKGV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGlmICh0aGlzLmRyYWcucGluY2hlZCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSB0aGUgZm9jdXMgb24gbm9kZSBpZiBpdCBpcyBmb2N1c3NlZCBvbiBieSB0aGUgZm9jdXNPbk5vZGVcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJ1bmxvY2tOb2RlXCIpO1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmRyYWcuc2VsZWN0aW9uO1xuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24ubGVuZ3RoICYmIHRoaXMub3B0aW9ucy5kcmFnTm9kZXMgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdnaW5nXCIsIGV2ZW50LCBwb2ludGVyKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZGVsdGEncyBhbmQgbmV3IGxvY2F0aW9uXG4gICAgICAgIHZhciBkZWx0YVggPSBwb2ludGVyLnggLSB0aGlzLmRyYWcucG9pbnRlci54O1xuICAgICAgICB2YXIgZGVsdGFZID0gcG9pbnRlci55IC0gdGhpcy5kcmFnLnBvaW50ZXIueTtcblxuICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24gb2YgYWxsIHNlbGVjdGVkIG5vZGVzXG4gICAgICAgIF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShzZWxlY3Rpb24pLmNhbGwoc2VsZWN0aW9uLCBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBzZWxlY3Rpb24ubm9kZTtcbiAgICAgICAgICAvLyBvbmx5IG1vdmUgdGhlIG5vZGUgaWYgaXQgd2FzIG5vdCBmaXhlZCBpbml0aWFsbHlcbiAgICAgICAgICBpZiAoc2VsZWN0aW9uLnhGaXhlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5vZGUueCA9IF90aGlzMi5jYW52YXMuX1hjb252ZXJ0RE9NdG9DYW52YXMoX3RoaXMyLmNhbnZhcy5fWGNvbnZlcnRDYW52YXNUb0RPTShzZWxlY3Rpb24ueCkgKyBkZWx0YVgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBvbmx5IG1vdmUgdGhlIG5vZGUgaWYgaXQgd2FzIG5vdCBmaXhlZCBpbml0aWFsbHlcbiAgICAgICAgICBpZiAoc2VsZWN0aW9uLnlGaXhlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG5vZGUueSA9IF90aGlzMi5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMoX3RoaXMyLmNhbnZhcy5fWWNvbnZlcnRDYW52YXNUb0RPTShzZWxlY3Rpb24ueSkgKyBkZWx0YVkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc3RhcnQgdGhlIHNpbXVsYXRpb24gb2YgdGhlIHBoeXNpY3NcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInN0YXJ0U2ltdWxhdGlvblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBzZWxlY3Rpb24gYm94XG4gICAgICAgIGlmIChldmVudC5zcmNFdmVudC5zaGlmdEtleSkge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnZ2luZ1wiLCBldmVudCwgcG9pbnRlciwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgICAgIC8vIGlmIHRoZSBkcmFnIHdhcyBub3Qgc3RhcnRlZCBwcm9wZXJseSBiZWNhdXNlIHRoZSBjbGljayBzdGFydGVkIG91dHNpZGUgdGhlIG5ldHdvcmsgZGl2LCBzdGFydCBpdCBub3cuXG4gICAgICAgICAgaWYgKHRoaXMuZHJhZy5wb2ludGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25EcmFnU3RhcnQoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnBvc2l0aW9uLmVuZCA9IHtcbiAgICAgICAgICAgIHg6IHRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueCksXG4gICAgICAgICAgICB5OiB0aGlzLmNhbnZhcy5fWWNvbnZlcnRET010b0NhbnZhcyhwb2ludGVyLnkpXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3ZlIHRoZSBuZXR3b3JrXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHJhZ1ZpZXcgPT09IHRydWUgJiYgIWV2ZW50LnNyY0V2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdnaW5nXCIsIGV2ZW50LCBwb2ludGVyLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICAgICAgLy8gaWYgdGhlIGRyYWcgd2FzIG5vdCBzdGFydGVkIHByb3Blcmx5IGJlY2F1c2UgdGhlIGNsaWNrIHN0YXJ0ZWQgb3V0c2lkZSB0aGUgbmV0d29yayBkaXYsIHN0YXJ0IGl0IG5vdy5cbiAgICAgICAgICBpZiAodGhpcy5kcmFnLnBvaW50ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5vbkRyYWdTdGFydChldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkaWZmWCA9IHBvaW50ZXIueCAtIHRoaXMuZHJhZy5wb2ludGVyLng7XG4gICAgICAgICAgdmFyIGRpZmZZID0gcG9pbnRlci55IC0gdGhpcy5kcmFnLnBvaW50ZXIueTtcbiAgICAgICAgICB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IHRoaXMuZHJhZy50cmFuc2xhdGlvbi54ICsgZGlmZlgsXG4gICAgICAgICAgICB5OiB0aGlzLmRyYWcudHJhbnNsYXRpb24ueSArIGRpZmZZXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoYW5kbGUgZHJhZyBzdGFydCBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm9uRHJhZ0VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkRyYWdFbmQoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgdGhpcy5kcmFnLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5ib2R5LnNlbGVjdGlvbkJveC5zaG93KSB7XG4gICAgICAgIHZhciBfY29udGV4dDE0O1xuICAgICAgICB0aGlzLmJvZHkuc2VsZWN0aW9uQm94LnNob3cgPSBmYWxzZTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkJveFBvc2l0aW9uID0gdGhpcy5ib2R5LnNlbGVjdGlvbkJveC5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkJveFBvc2l0aW9uTWluTWF4ID0ge1xuICAgICAgICAgIG1pblg6IE1hdGgubWluKHNlbGVjdGlvbkJveFBvc2l0aW9uLnN0YXJ0LngsIHNlbGVjdGlvbkJveFBvc2l0aW9uLmVuZC54KSxcbiAgICAgICAgICBtaW5ZOiBNYXRoLm1pbihzZWxlY3Rpb25Cb3hQb3NpdGlvbi5zdGFydC55LCBzZWxlY3Rpb25Cb3hQb3NpdGlvbi5lbmQueSksXG4gICAgICAgICAgbWF4WDogTWF0aC5tYXgoc2VsZWN0aW9uQm94UG9zaXRpb24uc3RhcnQueCwgc2VsZWN0aW9uQm94UG9zaXRpb24uZW5kLngpLFxuICAgICAgICAgIG1heFk6IE1hdGgubWF4KHNlbGVjdGlvbkJveFBvc2l0aW9uLnN0YXJ0LnksIHNlbGVjdGlvbkJveFBvc2l0aW9uLmVuZC55KVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdG9CZVNlbGVjdGVkTm9kZXMgPSBfZmlsdGVySW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDE0ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzKS5jYWxsKF9jb250ZXh0MTQsIGZ1bmN0aW9uIChub2RlSWQpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzMy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgcmV0dXJuIG5vZGUueCA+PSBzZWxlY3Rpb25Cb3hQb3NpdGlvbk1pbk1heC5taW5YICYmIG5vZGUueCA8PSBzZWxlY3Rpb25Cb3hQb3NpdGlvbk1pbk1heC5tYXhYICYmIG5vZGUueSA+PSBzZWxlY3Rpb25Cb3hQb3NpdGlvbk1pbk1heC5taW5ZICYmIG5vZGUueSA8PSBzZWxlY3Rpb25Cb3hQb3NpdGlvbk1pbk1heC5tYXhZO1xuICAgICAgICB9KTtcbiAgICAgICAgX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KHRvQmVTZWxlY3RlZE5vZGVzKS5jYWxsKHRvQmVTZWxlY3RlZE5vZGVzLCBmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdE9iamVjdChfdGhpczMuYm9keS5ub2Rlc1tub2RlSWRdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5jb21taXRBbmRFbWl0KHBvaW50ZXIsIGV2ZW50KTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdFbmRcIiwgZXZlbnQsIHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5kcmFnLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiBzZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KHNlbGVjdGlvbikuY2FsbChzZWxlY3Rpb24sIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAvLyByZXN0b3JlIG9yaWdpbmFsIHhGaXhlZCBhbmQgeUZpeGVkXG4gICAgICAgICAgICBzLm5vZGUub3B0aW9ucy5maXhlZC54ID0gcy54Rml4ZWQ7XG4gICAgICAgICAgICBzLm5vZGUub3B0aW9ucy5maXhlZC55ID0gcy55Rml4ZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImRyYWdFbmRcIiwgZXZlbnQsIHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnRW5kXCIsIGV2ZW50LCB0aGlzLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgcGluY2ggZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwib25QaW5jaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblBpbmNoKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdGhpcy5kcmFnLnBpbmNoZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMucGluY2hbXCJzY2FsZVwiXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucGluY2guc2NhbGUgPSAxO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBlbmFibGVkIG1vdmluZyB3aGlsZSBwaW5jaGluZz9cbiAgICAgIHZhciBzY2FsZSA9IHRoaXMucGluY2guc2NhbGUgKiBldmVudC5zY2FsZTtcbiAgICAgIHRoaXMuem9vbShzY2FsZSwgcG9pbnRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWm9vbSB0aGUgbmV0d29yayBpbiBvciBvdXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSBhIG51bWJlciBhcm91bmQgMSwgYW5kIGJldHdlZW4gMC4wMSBhbmQgMTBcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgICAgUG9zaXRpb24gb24gc2NyZWVuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ6b29tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHpvb20oc2NhbGUsIHBvaW50ZXIpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuem9vbVZpZXcgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIHNjYWxlT2xkID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgIGlmIChzY2FsZSA8IDAuMDAwMDEpIHtcbiAgICAgICAgICBzY2FsZSA9IDAuMDAwMDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjYWxlID4gMTApIHtcbiAgICAgICAgICBzY2FsZSA9IDEwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcmVTY2FsZURyYWdQb2ludGVyID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5kcmFnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAodGhpcy5kcmFnLmRyYWdnaW5nID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwcmVTY2FsZURyYWdQb2ludGVyID0gdGhpcy5jYW52YXMuRE9NdG9DYW52YXModGhpcy5kcmFnLnBvaW50ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyArIHRoaXMuY2FudmFzLmZyYW1lLmNhbnZhcy5jbGllbnRIZWlnaHQgLyAyXG4gICAgICAgIHZhciB0cmFuc2xhdGlvbiA9IHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uO1xuICAgICAgICB2YXIgc2NhbGVGcmFjID0gc2NhbGUgLyBzY2FsZU9sZDtcbiAgICAgICAgdmFyIHR4ID0gKDEgLSBzY2FsZUZyYWMpICogcG9pbnRlci54ICsgdHJhbnNsYXRpb24ueCAqIHNjYWxlRnJhYztcbiAgICAgICAgdmFyIHR5ID0gKDEgLSBzY2FsZUZyYWMpICogcG9pbnRlci55ICsgdHJhbnNsYXRpb24ueSAqIHNjYWxlRnJhYztcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgdGhpcy5ib2R5LnZpZXcudHJhbnNsYXRpb24gPSB7XG4gICAgICAgICAgeDogdHgsXG4gICAgICAgICAgeTogdHlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHByZVNjYWxlRHJhZ1BvaW50ZXIgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHBvc3RTY2FsZURyYWdQb2ludGVyID0gdGhpcy5jYW52YXMuY2FudmFzVG9ET00ocHJlU2NhbGVEcmFnUG9pbnRlcik7XG4gICAgICAgICAgdGhpcy5kcmFnLnBvaW50ZXIueCA9IHBvc3RTY2FsZURyYWdQb2ludGVyLng7XG4gICAgICAgICAgdGhpcy5kcmFnLnBvaW50ZXIueSA9IHBvc3RTY2FsZURyYWdQb2ludGVyLnk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgICBpZiAoc2NhbGVPbGQgPCBzY2FsZSkge1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJ6b29tXCIsIHtcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCIrXCIsXG4gICAgICAgICAgICBzY2FsZTogdGhpcy5ib2R5LnZpZXcuc2NhbGUsXG4gICAgICAgICAgICBwb2ludGVyOiBwb2ludGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInpvb21cIiwge1xuICAgICAgICAgICAgZGlyZWN0aW9uOiBcIi1cIixcbiAgICAgICAgICAgIHNjYWxlOiB0aGlzLmJvZHkudmlldy5zY2FsZSxcbiAgICAgICAgICAgIHBvaW50ZXI6IHBvaW50ZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2ZW50IGhhbmRsZXIgZm9yIG1vdXNlIHdoZWVsIGV2ZW50LCB1c2VkIHRvIHpvb20gdGhlIHRpbWVsaW5lXG4gICAgICogU2VlIGh0dHA6Ly9hZG9tYXMub3JnL2phdmFzY3JpcHQtbW91c2Utd2hlZWwvXG4gICAgICogICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9FaWdodE1lZGlhL2hhbW1lci5qcy9pc3N1ZXMvMjU2XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9ICBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwib25Nb3VzZVdoZWVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTW91c2VXaGVlbChldmVudCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy56b29tVmlldyA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBJZiBkZWx0YSBpcyBub256ZXJvLCBoYW5kbGUgaXQuXG4gICAgICAgIC8vIEJhc2ljYWxseSwgZGVsdGEgaXMgbm93IHBvc2l0aXZlIGlmIHdoZWVsIHdhcyBzY3JvbGxlZCB1cCxcbiAgICAgICAgLy8gYW5kIG5lZ2F0aXZlLCBpZiB3aGVlbCB3YXMgc2Nyb2xsZWQgZG93bi5cbiAgICAgICAgaWYgKGV2ZW50LmRlbHRhWSAhPT0gMCkge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgbmV3IHNjYWxlXG4gICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5ib2R5LnZpZXcuc2NhbGU7XG4gICAgICAgICAgc2NhbGUgKj0gMSArIChldmVudC5kZWx0YVkgPCAwID8gMSA6IC0xKSAqICh0aGlzLm9wdGlvbnMuem9vbVNwZWVkICogMC4xKTtcblxuICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcG9pbnRlciBsb2NhdGlvblxuICAgICAgICAgIHZhciBwb2ludGVyID0gdGhpcy5nZXRQb2ludGVyKHtcbiAgICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBhcHBseSB0aGUgbmV3IHNjYWxlXG4gICAgICAgICAgdGhpcy56b29tKHNjYWxlLCBwb2ludGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXZlbnQgZGVmYXVsdCBhY3Rpb25zIGNhdXNlZCBieSBtb3VzZSB3aGVlbC5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3VzZSBtb3ZlIGhhbmRsZXIgZm9yIGNoZWNraW5nIHdoZXRoZXIgdGhlIHRpdGxlIG1vdmVzIG92ZXIgYSBub2RlIHdpdGggYSB0aXRsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwib25Nb3VzZU1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmdldFBvaW50ZXIoe1xuICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICB5OiBldmVudC5jbGllbnRZXG4gICAgICB9KTtcbiAgICAgIHZhciBwb3B1cFZpc2libGUgPSBmYWxzZTtcblxuICAgICAgLy8gY2hlY2sgaWYgdGhlIHByZXZpb3VzbHkgc2VsZWN0ZWQgbm9kZSBpcyBzdGlsbCBzZWxlY3RlZFxuICAgICAgaWYgKHRoaXMucG9wdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cC5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5fY2hlY2tIaWRlUG9wdXAocG9pbnRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgcG9wdXAgd2FzIG5vdCBoaWRkZW4gYWJvdmVcbiAgICAgICAgaWYgKHRoaXMucG9wdXAuaGlkZGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHBvcHVwVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5wb3B1cC5zZXRQb3NpdGlvbihwb2ludGVyLnggKyAzLCBwb2ludGVyLnkgLSA1KTtcbiAgICAgICAgICB0aGlzLnBvcHVwLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiB3ZSBiaW5kIHRoZSBrZXlib2FyZCB0byB0aGUgZGl2LCB3ZSBoYXZlIHRvIGhpZ2hsaWdodCBpdCB0byB1c2UgaXQuIFRoaXMgaGlnaGxpZ2h0cyBpdCBvbiBtb3VzZSBvdmVyLlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZXlib2FyZC5hdXRvRm9jdXMgJiYgdGhpcy5vcHRpb25zLmtleWJvYXJkLmJpbmRUb1dpbmRvdyA9PT0gZmFsc2UgJiYgdGhpcy5vcHRpb25zLmtleWJvYXJkLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUuZm9jdXMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gc3RhcnQgYSB0aW1lb3V0IHRoYXQgd2lsbCBjaGVjayBpZiB0aGUgbW91c2UgaXMgcG9zaXRpb25lZCBhYm92ZSBhbiBlbGVtZW50XG4gICAgICBpZiAocG9wdXBWaXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cFRpbWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMucG9wdXBUaW1lcik7IC8vIHN0b3AgYW55IHJ1bm5pbmcgY2FsY3VsYXRpb25UaW1lclxuICAgICAgICAgIHRoaXMucG9wdXBUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZHJhZy5kcmFnZ2luZykge1xuICAgICAgICAgIHRoaXMucG9wdXBUaW1lciA9IF9zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczQuX2NoZWNrU2hvd1BvcHVwKHBvaW50ZXIpO1xuICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy50b29sdGlwRGVsYXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZGluZyBob3ZlciBoaWdobGlnaHRzXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhvdmVyID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5ob3Zlck9iamVjdChldmVudCwgcG9pbnRlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlcmUgaXMgYW4gZWxlbWVudCBvbiB0aGUgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlIG5ldHdvcmtcbiAgICAgKiAoYSBub2RlIG9yIGVkZ2UpLiBJZiBzbywgYW5kIGlmIHRoaXMgZWxlbWVudCBoYXMgYSB0aXRsZSxcbiAgICAgKiBzaG93IGEgcG9wdXAgd2luZG93IHdpdGggaXRzIHRpdGxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDpudW1iZXIsIHk6bnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NoZWNrU2hvd1BvcHVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja1Nob3dQb3B1cChwb2ludGVyKSB7XG4gICAgICB2YXIgeCA9IHRoaXMuY2FudmFzLl9YY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueCk7XG4gICAgICB2YXIgeSA9IHRoaXMuY2FudmFzLl9ZY29udmVydERPTXRvQ2FudmFzKHBvaW50ZXIueSk7XG4gICAgICB2YXIgcG9pbnRlck9iaiA9IHtcbiAgICAgICAgbGVmdDogeCxcbiAgICAgICAgdG9wOiB5LFxuICAgICAgICByaWdodDogeCxcbiAgICAgICAgYm90dG9tOiB5XG4gICAgICB9O1xuICAgICAgdmFyIHByZXZpb3VzUG9wdXBPYmpJZCA9IHRoaXMucG9wdXBPYmogPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRoaXMucG9wdXBPYmouaWQ7XG4gICAgICB2YXIgbm9kZVVuZGVyQ3Vyc29yID0gZmFsc2U7XG4gICAgICB2YXIgcG9wdXBUeXBlID0gXCJub2RlXCI7XG5cbiAgICAgIC8vIGNoZWNrIGlmIGEgbm9kZSBpcyB1bmRlciB0aGUgY3Vyc29yLlxuICAgICAgaWYgKHRoaXMucG9wdXBPYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBzZWFyY2ggdGhlIG5vZGVzIGZvciBvdmVybGFwLCBzZWxlY3QgdGhlIHRvcCBvbmUgaW4gY2FzZSBvZiBtdWx0aXBsZSBub2Rlc1xuICAgICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICAgIHZhciBub2RlcyA9IHRoaXMuYm9keS5ub2RlcztcbiAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgIHZhciBvdmVybGFwcGluZ05vZGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlID0gbm9kZXNbbm9kZUluZGljZXNbaV1dO1xuICAgICAgICAgIGlmIChub2RlLmlzT3ZlcmxhcHBpbmdXaXRoKHBvaW50ZXJPYmopID09PSB0cnVlKSB7XG4gICAgICAgICAgICBub2RlVW5kZXJDdXJzb3IgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG5vZGUuZ2V0VGl0bGUoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG92ZXJsYXBwaW5nTm9kZXMucHVzaChub2RlSW5kaWNlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvdmVybGFwcGluZ05vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgb3ZlcmxhcHBpbmcgbm9kZXMsIHNlbGVjdCB0aGUgbGFzdCBvbmUsIHRoaXMgaXMgdGhlIG9uZSB3aGljaCBpcyBkcmF3biBvbiB0b3Agb2YgdGhlIG90aGVyc1xuICAgICAgICAgIHRoaXMucG9wdXBPYmogPSBub2Rlc1tvdmVybGFwcGluZ05vZGVzW292ZXJsYXBwaW5nTm9kZXMubGVuZ3RoIC0gMV1dO1xuICAgICAgICAgIC8vIGlmIHlvdSBob3ZlciBvdmVyIGEgbm9kZSwgdGhlIHRpdGxlIG9mIHRoZSBlZGdlIGlzIG5vdCBzdXBwb3NlZCB0byBiZSBzaG93bi5cbiAgICAgICAgICBub2RlVW5kZXJDdXJzb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5wb3B1cE9iaiA9PT0gdW5kZWZpbmVkICYmIG5vZGVVbmRlckN1cnNvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gc2VhcmNoIHRoZSBlZGdlcyBmb3Igb3ZlcmxhcFxuICAgICAgICB2YXIgZWRnZUluZGljZXMgPSB0aGlzLmJvZHkuZWRnZUluZGljZXM7XG4gICAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgICAgdmFyIGVkZ2U7XG4gICAgICAgIHZhciBvdmVybGFwcGluZ0VkZ2VzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBlZGdlSW5kaWNlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICBlZGdlID0gZWRnZXNbZWRnZUluZGljZXNbX2ldXTtcbiAgICAgICAgICBpZiAoZWRnZS5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlICYmIGVkZ2UuZ2V0VGl0bGUoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIG92ZXJsYXBwaW5nRWRnZXMucHVzaChlZGdlSW5kaWNlc1tfaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcmxhcHBpbmdFZGdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5wb3B1cE9iaiA9IGVkZ2VzW292ZXJsYXBwaW5nRWRnZXNbb3ZlcmxhcHBpbmdFZGdlcy5sZW5ndGggLSAxXV07XG4gICAgICAgICAgcG9wdXBUeXBlID0gXCJlZGdlXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnBvcHVwT2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gc2hvdyBwb3B1cCBtZXNzYWdlIHdpbmRvd1xuICAgICAgICBpZiAodGhpcy5wb3B1cE9iai5pZCAhPT0gcHJldmlvdXNQb3B1cE9iaklkKSB7XG4gICAgICAgICAgaWYgKHRoaXMucG9wdXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cCA9IG5ldyBQb3B1cCh0aGlzLmNhbnZhcy5mcmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucG9wdXAucG9wdXBUYXJnZXRUeXBlID0gcG9wdXBUeXBlO1xuICAgICAgICAgIHRoaXMucG9wdXAucG9wdXBUYXJnZXRJZCA9IHRoaXMucG9wdXBPYmouaWQ7XG5cbiAgICAgICAgICAvLyBhZGp1c3QgYSBzbWFsbCBvZmZzZXQgc3VjaCB0aGF0IHRoZSBtb3VzZSBjdXJzb3IgaXMgbG9jYXRlZCBpbiB0aGVcbiAgICAgICAgICAvLyBib3R0b20gbGVmdCBsb2NhdGlvbiBvZiB0aGUgcG9wdXAsIGFuZCB5b3UgY2FuIGVhc2lseSBtb3ZlIG92ZXIgdGhlXG4gICAgICAgICAgLy8gcG9wdXAgYXJlYVxuICAgICAgICAgIHRoaXMucG9wdXAuc2V0UG9zaXRpb24ocG9pbnRlci54ICsgMywgcG9pbnRlci55IC0gNSk7XG4gICAgICAgICAgdGhpcy5wb3B1cC5zZXRUZXh0KHRoaXMucG9wdXBPYmouZ2V0VGl0bGUoKSk7XG4gICAgICAgICAgdGhpcy5wb3B1cC5zaG93KCk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInNob3dQb3B1cFwiLCB0aGlzLnBvcHVwT2JqLmlkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMucG9wdXAuaGlkZSgpO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJoaWRlUG9wdXBcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgcG9wdXAgbXVzdCBiZSBoaWRkZW4sIHdoaWNoIGlzIHRoZSBjYXNlIHdoZW4gdGhlIG1vdXNlIGlzIG5vXG4gICAgICogbG9uZ2VyIGhvdmVyaW5nIG9uIHRoZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6bnVtYmVyLCB5Om51bWJlcn19IHBvaW50ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jaGVja0hpZGVQb3B1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2hlY2tIaWRlUG9wdXAocG9pbnRlcikge1xuICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuICAgICAgdmFyIHN0aWxsT25PYmogPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0VHlwZSA9PT0gXCJub2RlXCIpIHtcbiAgICAgICAgaWYgKHRoaXMuYm9keS5ub2Rlc1t0aGlzLnBvcHVwLnBvcHVwVGFyZ2V0SWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdGlsbE9uT2JqID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMucG9wdXAucG9wdXBUYXJnZXRJZF0uaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG5cbiAgICAgICAgICAvLyBpZiB0aGUgbW91c2UgaXMgc3RpbGwgb25lIHRoZSBub2RlLCB3ZSBoYXZlIHRvIGNoZWNrIGlmIGl0IGlzIG5vdCBhbHNvIG9uIG9uZSB0aGF0IGlzIGRyYXduIG9uIHRvcCBvZiBpdC5cbiAgICAgICAgICAvLyB3ZSBpbml0aWFsbHkgb25seSBjaGVjayBzdGlsbE9uT2JqIGJlY2F1c2UgdGhpcyBpcyBtdWNoIGZhc3Rlci5cbiAgICAgICAgICBpZiAoc3RpbGxPbk9iaiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG92ZXJOb2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldE5vZGVBdChwb2ludGVyKTtcbiAgICAgICAgICAgIHN0aWxsT25PYmogPSBvdmVyTm9kZSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvdmVyTm9kZS5pZCA9PT0gdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQocG9pbnRlcikgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkuZWRnZXNbdGhpcy5wb3B1cC5wb3B1cFRhcmdldElkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGlsbE9uT2JqID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMucG9wdXAucG9wdXBUYXJnZXRJZF0uaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RpbGxPbk9iaiA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5wb3B1cE9iaiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wb3B1cC5oaWRlKCk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJoaWRlUG9wdXBcIik7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBJbnRlcmFjdGlvbkhhbmRsZXI7XG59KCk7XG5cbnZhciBjb2xsZWN0aW9uJDEgPSBjb2xsZWN0aW9uJDM7XG52YXIgY29sbGVjdGlvblN0cm9uZyA9IGNvbGxlY3Rpb25TdHJvbmckMjtcblxuLy8gYFNldGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2V0LW9iamVjdHNcbmNvbGxlY3Rpb24kMSgnU2V0JywgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpIHsgcmV0dXJuIGluaXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCBjb2xsZWN0aW9uU3Ryb25nKTtcblxudmFyIHBhdGgkMSA9IHBhdGgkdztcblxudmFyIHNldCQyID0gcGF0aCQxLlNldDtcblxudmFyIHBhcmVudCQ0ID0gc2V0JDI7XG5cblxudmFyIHNldCQxID0gcGFyZW50JDQ7XG5cbnZhciBzZXQgPSBzZXQkMTtcblxudmFyIF9TZXQgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoc2V0KTtcblxudmFyIHVuY3VycnlUaGlzJDIgPSBmdW5jdGlvblVuY3VycnlUaGlzO1xudmFyIGRlZmluZUJ1aWx0SW5zJDEgPSBkZWZpbmVCdWlsdElucyQzO1xudmFyIGdldFdlYWtEYXRhID0gaW50ZXJuYWxNZXRhZGF0YUV4cG9ydHMuZ2V0V2Vha0RhdGE7XG52YXIgYW5JbnN0YW5jZSA9IGFuSW5zdGFuY2UkMztcbnZhciBhbk9iamVjdCA9IGFuT2JqZWN0JGQ7XG52YXIgaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZCQ2O1xudmFyIGlzT2JqZWN0JDEgPSBpc09iamVjdCRqO1xudmFyIGl0ZXJhdGUgPSBpdGVyYXRlJDM7XG52YXIgQXJyYXlJdGVyYXRpb25Nb2R1bGUgPSBhcnJheUl0ZXJhdGlvbjtcbnZhciBoYXNPd24gPSBoYXNPd25Qcm9wZXJ0eV8xO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBpbnRlcm5hbFN0YXRlO1xuXG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGludGVybmFsU3RhdGVHZXR0ZXJGb3IgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcjtcbnZhciBmaW5kID0gQXJyYXlJdGVyYXRpb25Nb2R1bGUuZmluZDtcbnZhciBmaW5kSW5kZXggPSBBcnJheUl0ZXJhdGlvbk1vZHVsZS5maW5kSW5kZXg7XG52YXIgc3BsaWNlID0gdW5jdXJyeVRoaXMkMihbXS5zcGxpY2UpO1xudmFyIGlkID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZnJvemVuIHx8IChzdGF0ZS5mcm96ZW4gPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSgpKTtcbn07XG5cbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVudHJpZXMgPSBbXTtcbn07XG5cbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gZmluZChzdG9yZS5lbnRyaWVzLCBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuXG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5lbnRyaWVzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXgodGhpcy5lbnRyaWVzLCBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmICh+aW5kZXgpIHNwbGljZSh0aGlzLmVudHJpZXMsIGluZGV4LCAxKTtcbiAgICByZXR1cm4gISF+aW5kZXg7XG4gIH1cbn07XG5cbnZhciBjb2xsZWN0aW9uV2VhayQxID0ge1xuICBnZXRDb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHdyYXBwZXIsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCwgQURERVIpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBQcm90b3R5cGUpO1xuICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGF0LCB7XG4gICAgICAgIHR5cGU6IENPTlNUUlVDVE9SX05BTUUsXG4gICAgICAgIGlkOiBpZCsrLFxuICAgICAgICBmcm96ZW46IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGl0ZXJhYmxlKSkgaXRlcmF0ZShpdGVyYWJsZSwgdGhhdFtBRERFUl0sIHsgdGhhdDogdGhhdCwgQVNfRU5UUklFUzogSVNfTUFQIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIFByb3RvdHlwZSA9IENvbnN0cnVjdG9yLnByb3RvdHlwZTtcblxuICAgIHZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihDT05TVFJVQ1RPUl9OQU1FKTtcblxuICAgIHZhciBkZWZpbmUgPSBmdW5jdGlvbiAodGhhdCwga2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoYW5PYmplY3Qoa2V5KSwgdHJ1ZSk7XG4gICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSkuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgZWxzZSBkYXRhW3N0YXRlLmlkXSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgfTtcblxuICAgIGRlZmluZUJ1aWx0SW5zJDEoUHJvdG90eXBlLCB7XG4gICAgICAvLyBgeyBXZWFrTWFwLCBXZWFrU2V0IH0ucHJvdG90eXBlLmRlbGV0ZShrZXkpYCBtZXRob2RzXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWttYXAucHJvdG90eXBlLmRlbGV0ZVxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrc2V0LnByb3RvdHlwZS5kZWxldGVcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIGlmICghaXNPYmplY3QkMShrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcbiAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKVsnZGVsZXRlJ10oa2V5KTtcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgaGFzT3duKGRhdGEsIHN0YXRlLmlkKSAmJiBkZWxldGUgZGF0YVtzdGF0ZS5pZF07XG4gICAgICB9LFxuICAgICAgLy8gYHsgV2Vha01hcCwgV2Vha1NldCB9LnByb3RvdHlwZS5oYXMoa2V5KWAgbWV0aG9kc1xuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy13ZWFrbWFwLnByb3RvdHlwZS5oYXNcbiAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtd2Vha3NldC5wcm90b3R5cGUuaGFzXG4gICAgICBoYXM6IGZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFpc09iamVjdCQxKGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrRGF0YShrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiBoYXNPd24oZGF0YSwgc3RhdGUuaWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgZGVmaW5lQnVpbHRJbnMkMShQcm90b3R5cGUsIElTX01BUCA/IHtcbiAgICAgIC8vIGBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWttYXAucHJvdG90eXBlLmdldFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIGlmIChpc09iamVjdCQxKGtleSkpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGtleSk7XG4gICAgICAgICAgaWYgKGRhdGEgPT09IHRydWUpIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKS5nZXQoa2V5KTtcbiAgICAgICAgICByZXR1cm4gZGF0YSA/IGRhdGFbc3RhdGUuaWRdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gYFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWttYXAucHJvdG90eXBlLnNldFxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gOiB7XG4gICAgICAvLyBgV2Vha1NldC5wcm90b3R5cGUuYWRkKHZhbHVlKWAgbWV0aG9kXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWtzZXQucHJvdG90eXBlLmFkZFxuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cbn07XG5cbnZhciBGUkVFWklORyA9IGZyZWV6aW5nO1xudmFyIGdsb2JhbCQyID0gZ2xvYmFsJG47XG52YXIgdW5jdXJyeVRoaXMkMSA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgZGVmaW5lQnVpbHRJbnMgPSBkZWZpbmVCdWlsdElucyQzO1xudmFyIEludGVybmFsTWV0YWRhdGFNb2R1bGUgPSBpbnRlcm5hbE1ldGFkYXRhRXhwb3J0cztcbnZhciBjb2xsZWN0aW9uID0gY29sbGVjdGlvbiQzO1xudmFyIGNvbGxlY3Rpb25XZWFrID0gY29sbGVjdGlvbldlYWskMTtcbnZhciBpc09iamVjdCA9IGlzT2JqZWN0JGo7XG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlLmVuZm9yY2U7XG52YXIgZmFpbHMkMSA9IGZhaWxzJHc7XG52YXIgTkFUSVZFX1dFQUtfTUFQID0gd2Vha01hcEJhc2ljRGV0ZWN0aW9uO1xuXG52YXIgJE9iamVjdCA9IE9iamVjdDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1hcnJheS1pc2FycmF5IC0tIHNhZmVcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaXNleHRlbnNpYmxlIC0tIHNhZmVcbnZhciBpc0V4dGVuc2libGUgPSAkT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaXNmcm96ZW4gLS0gc2FmZVxudmFyIGlzRnJvemVuID0gJE9iamVjdC5pc0Zyb3plbjtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtaXNzZWFsZWQgLS0gc2FmZVxudmFyIGlzU2VhbGVkID0gJE9iamVjdC5pc1NlYWxlZDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZnJlZXplIC0tIHNhZmVcbnZhciBmcmVlemUgPSAkT2JqZWN0LmZyZWV6ZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qtc2VhbCAtLSBzYWZlXG52YXIgc2VhbCA9ICRPYmplY3Quc2VhbDtcblxudmFyIEZST1pFTiA9IHt9O1xudmFyIFNFQUxFRCA9IHt9O1xudmFyIElTX0lFMTEgPSAhZ2xvYmFsJDIuQWN0aXZlWE9iamVjdCAmJiAnQWN0aXZlWE9iamVjdCcgaW4gZ2xvYmFsJDI7XG52YXIgSW50ZXJuYWxXZWFrTWFwO1xuXG52YXIgd3JhcHBlciA9IGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBXZWFrTWFwKCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufTtcblxuLy8gYFdlYWtNYXBgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXdlYWttYXAtY29uc3RydWN0b3JcbnZhciAkV2Vha01hcCA9IGNvbGxlY3Rpb24oJ1dlYWtNYXAnLCB3cmFwcGVyLCBjb2xsZWN0aW9uV2Vhayk7XG52YXIgV2Vha01hcFByb3RvdHlwZSA9ICRXZWFrTWFwLnByb3RvdHlwZTtcbnZhciBuYXRpdmVTZXQgPSB1bmN1cnJ5VGhpcyQxKFdlYWtNYXBQcm90b3R5cGUuc2V0KTtcblxuLy8gQ2hha3JhIEVkZ2UgYnVnOiBhZGRpbmcgZnJvemVuIGFycmF5cyB0byBXZWFrTWFwIHVuZnJlZXplIHRoZW1cbnZhciBoYXNNU0VkZ2VGcmVlemluZ0J1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIEZSRUVaSU5HICYmIGZhaWxzJDEoZnVuY3Rpb24gKCkge1xuICAgIHZhciBmcm96ZW5BcnJheSA9IGZyZWV6ZShbXSk7XG4gICAgbmF0aXZlU2V0KG5ldyAkV2Vha01hcCgpLCBmcm96ZW5BcnJheSwgMSk7XG4gICAgcmV0dXJuICFpc0Zyb3plbihmcm96ZW5BcnJheSk7XG4gIH0pO1xufTtcblxuLy8gSUUxMSBXZWFrTWFwIGZyb3plbiBrZXlzIGZpeFxuLy8gV2UgY2FuJ3QgdXNlIGZlYXR1cmUgZGV0ZWN0aW9uIGJlY2F1c2UgaXQgY3Jhc2ggc29tZSBvbGQgSUUgYnVpbGRzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvNDg1XG5pZiAoTkFUSVZFX1dFQUtfTUFQKSBpZiAoSVNfSUUxMSkge1xuICBJbnRlcm5hbFdlYWtNYXAgPSBjb2xsZWN0aW9uV2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCAnV2Vha01hcCcsIHRydWUpO1xuICBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlLmVuYWJsZSgpO1xuICB2YXIgbmF0aXZlRGVsZXRlID0gdW5jdXJyeVRoaXMkMShXZWFrTWFwUHJvdG90eXBlWydkZWxldGUnXSk7XG4gIHZhciBuYXRpdmVIYXMgPSB1bmN1cnJ5VGhpcyQxKFdlYWtNYXBQcm90b3R5cGUuaGFzKTtcbiAgdmFyIG5hdGl2ZUdldCA9IHVuY3VycnlUaGlzJDEoV2Vha01hcFByb3RvdHlwZS5nZXQpO1xuICBkZWZpbmVCdWlsdElucyhXZWFrTWFwUHJvdG90eXBlLCB7XG4gICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZURlbGV0ZSh0aGlzLCBrZXkpIHx8IHN0YXRlLmZyb3plblsnZGVsZXRlJ10oa2V5KTtcbiAgICAgIH0gcmV0dXJuIG5hdGl2ZURlbGV0ZSh0aGlzLCBrZXkpO1xuICAgIH0sXG4gICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIGlmICghc3RhdGUuZnJvemVuKSBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVIYXModGhpcywga2V5KSB8fCBzdGF0ZS5mcm96ZW4uaGFzKGtleSk7XG4gICAgICB9IHJldHVybiBuYXRpdmVIYXModGhpcywga2V5KTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIWlzRXh0ZW5zaWJsZShrZXkpKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICBpZiAoIXN0YXRlLmZyb3plbikgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlSGFzKHRoaXMsIGtleSkgPyBuYXRpdmVHZXQodGhpcywga2V5KSA6IHN0YXRlLmZyb3plbi5nZXQoa2V5KTtcbiAgICAgIH0gcmV0dXJuIG5hdGl2ZUdldCh0aGlzLCBrZXkpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIWlzRXh0ZW5zaWJsZShrZXkpKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICBpZiAoIXN0YXRlLmZyb3plbikgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xuICAgICAgICBuYXRpdmVIYXModGhpcywga2V5KSA/IG5hdGl2ZVNldCh0aGlzLCBrZXksIHZhbHVlKSA6IHN0YXRlLmZyb3plbi5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgbmF0aXZlU2V0KHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbi8vIENoYWtyYSBFZGdlIGZyb3plbiBrZXlzIGZpeFxufSBlbHNlIGlmIChoYXNNU0VkZ2VGcmVlemluZ0J1ZygpKSB7XG4gIGRlZmluZUJ1aWx0SW5zKFdlYWtNYXBQcm90b3R5cGUsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgYXJyYXlJbnRlZ3JpdHlMZXZlbDtcbiAgICAgIGlmIChpc0FycmF5KGtleSkpIHtcbiAgICAgICAgaWYgKGlzRnJvemVuKGtleSkpIGFycmF5SW50ZWdyaXR5TGV2ZWwgPSBGUk9aRU47XG4gICAgICAgIGVsc2UgaWYgKGlzU2VhbGVkKGtleSkpIGFycmF5SW50ZWdyaXR5TGV2ZWwgPSBTRUFMRUQ7XG4gICAgICB9XG4gICAgICBuYXRpdmVTZXQodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoYXJyYXlJbnRlZ3JpdHlMZXZlbCA9PT0gRlJPWkVOKSBmcmVlemUoa2V5KTtcbiAgICAgIGlmIChhcnJheUludGVncml0eUxldmVsID09PSBTRUFMRUQpIHNlYWwoa2V5KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBwYXRoID0gcGF0aCR3O1xuXG52YXIgd2Vha01hcCQyID0gcGF0aC5XZWFrTWFwO1xuXG52YXIgcGFyZW50JDMgPSB3ZWFrTWFwJDI7XG5cblxudmFyIHdlYWtNYXAkMSA9IHBhcmVudCQzO1xuXG52YXIgd2Vha01hcCA9IHdlYWtNYXAkMTtcblxudmFyIF9XZWFrTWFwID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHdlYWtNYXApO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sICovXHJcblxyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBfU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIF9nZXRJdGVyYXRvck1ldGhvZChvKSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoX0FycmF5JGlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDMobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDMobywgbWluTGVuKSB7IHZhciBfY29udGV4dDI7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQzKG8sIG1pbkxlbik7IHZhciBuID0gX3NsaWNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykpLmNhbGwoX2NvbnRleHQyLCA4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBfQXJyYXkkZnJvbSQxKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDMobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkMyhhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxudmFyIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3JfcHJldmlvdXNTZWxlY3Rpb24sIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBfU2VsZWN0aW9uQWNjdW11bGF0b3Jfbm9kZXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9lZGdlcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2NvbW1pdEhhbmRsZXI7XG4vKipcclxuICogQHBhcmFtIHByZXZcclxuICogQHBhcmFtIG5leHRcclxuICovXG5mdW5jdGlvbiBkaWZmU2V0cyhwcmV2LCBuZXh0KSB7XG4gIHZhciBkaWZmID0gbmV3IF9TZXQoKTtcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMobmV4dCksXG4gICAgX3N0ZXA7XG4gIHRyeSB7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIHZhciBpdGVtID0gX3N0ZXAudmFsdWU7XG4gICAgICBpZiAoIXByZXYuaGFzKGl0ZW0pKSB7XG4gICAgICAgIGRpZmYuYWRkKGl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBfaXRlcmF0b3IuZigpO1xuICB9XG4gIHJldHVybiBkaWZmO1xufVxudmFyIFNpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yKTtcbiAgICBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3ByZXZpb3VzU2VsZWN0aW9uLnNldCh0aGlzLCBuZXcgX1NldCgpKTtcbiAgICBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbi5zZXQodGhpcywgbmV3IF9TZXQoKSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFNpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvciwgW3tcbiAgICBrZXk6IFwic2l6ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIFwiZlwiKS5zaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGl0ZW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBpdGVtc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF9pID0gMCwgX2l0ZW1zID0gaXRlbXM7IF9pIDwgX2l0ZW1zLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaXRlbSA9IF9pdGVtc1tfaV07XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIFwiZlwiKS5hZGQoaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVsZXRlKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBpdGVtcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBpdGVtc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX2kyID0gMCwgX2l0ZW1zMiA9IGl0ZW1zOyBfaTIgPCBfaXRlbXMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBfaXRlbXMyW19pMl07XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIFwiZlwiKS5kZWxldGUoaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbiwgXCJmXCIpLmNsZWFyKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX3RvQ29uc3VtYWJsZUFycmF5KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIFwiZlwiKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldENoYW5nZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2hhbmdlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFkZGVkOiBfdG9Db25zdW1hYmxlQXJyYXkoZGlmZlNldHMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3ByZXZpb3VzU2VsZWN0aW9uLCBcImZcIiksIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIFwiZlwiKSkpLFxuICAgICAgICBkZWxldGVkOiBfdG9Db25zdW1hYmxlQXJyYXkoZGlmZlNldHMoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbiwgXCJmXCIpLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3JfcHJldmlvdXNTZWxlY3Rpb24sIFwiZlwiKSkpLFxuICAgICAgICBwcmV2aW91czogX3RvQ29uc3VtYWJsZUFycmF5KG5ldyBfU2V0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9wcmV2aW91c1NlbGVjdGlvbiwgXCJmXCIpKSksXG4gICAgICAgIGN1cnJlbnQ6IF90b0NvbnN1bWFibGVBcnJheShuZXcgX1NldChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3Jfc2VsZWN0aW9uLCBcImZcIikpKVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbW1pdCgpIHtcbiAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5nZXRDaGFuZ2VzKCk7XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3JfcHJldmlvdXNTZWxlY3Rpb24sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24sIFwiZlwiKSwgXCJmXCIpO1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3NlbGVjdGlvbiwgbmV3IF9TZXQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2luZ2xlVHlwZVNlbGVjdGlvbkFjY3VtdWxhdG9yX3ByZXZpb3VzU2VsZWN0aW9uLCBcImZcIikpLCBcImZcIik7XG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMoY2hhbmdlcy5hZGRlZCksXG4gICAgICAgIF9zdGVwMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgaXRlbS5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG4gICAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDMoY2hhbmdlcy5kZWxldGVkKSxcbiAgICAgICAgX3N0ZXAzO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX2l0ZW0gPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgX2l0ZW0udW5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2hhbmdlcztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFNpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcjtcbn0oKTtcbl9TaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3JfcHJldmlvdXNTZWxlY3Rpb24gPSBuZXcgX1dlYWtNYXAoKSwgX1NpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcl9zZWxlY3Rpb24gPSBuZXcgX1dlYWtNYXAoKTtcbnZhciBTZWxlY3Rpb25BY2N1bXVsYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNlbGVjdGlvbkFjY3VtdWxhdG9yKCkge1xuICAgIHZhciBjb21taXRIYW5kbGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmdW5jdGlvbiAoKSB7fTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VsZWN0aW9uQWNjdW11bGF0b3IpO1xuICAgIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9ub2Rlcy5zZXQodGhpcywgbmV3IFNpbmdsZVR5cGVTZWxlY3Rpb25BY2N1bXVsYXRvcigpKTtcbiAgICBfU2VsZWN0aW9uQWNjdW11bGF0b3JfZWRnZXMuc2V0KHRoaXMsIG5ldyBTaW5nbGVUeXBlU2VsZWN0aW9uQWNjdW11bGF0b3IoKSk7XG4gICAgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2NvbW1pdEhhbmRsZXIuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfY29tbWl0SGFuZGxlciwgY29tbWl0SGFuZGxlciwgXCJmXCIpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhTZWxlY3Rpb25BY2N1bXVsYXRvciwgW3tcbiAgICBrZXk6IFwic2l6ZU5vZGVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3Jfbm9kZXMsIFwiZlwiKS5zaXplO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaXplRWRnZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9lZGdlcywgXCJmXCIpLnNpemU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vZGVzKCkge1xuICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX25vZGVzLCBcImZcIikuZ2V0U2VsZWN0aW9uKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVkZ2VzKCkge1xuICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2VkZ2VzLCBcImZcIikuZ2V0U2VsZWN0aW9uKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZE5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE5vZGVzKCkge1xuICAgICAgdmFyIF9jbGFzc1ByaXZhdGVGaWVsZEdlO1xuICAgICAgKF9jbGFzc1ByaXZhdGVGaWVsZEdlID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3Jfbm9kZXMsIFwiZlwiKSkuYWRkLmFwcGx5KF9jbGFzc1ByaXZhdGVGaWVsZEdlLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFZGdlcygpIHtcbiAgICAgIHZhciBfY2xhc3NQcml2YXRlRmllbGRHZTI7XG4gICAgICAoX2NsYXNzUHJpdmF0ZUZpZWxkR2UyID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfZWRnZXMsIFwiZlwiKSkuYWRkLmFwcGx5KF9jbGFzc1ByaXZhdGVGaWVsZEdlMiwgYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlTm9kZXMobm9kZSkge1xuICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3Jfbm9kZXMsIFwiZlwiKS5kZWxldGUobm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlbGV0ZUVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUVkZ2VzKGVkZ2UpIHtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2VkZ2VzLCBcImZcIikuZGVsZXRlKGVkZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX25vZGVzLCBcImZcIikuY2xlYXIoKTtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2VkZ2VzLCBcImZcIikuY2xlYXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbW1pdCgpIHtcbiAgICAgIHZhciBfY2xhc3NQcml2YXRlRmllbGRHZTMsIF9jb250ZXh0O1xuICAgICAgdmFyIHN1bW1hcnkgPSB7XG4gICAgICAgIG5vZGVzOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9ub2RlcywgXCJmXCIpLmNvbW1pdCgpLFxuICAgICAgICBlZGdlczogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfZWRnZXMsIFwiZlwiKS5jb21taXQoKVxuICAgICAgfTtcbiAgICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgcmVzdCA9IG5ldyBBcnJheShfbGVuMyksIF9rZXkzID0gMDsgX2tleTMgPCBfbGVuMzsgX2tleTMrKykge1xuICAgICAgICByZXN0W19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG4gICAgICAoX2NsYXNzUHJpdmF0ZUZpZWxkR2UzID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU2VsZWN0aW9uQWNjdW11bGF0b3JfY29tbWl0SGFuZGxlciwgXCJmXCIpKS5jYWxsLmFwcGx5KF9jbGFzc1ByaXZhdGVGaWVsZEdlMywgX2NvbmNhdEluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQgPSBbdGhpcywgc3VtbWFyeV0pLmNhbGwoX2NvbnRleHQsIHJlc3QpKTtcbiAgICAgIHJldHVybiBzdW1tYXJ5O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU2VsZWN0aW9uQWNjdW11bGF0b3I7XG59KCk7XG5fU2VsZWN0aW9uQWNjdW11bGF0b3Jfbm9kZXMgPSBuZXcgX1dlYWtNYXAoKSwgX1NlbGVjdGlvbkFjY3VtdWxhdG9yX2VkZ2VzID0gbmV3IF9XZWFrTWFwKCksIF9TZWxlY3Rpb25BY2N1bXVsYXRvcl9jb21taXRIYW5kbGVyID0gbmV3IF9XZWFrTWFwKCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIF9TeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgX2dldEl0ZXJhdG9yTWV0aG9kKG8pIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChfQXJyYXkkaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMihvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMihvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0MzsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDIobywgbWluTGVuKTsgdmFyIG4gPSBfc2xpY2VJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDMsIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIF9BcnJheSRmcm9tJDEobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMihvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQyKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5cbi8qKlxuICogVGhlIGhhbmRsZXIgZm9yIHNlbGVjdGlvbnNcbiAqL1xudmFyIFNlbGVjdGlvbkhhbmRsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGJvZHlcbiAgICogQHBhcmFtIHtDYW52YXN9IGNhbnZhc1xuICAgKi9cbiAgZnVuY3Rpb24gU2VsZWN0aW9uSGFuZGxlcihib2R5LCBjYW52YXMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZWxlY3Rpb25IYW5kbGVyKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIC8vIFRPRE86IENvbnNpZGVyIGZpcmluZyBhbiBldmVudCBvbiBhbnkgY2hhbmdlIHRvIHRoZSBzZWxlY3Rpb24sIG5vdFxuICAgIC8vIG9ubHkgdGhvc2UgY2F1c2VkIGJ5IGNsaWNrcyBhbmQgdGFwcy4gSXQgd291bGQgYmUgZWFzeSB0byBpbXBsZW1lbnRcbiAgICAvLyBub3cgYW5kIChhdCBsZWFzdCB0byBtZSkgaXQgc2VlbXMgbGlrZSBzb21ldGhpbmcgdGhhdCBjb3VsZCBiZVxuICAgIC8vIHF1aXRlIHVzZWZ1bC5cbiAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvciA9IG5ldyBTZWxlY3Rpb25BY2N1bXVsYXRvcigpO1xuICAgIHRoaXMuaG92ZXJPYmogPSB7XG4gICAgICBub2Rlczoge30sXG4gICAgICBlZGdlczoge31cbiAgICB9O1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBtdWx0aXNlbGVjdDogZmFsc2UsXG4gICAgICBzZWxlY3RhYmxlOiB0cnVlLFxuICAgICAgc2VsZWN0Q29ubmVjdGVkRWRnZXM6IHRydWUsXG4gICAgICBob3ZlckNvbm5lY3RlZEVkZ2VzOiB0cnVlXG4gICAgfTtcbiAgICBfT2JqZWN0JGFzc2lnbih0aGlzLm9wdGlvbnMsIHRoaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLnVwZGF0ZVNlbGVjdGlvbigpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhTZWxlY3Rpb25IYW5kbGVyLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZmllbGRzID0gW1wibXVsdGlzZWxlY3RcIiwgXCJob3ZlckNvbm5lY3RlZEVkZ2VzXCIsIFwic2VsZWN0YWJsZVwiLCBcInNlbGVjdENvbm5lY3RlZEVkZ2VzXCJdO1xuICAgICAgICBzZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBoYW5kbGVzIHRoZSBzZWxlY3Rpb24gcGFydCBvZiB0aGUgdGFwO1xuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0T25Qb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RPblBvaW50KHBvaW50ZXIpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZWxlY3RhYmxlID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBvYmogPSB0aGlzLmdldE5vZGVBdChwb2ludGVyKSB8fCB0aGlzLmdldEVkZ2VBdChwb2ludGVyKTtcblxuICAgICAgICAvLyB1bnNlbGVjdCBhZnRlciBnZXR0aW5nIHRoZSBvYmplY3RzIGluIG9yZGVyIHRvIHJlc3RvcmUgd2lkdGggYW5kIGhlaWdodC5cbiAgICAgICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgICAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0T2JqZWN0KG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0QWRkaXRpb25hbE9uUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0QWRkaXRpb25hbE9uUG9pbnQocG9pbnRlcikge1xuICAgICAgdmFyIHNlbGVjdGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VsZWN0YWJsZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgb2JqID0gdGhpcy5nZXROb2RlQXQocG9pbnRlcikgfHwgdGhpcy5nZXRFZGdlQXQocG9pbnRlcik7XG4gICAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNlbGVjdGlvbkNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIGlmIChvYmouaXNTZWxlY3RlZCgpID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0T2JqZWN0KG9iaik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0T2JqZWN0KG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNlbGVjdGlvbkNoYW5nZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzdGFuZGFyZCBmaWVsZHMgZm9yIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgT2JqZWN0IHdpdGggdGhlIHggYW5kIHkgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqIEByZXR1cm5zIHt7fX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9pbml0QmFzZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0QmFzZUV2ZW50KGV2ZW50LCBwb2ludGVyKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgcHJvcGVydGllc1tcInBvaW50ZXJcIl0gPSB7XG4gICAgICAgIERPTToge1xuICAgICAgICAgIHg6IHBvaW50ZXIueCxcbiAgICAgICAgICB5OiBwb2ludGVyLnlcbiAgICAgICAgfSxcbiAgICAgICAgY2FudmFzOiB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKVxuICAgICAgfTtcbiAgICAgIHByb3BlcnRpZXNbXCJldmVudFwiXSA9IGV2ZW50O1xuICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW4gZXZlbnQgd2hpY2ggdGhlIHVzZXIgY2FuIGNhdGNoLlxuICAgICAqXG4gICAgICogVGhpcyBhZGRzIHNvbWUgZXh0cmEgZGF0YSB0byB0aGUgZXZlbnQgd2l0aCByZXNwZWN0IHRvIGN1cnNvciBwb3NpdGlvbiBhbmRcbiAgICAgKiBzZWxlY3RlZCBub2RlcyBhbmQgZWRnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlICAgICAgICAgICAgICAgICAgICAgICAgICBOYW1lIG9mIGV2ZW50IHRvIHNlbmRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgICAgICAgICAgICBPYmplY3Qgd2l0aCB0aGUgeCBhbmQgeSBzY3JlZW4gY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICogQHBhcmFtIHtvYmplY3QgfCB1bmRlZmluZWR9IG9sZFNlbGVjdGlvbiAgICAgICAgICAgICBJZiBwcmVzZW50LCBzZWxlY3Rpb24gc3RhdGUgYmVmb3JlIGV2ZW50IG9jY3VyZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58dW5kZWZpbmVkfSBbZW1wdHlTZWxlY3Rpb249ZmFsc2VdICBJbmRpY2F0ZSBpZiBzZWxlY3Rpb24gZGF0YSBzaG91bGQgYmUgcGFzc2VkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2VuZXJhdGVDbGlja0V2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdlbmVyYXRlQ2xpY2tFdmVudChldmVudFR5cGUsIGV2ZW50LCBwb2ludGVyLCBvbGRTZWxlY3Rpb24pIHtcbiAgICAgIHZhciBlbXB0eVNlbGVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuX2luaXRCYXNlRXZlbnQoZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgaWYgKGVtcHR5U2VsZWN0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIHByb3BlcnRpZXMubm9kZXMgPSBbXTtcbiAgICAgICAgcHJvcGVydGllcy5lZGdlcyA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRtcCA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIHByb3BlcnRpZXMubm9kZXMgPSB0bXAubm9kZXM7XG4gICAgICAgIHByb3BlcnRpZXMuZWRnZXMgPSB0bXAuZWRnZXM7XG4gICAgICB9XG4gICAgICBpZiAob2xkU2VsZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcGVydGllc1tcInByZXZpb3VzU2VsZWN0aW9uXCJdID0gb2xkU2VsZWN0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50VHlwZSA9PSBcImNsaWNrXCIpIHtcbiAgICAgICAgLy8gRm9yIHRoZSB0aW1lIGJlaW5nLCByZXN0cmljdCB0aGlzIGZ1bmN0aW9uYWxpdHkgdG9cbiAgICAgICAgLy8ganVzdCB0aGUgY2xpY2sgZXZlbnQuXG4gICAgICAgIHByb3BlcnRpZXMuaXRlbXMgPSB0aGlzLmdldENsaWNrZWRJdGVtcyhwb2ludGVyKTtcbiAgICAgIH1cbiAgICAgIGlmIChldmVudC5jb250cm9sRWRnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BlcnRpZXMuY29udHJvbEVkZ2UgPSBldmVudC5jb250cm9sRWRnZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoZXZlbnRUeXBlLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoaWdobGlnaHRFZGdlcz10aGlzLm9wdGlvbnMuc2VsZWN0Q29ubmVjdGVkRWRnZXNdXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0T2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdE9iamVjdChvYmopIHtcbiAgICAgIHZhciBoaWdobGlnaHRFZGdlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdGhpcy5vcHRpb25zLnNlbGVjdENvbm5lY3RlZEVkZ2VzO1xuICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgaWYgKGhpZ2hsaWdodEVkZ2VzID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMkX3NlbGVjdGlvbkFjY3VtO1xuICAgICAgICAgICAgKF90aGlzJF9zZWxlY3Rpb25BY2N1bSA9IHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yKS5hZGRFZGdlcy5hcHBseShfdGhpcyRfc2VsZWN0aW9uQWNjdW0sIF90b0NvbnN1bWFibGVBcnJheShvYmouZWRnZXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuYWRkTm9kZXMob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5hZGRFZGdlcyhvYmopO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlc2VsZWN0T2JqZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc2VsZWN0T2JqZWN0KG9iaikge1xuICAgICAgaWYgKG9iai5pc1NlbGVjdGVkKCkgPT09IHRydWUpIHtcbiAgICAgICAgb2JqLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JlbW92ZUZyb21TZWxlY3Rpb24ob2JqKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXRyaWV2ZSBhbGwgbm9kZXMgb3ZlcmxhcHBpbmcgd2l0aCBnaXZlbiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3QgIEFuIG9iamVjdCB3aXRoIHBhcmFtZXRlcnMgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXG4gICAgICogQHJldHVybnMge251bWJlcltdfSAgIEFuIGFycmF5IHdpdGggaWQncyBvZiB0aGUgb3ZlcmxhcHBpbmcgbm9kZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgob2JqZWN0KSB7XG4gICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlcyA9IFtdO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGVJZCA9IHRoaXMuYm9keS5ub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgaWYgKG5vZGVzW25vZGVJZF0uaXNPdmVybGFwcGluZ1dpdGgob2JqZWN0KSkge1xuICAgICAgICAgIG92ZXJsYXBwaW5nTm9kZXMucHVzaChub2RlSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3ZlcmxhcHBpbmdOb2RlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBwb3NpdGlvbiBvYmplY3QgaW4gY2FudmFzc3BhY2UgZnJvbSBhIHNpbmdsZSBwb2ludCBpbiBzY3JlZW5zcGFjZVxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHJldHVybnMge3tsZWZ0OiBudW1iZXIsIHRvcDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBib3R0b206IG51bWJlcn19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcG9pbnRlclRvUG9zaXRpb25PYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpIHtcbiAgICAgIHZhciBjYW52YXNQb3MgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGNhbnZhc1Bvcy54IC0gMSxcbiAgICAgICAgdG9wOiBjYW52YXNQb3MueSArIDEsXG4gICAgICAgIHJpZ2h0OiBjYW52YXNQb3MueCArIDEsXG4gICAgICAgIGJvdHRvbTogY2FudmFzUG9zLnkgLSAxXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdG9wIG5vZGUgYXQgdGhlIHBhc3NlZCBwb2ludCAobGlrZSBhIGNsaWNrKVxuICAgICAqXG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0dXJuTm9kZT10cnVlXVxuICAgICAqIEByZXR1cm5zIHtOb2RlIHwgdW5kZWZpbmVkfSBub2RlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Tm9kZUF0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vZGVBdChwb2ludGVyKSB7XG4gICAgICB2YXIgcmV0dXJuTm9kZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIC8vIHdlIGZpcnN0IGNoZWNrIGlmIHRoaXMgaXMgYW4gbmF2aWdhdGlvbiBjb250cm9scyBlbGVtZW50XG4gICAgICB2YXIgcG9zaXRpb25PYmplY3QgPSB0aGlzLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTtcbiAgICAgIHZhciBvdmVybGFwcGluZ05vZGVzID0gdGhpcy5fZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgocG9zaXRpb25PYmplY3QpO1xuICAgICAgLy8gaWYgdGhlcmUgYXJlIG92ZXJsYXBwaW5nIG5vZGVzLCBzZWxlY3QgdGhlIGxhc3Qgb25lLCB0aGlzIGlzIHRoZVxuICAgICAgLy8gb25lIHdoaWNoIGlzIGRyYXduIG9uIHRvcCBvZiB0aGUgb3RoZXJzXG4gICAgICBpZiAob3ZlcmxhcHBpbmdOb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChyZXR1cm5Ob2RlID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5ub2Rlc1tvdmVybGFwcGluZ05vZGVzW292ZXJsYXBwaW5nTm9kZXMubGVuZ3RoIC0gMV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBvdmVybGFwcGluZ05vZGVzW292ZXJsYXBwaW5nTm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0cmlldmUgYWxsIGVkZ2VzIG92ZXJsYXBwaW5nIHdpdGggZ2l2ZW4gb2JqZWN0LCBzZWxlY3RvciBpcyBhcm91bmQgY2VudGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0ICBBbiBvYmplY3Qgd2l0aCBwYXJhbWV0ZXJzIGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbVxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IG92ZXJsYXBwaW5nRWRnZXMgQW4gYXJyYXkgd2l0aCBpZCdzIG9mIHRoZSBvdmVybGFwcGluZyBub2Rlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEVkZ2VzT3ZlcmxhcHBpbmdXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRFZGdlc092ZXJsYXBwaW5nV2l0aChvYmplY3QsIG92ZXJsYXBwaW5nRWRnZXMpIHtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlSWQgPSB0aGlzLmJvZHkuZWRnZUluZGljZXNbaV07XG4gICAgICAgIGlmIChlZGdlc1tlZGdlSWRdLmlzT3ZlcmxhcHBpbmdXaXRoKG9iamVjdCkpIHtcbiAgICAgICAgICBvdmVybGFwcGluZ0VkZ2VzLnB1c2goZWRnZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHJpZXZlIGFsbCBub2RlcyBvdmVybGFwcGluZyB3aXRoIGdpdmVuIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCAgQW4gb2JqZWN0IHdpdGggcGFyYW1ldGVycyBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b21cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119ICAgQW4gYXJyYXkgd2l0aCBpZCdzIG9mIHRoZSBvdmVybGFwcGluZyBub2Rlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEFsbEVkZ2VzT3ZlcmxhcHBpbmdXaXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRBbGxFZGdlc092ZXJsYXBwaW5nV2l0aChvYmplY3QpIHtcbiAgICAgIHZhciBvdmVybGFwcGluZ0VkZ2VzID0gW107XG4gICAgICB0aGlzLl9nZXRFZGdlc092ZXJsYXBwaW5nV2l0aChvYmplY3QsIG92ZXJsYXBwaW5nRWRnZXMpO1xuICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nRWRnZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBlZGdlcyBuZWFyZXN0IHRvIHRoZSBwYXNzZWQgcG9pbnQgKGxpa2UgYSBjbGljaylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldHVybkVkZ2U9dHJ1ZV1cbiAgICAgKiBAcmV0dXJucyB7RWRnZSB8IHVuZGVmaW5lZH0gbm9kZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEVkZ2VBdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFZGdlQXQocG9pbnRlcikge1xuICAgICAgdmFyIHJldHVybkVkZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICAvLyBJdGVyYXRlIG92ZXIgZWRnZXMsIHBpY2sgY2xvc2VzdCB3aXRoaW4gMTBcbiAgICAgIHZhciBjYW52YXNQb3MgPSB0aGlzLmNhbnZhcy5ET010b0NhbnZhcyhwb2ludGVyKTtcbiAgICAgIHZhciBtaW5kaXN0ID0gMTA7XG4gICAgICB2YXIgb3ZlcmxhcHBpbmdFZGdlID0gbnVsbDtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlSWQgPSB0aGlzLmJvZHkuZWRnZUluZGljZXNbaV07XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkKSB7XG4gICAgICAgICAgdmFyIHhGcm9tID0gZWRnZS5mcm9tLng7XG4gICAgICAgICAgdmFyIHlGcm9tID0gZWRnZS5mcm9tLnk7XG4gICAgICAgICAgdmFyIHhUbyA9IGVkZ2UudG8ueDtcbiAgICAgICAgICB2YXIgeVRvID0gZWRnZS50by55O1xuICAgICAgICAgIHZhciBkaXN0ID0gZWRnZS5lZGdlVHlwZS5nZXREaXN0YW5jZVRvRWRnZSh4RnJvbSwgeUZyb20sIHhUbywgeVRvLCBjYW52YXNQb3MueCwgY2FudmFzUG9zLnkpO1xuICAgICAgICAgIGlmIChkaXN0IDwgbWluZGlzdCkge1xuICAgICAgICAgICAgb3ZlcmxhcHBpbmdFZGdlID0gZWRnZUlkO1xuICAgICAgICAgICAgbWluZGlzdCA9IGRpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob3ZlcmxhcHBpbmdFZGdlICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChyZXR1cm5FZGdlID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5lZGdlc1tvdmVybGFwcGluZ0VkZ2VdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBvdmVybGFwcGluZ0VkZ2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIG9iamVjdCB0byB0aGUgc2VsZWN0aW9uIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZFRvSG92ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZFRvSG92ZXIob2JqKSB7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICB0aGlzLmhvdmVyT2JqLm5vZGVzW29iai5pZF0gPSBvYmo7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhvdmVyT2JqLmVkZ2VzW29iai5pZF0gPSBvYmo7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgc2luZ2xlIG9wdGlvbiBmcm9tIHNlbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVGcm9tU2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVGcm9tU2VsZWN0aW9uKG9iaikge1xuICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzJF9zZWxlY3Rpb25BY2N1bTI7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmRlbGV0ZU5vZGVzKG9iaik7XG4gICAgICAgIChfdGhpcyRfc2VsZWN0aW9uQWNjdW0yID0gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IpLmRlbGV0ZUVkZ2VzLmFwcGx5KF90aGlzJF9zZWxlY3Rpb25BY2N1bTIsIF90b0NvbnN1bWFibGVBcnJheShvYmouZWRnZXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmRlbGV0ZUVkZ2VzKG9iaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5zZWxlY3QgYWxsIG5vZGVzIGFuZCBlZGdlcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1bnNlbGVjdEFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNlbGVjdEFsbCgpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBudW1iZXIgb2Ygc2VsZWN0ZWQgbm9kZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VsZWN0ZWROb2RlQ291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWROb2RlQ291bnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3Iuc2l6ZU5vZGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgbnVtYmVyIG9mIHNlbGVjdGVkIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGVkRWRnZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGVkRWRnZUNvdW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLnNpemVFZGdlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgdGhlIGVkZ2VzIGNvbm5lY3RlZCB0byB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIHNlbGVjdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9ob3ZlckNvbm5lY3RlZEVkZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9ob3ZlckNvbm5lY3RlZEVkZ2VzKG5vZGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IG5vZGUuZWRnZXNbaV07XG4gICAgICAgIGVkZ2UuaG92ZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl9hZGRUb0hvdmVyKGVkZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgaGlnaGxpZ2h0IGZyb20gYSBub2RlIG9yIGVkZ2UsIGluIHJlc3BvbnNlIHRvIG1vdXNlIG1vdmVtZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgb2JqZWN0IHdpdGggdGhlIHggYW5kIHkgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIHRoZSBtb3VzZVxuICAgICAqIEBwYXJhbSB7Tm9kZXx2aXMuRWRnZX0gb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJlbWl0Qmx1ckV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXRCbHVyRXZlbnQoZXZlbnQsIHBvaW50ZXIsIG9iamVjdCkge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLl9pbml0QmFzZUV2ZW50KGV2ZW50LCBwb2ludGVyKTtcbiAgICAgIGlmIChvYmplY3QuaG92ZXIgPT09IHRydWUpIHtcbiAgICAgICAgb2JqZWN0LmhvdmVyID0gZmFsc2U7XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5ub2RlID0gb2JqZWN0LmlkO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJibHVyTm9kZVwiLCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLmVkZ2UgPSBvYmplY3QuaWQ7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImJsdXJFZGdlXCIsIHByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHRoZSBoaWdobGlnaHQgZm9yIGEgbm9kZSBvciBlZGdlLCBpbiByZXNwb25zZSB0byBtb3VzZSBtb3ZlbWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gIGV2ZW50XG4gICAgICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwb2ludGVyIG9iamVjdCB3aXRoIHRoZSB4IGFuZCB5IHNjcmVlbiBjb29yZGluYXRlcyBvZiB0aGUgbW91c2VcbiAgICAgKiBAcGFyYW0ge05vZGV8dmlzLkVkZ2V9IG9iamVjdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBob3ZlckNoYW5nZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImVtaXRIb3ZlckV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVtaXRIb3ZlckV2ZW50KGV2ZW50LCBwb2ludGVyLCBvYmplY3QpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5faW5pdEJhc2VFdmVudChldmVudCwgcG9pbnRlcik7XG4gICAgICB2YXIgaG92ZXJDaGFuZ2VkID0gZmFsc2U7XG4gICAgICBpZiAob2JqZWN0LmhvdmVyID09PSBmYWxzZSkge1xuICAgICAgICBvYmplY3QuaG92ZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl9hZGRUb0hvdmVyKG9iamVjdCk7XG4gICAgICAgIGhvdmVyQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgcHJvcGVydGllcy5ub2RlID0gb2JqZWN0LmlkO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJob3Zlck5vZGVcIiwgcHJvcGVydGllcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcGVydGllcy5lZGdlID0gb2JqZWN0LmlkO1xuICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJob3ZlckVkZ2VcIiwgcHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBob3ZlckNoYW5nZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhY3Rpb25zIGluIHJlc3BvbnNlIHRvIGEgbW91c2UgbW92ZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvaW50ZXIgfCBvYmplY3Qgd2l0aCB0aGUgeCBhbmQgeSBzY3JlZW4gY29vcmRpbmF0ZXMgb2YgdGhlIG1vdXNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaG92ZXJPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaG92ZXJPYmplY3QoZXZlbnQsIHBvaW50ZXIpIHtcbiAgICAgIHZhciBvYmplY3QgPSB0aGlzLmdldE5vZGVBdChwb2ludGVyKTtcbiAgICAgIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvYmplY3QgPSB0aGlzLmdldEVkZ2VBdChwb2ludGVyKTtcbiAgICAgIH1cbiAgICAgIHZhciBob3ZlckNoYW5nZWQgPSBmYWxzZTtcbiAgICAgIC8vIHJlbW92ZSBhbGwgbm9kZSBob3ZlciBoaWdobGlnaHRzXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ob3Zlck9iai5ub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuaG92ZXJPYmoubm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb2JqZWN0IGluc3RhbmNlb2YgTm9kZSAmJiBvYmplY3QuaWQgIT0gbm9kZUlkIHx8IG9iamVjdCBpbnN0YW5jZW9mIEVkZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdEJsdXJFdmVudChldmVudCwgcG9pbnRlciwgdGhpcy5ob3Zlck9iai5ub2Rlc1tub2RlSWRdKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhvdmVyT2JqLm5vZGVzW25vZGVJZF07XG4gICAgICAgICAgICBob3ZlckNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmluZyBhbGwgZWRnZSBob3ZlciBoaWdobGlnaHRzXG4gICAgICBmb3IgKHZhciBlZGdlSWQgaW4gdGhpcy5ob3Zlck9iai5lZGdlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuaG92ZXJPYmouZWRnZXMsIGVkZ2VJZCkpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgaG92ZXIgaGFzIGJlZW4gY2hhbmdlZCBoZXJlIGl0IG1lYW5zIHRoYXQgdGhlIG5vZGUgaGFzIGJlZW4gaG92ZXJlZCBvdmVyIG9yIG9mZlxuICAgICAgICAgIC8vIHdlIHRoZW4gZG8gbm90IHVzZSB0aGUgZW1pdEJsdXJFdmVudCBtZXRob2QgaGVyZS5cbiAgICAgICAgICBpZiAoaG92ZXJDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLmhvdmVyT2JqLmVkZ2VzW2VkZ2VJZF0uaG92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhvdmVyT2JqLmVkZ2VzW2VkZ2VJZF07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlmIHRoZSBibHVyIHJlbWFpbnMgdGhlIHNhbWUgYW5kIHRoZSBvYmplY3QgaXMgdW5kZWZpbmVkIChtb3VzZSBvZmYpIG9yIGFub3RoZXJcbiAgICAgICAgICAvLyBlZGdlIGhhcyBiZWVuIGhvdmVyZWQsIG9yIGFub3RoZXIgbm9kZSBoYXMgYmVlbiBob3ZlcmVkIHdlIGJsdXIgdGhlIGVkZ2UuXG4gICAgICAgICAgZWxzZSBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb2JqZWN0IGluc3RhbmNlb2YgRWRnZSAmJiBvYmplY3QuaWQgIT0gZWRnZUlkIHx8IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgJiYgIW9iamVjdC5ob3Zlcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0Qmx1ckV2ZW50KGV2ZW50LCBwb2ludGVyLCB0aGlzLmhvdmVyT2JqLmVkZ2VzW2VkZ2VJZF0pO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuaG92ZXJPYmouZWRnZXNbZWRnZUlkXTtcbiAgICAgICAgICAgIGhvdmVyQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGhvdmVyZWRFZGdlc0NvdW50ID0gX09iamVjdCRrZXlzKHRoaXMuaG92ZXJPYmouZWRnZXMpLmxlbmd0aDtcbiAgICAgICAgdmFyIGhvdmVyZWROb2Rlc0NvdW50ID0gX09iamVjdCRrZXlzKHRoaXMuaG92ZXJPYmoubm9kZXMpLmxlbmd0aDtcbiAgICAgICAgdmFyIG5ld09ubHlIb3ZlcmVkRWRnZSA9IG9iamVjdCBpbnN0YW5jZW9mIEVkZ2UgJiYgaG92ZXJlZEVkZ2VzQ291bnQgPT09IDAgJiYgaG92ZXJlZE5vZGVzQ291bnQgPT09IDA7XG4gICAgICAgIHZhciBuZXdPbmx5SG92ZXJlZE5vZGUgPSBvYmplY3QgaW5zdGFuY2VvZiBOb2RlICYmIGhvdmVyZWRFZGdlc0NvdW50ID09PSAwICYmIGhvdmVyZWROb2Rlc0NvdW50ID09PSAwO1xuICAgICAgICBpZiAoaG92ZXJDaGFuZ2VkIHx8IG5ld09ubHlIb3ZlcmVkRWRnZSB8fCBuZXdPbmx5SG92ZXJlZE5vZGUpIHtcbiAgICAgICAgICBob3ZlckNoYW5nZWQgPSB0aGlzLmVtaXRIb3ZlckV2ZW50KGV2ZW50LCBwb2ludGVyLCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOb2RlICYmIHRoaXMub3B0aW9ucy5ob3ZlckNvbm5lY3RlZEVkZ2VzID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5faG92ZXJDb25uZWN0ZWRFZGdlcyhvYmplY3QpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaG92ZXJDaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVxdWVzdFJlZHJhd1wiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21taXQgdGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGJ1dCBkb24ndCBlbWl0IGFueSBldmVudHMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tbWl0V2l0aG91dEVtaXR0aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbW1pdFdpdGhvdXRFbWl0dGluZygpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmNvbW1pdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBhbmQgZGVzZWxlY3Qgbm9kZXMgZGVwZW5kaW5nIGN1cnJlbnQgc2VsZWN0aW9uIGNoYW5nZS5cbiAgICAgKlxuICAgICAqIEZvciBjaGFuZ2luZyBub2Rlcywgc2VsZWN0L2Rlc2VsZWN0IGV2ZW50cyBhcmUgZmlyZWQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBGb3IgYSBnaXZlbiBlZGdlLCBpZiBvbmUgY29ubmVjdGluZyBub2RlIGlzIGRlc2VsZWN0ZWQgYW5kIHdpdGggdGhlXG4gICAgICogc2FtZSBjbGljayB0aGUgb3RoZXIgbm9kZSBpcyBzZWxlY3RlZCwgbm8gZXZlbnRzIGZvciB0aGUgZWRnZSB3aWxsIGZpcmUuIEl0XG4gICAgICogd2FzIHNlbGVjdGVkIGFuZCBpdCB3aWxsIHJlbWFpbiBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7e3g6IG51bWJlciwgeTogbnVtYmVyfX0gcG9pbnRlciAtIFRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZVxuICAgICAqIGNsaWNrLCB0YXAsIGRyYWdlbmTigKYgdGhhdCB0cmlnZ2VyZWQgdGhpcy5cbiAgICAgKiBAcGFyYW0ge1VJRXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tbWl0QW5kRW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21taXRBbmRFbWl0KHBvaW50ZXIsIGV2ZW50KSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBzZWxlY3Rpb25DaGFuZ2VzID0gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuY29tbWl0KCk7XG4gICAgICB2YXIgcHJldmlvdXNTZWxlY3Rpb24gPSB7XG4gICAgICAgIG5vZGVzOiBzZWxlY3Rpb25DaGFuZ2VzLm5vZGVzLnByZXZpb3VzLFxuICAgICAgICBlZGdlczogc2VsZWN0aW9uQ2hhbmdlcy5lZGdlcy5wcmV2aW91c1xuICAgICAgfTtcbiAgICAgIGlmIChzZWxlY3Rpb25DaGFuZ2VzLmVkZ2VzLmRlbGV0ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlQ2xpY2tFdmVudChcImRlc2VsZWN0RWRnZVwiLCBldmVudCwgcG9pbnRlciwgcHJldmlvdXNTZWxlY3Rpb24pO1xuICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0aW9uQ2hhbmdlcy5ub2Rlcy5kZWxldGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkZXNlbGVjdE5vZGVcIiwgZXZlbnQsIHBvaW50ZXIsIHByZXZpb3VzU2VsZWN0aW9uKTtcbiAgICAgICAgc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGlvbkNoYW5nZXMubm9kZXMuYWRkZWQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlQ2xpY2tFdmVudChcInNlbGVjdE5vZGVcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0aW9uQ2hhbmdlcy5lZGdlcy5hZGRlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDbGlja0V2ZW50KFwic2VsZWN0RWRnZVwiLCBldmVudCwgcG9pbnRlcik7XG4gICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gZmlyZSB0aGUgc2VsZWN0IGV2ZW50IGlmIGFueXRoaW5nIGhhcyBiZWVuIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWRcbiAgICAgIGlmIChzZWxlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBzZWxlY3Qgb3IgdW5zZWxlY3RcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJzZWxlY3RcIiwgZXZlbnQsIHBvaW50ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbm9kZSBhbmQgZWRnZSBpZHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7e25vZGVzOiBBcnJheS48c3RyaW5nPiwgZWRnZXM6IEFycmF5LjxzdHJpbmc+fX0gQXJyYXlzIHdpdGggdGhlXG4gICAgICogaWRzIG9mIHRoZSBzZWxlY3RlZCBub2RlcyBhbmQgZWRnZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VsZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNlbGVjdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVzOiB0aGlzLmdldFNlbGVjdGVkTm9kZUlkcygpLFxuICAgICAgICBlZGdlczogdGhpcy5nZXRTZWxlY3RlZEVkZ2VJZHMoKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSB3aXRoIHNlbGVjdGVkIG5vZGVzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGVkTm9kZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWROb2RlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXROb2RlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZWRnZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IHdpdGggc2VsZWN0ZWQgZWRnZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VsZWN0ZWRFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZEVkZ2VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmdldEVkZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBub2RlIGlkcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZSBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTZWxlY3RlZE5vZGVJZHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWROb2RlSWRzKCkge1xuICAgICAgdmFyIF9jb250ZXh0O1xuICAgICAgcmV0dXJuIF9tYXBJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0ID0gdGhpcy5fc2VsZWN0aW9uQWNjdW11bGF0b3IuZ2V0Tm9kZXMoKSkuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuaWQ7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGVkZ2UgaWRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlIHNlbGVjdGVkIGVkZ2VzLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNlbGVjdGVkRWRnZUlkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWxlY3RlZEVkZ2VJZHMoKSB7XG4gICAgICB2YXIgX2NvbnRleHQyO1xuICAgICAgcmV0dXJuIF9tYXBJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MiA9IHRoaXMuX3NlbGVjdGlvbkFjY3VtdWxhdG9yLmdldEVkZ2VzKCkpLmNhbGwoX2NvbnRleHQyLCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICByZXR1cm4gZWRnZS5pZDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3tub2RlczogQXJyYXkuPHN0cmluZz4sIGVkZ2VzOiBBcnJheS48c3RyaW5nPn19IHNlbGVjdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3B0aW9uc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFNlbGVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICBpZiAoIXNlbGVjdGlvbiB8fCAhc2VsZWN0aW9uLm5vZGVzICYmICFzZWxlY3Rpb24uZWRnZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlNlbGVjdGlvbiBtdXN0IGJlIGFuIG9iamVjdCB3aXRoIG5vZGVzIGFuZC9vciBlZGdlcyBwcm9wZXJ0aWVzXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBmaXJzdCB1bnNlbGVjdCBhbnkgc2VsZWN0ZWQgbm9kZSwgaWYgb3B0aW9uIGlzIHRydWUgb3IgdW5kZWZpbmVkXG4gICAgICBpZiAob3B0aW9ucy51bnNlbGVjdEFsbCB8fCBvcHRpb25zLnVuc2VsZWN0QWxsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGlvbi5ub2Rlcykge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihzZWxlY3Rpb24ubm9kZXMpLFxuICAgICAgICAgIF9zdGVwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW2lkXTtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTm9kZSB3aXRoIGlkIFwiJyArIGlkICsgJ1wiIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3Qgc2VsZWN0IGVkZ2VzIHdpdGggaXRcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0T2JqZWN0KG5vZGUsIG9wdGlvbnMuaGlnaGxpZ2h0RWRnZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0aW9uLmVkZ2VzKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihzZWxlY3Rpb24uZWRnZXMpLFxuICAgICAgICAgIF9zdGVwMjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIF9pZCA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW19pZF07XG4gICAgICAgICAgICBpZiAoIWVkZ2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0VkZ2Ugd2l0aCBpZCBcIicgKyBfaWQgKyAnXCIgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNlbGVjdE9iamVjdChlZGdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlcXVlc3RSZWRyYXdcIik7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5jb21taXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgemVybyBvciBtb3JlIG5vZGVzIHdpdGggdGhlIG9wdGlvbiB0byBoaWdobGlnaHQgZWRnZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW10gfCBzdHJpbmdbXX0gc2VsZWN0aW9uICAgICBBbiBhcnJheSB3aXRoIHRoZSBpZHMgb2YgdGhlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkIG5vZGVzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hpZ2hsaWdodEVkZ2VzXVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdE5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdE5vZGVzKHNlbGVjdGlvbikge1xuICAgICAgdmFyIGhpZ2hsaWdodEVkZ2VzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLmxlbmd0aCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBcIlNlbGVjdGlvbiBtdXN0IGJlIGFuIGFycmF5IHdpdGggaWRzXCI7XG4gICAgICB0aGlzLnNldFNlbGVjdGlvbih7XG4gICAgICAgIG5vZGVzOiBzZWxlY3Rpb25cbiAgICAgIH0sIHtcbiAgICAgICAgaGlnaGxpZ2h0RWRnZXM6IGhpZ2hsaWdodEVkZ2VzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZWxlY3QgemVybyBvciBtb3JlIGVkZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdIHwgc3RyaW5nW119IHNlbGVjdGlvbiAgICAgQW4gYXJyYXkgd2l0aCB0aGUgaWRzIG9mIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCBub2Rlcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZWxlY3RFZGdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RFZGdlcyhzZWxlY3Rpb24pIHtcbiAgICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5sZW5ndGggPT09IHVuZGVmaW5lZCkgdGhyb3cgXCJTZWxlY3Rpb24gbXVzdCBiZSBhbiBhcnJheSB3aXRoIGlkc1wiO1xuICAgICAgdGhpcy5zZXRTZWxlY3Rpb24oe1xuICAgICAgICBlZGdlczogc2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgc2VsZWN0aW9uOiByZW1vdmUgaWRzIG9mIG5vZGVzIHdoaWNoIG5vIGxvbmdlciBleGlzdFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTZWxlY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgbm9kZSBpbiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXROb2RlcygpKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5ub2Rlcywgbm9kZS5pZCkpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5kZWxldGVOb2Rlcyhub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgZWRnZSBpbiB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5nZXRFZGdlcygpKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5lZGdlcywgZWRnZS5pZCkpIHtcbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25BY2N1bXVsYXRvci5kZWxldGVFZGdlcyhlZGdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSBhbGwgdGhlIHZpc3VhbCBlbGVtZW50cyBjbGlja2VkIHdoaWNoIGFyZSBvbiB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAgICpcbiAgICAgKiBBbGwgZWxlbWVudHMgYXJlIHJldHVybmVkOyB0aGlzIGluY2x1ZGVzIG5vZGVzLCBlZGdlcyBhbmQgdGhlaXIgbGFiZWxzLlxuICAgICAqIFRoZSBvcmRlciByZXR1cm5lZCBpcyBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0LCBpLmUuIGVsZW1lbnQgMCBvZiB0aGUgcmV0dXJuXG4gICAgICogdmFsdWUgaXMgdGhlIHRvcG1vc3QgaXRlbSBjbGlja2VkIG9uLlxuICAgICAqXG4gICAgICogVGhlIHJldHVybiB2YWx1ZSBjb25zaXN0cyBvZiBhbiBhcnJheSBvZiB0aGUgZm9sbG93aW5nIHBvc3NpYmxlIGVsZW1lbnRzOlxuICAgICAqXG4gICAgICogLSBge25vZGVJZDpudW1iZXJ9YCAgICAgICAgICAgICAtIG5vZGUgd2l0aCBnaXZlbiBpZCBjbGlja2VkIG9uXG4gICAgICogLSBge25vZGVJZDpudW1iZXIsIGxhYmVsSWQ6MH1gICAtIGxhYmVsIG9mIG5vZGUgd2l0aCBnaXZlbiBpZCBjbGlja2VkIG9uXG4gICAgICogLSBge2VkZ2VJZDpudW1iZXJ9YCAgICAgICAgICAgICAtIGVkZ2Ugd2l0aCBnaXZlbiBpZCBjbGlja2VkIG9uXG4gICAgICogLSBge2VkZ2U6bnVtYmVyLCBsYWJlbElkOjB9YCAgICAtIGxhYmVsIG9mIGVkZ2Ugd2l0aCBnaXZlbiBpZCBjbGlja2VkIG9uXG4gICAgICpcbiAgICAgKiAjIyBOT1RFU1xuICAgICAqXG4gICAgICogLSBDdXJyZW50bHksIHRoZXJlIGlzIG9ubHkgb25lIGxhYmVsIGFzc29jaWF0ZWQgd2l0aCBhIG5vZGUgb3IgYW4gZWRnZSxcbiAgICAgKiAgIGJ1dCB0aGlzIGlzIGV4cGVjdGVkIHRvIGNoYW5nZSBzb21ld2hlcmUgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKiAtIFNpbmNlIHRoZXJlIGlzIG5vIHotaW5kZXhpbmcgeWV0LCBpdCBpcyBub3QgcmVhbGx5IHBvc3NpYmxlIHRvIHNldCB0aGUgbm9kZXMgYW5kXG4gICAgICogICBlZGdlcyBpbiB0aGUgY29ycmVjdCBvcmRlci4gRm9yIHRoZSB0aW1lIGJlaW5nLCBub2RlcyBjb21lIGZpcnN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtwb2ludH0gcG9pbnRlciAgbW91c2UgcG9zaXRpb24gaW4gc2NyZWVuIGNvb3JkaW5hdGVzXG4gICAgICogQHJldHVybnMge0FycmF5Ljxub2RlQ2xpY2tJdGVtfG5vZGVMYWJlbENsaWNrSXRlbXxlZGdlQ2xpY2tJdGVtfGVkZ2VMYWJlbENsaWNrSXRlbT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDbGlja2VkSXRlbXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xpY2tlZEl0ZW1zKHBvaW50ZXIpIHtcbiAgICAgIHZhciBwb2ludCA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHBvaW50ZXIpO1xuICAgICAgdmFyIGl0ZW1zID0gW107XG5cbiAgICAgIC8vIE5vdGUgcmV2ZXJzZSBvcmRlcjsgd2Ugd2FudCB0aGUgdG9wbW9zdCBjbGlja2VkIGl0ZW1zIHRvIGJlIGZpcnN0IGluIHRoZSBhcnJheVxuICAgICAgLy8gQWxzbyBub3RlIHRoYXQgc2VsZWN0ZWQgbm9kZXMgYXJlIGRpc3JlZ2FyZGVkIGhlcmU7IHRoZXNlIG5vcm1hbGx5IGRpc3BsYXkgb24gdG9wXG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICBmb3IgKHZhciBpID0gbm9kZUluZGljZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tub2RlSW5kaWNlc1tpXV07XG4gICAgICAgIHZhciByZXQgPSBub2RlLmdldEl0ZW1zT25Qb2ludChwb2ludCk7XG4gICAgICAgIGl0ZW1zLnB1c2guYXBwbHkoaXRlbXMsIHJldCk7IC8vIEFwcGVuZCB0aGUgcmV0dXJuIHZhbHVlIHRvIHRoZSBydW5uaW5nIGxpc3QuXG4gICAgICB9XG5cbiAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHRoaXMuYm9keS5lZGdlSW5kaWNlcztcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgICAgIGZvciAodmFyIF9pID0gZWRnZUluZGljZXMubGVuZ3RoIC0gMTsgX2kgPj0gMDsgX2ktLSkge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2VkZ2VJbmRpY2VzW19pXV07XG4gICAgICAgIHZhciBfcmV0ID0gZWRnZS5nZXRJdGVtc09uUG9pbnQocG9pbnQpO1xuICAgICAgICBpdGVtcy5wdXNoLmFwcGx5KGl0ZW1zLCBfcmV0KTsgLy8gQXBwZW5kIHRoZSByZXR1cm4gdmFsdWUgdG8gdGhlIHJ1bm5pbmcgbGlzdC5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU2VsZWN0aW9uSGFuZGxlcjtcbn0oKTtcblxudmFyIGFycmF5U2xpY2UgPSBhcnJheVNsaWNlU2ltcGxlO1xuXG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG52YXIgbWVyZ2VTb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIG1pZGRsZSA9IGZsb29yKGxlbmd0aCAvIDIpO1xuICByZXR1cm4gbGVuZ3RoIDwgOCA/IGluc2VydGlvblNvcnQoYXJyYXksIGNvbXBhcmVmbikgOiBtZXJnZShcbiAgICBhcnJheSxcbiAgICBtZXJnZVNvcnQoYXJyYXlTbGljZShhcnJheSwgMCwgbWlkZGxlKSwgY29tcGFyZWZuKSxcbiAgICBtZXJnZVNvcnQoYXJyYXlTbGljZShhcnJheSwgbWlkZGxlKSwgY29tcGFyZWZuKSxcbiAgICBjb21wYXJlZm5cbiAgKTtcbn07XG5cbnZhciBpbnNlcnRpb25Tb3J0ID0gZnVuY3Rpb24gKGFycmF5LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgdmFyIGkgPSAxO1xuICB2YXIgZWxlbWVudCwgajtcblxuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIGogPSBpO1xuICAgIGVsZW1lbnQgPSBhcnJheVtpXTtcbiAgICB3aGlsZSAoaiAmJiBjb21wYXJlZm4oYXJyYXlbaiAtIDFdLCBlbGVtZW50KSA+IDApIHtcbiAgICAgIGFycmF5W2pdID0gYXJyYXlbLS1qXTtcbiAgICB9XG4gICAgaWYgKGogIT09IGkrKykgYXJyYXlbal0gPSBlbGVtZW50O1xuICB9IHJldHVybiBhcnJheTtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uIChhcnJheSwgbGVmdCwgcmlnaHQsIGNvbXBhcmVmbikge1xuICB2YXIgbGxlbmd0aCA9IGxlZnQubGVuZ3RoO1xuICB2YXIgcmxlbmd0aCA9IHJpZ2h0Lmxlbmd0aDtcbiAgdmFyIGxpbmRleCA9IDA7XG4gIHZhciByaW5kZXggPSAwO1xuXG4gIHdoaWxlIChsaW5kZXggPCBsbGVuZ3RoIHx8IHJpbmRleCA8IHJsZW5ndGgpIHtcbiAgICBhcnJheVtsaW5kZXggKyByaW5kZXhdID0gKGxpbmRleCA8IGxsZW5ndGggJiYgcmluZGV4IDwgcmxlbmd0aClcbiAgICAgID8gY29tcGFyZWZuKGxlZnRbbGluZGV4XSwgcmlnaHRbcmluZGV4XSkgPD0gMCA/IGxlZnRbbGluZGV4KytdIDogcmlnaHRbcmluZGV4KytdXG4gICAgICA6IGxpbmRleCA8IGxsZW5ndGggPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXTtcbiAgfSByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgYXJyYXlTb3J0ID0gbWVyZ2VTb3J0O1xuXG52YXIgdXNlckFnZW50JDEgPSBlbmdpbmVVc2VyQWdlbnQ7XG5cbnZhciBmaXJlZm94ID0gdXNlckFnZW50JDEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvaSk7XG5cbnZhciBlbmdpbmVGZlZlcnNpb24gPSAhIWZpcmVmb3ggJiYgK2ZpcmVmb3hbMV07XG5cbnZhciBVQSA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIGVuZ2luZUlzSWVPckVkZ2UgPSAvTVNJRXxUcmlkZW50Ly50ZXN0KFVBKTtcblxudmFyIHVzZXJBZ2VudCA9IGVuZ2luZVVzZXJBZ2VudDtcblxudmFyIHdlYmtpdCA9IHVzZXJBZ2VudC5tYXRjaCgvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vKTtcblxudmFyIGVuZ2luZVdlYmtpdFZlcnNpb24gPSAhIXdlYmtpdCAmJiArd2Via2l0WzFdO1xuXG52YXIgJCQyID0gX2V4cG9ydDtcbnZhciB1bmN1cnJ5VGhpcyA9IGZ1bmN0aW9uVW5jdXJyeVRoaXM7XG52YXIgYUNhbGxhYmxlJDEgPSBhQ2FsbGFibGUkNztcbnZhciB0b09iamVjdCQxID0gdG9PYmplY3QkZTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSQxID0gbGVuZ3RoT2ZBcnJheUxpa2UkYztcbnZhciBkZWxldGVQcm9wZXJ0eU9yVGhyb3cgPSBkZWxldGVQcm9wZXJ0eU9yVGhyb3ckMjtcbnZhciB0b1N0cmluZyA9IHRvU3RyaW5nJGE7XG52YXIgZmFpbHMgPSBmYWlscyR3O1xudmFyIGludGVybmFsU29ydCA9IGFycmF5U29ydDtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0JDIgPSBhcnJheU1ldGhvZElzU3RyaWN0JDY7XG52YXIgRkYgPSBlbmdpbmVGZlZlcnNpb247XG52YXIgSUVfT1JfRURHRSA9IGVuZ2luZUlzSWVPckVkZ2U7XG52YXIgVjggPSBlbmdpbmVWOFZlcnNpb247XG52YXIgV0VCS0lUID0gZW5naW5lV2Via2l0VmVyc2lvbjtcblxudmFyIHRlc3QgPSBbXTtcbnZhciBuYXRpdmVTb3J0ID0gdW5jdXJyeVRoaXModGVzdC5zb3J0KTtcbnZhciBwdXNoID0gdW5jdXJyeVRoaXModGVzdC5wdXNoKTtcblxuLy8gSUU4LVxudmFyIEZBSUxTX09OX1VOREVGSU5FRCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdGVzdC5zb3J0KHVuZGVmaW5lZCk7XG59KTtcbi8vIFY4IGJ1Z1xudmFyIEZBSUxTX09OX05VTEwgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHRlc3Quc29ydChudWxsKTtcbn0pO1xuLy8gT2xkIFdlYktpdFxudmFyIFNUUklDVF9NRVRIT0QkMSA9IGFycmF5TWV0aG9kSXNTdHJpY3QkMignc29ydCcpO1xuXG52YXIgU1RBQkxFX1NPUlQgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBmZWF0dXJlIGRldGVjdGlvbiBjYW4gYmUgdG9vIHNsb3csIHNvIGNoZWNrIGVuZ2luZXMgdmVyc2lvbnNcbiAgaWYgKFY4KSByZXR1cm4gVjggPCA3MDtcbiAgaWYgKEZGICYmIEZGID4gMykgcmV0dXJuO1xuICBpZiAoSUVfT1JfRURHRSkgcmV0dXJuIHRydWU7XG4gIGlmIChXRUJLSVQpIHJldHVybiBXRUJLSVQgPCA2MDM7XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgY29kZSwgY2hyLCB2YWx1ZSwgaW5kZXg7XG5cbiAgLy8gZ2VuZXJhdGUgYW4gYXJyYXkgd2l0aCBtb3JlIDUxMiBlbGVtZW50cyAoQ2hha3JhIGFuZCBvbGQgVjggZmFpbHMgb25seSBpbiB0aGlzIGNhc2UpXG4gIGZvciAoY29kZSA9IDY1OyBjb2RlIDwgNzY7IGNvZGUrKykge1xuICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG5cbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgNjY6IGNhc2UgNjk6IGNhc2UgNzA6IGNhc2UgNzI6IHZhbHVlID0gMzsgYnJlYWs7XG4gICAgICBjYXNlIDY4OiBjYXNlIDcxOiB2YWx1ZSA9IDQ7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogdmFsdWUgPSAyO1xuICAgIH1cblxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IDQ3OyBpbmRleCsrKSB7XG4gICAgICB0ZXN0LnB1c2goeyBrOiBjaHIgKyBpbmRleCwgdjogdmFsdWUgfSk7XG4gICAgfVxuICB9XG5cbiAgdGVzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiLnYgLSBhLnY7IH0pO1xuXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRlc3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY2hyID0gdGVzdFtpbmRleF0uay5jaGFyQXQoMCk7XG4gICAgaWYgKHJlc3VsdC5jaGFyQXQocmVzdWx0Lmxlbmd0aCAtIDEpICE9PSBjaHIpIHJlc3VsdCArPSBjaHI7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0ICE9PSAnREdCRUZIQUNJSksnO1xufSk7XG5cbnZhciBGT1JDRUQkMSA9IEZBSUxTX09OX1VOREVGSU5FRCB8fCAhRkFJTFNfT05fTlVMTCB8fCAhU1RSSUNUX01FVEhPRCQxIHx8ICFTVEFCTEVfU09SVDtcblxudmFyIGdldFNvcnRDb21wYXJlID0gZnVuY3Rpb24gKGNvbXBhcmVmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gLTE7XG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkgcmV0dXJuIDE7XG4gICAgaWYgKGNvbXBhcmVmbiAhPT0gdW5kZWZpbmVkKSByZXR1cm4gK2NvbXBhcmVmbih4LCB5KSB8fCAwO1xuICAgIHJldHVybiB0b1N0cmluZyh4KSA+IHRvU3RyaW5nKHkpID8gMSA6IC0xO1xuICB9O1xufTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvcnRcbiQkMih7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEJDEgfSwge1xuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgIGlmIChjb21wYXJlZm4gIT09IHVuZGVmaW5lZCkgYUNhbGxhYmxlJDEoY29tcGFyZWZuKTtcblxuICAgIHZhciBhcnJheSA9IHRvT2JqZWN0JDEodGhpcyk7XG5cbiAgICBpZiAoU1RBQkxFX1NPUlQpIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZCA/IG5hdGl2ZVNvcnQoYXJyYXkpIDogbmF0aXZlU29ydChhcnJheSwgY29tcGFyZWZuKTtcblxuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHZhciBhcnJheUxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDEoYXJyYXkpO1xuICAgIHZhciBpdGVtc0xlbmd0aCwgaW5kZXg7XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBhcnJheUxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGluZGV4IGluIGFycmF5KSBwdXNoKGl0ZW1zLCBhcnJheVtpbmRleF0pO1xuICAgIH1cblxuICAgIGludGVybmFsU29ydChpdGVtcywgZ2V0U29ydENvbXBhcmUoY29tcGFyZWZuKSk7XG5cbiAgICBpdGVtc0xlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlJDEoaXRlbXMpO1xuICAgIGluZGV4ID0gMDtcblxuICAgIHdoaWxlIChpbmRleCA8IGl0ZW1zTGVuZ3RoKSBhcnJheVtpbmRleF0gPSBpdGVtc1tpbmRleCsrXTtcbiAgICB3aGlsZSAoaW5kZXggPCBhcnJheUxlbmd0aCkgZGVsZXRlUHJvcGVydHlPclRocm93KGFycmF5LCBpbmRleCsrKTtcblxuICAgIHJldHVybiBhcnJheTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwkMiA9IGVudHJ5VmlydHVhbCRpO1xuXG52YXIgc29ydCQzID0gZW50cnlWaXJ0dWFsJDIoJ0FycmF5Jykuc29ydDtcblxudmFyIGlzUHJvdG90eXBlT2YkMiA9IG9iamVjdElzUHJvdG90eXBlT2Y7XG52YXIgbWV0aG9kJDIgPSBzb3J0JDM7XG5cbnZhciBBcnJheVByb3RvdHlwZSQyID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgc29ydCQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5zb3J0O1xuICByZXR1cm4gaXQgPT09IEFycmF5UHJvdG90eXBlJDIgfHwgKGlzUHJvdG90eXBlT2YkMihBcnJheVByb3RvdHlwZSQyLCBpdCkgJiYgb3duID09PSBBcnJheVByb3RvdHlwZSQyLnNvcnQpID8gbWV0aG9kJDIgOiBvd247XG59O1xuXG52YXIgcGFyZW50JDIgPSBzb3J0JDI7XG5cbnZhciBzb3J0JDEgPSBwYXJlbnQkMjtcblxudmFyIHNvcnQgPSBzb3J0JDE7XG5cbnZhciBfc29ydEluc3RhbmNlUHJvcGVydHkgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoc29ydCk7XG5cbnZhciBhQ2FsbGFibGUgPSBhQ2FsbGFibGUkNztcbnZhciB0b09iamVjdCA9IHRvT2JqZWN0JGU7XG52YXIgSW5kZXhlZE9iamVjdCA9IGluZGV4ZWRPYmplY3Q7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBsZW5ndGhPZkFycmF5TGlrZSRjO1xuXG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IHJlZHVjZSwgcmVkdWNlUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19SSUdIVCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c0xlbmd0aCwgbWVtbykge1xuICAgIGFDYWxsYWJsZShjYWxsYmFja2ZuKTtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gICAgdmFyIGluZGV4ID0gSVNfUklHSFQgPyBsZW5ndGggLSAxIDogMDtcbiAgICB2YXIgaSA9IElTX1JJR0hUID8gLTEgOiAxO1xuICAgIGlmIChhcmd1bWVudHNMZW5ndGggPCAyKSB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgICAgbWVtbyA9IHNlbGZbaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGluZGV4ICs9IGk7XG4gICAgICBpZiAoSVNfUklHSFQgPyBpbmRleCA8IDAgOiBsZW5ndGggPD0gaW5kZXgpIHtcbiAgICAgICAgdGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICg7SVNfUklHSFQgPyBpbmRleCA+PSAwIDogbGVuZ3RoID4gaW5kZXg7IGluZGV4ICs9IGkpIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICBtZW1vID0gY2FsbGJhY2tmbihtZW1vLCBzZWxmW2luZGV4XSwgaW5kZXgsIE8pO1xuICAgIH1cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn07XG5cbnZhciBhcnJheVJlZHVjZSA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcbiAgbGVmdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZXJpZ2h0XG4gIHJpZ2h0OiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG5cbnZhciBnbG9iYWwkMSA9IGdsb2JhbCRuO1xudmFyIGNsYXNzb2YgPSBjbGFzc29mUmF3JDI7XG5cbnZhciBlbmdpbmVJc05vZGUgPSBjbGFzc29mKGdsb2JhbCQxLnByb2Nlc3MpID09PSAncHJvY2Vzcyc7XG5cbnZhciAkJDEgPSBfZXhwb3J0O1xudmFyICRyZWR1Y2UgPSBhcnJheVJlZHVjZS5sZWZ0O1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QkMSA9IGFycmF5TWV0aG9kSXNTdHJpY3QkNjtcbnZhciBDSFJPTUVfVkVSU0lPTiA9IGVuZ2luZVY4VmVyc2lvbjtcbnZhciBJU19OT0RFID0gZW5naW5lSXNOb2RlO1xuXG4vLyBDaHJvbWUgODAtODIgaGFzIGEgY3JpdGljYWwgYnVnXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xMDQ5OTgyXG52YXIgQ0hST01FX0JVRyA9ICFJU19OT0RFICYmIENIUk9NRV9WRVJTSU9OID4gNzkgJiYgQ0hST01FX1ZFUlNJT04gPCA4MztcbnZhciBGT1JDRUQgPSBDSFJPTUVfQlVHIHx8ICFhcnJheU1ldGhvZElzU3RyaWN0JDEoJ3JlZHVjZScpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcbiQkMSh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgcmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHJldHVybiAkcmVkdWNlKHRoaXMsIGNhbGxiYWNrZm4sIGxlbmd0aCwgbGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG52YXIgZW50cnlWaXJ0dWFsJDEgPSBlbnRyeVZpcnR1YWwkaTtcblxudmFyIHJlZHVjZSQzID0gZW50cnlWaXJ0dWFsJDEoJ0FycmF5JykucmVkdWNlO1xuXG52YXIgaXNQcm90b3R5cGVPZiQxID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QkMSA9IHJlZHVjZSQzO1xuXG52YXIgQXJyYXlQcm90b3R5cGUkMSA9IEFycmF5LnByb3RvdHlwZTtcblxudmFyIHJlZHVjZSQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5yZWR1Y2U7XG4gIHJldHVybiBpdCA9PT0gQXJyYXlQcm90b3R5cGUkMSB8fCAoaXNQcm90b3R5cGVPZiQxKEFycmF5UHJvdG90eXBlJDEsIGl0KSAmJiBvd24gPT09IEFycmF5UHJvdG90eXBlJDEucmVkdWNlKSA/IG1ldGhvZCQxIDogb3duO1xufTtcblxudmFyIHBhcmVudCQxID0gcmVkdWNlJDI7XG5cbnZhciByZWR1Y2UkMSA9IHBhcmVudCQxO1xuXG52YXIgcmVkdWNlID0gcmVkdWNlJDE7XG5cbnZhciBfcmVkdWNlSW5zdGFuY2VQcm9wZXJ0eSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhyZWR1Y2UpO1xuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gX1JlZmxlY3QkY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhX1JlZmxlY3QkY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChfUmVmbGVjdCRjb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoX1JlZmxlY3QkY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuLyoqXG4gKiBIZWxwZXIgY2xhc3NlcyBmb3IgTGF5b3V0RW5naW5lLlxuICpcbiAqIFN0cmF0ZWd5IHBhdHRlcm4gZm9yIHVzYWdlIG9mIGRpcmVjdGlvbiBtZXRob2RzIGZvciBoaWVyYXJjaGljYWwgbGF5b3V0cy5cbiAqL1xuLyoqXG4gKiBJbnRlcmZhY2UgZGVmaW5pdGlvbiBmb3IgZGlyZWN0aW9uIHN0cmF0ZWd5IGNsYXNzZXMuXG4gKlxuICogVGhpcyBjbGFzcyBkZXNjcmliZXMgdGhlIGludGVyZmFjZSBmb3IgdGhlIFN0cmF0ZWd5XG4gKiBwYXR0ZXJuIGNsYXNzZXMgdXNlZCB0byBkaWZmZXJlbnRpYXRlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsXG4gKiBkaXJlY3Rpb24gb2YgaGllcmFyY2hpY2FsIHJlc3VsdHMuXG4gKlxuICogRm9yIGEgZ2l2ZW4gZGlyZWN0aW9uLCBvbmUgY29vcmRpbmF0ZSB3aWxsIGJlICdmaXhlZCcsIG1lYW5pbmcgdGhhdCBpdCBpc1xuICogZGV0ZXJtaW5lZCBieSBsZXZlbC5cbiAqIFRoZSBvdGhlciBjb29yZGluYXRlIGlzICd1bmZpeGVkJywgbWVhbmluZyB0aGF0IHRoZSBub2RlcyBvbiBhIGdpdmVuIGxldmVsXG4gKiBjYW4gc3RpbGwgbW92ZSBhbG9uZyB0aGF0IGNvb3JkaW5hdGUuIFNvOlxuICpcbiAqIC0gYHZlcnRpY2FsYCBsYXlvdXQ6IGB4YCB1bmZpeGVkLCBgeWAgZml4ZWQgcGVyIGxldmVsXG4gKiAtIGBob3Jpem9udGFsYCBsYXlvdXQ6IGB4YCBmaXhlZCBwZXIgbGV2ZWwsIGB5YCB1bmZpeGVkXG4gKlxuICogVGhlIGxvY2FsIG1ldGhvZHMgYXJlIHN0dWJzIGFuZCBzaG91bGQgYmUgcmVnYXJkZWQgYXMgYWJzdHJhY3QuXG4gKiBEZXJpdmVkIGNsYXNzZXMgKiptdXN0KiogaW1wbGVtZW50IGFsbCB0aGUgbWV0aG9kcyB0aGVtc2VsdmVzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBEaXJlY3Rpb25JbnRlcmZhY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEaXJlY3Rpb25JbnRlcmZhY2UoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpcmVjdGlvbkludGVyZmFjZSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKERpcmVjdGlvbkludGVyZmFjZSwgW3tcbiAgICBrZXk6IFwiYWJzdHJhY3RcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBpbnN0YW50aWF0ZSBhYnN0cmFjdCBjbGFzcyFcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBhIGR1bW15IGNhbGwgd2hpY2ggaXMgdXNlZCB0byBzdXBwcmVzcyB0aGUganNkb2MgZXJyb3JzIG9mIHR5cGU6XG4gICAgICpcbiAgICAgKiAgIFwiJ3BhcmFtJyBpcyBhc3NpZ25lZCBhIHZhbHVlIGJ1dCBuZXZlciB1c2VkXCJcbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmYWtlX3VzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmYWtlX3VzZSgpIHtcbiAgICAgIC8vIERvIG5vdGhpbmcgc3BlY2lhbFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFR5cGUgdG8gdXNlIHRvIHRyYW5zbGF0ZSBkeW5hbWljIGN1cnZlcyB0bywgaW4gdGhlIGNhc2Ugb2YgaGllcmFyY2hpY2FsIGxheW91dC5cbiAgICAgKiBEeW5hbWljIGN1cnZlcyBkbyBub3Qgd29yayBmb3IgdGhlc2UuXG4gICAgICpcbiAgICAgKiBUaGUgdmFsdWUgc2hvdWxkIGJlIHBlcnBlbmRpY3VsYXIgdG8gdGhlIGFjdHVhbCBkaXJlY3Rpb24gb2YgdGhlIGxheW91dC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IERpcmVjdGlvbiwgZWl0aGVyICd2ZXJ0aWNhbCcgb3IgJ2hvcml6b250YWwnXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY3VydmVUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGN1cnZlVHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgY29vcmRpbmF0ZSB0aGF0IGlzIG5vdCBmaXhlZCBmb3IgdGhpcyBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVhZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIG9mIHRoZSB1bmZpeGVkIGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb3NpdGlvbihub2RlKSB7XG4gICAgICB0aGlzLmZha2VfdXNlKG5vZGUpO1xuICAgICAgcmV0dXJuIHRoaXMuYWJzdHJhY3QoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSBjb29yZGluYXRlIHRoYXQgaXMgbm90IGZpeGVkIGZvciB0aGlzIGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byBhZGp1c3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xldmVsXSBpZiBzcGVjaWZpZWQsIHRoZSBoaWVyYXJjaHkgbGV2ZWwgdGhhdCB0aGlzIG5vZGUgc2hvdWxkIGJlIGZpeGVkIHRvXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UG9zaXRpb24obm9kZSwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBsZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5mYWtlX3VzZShub2RlLCBwb3NpdGlvbiwgbGV2ZWwpO1xuICAgICAgdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgd2lkdGggb2YgYSB0cmVlLlxuICAgICAqXG4gICAgICogQSBgdHJlZWAgaGVyZSBpcyBhIHN1YnNldCBvZiBub2RlcyB3aXRoaW4gdGhlIG5ldHdvcmsgd2hpY2ggYXJlIG5vdCBjb25uZWN0ZWQgdG8gb3RoZXIgbm9kZXMsXG4gICAgICogb25seSBhbW9uZyB0aGVtc2VsdmVzLiBJbiBlc3NlbmNlLCBpdCBpcyBhIHN1Yi1uZXR3b3JrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBudW1iZXIgb2YgYSB0cmVlXG4gICAgICogQHJldHVybnMge251bWJlcn0gdGhlIHdpZHRoIG9mIGEgdHJlZSBpbiB0aGUgdmlldyBjb29yZGluYXRlc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFRyZWVTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRyZWVTaXplKGluZGV4KSB7XG4gICAgICB0aGlzLmZha2VfdXNlKGluZGV4KTtcbiAgICAgIHJldHVybiB0aGlzLmFic3RyYWN0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU29ydCBhcnJheSBvZiBub2RlcyBvbiB0aGUgdW5maXhlZCBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIE5vdGU6KiogY2hyb21lIGhhcyBub24tc3RhYmxlIHNvcnRpbmcgaW1wbGVtZW50YXRpb24sIHdoaWNoXG4gICAgICogaGFzIGEgdGVuZGVuY3kgdG8gY2hhbmdlIHRoZSBvcmRlciBvZiB0aGUgYXJyYXkgaXRlbXMsXG4gICAgICogZXZlbiBpZiB0aGUgY3VzdG9tIHNvcnQgZnVuY3Rpb24gcmV0dXJucyAwLlxuICAgICAqXG4gICAgICogRm9yIHRoaXMgcmVhc29uLCBhbiBleHRlcm5hbCBzb3J0IGltcGxlbWVudGF0aW9uIGlzIHVzZWQsXG4gICAgICogd2hpY2ggaGFzIHRoZSBhZGRlZCBiZW5lZml0IG9mIGJlaW5nIGZhc3RlciB0aGFuIHRoZSBzdGFuZGFyZFxuICAgICAqIHBsYXRmb3JtcyBpbXBsZW1lbnRhdGlvbi4gVGhpcyBoYXMgYmVlbiB2ZXJpZmllZCBvbiBgbm9kZS5qc2AsXG4gICAgICogYGZpcmVmb3hgIGFuZCBgY2hyb21lYCAoYWxsIGxpbnV4KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBub2RlQXJyYXkgYXJyYXkgb2Ygbm9kZXMgdG8gc29ydFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc29ydChub2RlQXJyYXkpIHtcbiAgICAgIHRoaXMuZmFrZV91c2Uobm9kZUFycmF5KTtcbiAgICAgIHRoaXMuYWJzdHJhY3QoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ24gdGhlIGZpeGVkIGNvb3JkaW5hdGUgb2YgdGhlIG5vZGUgdG8gdGhlIGdpdmVuIGxldmVsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gYWRqdXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsIFRoZSBsZXZlbCB0byBmaXggdG9cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml4KG5vZGUsIGxldmVsKSB7XG4gICAgICB0aGlzLmZha2VfdXNlKG5vZGUsIGxldmVsKTtcbiAgICAgIHRoaXMuYWJzdHJhY3QoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gb2Zmc2V0IHRvIHRoZSB1bmZpeGVkIGNvb3JkaW5hdGUgb2YgdGhlIGdpdmVuIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGVJZH0gbm9kZUlkIElkIG9mIHRoZSBub2RlIHRvIGFkanVzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaWZmIE9mZnNldCB0byBhZGQgdG8gdGhlIHVuZml4ZWQgY29vcmRpbmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KG5vZGVJZCwgZGlmZikge1xuICAgICAgdGhpcy5mYWtlX3VzZShub2RlSWQsIGRpZmYpO1xuICAgICAgdGhpcy5hYnN0cmFjdCgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRGlyZWN0aW9uSW50ZXJmYWNlO1xufSgpO1xuLyoqXG4gKiBWZXJ0aWNhbCBTdHJhdGVneVxuICpcbiAqIENvb3JkaW5hdGUgYHlgIGlzIGZpeGVkIG9uIGxldmVscywgY29vcmRpbmF0ZSBgeGAgaXMgdW5maXhlZC5cbiAqXG4gKiBAYXVnbWVudHMgRGlyZWN0aW9uSW50ZXJmYWNlXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgVmVydGljYWxTdHJhdGVneSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0RpcmVjdGlvbkludGVyZmFjZSkge1xuICBfaW5oZXJpdHMoVmVydGljYWxTdHJhdGVneSwgX0RpcmVjdGlvbkludGVyZmFjZSk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVmVydGljYWxTdHJhdGVneSk7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbGF5b3V0IHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IExheW91dEVuZ2luZSBpbnN0YW5jZS5cbiAgICovXG4gIGZ1bmN0aW9uIFZlcnRpY2FsU3RyYXRlZ3kobGF5b3V0KSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWZXJ0aWNhbFN0cmF0ZWd5KTtcbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF90aGlzLmxheW91dCA9IGxheW91dDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKiogQGluaGVyaXREb2MgKi9cbiAgX2NyZWF0ZUNsYXNzKFZlcnRpY2FsU3RyYXRlZ3ksIFt7XG4gICAga2V5OiBcImN1cnZlVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjdXJ2ZVR5cGUoKSB7XG4gICAgICByZXR1cm4gXCJob3Jpem9udGFsXCI7XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UG9zaXRpb24obm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUueDtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQb3NpdGlvbihub2RlLCBwb3NpdGlvbikge1xuICAgICAgdmFyIGxldmVsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxheW91dC5oaWVyYXJjaGljYWwuYWRkVG9PcmRlcmluZyhub2RlLCBsZXZlbCk7XG4gICAgICB9XG4gICAgICBub2RlLnggPSBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmVlU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmVlU2l6ZShpbmRleCkge1xuICAgICAgdmFyIHJlcyA9IHRoaXMubGF5b3V0LmhpZXJhcmNoaWNhbC5nZXRUcmVlU2l6ZSh0aGlzLmxheW91dC5ib2R5Lm5vZGVzLCBpbmRleCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW46IHJlcy5taW5feCxcbiAgICAgICAgbWF4OiByZXMubWF4X3hcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqIEBpbmhlcml0RG9jICovXG4gIH0sIHtcbiAgICBrZXk6IFwic29ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb3J0KG5vZGVBcnJheSkge1xuICAgICAgX3NvcnRJbnN0YW5jZVByb3BlcnR5KG5vZGVBcnJheSkuY2FsbChub2RlQXJyYXksIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLnggLSBiLng7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJmaXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZml4KG5vZGUsIGxldmVsKSB7XG4gICAgICBub2RlLnkgPSB0aGlzLmxheW91dC5vcHRpb25zLmhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKiBsZXZlbDtcbiAgICAgIG5vZGUub3B0aW9ucy5maXhlZC55ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdChub2RlSWQsIGRpZmYpIHtcbiAgICAgIHRoaXMubGF5b3V0LmJvZHkubm9kZXNbbm9kZUlkXS54ICs9IGRpZmY7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBWZXJ0aWNhbFN0cmF0ZWd5O1xufShEaXJlY3Rpb25JbnRlcmZhY2UpO1xuLyoqXG4gKiBIb3Jpem9udGFsIFN0cmF0ZWd5XG4gKlxuICogQ29vcmRpbmF0ZSBgeGAgaXMgZml4ZWQgb24gbGV2ZWxzLCBjb29yZGluYXRlIGB5YCBpcyB1bmZpeGVkLlxuICpcbiAqIEBhdWdtZW50cyBEaXJlY3Rpb25JbnRlcmZhY2VcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBIb3Jpem9udGFsU3RyYXRlZ3kgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9EaXJlY3Rpb25JbnRlcmZhY2UyKSB7XG4gIF9pbmhlcml0cyhIb3Jpem9udGFsU3RyYXRlZ3ksIF9EaXJlY3Rpb25JbnRlcmZhY2UyKTtcbiAgdmFyIF9zdXBlcjIgPSBfY3JlYXRlU3VwZXIoSG9yaXpvbnRhbFN0cmF0ZWd5KTtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsYXlvdXQgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgTGF5b3V0RW5naW5lIGluc3RhbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gSG9yaXpvbnRhbFN0cmF0ZWd5KGxheW91dCkge1xuICAgIHZhciBfdGhpczI7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhvcml6b250YWxTdHJhdGVneSk7XG4gICAgX3RoaXMyID0gX3N1cGVyMi5jYWxsKHRoaXMpO1xuICAgIF90aGlzMi5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIC8qKiBAaW5oZXJpdERvYyAqL1xuICBfY3JlYXRlQ2xhc3MoSG9yaXpvbnRhbFN0cmF0ZWd5LCBbe1xuICAgIGtleTogXCJjdXJ2ZVR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3VydmVUeXBlKCkge1xuICAgICAgcmV0dXJuIFwidmVydGljYWxcIjtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb3NpdGlvbihub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS55O1xuICAgIH1cblxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvc2l0aW9uKG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgbGV2ZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChsZXZlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubGF5b3V0LmhpZXJhcmNoaWNhbC5hZGRUb09yZGVyaW5nKG5vZGUsIGxldmVsKTtcbiAgICAgIH1cbiAgICAgIG5vZGUueSA9IHBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFRyZWVTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRyZWVTaXplKGluZGV4KSB7XG4gICAgICB2YXIgcmVzID0gdGhpcy5sYXlvdXQuaGllcmFyY2hpY2FsLmdldFRyZWVTaXplKHRoaXMubGF5b3V0LmJvZHkubm9kZXMsIGluZGV4KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogcmVzLm1pbl95LFxuICAgICAgICBtYXg6IHJlcy5tYXhfeVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiogQGluaGVyaXREb2MgKi9cbiAgfSwge1xuICAgIGtleTogXCJzb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNvcnQobm9kZUFycmF5KSB7XG4gICAgICBfc29ydEluc3RhbmNlUHJvcGVydHkobm9kZUFycmF5KS5jYWxsKG5vZGVBcnJheSwgZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEueSAtIGIueTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcImZpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXgobm9kZSwgbGV2ZWwpIHtcbiAgICAgIG5vZGUueCA9IHRoaXMubGF5b3V0Lm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbiAqIGxldmVsO1xuICAgICAgbm9kZS5vcHRpb25zLmZpeGVkLnggPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKiBAaW5oZXJpdERvYyAqL1xuICB9LCB7XG4gICAga2V5OiBcInNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNoaWZ0KG5vZGVJZCwgZGlmZikge1xuICAgICAgdGhpcy5sYXlvdXQuYm9keS5ub2Rlc1tub2RlSWRdLnkgKz0gZGlmZjtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEhvcml6b250YWxTdHJhdGVneTtcbn0oRGlyZWN0aW9uSW50ZXJmYWNlKTtcblxudmFyICQgPSBfZXhwb3J0O1xudmFyICRldmVyeSA9IGFycmF5SXRlcmF0aW9uLmV2ZXJ5O1xudmFyIGFycmF5TWV0aG9kSXNTdHJpY3QgPSBhcnJheU1ldGhvZElzU3RyaWN0JDY7XG5cbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnZXZlcnknKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5ldmVyeWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5ldmVyeVxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogIVNUUklDVF9NRVRIT0QgfSwge1xuICBldmVyeTogZnVuY3Rpb24gZXZlcnkoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJGV2ZXJ5KHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbnZhciBlbnRyeVZpcnR1YWwgPSBlbnRyeVZpcnR1YWwkaTtcblxudmFyIGV2ZXJ5JDMgPSBlbnRyeVZpcnR1YWwoJ0FycmF5JykuZXZlcnk7XG5cbnZhciBpc1Byb3RvdHlwZU9mID0gb2JqZWN0SXNQcm90b3R5cGVPZjtcbnZhciBtZXRob2QgPSBldmVyeSQzO1xuXG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBldmVyeSQyID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBvd24gPSBpdC5ldmVyeTtcbiAgcmV0dXJuIGl0ID09PSBBcnJheVByb3RvdHlwZSB8fCAoaXNQcm90b3R5cGVPZihBcnJheVByb3RvdHlwZSwgaXQpICYmIG93biA9PT0gQXJyYXlQcm90b3R5cGUuZXZlcnkpID8gbWV0aG9kIDogb3duO1xufTtcblxudmFyIHBhcmVudCA9IGV2ZXJ5JDI7XG5cbnZhciBldmVyeSQxID0gcGFyZW50O1xuXG52YXIgZXZlcnkgPSBldmVyeSQxO1xuXG52YXIgX2V2ZXJ5SW5zdGFuY2VQcm9wZXJ0eSA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhldmVyeSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIF9TeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgX2dldEl0ZXJhdG9yTWV0aG9kKG8pIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChfQXJyYXkkaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvLCBtaW5MZW4pIHsgdmFyIF9jb250ZXh0OTsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDEobywgbWluTGVuKTsgdmFyIG4gPSBfc2xpY2VJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0OSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSkuY2FsbChfY29udGV4dDksIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIF9BcnJheSRmcm9tJDEobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQxKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG4vKipcclxuICogVHJ5IHRvIGFzc2lnbiBsZXZlbHMgdG8gbm9kZXMgYWNjb3JkaW5nIHRvIHRoZWlyIHBvc2l0aW9ucyBpbiB0aGUgY3ljbGljIOKAnGhpZXJhcmNoeeKAnS5cclxuICpcclxuICogQHBhcmFtIG5vZGVzIC0gVmlzaWJsZSBub2RlcyBvZiB0aGUgZ3JhcGguXHJcbiAqIEBwYXJhbSBsZXZlbHMgLSBJZiBwcmVzZW50IGxldmVscyB3aWxsIGJlIGFkZGVkIHRvIGl0LCBpZiBub3QgYSBuZXcgb2JqZWN0IHdpbGwgYmUgY3JlYXRlZC5cclxuICogQHJldHVybnMgUG9wdWxhdGVkIG5vZGUgbGV2ZWxzLlxyXG4gKi9cbmZ1bmN0aW9uIGZpbGxMZXZlbHNCeURpcmVjdGlvbkN5Y2xpYyhub2RlcywgbGV2ZWxzKSB7XG4gIHZhciBlZGdlcyA9IG5ldyBfU2V0KCk7XG4gIF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShub2RlcykuY2FsbChub2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgX2NvbnRleHQ7XG4gICAgX2ZvckVhY2hJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0ID0gbm9kZS5lZGdlcykuY2FsbChfY29udGV4dCwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCkge1xuICAgICAgICBlZGdlcy5hZGQoZWRnZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICBfZm9yRWFjaEluc3RhbmNlUHJvcGVydHkoZWRnZXMpLmNhbGwoZWRnZXMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgdmFyIGZyb21JZCA9IGVkZ2UuZnJvbS5pZDtcbiAgICB2YXIgdG9JZCA9IGVkZ2UudG8uaWQ7XG4gICAgaWYgKGxldmVsc1tmcm9tSWRdID09IG51bGwpIHtcbiAgICAgIGxldmVsc1tmcm9tSWRdID0gMDtcbiAgICB9XG4gICAgaWYgKGxldmVsc1t0b0lkXSA9PSBudWxsIHx8IGxldmVsc1tmcm9tSWRdID49IGxldmVsc1t0b0lkXSkge1xuICAgICAgbGV2ZWxzW3RvSWRdID0gbGV2ZWxzW2Zyb21JZF0gKyAxO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBsZXZlbHM7XG59XG4vKipcclxuICogQXNzaWduIGxldmVscyB0byBub2RlcyBhY2NvcmRpbmcgdG8gdGhlaXIgcG9zaXRpb25zIGluIHRoZSBoaWVyYXJjaHkuIExlYXZlcyB3aWxsIGJlIGxpbmVkIHVwIGF0IHRoZSBib3R0b20gYW5kIGFsbCBvdGhlciBub2RlcyBhcyBjbG9zZSB0byB0aGVpciBjaGlsZHJlbiBhcyBwb3NzaWJsZS5cclxuICpcclxuICogQHBhcmFtIG5vZGVzIC0gVmlzaWJsZSBub2RlcyBvZiB0aGUgZ3JhcGguXHJcbiAqIEByZXR1cm5zIFBvcHVsYXRlZCBub2RlIGxldmVscy5cclxuICovXG5mdW5jdGlvbiBmaWxsTGV2ZWxzQnlEaXJlY3Rpb25MZWF2ZXMobm9kZXMpIHtcbiAgcmV0dXJuIGZpbGxMZXZlbHNCeURpcmVjdGlvbihcbiAgLy8gUGljayBvbmx5IGxlYXZlcyAobm9kZXMgd2l0aG91dCBjaGlsZHJlbikuXG4gIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIF9jb250ZXh0MiwgX2NvbnRleHQzO1xuICAgIHJldHVybiBfZXZlcnlJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MiA9IF9maWx0ZXJJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MyA9IG5vZGUuZWRnZXNcbiAgICAvLyBUYWtlIG9ubHkgdmlzaWJsZSBub2RlcyBpbnRvIGFjY291bnQuXG4gICAgKS5jYWxsKF9jb250ZXh0MywgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgIHJldHVybiBub2Rlcy5oYXMoZWRnZS50b0lkKTtcbiAgICB9KVxuICAgIC8vIENoZWNrIHRoYXQgYWxsIGVkZ2VzIGxlYWQgdG8gdGhpcyBub2RlIChsZWFmKS5cbiAgICApLmNhbGwoX2NvbnRleHQyLCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UudG8gPT09IG5vZGU7XG4gICAgfSk7XG4gIH0sXG4gIC8vIFVzZSB0aGUgbG93ZXN0IGxldmVsLlxuICBmdW5jdGlvbiAobmV3TGV2ZWwsIG9sZExldmVsKSB7XG4gICAgcmV0dXJuIG9sZExldmVsID4gbmV3TGV2ZWw7XG4gIH0sXG4gIC8vIEdvIGFnYWluc3QgdGhlIGRpcmVjdGlvbiBvZiB0aGUgZWRnZXMuXG4gIFwiZnJvbVwiLCBub2Rlcyk7XG59XG4vKipcclxuICogQXNzaWduIGxldmVscyB0byBub2RlcyBhY2NvcmRpbmcgdG8gdGhlaXIgcG9zaXRpb25zIGluIHRoZSBoaWVyYXJjaHkuIFJvb3RzIHdpbGwgYmUgbGluZWQgdXAgYXQgdGhlIHRvcCBhbmQgYWxsIG5vZGVzIGFzIGNsb3NlIHRvIHRoZWlyIHBhcmVudHMgYXMgcG9zc2libGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBub2RlcyAtIFZpc2libGUgbm9kZXMgb2YgdGhlIGdyYXBoLlxyXG4gKiBAcmV0dXJucyBQb3B1bGF0ZWQgbm9kZSBsZXZlbHMuXHJcbiAqL1xuZnVuY3Rpb24gZmlsbExldmVsc0J5RGlyZWN0aW9uUm9vdHMobm9kZXMpIHtcbiAgcmV0dXJuIGZpbGxMZXZlbHNCeURpcmVjdGlvbihcbiAgLy8gUGljayBvbmx5IHJvb3RzIChub2RlcyB3aXRob3V0IHBhcmVudHMpLlxuICBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBfY29udGV4dDQsIF9jb250ZXh0NTtcbiAgICByZXR1cm4gX2V2ZXJ5SW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDQgPSBfZmlsdGVySW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDUgPSBub2RlLmVkZ2VzXG4gICAgLy8gVGFrZSBvbmx5IHZpc2libGUgbm9kZXMgaW50byBhY2NvdW50LlxuICAgICkuY2FsbChfY29udGV4dDUsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICByZXR1cm4gbm9kZXMuaGFzKGVkZ2UudG9JZCk7XG4gICAgfSlcbiAgICAvLyBDaGVjayB0aGF0IGFsbCBlZGdlcyBsZWFkIGZyb20gdGhpcyBub2RlIChyb290KS5cbiAgICApLmNhbGwoX2NvbnRleHQ0LCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UuZnJvbSA9PT0gbm9kZTtcbiAgICB9KTtcbiAgfSxcbiAgLy8gVXNlIHRoZSBoaWdoZXN0IGxldmVsLlxuICBmdW5jdGlvbiAobmV3TGV2ZWwsIG9sZExldmVsKSB7XG4gICAgcmV0dXJuIG9sZExldmVsIDwgbmV3TGV2ZWw7XG4gIH0sXG4gIC8vIEdvIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVkZ2VzLlxuICBcInRvXCIsIG5vZGVzKTtcbn1cbi8qKlxyXG4gKiBBc3NpZ24gbGV2ZWxzIHRvIG5vZGVzIGFjY29yZGluZyB0byB0aGVpciBwb3NpdGlvbnMgaW4gdGhlIGhpZXJhcmNoeS5cclxuICpcclxuICogQHBhcmFtIGlzRW50cnlOb2RlIC0gQ2hlY2tzIGFuZCByZXR1cm4gdHJ1ZSBpZiB0aGUgZ3JhcGggc2hvdWxkIGJlIHRyYXZlcnNlZCBmcm9tIHRoaXMgbm9kZS5cclxuICogQHBhcmFtIHNob3VsZExldmVsQmVSZXBsYWNlZCAtIENoZWNrcyBhbmQgcmV0dXJucyB0cnVlIGlmIHRoZSBsZXZlbCBvZiBnaXZlbiBub2RlIHNob3VsZCBiZSB1cGRhdGVkIHRvIHRoZSBuZXcgdmFsdWUuXHJcbiAqIEBwYXJhbSBkaXJlY3Rpb24gLSBXaGV0ZXIgdGhlIGdyYXBoIHNob3VsZCBiZSB0cmF2ZXJzZWQgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgZWRnZXMgYFwidG9cImAgb3IgaW4gdGhlIG90aGVyIHdheSBgXCJmcm9tXCJgLlxyXG4gKiBAcGFyYW0gbm9kZXMgLSBWaXNpYmxlIG5vZGVzIG9mIHRoZSBncmFwaC5cclxuICogQHJldHVybnMgUG9wdWxhdGVkIG5vZGUgbGV2ZWxzLlxyXG4gKi9cbmZ1bmN0aW9uIGZpbGxMZXZlbHNCeURpcmVjdGlvbihpc0VudHJ5Tm9kZSwgc2hvdWxkTGV2ZWxCZVJlcGxhY2VkLCBkaXJlY3Rpb24sIG5vZGVzKSB7XG4gIHZhciBfY29udGV4dDY7XG4gIHZhciBsZXZlbHMgPSBfT2JqZWN0JGNyZWF0ZSQxKG51bGwpO1xuICAvLyBJZiBhY3ljbGljLCB0aGUgZ3JhcGggY2FuIGJlIHdhbGtlZCB0aHJvdWdoIHdpdGggKG1vc3QgbGlrZWx5IHdheSkgZmV3ZXJcbiAgLy8gc3RlcHMgdGhhbiB0aGUgbnVtYmVyIGJlbGxvdy4gVGhlIGV4YWN0IHZhbHVlIGlzbid0IHRvbyBpbXBvcnRhbnQgYXMgbG9uZ1xuICAvLyBhcyBpdCdzIHF1aWNrIHRvIGNvbXB1dGUgKGRvZXNuJ3QgaW1wYWN0IGFjeWNsaWMgZ3JhcGhzIHRvbyBtdWNoKSwgaXNcbiAgLy8gaGlnaGVyIHRoYW4gdGhlIG51bWJlciBvZiBzdGVwcyBhY3R1YWxseSBuZWVkZWQgKGRvZXNuJ3QgY3V0IG9mZiBiZWZvcmVcbiAgLy8gYWN5Y2xpYyBncmFwaCBpcyB3YWxrZWQgdGhyb3VnaCkgYW5kIHByZXZlbnRzIGluZmluaXRlIGxvb3BzIChjdXRzIG9mZiBmb3JcbiAgLy8gY3ljbGljIGdyYXBocykuXG4gIHZhciBsaW1pdCA9IF9yZWR1Y2VJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0NiA9IF90b0NvbnN1bWFibGVBcnJheShfdmFsdWVzSW5zdGFuY2VQcm9wZXJ0eShub2RlcykuY2FsbChub2RlcykpKS5jYWxsKF9jb250ZXh0NiwgZnVuY3Rpb24gKGFjYywgbm9kZSkge1xuICAgIHJldHVybiBhY2MgKyAxICsgbm9kZS5lZGdlcy5sZW5ndGg7XG4gIH0sIDApO1xuICB2YXIgZWRnZUlkUHJvcCA9IGRpcmVjdGlvbiArIFwiSWRcIjtcbiAgdmFyIG5ld0xldmVsRGlmZiA9IGRpcmVjdGlvbiA9PT0gXCJ0b1wiID8gMSA6IC0xO1xuICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShub2RlcyksXG4gICAgX3N0ZXA7XG4gIHRyeSB7XG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICBlbnRyeU5vZGVJZCA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgIGVudHJ5Tm9kZSA9IF9zdGVwJHZhbHVlWzFdO1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIFNraXAgaWYgdGhlIG5vZGUgaXMgbm90IHZpc2libGUuXG4gICAgICAgICFub2Rlcy5oYXMoZW50cnlOb2RlSWQpIHx8XG4gICAgICAgIC8vIFNraXAgaWYgdGhlIG5vZGUgaXMgbm90IGFuIGVudHJ5IG5vZGUuXG4gICAgICAgICFpc0VudHJ5Tm9kZShlbnRyeU5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIDA7IC8vIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgLy8gTGluZSB1cCBhbGwgdGhlIGVudHJ5IG5vZGVzIG9uIGxldmVsIDAuXG4gICAgICAgIGxldmVsc1tlbnRyeU5vZGVJZF0gPSAwO1xuICAgICAgICB2YXIgc3RhY2sgPSBbZW50cnlOb2RlXTtcbiAgICAgICAgdmFyIGRvbmUgPSAwO1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMigpIHtcbiAgICAgICAgICAgIHZhciBfY29udGV4dDcsIF9jb250ZXh0ODtcbiAgICAgICAgICAgIGlmICghbm9kZXMuaGFzKGVudHJ5Tm9kZUlkKSkge1xuICAgICAgICAgICAgICAvLyBTa2lwIGlmIHRoZSBub2RlIGlzIG5vdCB2aXNpYmxlLlxuICAgICAgICAgICAgICByZXR1cm4gMDsgLy8gY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXdMZXZlbCA9IGxldmVsc1tub2RlLmlkXSArIG5ld0xldmVsRGlmZjtcbiAgICAgICAgICAgIF9mb3JFYWNoSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDcgPSBfZmlsdGVySW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDggPSBub2RlLmVkZ2VzKS5jYWxsKF9jb250ZXh0OCwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZGlzY29ubmVjdGVkIGVkZ2VzLlxuICAgICAgICAgICAgICAgIGVkZ2UuY29ubmVjdGVkICYmXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGNpcmN1bGFyIGVkZ2VzLlxuICAgICAgICAgICAgICAgIGVkZ2UudG8gIT09IGVkZ2UuZnJvbSAmJlxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlZGdlcyBsZWFkaW5nIHRvIHRoZSBub2RlIHRoYXQncyBjdXJyZW50bHkgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAgICAgICAgIGVkZ2VbZGlyZWN0aW9uXSAhPT0gbm9kZSAmJlxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlZGdlcyBjb25uZWN0aW5nIHRvIGFuIGludmlzaWJsZSBub2RlLlxuICAgICAgICAgICAgICAgIG5vZGVzLmhhcyhlZGdlLnRvSWQpICYmXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGVkZ2VzIGNvbm5lY3RpbmcgZnJvbSBhbiBpbnZpc2libGUgbm9kZS5cbiAgICAgICAgICAgICAgICBub2Rlcy5oYXMoZWRnZS5mcm9tSWQpXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KSkuY2FsbChfY29udGV4dDcsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICAgIHZhciB0YXJnZXROb2RlSWQgPSBlZGdlW2VkZ2VJZFByb3BdO1xuICAgICAgICAgICAgICB2YXIgb2xkTGV2ZWwgPSBsZXZlbHNbdGFyZ2V0Tm9kZUlkXTtcbiAgICAgICAgICAgICAgaWYgKG9sZExldmVsID09IG51bGwgfHwgc2hvdWxkTGV2ZWxCZVJlcGxhY2VkKG5ld0xldmVsLCBvbGRMZXZlbCkpIHtcbiAgICAgICAgICAgICAgICBsZXZlbHNbdGFyZ2V0Tm9kZUlkXSA9IG5ld0xldmVsO1xuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goZWRnZVtkaXJlY3Rpb25dKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZG9uZSA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgd291bGQgcnVuIGZvcmV2ZXIgb24gYSBjeWNsaWMgZ3JhcGguXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdjoge1xuICAgICAgICAgICAgICAgICAgdjogZmlsbExldmVsc0J5RGlyZWN0aW9uQ3ljbGljKG5vZGVzLCBsZXZlbHMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgKytkb25lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgX3JldDI7XG4gICAgICAgIHdoaWxlIChub2RlID0gc3RhY2sucG9wKCkpIHtcbiAgICAgICAgICBfcmV0MiA9IF9sb29wMigpO1xuICAgICAgICAgIGlmIChfcmV0MiA9PT0gMCkgY29udGludWU7XG4gICAgICAgICAgaWYgKF9yZXQyKSByZXR1cm4gX3JldDIudjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9yZXQ7XG4gICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgIF9yZXQgPSBfbG9vcCgpO1xuICAgICAgaWYgKF9yZXQgPT09IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKF9yZXQpIHJldHVybiBfcmV0LnY7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfaXRlcmF0b3IuZShlcnIpO1xuICB9IGZpbmFsbHkge1xuICAgIF9pdGVyYXRvci5mKCk7XG4gIH1cbiAgcmV0dXJuIGxldmVscztcbn1cblxuLyoqXG4gKiBUaGVyZSdzIGEgbWl4LXVwIHdpdGggdGVybXMgaW4gdGhlIGNvZGUuIEZvbGxvd2luZyBhcmUgdGhlIGZvcm1hbCBkZWZpbml0aW9uczpcbiAqXG4gKiAgIHRyZWUgICAtIGEgc3RyaWN0IGhpZXJhcmNoaWNhbCBuZXR3b3JrLCBpLmUuIGV2ZXJ5IG5vZGUgaGFzIGF0IG1vc3Qgb25lIHBhcmVudFxuICogICBmb3Jlc3QgLSBhIGNvbGxlY3Rpb24gb2YgdHJlZXMuIFRoZXNlIGRpc3RpbmN0IHRyZWVzIGFyZSB0aHVzIG5vdCBjb25uZWN0ZWQuXG4gKlxuICogU286XG4gKiAtIGluIGEgbmV0d29yayB0aGF0IGlzIG5vdCBhIHRyZWUsIHRoZXJlIGV4aXN0IG5vZGVzIHdpdGggbXVsdGlwbGUgcGFyZW50cy5cbiAqIC0gYSBuZXR3b3JrIGNvbnNpc3Rpbmcgb2YgdW5jb25uZWN0ZWQgc3ViLW5ldHdvcmtzLCBvZiB3aGljaCBhdCBsZWFzdCBvbmVcbiAqICAgaXMgbm90IGEgdHJlZSwgaXMgbm90IGEgZm9yZXN0LlxuICpcbiAqIEluIHRoZSBjb2RlLCB0aGUgZGVmaW5pdGlvbnMgYXJlOlxuICpcbiAqICAgdHJlZSAgIC0gYW55IGRpc2Nvbm5lY3RlZCBzdWItbmV0d29yaywgc3RyaWN0IGhpZXJhcmNoaWNhbCBvciBub3QuXG4gKiAgIGZvcmVzdCAtIGEgYnVuY2ggb2YgdGhlc2Ugc3ViLW5ldHdvcmtzXG4gKlxuICogVGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0cmVlIGFuZCBub3QtdHJlZSBpcyBpbXBvcnRhbnQgaW4gdGhlIGNvZGUsIG5vdGFibHkgd2l0aGluXG4gKiB0byB0aGUgYmxvY2stc2hpZnRpbmcgYWxnb3JpdGhtLiBUaGUgYWxnb3JpdGhtIGFzc3VtZXMgZm9ybWFsIHRyZWVzIGFuZCBmYWlsc1xuICogZm9yIG5vdC10cmVlcywgb2Z0ZW4gaW4gYSBzcGVjdGFjdWxhciBtYW5uZXIgKHNlYXJjaCBmb3IgJ2V4cGxvZGluZyBuZXR3b3JrJyBpbiB0aGUgaXNzdWVzKS5cbiAqXG4gKiBJbiBvcmRlciB0byBkaXN0aW5ndWlzaCB0aGUgZGVmaW5pdGlvbnMgaW4gdGhlIGZvbGxvd2luZyBjb2RlLCB0aGUgYWRqZWN0aXZlICdmb3JtYWwnIGlzXG4gKiB1c2VkLiBJZiAnZm9ybWFsJyBpcyBhYnNlbnQsIHlvdSBtdXN0IGFzc3VtZSB0aGUgbm9uLWZvcm1hbCBkZWZpbml0aW9uLlxuICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIE5PVEVTXG4gKiA9PT09PVxuICpcbiAqIEEgaGllcmFyY2hpY2FsIGxheW91dCBpcyBhIGRpZmZlcmVudCB0aGluZyBmcm9tIGEgaGllcmFyY2hpY2FsIG5ldHdvcmsuXG4gKiBUaGUgbGF5b3V0IGlzIGEgd2F5IHRvIGFycmFuZ2UgdGhlIG5vZGVzIGluIHRoZSB2aWV3OyB0aGlzIGNhbiBiZSBkb25lXG4gKiBvbiBub24taGllcmFyY2hpY2FsIG5ldHdvcmtzIGFzIHdlbGwuIFRoZSBjb252ZXJzZSBpcyBhbHNvIHBvc3NpYmxlLlxuICovXG5cbi8qKlxuICogQ29udGFpbmVyIGZvciBkZXJpdmVkIGRhdGEgb24gY3VycmVudCBuZXR3b3JrLCByZWxhdGluZyB0byBoaWVyYXJjaHkuXG4gKlxuICogQHByaXZhdGVcbiAqL1xudmFyIEhpZXJhcmNoaWNhbFN0YXR1cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBmdW5jdGlvbiBIaWVyYXJjaGljYWxTdGF0dXMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhpZXJhcmNoaWNhbFN0YXR1cyk7XG4gICAgdGhpcy5jaGlsZHJlblJlZmVyZW5jZSA9IHt9OyAvLyBjaGlsZCBpZCdzIHBlciBub2RlIGlkXG4gICAgdGhpcy5wYXJlbnRSZWZlcmVuY2UgPSB7fTsgLy8gcGFyZW50IGlkJ3MgcGVyIG5vZGUgaWRcbiAgICB0aGlzLnRyZWVzID0ge307IC8vIHRyZWUgaWQgcGVyIG5vZGUgaWQ7IGkuZS4gdG8gd2hpY2ggdHJlZSBkb2VzIGdpdmVuIG5vZGUgaWQgYmVsb25nXG5cbiAgICB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nID0ge307IC8vIFRoZSBub2RlcyBwZXIgbGV2ZWwsIGluIHRoZSBkaXNwbGF5IG9yZGVyXG4gICAgdGhpcy5sZXZlbHMgPSB7fTsgLy8gaGllcmFyY2h5IGxldmVsIHBlciBub2RlIGlkXG4gICAgdGhpcy5kaXN0cmlidXRpb25JbmRleCA9IHt9OyAvLyBUaGUgcG9zaXRpb24gb2YgdGhlIG5vZGUgaW4gdGhlIGxldmVsIHNvcnRpbmcgb3JkZXIsIHBlciBub2RlIGlkLlxuXG4gICAgdGhpcy5pc1RyZWUgPSBmYWxzZTsgLy8gVHJ1ZSBpZiBjdXJyZW50IG5ldHdvcmsgaXMgYSBmb3JtYWwgdHJlZVxuICAgIHRoaXMudHJlZUluZGV4ID0gLTE7IC8vIEhpZ2hlc3QgdHJlZSBpZCBpbiBjdXJyZW50IG5ldHdvcmsuXG4gIH1cblxuICAvKipcbiAgICogQWRkIHRoZSByZWxhdGlvbiBiZXR3ZWVuIGdpdmVuIG5vZGVzIHRvIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGUuaWR9IHBhcmVudE5vZGVJZFxuICAgKiBAcGFyYW0ge05vZGUuaWR9IGNoaWxkTm9kZUlkXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoSGllcmFyY2hpY2FsU3RhdHVzLCBbe1xuICAgIGtleTogXCJhZGRSZWxhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSZWxhdGlvbihwYXJlbnROb2RlSWQsIGNoaWxkTm9kZUlkKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnROb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlblJlZmVyZW5jZVtwYXJlbnROb2RlSWRdID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLmNoaWxkcmVuUmVmZXJlbmNlW3BhcmVudE5vZGVJZF0ucHVzaChjaGlsZE5vZGVJZCk7XG4gICAgICBpZiAodGhpcy5wYXJlbnRSZWZlcmVuY2VbY2hpbGROb2RlSWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnRSZWZlcmVuY2VbY2hpbGROb2RlSWRdID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLnBhcmVudFJlZmVyZW5jZVtjaGlsZE5vZGVJZF0ucHVzaChwYXJlbnROb2RlSWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBjdXJyZW50IHN0YXRlIGlzIGZvciBhIGZvcm1hbCB0cmVlIG9yIGZvcm1hbCBmb3Jlc3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSBjYXNlIGlmIGV2ZXJ5IG5vZGUgaGFzIGF0IG1vc3Qgb25lIHBhcmVudC5cbiAgICAgKlxuICAgICAqIFByZTogcGFyZW50UmVmZXJlbmNlIGluaXQnZWQgcHJvcGVybHkgZm9yIGN1cnJlbnQgbmV0d29ya1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNoZWNrSWZUcmVlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrSWZUcmVlKCkge1xuICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnBhcmVudFJlZmVyZW5jZSkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnRSZWZlcmVuY2VbaV0ubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMuaXNUcmVlID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmlzVHJlZSA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2Ygc2VwYXJhdGUgdHJlZXMgaW4gdGhlIGN1cnJlbnQgbmV0d29yay5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibnVtVHJlZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbnVtVHJlZXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmVlSW5kZXggKyAxOyAvLyBUaGlzIGFzc3VtZXMgdGhlIGluZGV4ZXMgYXJlIGFzc2lnbmVkIGNvbnNlY2l0aXZlbHlcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ24gYSB0cmVlIGlkIHRvIGEgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB0cmVlSWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRUcmVlSW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VHJlZUluZGV4KG5vZGUsIHRyZWVJZCkge1xuICAgICAgaWYgKHRyZWVJZCA9PT0gdW5kZWZpbmVkKSByZXR1cm47IC8vIERvbid0IGJvdGhlclxuXG4gICAgICBpZiAodGhpcy50cmVlc1tub2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudHJlZXNbbm9kZS5pZF0gPSB0cmVlSWQ7XG4gICAgICAgIHRoaXMudHJlZUluZGV4ID0gTWF0aC5tYXgodHJlZUlkLCB0aGlzLnRyZWVJbmRleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlIGxldmVsIGZvciBnaXZlbiBpZCBpcyBkZWZpbmVkLlxuICAgICAqXG4gICAgICogU2V0cyBsZXZlbCB0byB6ZXJvIGZvciBnaXZlbiBub2RlIGlkIGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gbm9kZUlkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZW5zdXJlTGV2ZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5zdXJlTGV2ZWwobm9kZUlkKSB7XG4gICAgICBpZiAodGhpcy5sZXZlbHNbbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubGV2ZWxzW25vZGVJZF0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgbWF4aW11bSBsZXZlbCBvZiBhIGJyYW5jaC5cbiAgICAgKlxuICAgICAqIFRPRE86IE5ldmVyIGVudGVyZWQ7IGZpbmQgYSB0ZXN0IGNhc2UgdG8gdGVzdCB0aGlzIVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBub2RlSWRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldE1heExldmVsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1heExldmVsKG5vZGVJZCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBhY2N1bXVsYXRvciA9IHt9O1xuICAgICAgdmFyIF9nZXRNYXhMZXZlbCA9IGZ1bmN0aW9uIF9nZXRNYXhMZXZlbChub2RlSWQpIHtcbiAgICAgICAgaWYgKGFjY3VtdWxhdG9yW25vZGVJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcltub2RlSWRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZXZlbCA9IF90aGlzLmxldmVsc1tub2RlSWRdO1xuICAgICAgICBpZiAoX3RoaXMuY2hpbGRyZW5SZWZlcmVuY2Vbbm9kZUlkXSkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IF90aGlzLmNoaWxkcmVuUmVmZXJlbmNlW25vZGVJZF07XG4gICAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBNYXRoLm1heChsZXZlbCwgX2dldE1heExldmVsKGNoaWxkcmVuW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFjY3VtdWxhdG9yW25vZGVJZF0gPSBsZXZlbDtcbiAgICAgICAgcmV0dXJuIGxldmVsO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfZ2V0TWF4TGV2ZWwobm9kZUlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZUFcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVCXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibGV2ZWxEb3duc3RyZWFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxldmVsRG93bnN0cmVhbShub2RlQSwgbm9kZUIpIHtcbiAgICAgIGlmICh0aGlzLmxldmVsc1tub2RlQi5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBzZXQgaW5pdGlhbCBsZXZlbFxuICAgICAgICBpZiAodGhpcy5sZXZlbHNbbm9kZUEuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmxldmVsc1tub2RlQS5pZF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBsZXZlbFxuICAgICAgICB0aGlzLmxldmVsc1tub2RlQi5pZF0gPSB0aGlzLmxldmVsc1tub2RlQS5pZF0gKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNtYWxsIHV0aWwgbWV0aG9kIHRvIHNldCB0aGUgbWluaW11bSBsZXZlbHMgb2YgdGhlIG5vZGVzIHRvIHplcm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlPn0gbm9kZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRNaW5MZXZlbFRvWmVyb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNaW5MZXZlbFRvWmVybyhub2Rlcykge1xuICAgICAgdmFyIG1pbkxldmVsID0gMWU5O1xuICAgICAgLy8gZ2V0IHRoZSBtaW5pbXVtIGxldmVsXG4gICAgICBmb3IgKHZhciBub2RlSWQgaW4gbm9kZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChub2Rlcywgbm9kZUlkKSkge1xuICAgICAgICAgIGlmICh0aGlzLmxldmVsc1tub2RlSWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1pbkxldmVsID0gTWF0aC5taW4odGhpcy5sZXZlbHNbbm9kZUlkXSwgbWluTGV2ZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBzdWJ0cmFjdCB0aGUgbWluaW11bSBmcm9tIHRoZSBzZXQgc28gd2UgaGF2ZSBhIHJhbmdlIHN0YXJ0aW5nIGZyb20gMFxuICAgICAgZm9yICh2YXIgX25vZGVJZCBpbiBub2Rlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGVzLCBfbm9kZUlkKSkge1xuICAgICAgICAgIGlmICh0aGlzLmxldmVsc1tfbm9kZUlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmxldmVsc1tfbm9kZUlkXSAtPSBtaW5MZXZlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG1pbiBhbmQgbWF4IHh5LWNvb3JkaW5hdGVzIG9mIGEgZ2l2ZW4gdHJlZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAgICogQHJldHVybnMge3ttaW5feDogbnVtYmVyLCBtYXhfeDogbnVtYmVyLCBtaW5feTogbnVtYmVyLCBtYXhfeTogbnVtYmVyfX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmVlU2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUcmVlU2l6ZShub2RlcywgaW5kZXgpIHtcbiAgICAgIHZhciBtaW5feCA9IDFlOTtcbiAgICAgIHZhciBtYXhfeCA9IC0xZTk7XG4gICAgICB2YXIgbWluX3kgPSAxZTk7XG4gICAgICB2YXIgbWF4X3kgPSAtMWU5O1xuICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRoaXMudHJlZXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLnRyZWVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgaWYgKHRoaXMudHJlZXNbbm9kZUlkXSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIG1pbl94ID0gTWF0aC5taW4obm9kZS54LCBtaW5feCk7XG4gICAgICAgICAgICBtYXhfeCA9IE1hdGgubWF4KG5vZGUueCwgbWF4X3gpO1xuICAgICAgICAgICAgbWluX3kgPSBNYXRoLm1pbihub2RlLnksIG1pbl95KTtcbiAgICAgICAgICAgIG1heF95ID0gTWF0aC5tYXgobm9kZS55LCBtYXhfeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW5feDogbWluX3gsXG4gICAgICAgIG1heF94OiBtYXhfeCxcbiAgICAgICAgbWluX3k6IG1pbl95LFxuICAgICAgICBtYXhfeTogbWF4X3lcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdHdvIG5vZGVzIGhhdmUgdGhlIHNhbWUgcGFyZW50KHMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUxXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlMlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSB0d28gbm9kZXMgaGF2ZSBhIHNhbWUgYW5jZXN0b3Igbm9kZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzU2FtZVBhcmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNTYW1lUGFyZW50KG5vZGUxLCBub2RlMikge1xuICAgICAgdmFyIHBhcmVudHMxID0gdGhpcy5wYXJlbnRSZWZlcmVuY2Vbbm9kZTEuaWRdO1xuICAgICAgdmFyIHBhcmVudHMyID0gdGhpcy5wYXJlbnRSZWZlcmVuY2Vbbm9kZTIuaWRdO1xuICAgICAgaWYgKHBhcmVudHMxID09PSB1bmRlZmluZWQgfHwgcGFyZW50czIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFyZW50czIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAocGFyZW50czFbaV0gPT0gcGFyZW50czJbal0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHR3byBub2RlcyBhcmUgaW4gdGhlIHNhbWUgdHJlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZTFcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhpcyBpcyBzbywgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5TYW1lU3ViTmV0d29ya1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpblNhbWVTdWJOZXR3b3JrKG5vZGUxLCBub2RlMikge1xuICAgICAgcmV0dXJuIHRoaXMudHJlZXNbbm9kZTEuaWRdID09PSB0aGlzLnRyZWVzW25vZGUyLmlkXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBsaXN0IG9mIHRoZSBkaXN0aW5jdCBsZXZlbHMgaW4gdGhlIGN1cnJlbnQgbmV0d29ya1xuICAgICAqXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldExldmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMZXZlbHMoKSB7XG4gICAgICByZXR1cm4gX09iamVjdCRrZXlzKHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5vZGUgdG8gdGhlIG9yZGVyaW5nIHBlciBsZXZlbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkVG9PcmRlcmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRUb09yZGVyaW5nKG5vZGUsIGxldmVsKSB7XG4gICAgICBpZiAodGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXSA9IFtdO1xuICAgICAgfVxuICAgICAgdmFyIGlzUHJlc2VudCA9IGZhbHNlO1xuICAgICAgdmFyIGN1ckxldmVsID0gdGhpcy5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG4gICAgICBmb3IgKHZhciBuIGluIGN1ckxldmVsKSB7XG4gICAgICAgIC8vaWYgKGN1ckxldmVsW25dLmlkID09PSBub2RlLmlkKSB7XG4gICAgICAgIGlmIChjdXJMZXZlbFtuXSA9PT0gbm9kZSkge1xuICAgICAgICAgIGlzUHJlc2VudCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaXNQcmVzZW50KSB7XG4gICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdLnB1c2gobm9kZSk7XG4gICAgICAgIHRoaXMuZGlzdHJpYnV0aW9uSW5kZXhbbm9kZS5pZF0gPSB0aGlzLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gSGllcmFyY2hpY2FsU3RhdHVzO1xufSgpO1xuLyoqXG4gKiBUaGUgTGF5b3V0IEVuZ2luZVxuICovXG52YXIgTGF5b3V0RW5naW5lID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqL1xuICBmdW5jdGlvbiBMYXlvdXRFbmdpbmUoYm9keSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYXlvdXRFbmdpbmUpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhlcmUgYWx3YXlzIGlzIHNvbWUgUk5HIGJlY2F1c2UgdGhlIHNldE9wdGlvbnMgbWV0aG9kIHdvbid0XG4gICAgLy8gc2V0IGl0IHVubGVzcyB0aGVyZSdzIGEgc2VlZCBmb3IgaXQuXG4gICAgdGhpcy5fcmVzZXRSTkcoTWF0aC5yYW5kb20oKSArIFwiOlwiICsgX0RhdGUkbm93KCkpO1xuICAgIHRoaXMuc2V0UGh5c2ljcyA9IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMub3B0aW9uc0JhY2t1cCA9IHtcbiAgICAgIHBoeXNpY3M6IHt9XG4gICAgfTtcbiAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgcmFuZG9tU2VlZDogdW5kZWZpbmVkLFxuICAgICAgaW1wcm92ZWRMYXlvdXQ6IHRydWUsXG4gICAgICBjbHVzdGVyVGhyZXNob2xkOiAxNTAsXG4gICAgICBoaWVyYXJjaGljYWw6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGxldmVsU2VwYXJhdGlvbjogMTUwLFxuICAgICAgICBub2RlU3BhY2luZzogMTAwLFxuICAgICAgICB0cmVlU3BhY2luZzogMjAwLFxuICAgICAgICBibG9ja1NoaWZ0aW5nOiB0cnVlLFxuICAgICAgICBlZGdlTWluaW1pemF0aW9uOiB0cnVlLFxuICAgICAgICBwYXJlbnRDZW50cmFsaXphdGlvbjogdHJ1ZSxcbiAgICAgICAgZGlyZWN0aW9uOiBcIlVEXCIsXG4gICAgICAgIC8vIFVELCBEVSwgTFIsIFJMXG4gICAgICAgIHNvcnRNZXRob2Q6IFwiaHVic2l6ZVwiIC8vIGh1YnNpemUsIGRpcmVjdGVkXG4gICAgICB9XG4gICAgfTtcblxuICAgIF9PYmplY3QkYXNzaWduKHRoaXMub3B0aW9ucywgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG4gICAgdGhpcy5iaW5kRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kcyBldmVudCBsaXN0ZW5lcnNcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhMYXlvdXRFbmdpbmUsIFt7XG4gICAga2V5OiBcImJpbmRFdmVudExpc3RlbmVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFDaGFuZ2VkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnNldHVwSGllcmFyY2hpY2FsTGF5b3V0KCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFMb2FkZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIubGF5b3V0TmV0d29yaygpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9yZXNldEhpZXJhcmNoaWNhbExheW91dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zZXR1cEhpZXJhcmNoaWNhbExheW91dCgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9hZGp1c3RFZGdlc0ZvckhpZXJhcmNoaWNhbExheW91dFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgdGhlIHR5cGUgb2Ygc3RhdGljIHNtb290aCBjdXJ2ZSBpbiBjYXNlIGl0IGlzIHJlcXVpcmVkXG4gICAgICAgIHZhciB0eXBlID0gX3RoaXMyLmRpcmVjdGlvbi5jdXJ2ZVR5cGUoKTtcblxuICAgICAgICAvLyBmb3JjZSBhbGwgZWRnZXMgaW50byBzdGF0aWMgc21vb3RoIGN1cnZlcy5cbiAgICAgICAgX3RoaXMyLmJvZHkuZW1pdHRlci5lbWl0KFwiX2ZvcmNlRGlzYWJsZUR5bmFtaWNDdXJ2ZXNcIiwgdHlwZSwgZmFsc2UpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhbGxPcHRpb25zXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucywgYWxsT3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgaGllcmFyY2hpY2FsID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbDtcbiAgICAgICAgdmFyIHByZXZIaWVyYXJjaGljYWxTdGF0ZSA9IGhpZXJhcmNoaWNhbC5lbmFibGVkO1xuICAgICAgICBzZWxlY3RpdmVEZWVwRXh0ZW5kKFtcInJhbmRvbVNlZWRcIiwgXCJpbXByb3ZlZExheW91dFwiLCBcImNsdXN0ZXJUaHJlc2hvbGRcIl0sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG9wdGlvbnMsIFwiaGllcmFyY2hpY2FsXCIpO1xuICAgICAgICBpZiAob3B0aW9ucy5yYW5kb21TZWVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLl9yZXNldFJORyhvcHRpb25zLnJhbmRvbVNlZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaWVyYXJjaGljYWwuZW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGlmIChwcmV2SGllcmFyY2hpY2FsU3RhdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIG92ZXJyaWRkZW4gb3B0aW9ucyBmb3Igbm9kZXMgYW5kIGVkZ2VzLlxuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlZnJlc2hcIiwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBsZXZlbCBzZXBhcmF0aW9uIGlzIHRoZSByaWdodCB3YXkgdXBcbiAgICAgICAgICBpZiAoaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gXCJSTFwiIHx8IGhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09IFwiRFVcIikge1xuICAgICAgICAgICAgaWYgKGhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgIGhpZXJhcmNoaWNhbC5sZXZlbFNlcGFyYXRpb24gKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uIDwgMCkge1xuICAgICAgICAgICAgICBoaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICo9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNldERpcmVjdGlvblN0cmF0ZWd5KCk7XG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNldEhpZXJhcmNoaWNhbExheW91dFwiKTtcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBoaWVyYXJjaGljYWwgc3lzdGVtIG5lZWRzIGl0J3Mgb3duIHBoeXNpY3MgYW5kIHNtb290aCBjdXJ2ZSBzZXR0aW5ncyxcbiAgICAgICAgICAvLyB3ZSBhZGFwdCB0aGUgb3RoZXIgb3B0aW9ucyBpZiBuZWVkZWQuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRBbGxPcHRpb25zRm9ySGllcmFyY2hpY2FsTGF5b3V0KGFsbE9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwcmV2SGllcmFyY2hpY2FsU3RhdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIG92ZXJyaWRkZW4gb3B0aW9ucyBmb3Igbm9kZXMgYW5kIGVkZ2VzLlxuICAgICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlZnJlc2hcIik7XG4gICAgICAgICAgICByZXR1cm4gZGVlcEV4dGVuZChhbGxPcHRpb25zLCB0aGlzLm9wdGlvbnNCYWNrdXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFsbE9wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIHdpdGggZ2l2ZW4gc2VlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7YW55fSBzZWVkIC0gVGhlIHNlZWQgdGhhdCB3aWxsIGJlIGZvcndhcmRlZCB0aGUgdGhlIFJORy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcmVzZXRSTkdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2V0Uk5HKHNlZWQpIHtcbiAgICAgIHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQgPSBzZWVkO1xuICAgICAgdGhpcy5fcm5nID0gQWxlYSh0aGlzLmluaXRpYWxSYW5kb21TZWVkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBhbGxPcHRpb25zXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGFwdEFsbE9wdGlvbnNGb3JIaWVyYXJjaGljYWxMYXlvdXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRhcHRBbGxPcHRpb25zRm9ySGllcmFyY2hpY2FsTGF5b3V0KGFsbE9wdGlvbnMpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGJhY2t1cFBoeXNpY3MgPSB0aGlzLm9wdGlvbnNCYWNrdXAucGh5c2ljcztcblxuICAgICAgICAvLyBzZXQgdGhlIHBoeXNpY3NcbiAgICAgICAgaWYgKGFsbE9wdGlvbnMucGh5c2ljcyA9PT0gdW5kZWZpbmVkIHx8IGFsbE9wdGlvbnMucGh5c2ljcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFsbE9wdGlvbnMucGh5c2ljcyA9IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGJhY2t1cFBoeXNpY3MuZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGJhY2t1cFBoeXNpY3MuZW5hYmxlZCxcbiAgICAgICAgICAgIHNvbHZlcjogXCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIlxuICAgICAgICAgIH07XG4gICAgICAgICAgYmFja3VwUGh5c2ljcy5lbmFibGVkID0gYmFja3VwUGh5c2ljcy5lbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogYmFja3VwUGh5c2ljcy5lbmFibGVkO1xuICAgICAgICAgIGJhY2t1cFBoeXNpY3Muc29sdmVyID0gYmFja3VwUGh5c2ljcy5zb2x2ZXIgfHwgXCJiYXJuZXNIdXRcIjtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKGFsbE9wdGlvbnMucGh5c2ljcykgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBiYWNrdXBQaHlzaWNzLmVuYWJsZWQgPSBhbGxPcHRpb25zLnBoeXNpY3MuZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFsbE9wdGlvbnMucGh5c2ljcy5lbmFibGVkO1xuICAgICAgICAgIGJhY2t1cFBoeXNpY3Muc29sdmVyID0gYWxsT3B0aW9ucy5waHlzaWNzLnNvbHZlciB8fCBcImJhcm5lc0h1dFwiO1xuICAgICAgICAgIGFsbE9wdGlvbnMucGh5c2ljcy5zb2x2ZXIgPSBcImhpZXJhcmNoaWNhbFJlcHVsc2lvblwiO1xuICAgICAgICB9IGVsc2UgaWYgKGFsbE9wdGlvbnMucGh5c2ljcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBiYWNrdXBQaHlzaWNzLnNvbHZlciA9IFwiYmFybmVzSHV0XCI7XG4gICAgICAgICAgYWxsT3B0aW9ucy5waHlzaWNzID0ge1xuICAgICAgICAgICAgc29sdmVyOiBcImhpZXJhcmNoaWNhbFJlcHVsc2lvblwiXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgdHlwZSBvZiBzdGF0aWMgc21vb3RoIGN1cnZlIGluIGNhc2UgaXQgaXMgcmVxdWlyZWRcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmRpcmVjdGlvbi5jdXJ2ZVR5cGUoKTtcblxuICAgICAgICAvLyBkaXNhYmxlIHNtb290aCBjdXJ2ZXMgaWYgbm90aGluZyBpcyBkZWZpbmVkLiBJZiBzbW9vdGggY3VydmVzIGhhdmUgYmVlbiB0dXJuZWQgb24sXG4gICAgICAgIC8vIHR1cm4gdGhlbSBpbnRvIHN0YXRpYyBzbW9vdGggY3VydmVzLlxuICAgICAgICBpZiAoYWxsT3B0aW9ucy5lZGdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0ge1xuICAgICAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgIHR5cGU6IFwiZHluYW1pY1wiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBhbGxPcHRpb25zLmVkZ2VzID0ge1xuICAgICAgICAgICAgc21vb3RoOiBmYWxzZVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMub3B0aW9uc0JhY2t1cC5lZGdlcyA9IHtcbiAgICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiBcImR5bmFtaWNcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGggPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zQmFja3VwLmVkZ2VzID0ge1xuICAgICAgICAgICAgICBzbW9vdGg6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGggPSB7XG4gICAgICAgICAgICAgIGVuYWJsZWQ6IGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoLFxuICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgc21vb3RoID0gYWxsT3B0aW9ucy5lZGdlcy5zbW9vdGg7XG5cbiAgICAgICAgICAgIC8vIGFsbG93IGN1c3RvbSB0eXBlcyBleGNlcHQgZm9yIGR5bmFtaWNcbiAgICAgICAgICAgIGlmIChzbW9vdGgudHlwZSAhPT0gdW5kZWZpbmVkICYmIHNtb290aC50eXBlICE9PSBcImR5bmFtaWNcIikge1xuICAgICAgICAgICAgICB0eXBlID0gc21vb3RoLnR5cGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgaXMgb3B0aW9ucyBtZXJnaW5nOyBzZWUgaWYgdGhlIHN0YW5kYXJkIHJvdXRpbmVzIGNhbiBiZSB1c2VkIGhlcmUuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNCYWNrdXAuZWRnZXMgPSB7XG4gICAgICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHNtb290aC5lbmFibGVkID09PSB1bmRlZmluZWQgPyB0cnVlIDogc21vb3RoLmVuYWJsZWQsXG4gICAgICAgICAgICAgICAgdHlwZTogc21vb3RoLnR5cGUgPT09IHVuZGVmaW5lZCA/IFwiZHluYW1pY1wiIDogc21vb3RoLnR5cGUsXG4gICAgICAgICAgICAgICAgcm91bmRuZXNzOiBzbW9vdGgucm91bmRuZXNzID09PSB1bmRlZmluZWQgPyAwLjUgOiBzbW9vdGgucm91bmRuZXNzLFxuICAgICAgICAgICAgICAgIGZvcmNlRGlyZWN0aW9uOiBzbW9vdGguZm9yY2VEaXJlY3Rpb24gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogc21vb3RoLmZvcmNlRGlyZWN0aW9uXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIE5PVEU6IENvcHlpbmcgYW4gb2JqZWN0IHRvIHNlbGY7IHRoaXMgaXMgYmFzaWNhbGx5IHNldHRpbmcgZGVmYXVsdHMgZm9yIHVuZGVmaW5lZCB2YXJpYWJsZXNcbiAgICAgICAgICAgIGFsbE9wdGlvbnMuZWRnZXMuc21vb3RoID0ge1xuICAgICAgICAgICAgICBlbmFibGVkOiBzbW9vdGguZW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHNtb290aC5lbmFibGVkLFxuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICByb3VuZG5lc3M6IHNtb290aC5yb3VuZG5lc3MgPT09IHVuZGVmaW5lZCA/IDAuNSA6IHNtb290aC5yb3VuZG5lc3MsXG4gICAgICAgICAgICAgIGZvcmNlRGlyZWN0aW9uOiBzbW9vdGguZm9yY2VEaXJlY3Rpb24gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogc21vb3RoLmZvcmNlRGlyZWN0aW9uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvcmNlIGFsbCBlZGdlcyBpbnRvIHN0YXRpYyBzbW9vdGggY3VydmVzLlxuICAgICAgICAvLyBPbmx5IGFwcGxpZXMgdG8gZWRnZXMgdGhhdCBkbyBub3QgdXNlIHRoZSBnbG9iYWwgb3B0aW9ucyBmb3Igc21vb3RoLlxuICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2ZvcmNlRGlzYWJsZUR5bmFtaWNDdXJ2ZXNcIiwgdHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxsT3B0aW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBub2Rlc0FycmF5XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicG9zaXRpb25Jbml0aWFsbHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9zaXRpb25Jbml0aWFsbHkobm9kZXNBcnJheSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9yZXNldFJORyh0aGlzLmluaXRpYWxSYW5kb21TZWVkKTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IG5vZGVzQXJyYXkubGVuZ3RoICsgNTA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNBcnJheVtpXTtcbiAgICAgICAgICB2YXIgYW5nbGUgPSAyICogTWF0aC5QSSAqIHRoaXMuX3JuZygpO1xuICAgICAgICAgIGlmIChub2RlLnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9kZS54ID0gcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZS55ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5vZGUueSA9IHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2UgS2FtYWRhIEthd2FpIHRvIHBvc2l0aW9uIG5vZGVzLiBUaGlzIGlzIHF1aXRlIGEgaGVhdnkgYWxnb3JpdGhtIHNvIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiBub2RlcyB3ZVxuICAgICAqIGNsdXN0ZXIgdGhlbSBmaXJzdCB0byByZWR1Y2UgdGhlIGFtb3VudC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJsYXlvdXROZXR3b3JrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxheW91dE5ldHdvcmsoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5lbmFibGVkICE9PSB0cnVlICYmIHRoaXMub3B0aW9ucy5pbXByb3ZlZExheW91dCA9PT0gdHJ1ZSkge1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcblxuICAgICAgICAvLyBmaXJzdCBjaGVjayBpZiB3ZSBzaG91bGQgS2FtYWRhIEthd2FpIHRvIGxheW91dC4gVGhlIHRocmVzaG9sZCBpcyBpZiBsZXNzIHRoYW4gaGFsZiBvZiB0aGUgdmlzaWJsZVxuICAgICAgICAvLyBub2RlcyBoYXZlIHByZWRlZmluZWQgcG9zaXRpb25zIHdlIHVzZSB0aGlzLlxuICAgICAgICB2YXIgcG9zaXRpb25EZWZpbmVkID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbaW5kaWNlc1tpXV07XG4gICAgICAgICAgaWYgKG5vZGUucHJlZGVmaW5lZFBvc2l0aW9uID09PSB0cnVlKSB7XG4gICAgICAgICAgICBwb3NpdGlvbkRlZmluZWQgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBsZXNzIHRoYW4gaGFsZiBvZiB0aGUgbm9kZXMgaGF2ZSBhIHByZWRlZmluZWQgcG9zaXRpb24gd2UgY29udGludWVcbiAgICAgICAgaWYgKHBvc2l0aW9uRGVmaW5lZCA8IDAuNSAqIGluZGljZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIE1BWF9MRVZFTFMgPSAxMDtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSAwO1xuICAgICAgICAgIHZhciBjbHVzdGVyVGhyZXNob2xkID0gdGhpcy5vcHRpb25zLmNsdXN0ZXJUaHJlc2hvbGQ7XG5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIERlZmluZSB0aGUgb3B0aW9ucyBmb3IgdGhlIGhpZGRlbiBjbHVzdGVyIG5vZGVzXG4gICAgICAgICAgLy8gVGhlc2Ugb3B0aW9ucyBkb24ndCBwcm9wYWdhdGUgb3V0c2lkZSB0aGUgY2x1c3RlcmluZyBwaGFzZS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFNvbWUgb3B0aW9ucyBhcmUgZXhwbGljaXRseSBkaXNhYmxlZCwgYmVjYXVzZSB0aGV5IG1heSBiZSBzZXQgaW4gZ3JvdXAgb3IgZGVmYXVsdCBub2RlIG9wdGlvbnMuXG4gICAgICAgICAgLy8gVGhlIGNsdXN0ZXJzIGFyZSBuZXZlciBkaXNwbGF5ZWQsIHNvIG1vc3QgZXhwbGljaXQgc2V0dGluZ3MgaGVyZSBzZXJ2ZSBhcyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVGhlIGV4cGxpY2l0IHNldHRpbmcgb2YgJ3NoYXBlJyBpcyB0byBhdm9pZCBgc2hhcGU6ICdpbWFnZSdgOyBpbWFnZXMgYXJlIG5vdCBwYXNzZWQgdG8gdGhlIGhpZGRlblxuICAgICAgICAgIC8vIGNsdXN0ZXIgbm9kZXMsIGxlYWRpbmcgdG8gYW4gZXhjZXB0aW9uIG9uIGNyZWF0aW9uLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gQWxsIHNldHRpbmdzIGhlcmUgYXJlIHBlcmZvcm1hbmNlIHJlbGF0ZWQsIGV4Y2VwdCB3aGVuIG5vdGVkIG90aGVyd2lzZS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIHZhciBjbHVzdGVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGNsdXN0ZXJOb2RlUHJvcGVydGllczoge1xuICAgICAgICAgICAgICBzaGFwZTogXCJlbGxpcHNlXCIsXG4gICAgICAgICAgICAgIC8vIEJ1Z2ZpeDogYXZvaWQgdHlwZSAnaW1hZ2UnLCBubyBpbWFnZXMgc3VwcGxpZWRcbiAgICAgICAgICAgICAgbGFiZWw6IFwiXCIsXG4gICAgICAgICAgICAgIC8vIGF2b2lkIGxhYmVsIGhhbmRsaW5nXG4gICAgICAgICAgICAgIGdyb3VwOiBcIlwiLFxuICAgICAgICAgICAgICAvLyBhdm9pZCBncm91cCBoYW5kbGluZ1xuICAgICAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICAgICAgbXVsdGk6IGZhbHNlXG4gICAgICAgICAgICAgIH0gLy8gYXZvaWQgZm9udCBwcm9wYWdhdGlvblxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2x1c3RlckVkZ2VQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIGxhYmVsOiBcIlwiLFxuICAgICAgICAgICAgICAvLyBhdm9pZCBsYWJlbCBoYW5kbGluZ1xuICAgICAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICAgICAgbXVsdGk6IGZhbHNlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIC8vIGF2b2lkIGZvbnQgcHJvcGFnYXRpb25cbiAgICAgICAgICAgICAgc21vb3RoOiB7XG4gICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UgLy8gYXZvaWQgZHJhd2luZyBwZW5hbHR5IGZvciBjb21wbGV4IGVkZ2VzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIGEgbG90IG9mIG5vZGVzLCB3ZSBjbHVzdGVyIGJlZm9yZSB3ZSBydW4gdGhlIGFsZ29yaXRobS5cbiAgICAgICAgICAvLyBOT1RFOiB0aGlzIHBhcnQgZmFpbHMgdG8gZmluZCBjbHVzdGVycyBmb3IgbGFyZ2Ugc2NhbGUtZnJlZSBuZXR3b3Jrcywgd2hpY2ggc2hvdWxkXG4gICAgICAgICAgLy8gICAgICAgYmUgZWFzaWx5IGNsdXN0ZXJhYmxlLlxuICAgICAgICAgIC8vIFRPRE86IGV4YW1pbmUgd2h5IHRoaXMgaXMgc29cbiAgICAgICAgICBpZiAoaW5kaWNlcy5sZW5ndGggPiBjbHVzdGVyVGhyZXNob2xkKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRMZW5ndGggPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpbmRpY2VzLmxlbmd0aCA+IGNsdXN0ZXJUaHJlc2hvbGQgJiYgbGV2ZWwgPD0gTUFYX0xFVkVMUykge1xuICAgICAgICAgICAgICAvL2NvbnNvbGUudGltZShcImNsdXN0ZXJpbmdcIilcbiAgICAgICAgICAgICAgbGV2ZWwgKz0gMTtcbiAgICAgICAgICAgICAgdmFyIGJlZm9yZSA9IGluZGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbWFueSBub2RlcyB3ZSBkbyBhIGh1YnNpemUgY2x1c3RlclxuICAgICAgICAgICAgICBpZiAobGV2ZWwgJSAzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMuY2x1c3RlcmluZy5jbHVzdGVyQnJpZGdlcyhjbHVzdGVyT3B0aW9ucyk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMuY2x1c3RlcmluZy5jbHVzdGVyT3V0bGllcnMoY2x1c3Rlck9wdGlvbnMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBhZnRlciA9IGluZGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoYmVmb3JlID09IGFmdGVyICYmIGxldmVsICUgMyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlY2x1c3RlckFsbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfbGF5b3V0RmFpbGVkXCIpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcIlRoaXMgbmV0d29yayBjb3VsZCBub3QgYmUgcG9zaXRpb25lZCBieSB0aGlzIHZlcnNpb24gb2YgdGhlIGltcHJvdmVkIGxheW91dCBhbGdvcml0aG0uXCIgKyBcIiBQbGVhc2UgZGlzYWJsZSBpbXByb3ZlZExheW91dCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy9jb25zb2xlLnRpbWVFbmQoXCJjbHVzdGVyaW5nXCIpXG4gICAgICAgICAgICAgIC8vY29uc29sZS5sb2coYmVmb3JlLGxldmVsLGFmdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBzaXplIG9mIHRoZSBlZGdlc1xuICAgICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMua2FtYWRhS2F3YWkuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgIHNwcmluZ0xlbmd0aDogTWF0aC5tYXgoMTUwLCAyICogc3RhcnRMZW5ndGgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxldmVsID4gTUFYX0xFVkVMUykge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKFwiVGhlIGNsdXN0ZXJpbmcgZGlkbid0IHN1Y2NlZWQgd2l0aGluIHRoZSBhbW91bnQgb2YgaW50ZXJhdGlvbnMgYWxsb3dlZCxcIiArIFwiIHByb2dyZXNzaW5nIHdpdGggcGFydGlhbCByZXN1bHQuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHBvc2l0aW9uIHRoZSBzeXN0ZW0gZm9yIHRoZXNlIG5vZGVzIGFuZCBlZGdlc1xuICAgICAgICAgIHRoaXMuYm9keS5tb2R1bGVzLmthbWFkYUthd2FpLnNvbHZlKGluZGljZXMsIHRoaXMuYm9keS5lZGdlSW5kaWNlcywgdHJ1ZSk7XG5cbiAgICAgICAgICAvLyBzaGlmdCB0byBjZW50ZXIgcG9pbnRcbiAgICAgICAgICB0aGlzLl9zaGlmdFRvQ2VudGVyKCk7XG5cbiAgICAgICAgICAvLyBwZXJ0dXJiIHRoZSBub2RlcyBhIGxpdHRsZSBiaXQgdG8gZm9yY2UgdGhlIHBoeXNpY3MgdG8ga2ljayBpblxuICAgICAgICAgIHZhciBvZmZzZXQgPSA3MDtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaW5kaWNlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIC8vIE9ubHkgcGVydHVyYiB0aGUgbm9kZXMgdGhhdCBhcmVuJ3QgZml4ZWRcbiAgICAgICAgICAgIHZhciBfbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tpbmRpY2VzW19pXV07XG4gICAgICAgICAgICBpZiAoX25vZGUucHJlZGVmaW5lZFBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBfbm9kZS54ICs9ICgwLjUgLSB0aGlzLl9ybmcoKSkgKiBvZmZzZXQ7XG4gICAgICAgICAgICAgIF9ub2RlLnkgKz0gKDAuNSAtIHRoaXMuX3JuZygpKSAqIG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB1bmNsdXN0ZXIgYWxsIGNsdXN0ZXJzXG4gICAgICAgICAgdGhpcy5fZGVjbHVzdGVyQWxsKCk7XG5cbiAgICAgICAgICAvLyByZXBvc2l0aW9uIGFsbCBiZXppZXIgbm9kZXMuXG4gICAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXBvc2l0aW9uQmV6aWVyTm9kZXNcIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIGFsbCB0aGUgbm9kZXMgdG93YXJkcyB0byB0aGUgY2VudGVyIHNvIGdyYXZpdGF0aW9uYWwgcHVsbCB3aWwgbm90IG1vdmUgdGhlIG5vZGVzIGF3YXkgZnJvbSB2aWV3XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zaGlmdFRvQ2VudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaGlmdFRvQ2VudGVyKCkge1xuICAgICAgdmFyIHJhbmdlID0gTmV0d29ya1V0aWwuZ2V0UmFuZ2VDb3JlKHRoaXMuYm9keS5ub2RlcywgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzKTtcbiAgICAgIHZhciBjZW50ZXIgPSBOZXR3b3JrVXRpbC5maW5kQ2VudGVyKHJhbmdlKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV07XG4gICAgICAgIG5vZGUueCAtPSBjZW50ZXIueDtcbiAgICAgICAgbm9kZS55IC09IGNlbnRlci55O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYWxsIGNsdXN0ZXJzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9kZWNsdXN0ZXJBbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RlY2x1c3RlckFsbCgpIHtcbiAgICAgIHZhciBjbHVzdGVyc1ByZXNlbnQgPSB0cnVlO1xuICAgICAgd2hpbGUgKGNsdXN0ZXJzUHJlc2VudCA9PT0gdHJ1ZSkge1xuICAgICAgICBjbHVzdGVyc1ByZXNlbnQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5ib2R5Lm5vZGVzW3RoaXMuYm9keS5ub2RlSW5kaWNlc1tpXV0uaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjbHVzdGVyc1ByZXNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ib2R5Lm1vZHVsZXMuY2x1c3RlcmluZy5vcGVuQ2x1c3Rlcih0aGlzLmJvZHkubm9kZUluZGljZXNbaV0sIHt9LCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjbHVzdGVyc1ByZXNlbnQgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfCp9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2VlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZWVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFJhbmRvbVNlZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgbWFpbiBmdW5jdGlvbiB0byBsYXlvdXQgdGhlIG5vZGVzIGluIGEgaGllcmFyY2hpY2FsIHdheS5cbiAgICAgKiBJdCBjaGVja3MgaWYgdGhlIG5vZGUgZGV0YWlscyBhcmUgc3VwcGxpZWQgY29ycmVjdGx5XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldHVwSGllcmFyY2hpY2FsTGF5b3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldHVwSGllcmFyY2hpY2FsTGF5b3V0KCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuZW5hYmxlZCA9PT0gdHJ1ZSAmJiB0aGlzLmJvZHkubm9kZUluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBnZXQgdGhlIHNpemUgb2YgdGhlIGxhcmdlc3QgaHVicyBhbmQgY2hlY2sgaWYgdGhlIHVzZXIgaGFzIGRlZmluZWQgYSBsZXZlbCBmb3IgYSBub2RlLlxuICAgICAgICB2YXIgbm9kZSwgbm9kZUlkO1xuICAgICAgICB2YXIgZGVmaW5lZExldmVsID0gZmFsc2U7XG4gICAgICAgIHZhciB1bmRlZmluZWRMZXZlbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3ROb2RlT25MZXZlbCA9IHt9O1xuICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbCA9IG5ldyBIaWVyYXJjaGljYWxTdGF0dXMoKTtcbiAgICAgICAgZm9yIChub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsIG5vZGVJZCkpIHtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICAgIGlmIChub2RlLm9wdGlvbnMubGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBkZWZpbmVkTGV2ZWwgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUlkXSA9IG5vZGUub3B0aW9ucy5sZXZlbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVuZGVmaW5lZExldmVsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgdXNlciBkZWZpbmVkIHNvbWUgbGV2ZWxzIGJ1dCBub3QgYWxsLCBhbGVydCBhbmQgcnVuIHdpdGhvdXQgaGllcmFyY2hpY2FsIGxheW91dFxuICAgICAgICBpZiAodW5kZWZpbmVkTGV2ZWwgPT09IHRydWUgJiYgZGVmaW5lZExldmVsID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gdXNlIHRoZSBoaWVyYXJjaGljYWwgbGF5b3V0LCBub2RlcyByZXF1aXJlIGVpdGhlciBubyBwcmVkZWZpbmVkIGxldmVsc1wiICsgXCIgb3IgbGV2ZWxzIGhhdmUgdG8gYmUgZGVmaW5lZCBmb3IgYWxsIG5vZGVzLlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWZpbmUgbGV2ZWxzIGlmIHVuZGVmaW5lZCBieSB0aGUgdXNlcnMuIEJhc2VkIG9uIGh1YnNpemUuXG4gICAgICAgICAgaWYgKHVuZGVmaW5lZExldmVsID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YXIgc29ydE1ldGhvZCA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuc29ydE1ldGhvZDtcbiAgICAgICAgICAgIGlmIChzb3J0TWV0aG9kID09PSBcImh1YnNpemVcIikge1xuICAgICAgICAgICAgICB0aGlzLl9kZXRlcm1pbmVMZXZlbHNCeUh1YnNpemUoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc29ydE1ldGhvZCA9PT0gXCJkaXJlY3RlZFwiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RldGVybWluZUxldmVsc0RpcmVjdGVkKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNvcnRNZXRob2QgPT09IFwiY3VzdG9tXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZGV0ZXJtaW5lTGV2ZWxzQ3VzdG9tQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBmYWxsYmFjayBmb3IgY2FzZXMgd2hlcmUgdGhlcmUgYXJlIG5vZGVzIGJ1dCBubyBlZGdlc1xuICAgICAgICAgIGZvciAodmFyIF9ub2RlSWQyIGluIHRoaXMuYm9keS5ub2Rlcykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmJvZHkubm9kZXMsIF9ub2RlSWQyKSkge1xuICAgICAgICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbC5lbnN1cmVMZXZlbChfbm9kZUlkMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNoZWNrIHRoZSBkaXN0cmlidXRpb24gb2YgdGhlIG5vZGVzIHBlciBsZXZlbC5cbiAgICAgICAgICB2YXIgZGlzdHJpYnV0aW9uID0gdGhpcy5fZ2V0RGlzdHJpYnV0aW9uKCk7XG5cbiAgICAgICAgICAvLyBnZXQgdGhlIHBhcmVudCBjaGlsZHJlbiByZWxhdGlvbnMuXG4gICAgICAgICAgdGhpcy5fZ2VuZXJhdGVNYXAoKTtcblxuICAgICAgICAgIC8vIHBsYWNlIHRoZSBub2RlcyBvbiB0aGUgY2FudmFzLlxuICAgICAgICAgIHRoaXMuX3BsYWNlTm9kZXNCeUhpZXJhcmNoeShkaXN0cmlidXRpb24pO1xuXG4gICAgICAgICAgLy8gY29uZGVuc2UgdGhlIHdoaXRlc3BhY2UuXG4gICAgICAgICAgdGhpcy5fY29uZGVuc2VIaWVyYXJjaHkoKTtcblxuICAgICAgICAgIC8vIHNoaWZ0IHRvIGNlbnRlciBzbyBncmF2aXR5IGRvZXMgbm90IGhhdmUgdG8gZG8gbXVjaFxuICAgICAgICAgIHRoaXMuX3NoaWZ0VG9DZW50ZXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbmRlbnNlSGllcmFyY2h5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb25kZW5zZUhpZXJhcmNoeSgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgLy8gR2xvYmFsIHZhciBpbiB0aGlzIHNjb3BlIHRvIGRlZmluZSB3aGVuIHRoZSBtb3ZlbWVudCBoYXMgc3RvcHBlZC5cbiAgICAgIHZhciBzdGlsbFNoaWZ0aW5nID0gZmFsc2U7XG4gICAgICB2YXIgYnJhbmNoZXMgPSB7fTtcbiAgICAgIC8vIGZpcnN0IHdlIGhhdmUgc29tZSBtZXRob2RzIHRvIGhlbHAgc2hpZnRpbmcgdHJlZXMgYXJvdW5kLlxuICAgICAgLy8gdGhlIG1haW4gbWV0aG9kIHRvIHNoaWZ0IHRoZSB0cmVlc1xuICAgICAgdmFyIHNoaWZ0VHJlZXMgPSBmdW5jdGlvbiBzaGlmdFRyZWVzKCkge1xuICAgICAgICB2YXIgdHJlZVNpemVzID0gZ2V0VHJlZVNpemVzKCk7XG4gICAgICAgIHZhciBzaGlmdEJ5ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlU2l6ZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgdmFyIGRpZmYgPSB0cmVlU2l6ZXNbaV0ubWF4IC0gdHJlZVNpemVzW2kgKyAxXS5taW47XG4gICAgICAgICAgc2hpZnRCeSArPSBkaWZmICsgX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLnRyZWVTcGFjaW5nO1xuICAgICAgICAgIHNoaWZ0VHJlZShpICsgMSwgc2hpZnRCeSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIHNoaWZ0IGEgc2luZ2xlIHRyZWUgYnkgYW4gb2Zmc2V0XG4gICAgICB2YXIgc2hpZnRUcmVlID0gZnVuY3Rpb24gc2hpZnRUcmVlKGluZGV4LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHRyZWVzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC50cmVlcztcbiAgICAgICAgZm9yICh2YXIgbm9kZUlkIGluIHRyZWVzKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0cmVlcywgbm9kZUlkKSkge1xuICAgICAgICAgICAgaWYgKHRyZWVzW25vZGVJZF0gPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgIF90aGlzMy5kaXJlY3Rpb24uc2hpZnQobm9kZUlkLCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gZ2V0IHRoZSB3aWR0aCBvZiBhbGwgdHJlZXNcbiAgICAgIHZhciBnZXRUcmVlU2l6ZXMgPSBmdW5jdGlvbiBnZXRUcmVlU2l6ZXMoKSB7XG4gICAgICAgIHZhciB0cmVlV2lkdGhzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMzLmhpZXJhcmNoaWNhbC5udW1UcmVlcygpOyBpKyspIHtcbiAgICAgICAgICB0cmVlV2lkdGhzLnB1c2goX3RoaXMzLmRpcmVjdGlvbi5nZXRUcmVlU2l6ZShpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyZWVXaWR0aHM7XG4gICAgICB9O1xuXG4gICAgICAvLyBnZXQgYSBtYXAgb2YgYWxsIG5vZGVzIGluIHRoaXMgYnJhbmNoXG4gICAgICB2YXIgZ2V0QnJhbmNoTm9kZXMgPSBmdW5jdGlvbiBnZXRCcmFuY2hOb2Rlcyhzb3VyY2UsIG1hcCkge1xuICAgICAgICBpZiAobWFwW3NvdXJjZS5pZF0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWFwW3NvdXJjZS5pZF0gPSB0cnVlO1xuICAgICAgICBpZiAoX3RoaXMzLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtzb3VyY2UuaWRdKSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5jaGlsZHJlblJlZmVyZW5jZVtzb3VyY2UuaWRdO1xuICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGdldEJyYW5jaE5vZGVzKF90aGlzMy5ib2R5Lm5vZGVzW2NoaWxkcmVuW2ldXSwgbWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIGdldCBhIG1pbiBtYXggd2lkdGggYXMgd2VsbCBhcyB0aGUgbWF4aW11bSBtb3ZlbWVudCBzcGFjZSBpdCBoYXMgb24gZWl0aGVyIHNpZGVzXG4gICAgICAvLyB3ZSB1c2UgbWluIG1heCB0ZXJtaW5vbG9neSBiZWNhdXNlIHdpZHRoIGFuZCBoZWlnaHQgY2FuIGludGVyY2hhbmdlIGRlcGVuZGluZyBvbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBsYXlvdXRcbiAgICAgIHZhciBnZXRCcmFuY2hCb3VuZGFyeSA9IGZ1bmN0aW9uIGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaE1hcCkge1xuICAgICAgICB2YXIgbWF4TGV2ZWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDFlOTtcbiAgICAgICAgdmFyIG1pblNwYWNlID0gMWU5O1xuICAgICAgICB2YXIgbWF4U3BhY2UgPSAxZTk7XG4gICAgICAgIHZhciBtaW4gPSAxZTk7XG4gICAgICAgIHZhciBtYXggPSAtMWU5O1xuICAgICAgICBmb3IgKHZhciBicmFuY2hOb2RlIGluIGJyYW5jaE1hcCkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYnJhbmNoTWFwLCBicmFuY2hOb2RlKSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBfdGhpczMuYm9keS5ub2Rlc1ticmFuY2hOb2RlXTtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IF90aGlzMy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGUuaWRdO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uID0gX3RoaXMzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihub2RlKTtcblxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBzcGFjZSBhcm91bmQgdGhlIG5vZGUuXG4gICAgICAgICAgICB2YXIgX3RoaXMzJF9nZXRTcGFjZUFyb3VuID0gX3RoaXMzLl9nZXRTcGFjZUFyb3VuZE5vZGUobm9kZSwgYnJhbmNoTWFwKSxcbiAgICAgICAgICAgICAgX3RoaXMzJF9nZXRTcGFjZUFyb3VuMiA9IF9zbGljZWRUb0FycmF5KF90aGlzMyRfZ2V0U3BhY2VBcm91biwgMiksXG4gICAgICAgICAgICAgIG1pblNwYWNlTm9kZSA9IF90aGlzMyRfZ2V0U3BhY2VBcm91bjJbMF0sXG4gICAgICAgICAgICAgIG1heFNwYWNlTm9kZSA9IF90aGlzMyRfZ2V0U3BhY2VBcm91bjJbMV07XG4gICAgICAgICAgICBtaW5TcGFjZSA9IE1hdGgubWluKG1pblNwYWNlTm9kZSwgbWluU3BhY2UpO1xuICAgICAgICAgICAgbWF4U3BhY2UgPSBNYXRoLm1pbihtYXhTcGFjZU5vZGUsIG1heFNwYWNlKTtcblxuICAgICAgICAgICAgLy8gdGhlIHdpZHRoIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHRoZSBsZXZlbHMgdHdvIG5vZGVzIGhhdmUgaW4gY29tbW9uLiBUaGlzIGlzIHdoeSB3ZSBmaWx0ZXIgb24gdGhpcy5cbiAgICAgICAgICAgIGlmIChsZXZlbCA8PSBtYXhMZXZlbCkge1xuICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihwb3NpdGlvbiwgbWluKTtcbiAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgocG9zaXRpb24sIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbWluLCBtYXgsIG1pblNwYWNlLCBtYXhTcGFjZV07XG4gICAgICB9O1xuXG4gICAgICAvLyBjaGVjayB3aGF0IHRoZSBtYXhpbXVtIGxldmVsIGlzIHRoZXNlIG5vZGVzIGhhdmUgaW4gY29tbW9uLlxuICAgICAgdmFyIGdldENvbGxpc2lvbkxldmVsID0gZnVuY3Rpb24gZ2V0Q29sbGlzaW9uTGV2ZWwobm9kZTEsIG5vZGUyKSB7XG4gICAgICAgIHZhciBtYXhMZXZlbDEgPSBfdGhpczMuaGllcmFyY2hpY2FsLmdldE1heExldmVsKG5vZGUxLmlkKTtcbiAgICAgICAgdmFyIG1heExldmVsMiA9IF90aGlzMy5oaWVyYXJjaGljYWwuZ2V0TWF4TGV2ZWwobm9kZTIuaWQpO1xuICAgICAgICByZXR1cm4gTWF0aC5taW4obWF4TGV2ZWwxLCBtYXhMZXZlbDIpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDb25kZW5zZSBlbGVtZW50cy4gVGhlc2UgY2FuIGJlIG5vZGVzIG9yIGJyYW5jaGVzIGRlcGVuZGluZyBvbiB0aGUgY2FsbGJhY2suXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGxldmVsc1xuICAgICAgICogQHBhcmFtIHsqfSBjZW50ZXJQYXJlbnRzXG4gICAgICAgKi9cbiAgICAgIHZhciBzaGlmdEVsZW1lbnRzQ2xvc2VyID0gZnVuY3Rpb24gc2hpZnRFbGVtZW50c0Nsb3NlcihjYWxsYmFjaywgbGV2ZWxzLCBjZW50ZXJQYXJlbnRzKSB7XG4gICAgICAgIHZhciBoaWVyID0gX3RoaXMzLmhpZXJhcmNoaWNhbDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICAgICAgdmFyIGxldmVsTm9kZXMgPSBoaWVyLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXTtcbiAgICAgICAgICBpZiAobGV2ZWxOb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxldmVsTm9kZXMubGVuZ3RoIC0gMTsgaisrKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlMSA9IGxldmVsTm9kZXNbal07XG4gICAgICAgICAgICAgIHZhciBub2RlMiA9IGxldmVsTm9kZXNbaiArIDFdO1xuXG4gICAgICAgICAgICAgIC8vIE5PVEU6IGxvZ2ljIG1haW50YWluZWQgYXMgaXQgd2FzOyBpZiBub2RlcyBoYXZlIHNhbWUgYW5jZXN0b3IsXG4gICAgICAgICAgICAgIC8vICAgICAgIHRoZW4gb2YgY291cnNlIHRoZXkgYXJlIGluIHRoZSBzYW1lIHN1Yi1uZXR3b3JrLlxuICAgICAgICAgICAgICBpZiAoaGllci5oYXNTYW1lUGFyZW50KG5vZGUxLCBub2RlMikgJiYgaGllci5pblNhbWVTdWJOZXR3b3JrKG5vZGUxLCBub2RlMikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhub2RlMSwgbm9kZTIsIGNlbnRlclBhcmVudHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBjYWxsYmFjayBmb3Igc2hpZnRpbmcgYnJhbmNoZXNcbiAgICAgIHZhciBicmFuY2hTaGlmdENhbGxiYWNrID0gZnVuY3Rpb24gYnJhbmNoU2hpZnRDYWxsYmFjayhub2RlMSwgbm9kZTIpIHtcbiAgICAgICAgdmFyIGNlbnRlclBhcmVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICAgIC8vd2luZG93LkNBTExCQUNLUy5wdXNoKCgpID0+IHtcbiAgICAgICAgdmFyIHBvczEgPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGUxKTtcbiAgICAgICAgdmFyIHBvczIgPSBfdGhpczMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKG5vZGUyKTtcbiAgICAgICAgdmFyIGRpZmZBYnMgPSBNYXRoLmFicyhwb3MyIC0gcG9zMSk7XG4gICAgICAgIHZhciBub2RlU3BhY2luZyA9IF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZztcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIk5PVyBDSEVDS0lORzpcIiwgbm9kZTEuaWQsIG5vZGUyLmlkLCBkaWZmQWJzKTtcbiAgICAgICAgaWYgKGRpZmZBYnMgPiBub2RlU3BhY2luZykge1xuICAgICAgICAgIHZhciBicmFuY2hOb2RlczEgPSB7fTtcbiAgICAgICAgICB2YXIgYnJhbmNoTm9kZXMyID0ge307XG4gICAgICAgICAgZ2V0QnJhbmNoTm9kZXMobm9kZTEsIGJyYW5jaE5vZGVzMSk7XG4gICAgICAgICAgZ2V0QnJhbmNoTm9kZXMobm9kZTIsIGJyYW5jaE5vZGVzMik7XG5cbiAgICAgICAgICAvLyBjaGVjayB0aGUgbGFyZ2VzdCBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBicmFuY2hlc1xuICAgICAgICAgIHZhciBtYXhMZXZlbCA9IGdldENvbGxpc2lvbkxldmVsKG5vZGUxLCBub2RlMik7XG4gICAgICAgICAgdmFyIGJyYW5jaE5vZGVCb3VuZGFyeTEgPSBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hOb2RlczEsIG1heExldmVsKTtcbiAgICAgICAgICB2YXIgYnJhbmNoTm9kZUJvdW5kYXJ5MiA9IGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaE5vZGVzMiwgbWF4TGV2ZWwpO1xuICAgICAgICAgIHZhciBtYXgxID0gYnJhbmNoTm9kZUJvdW5kYXJ5MVsxXTtcbiAgICAgICAgICB2YXIgbWluMiA9IGJyYW5jaE5vZGVCb3VuZGFyeTJbMF07XG4gICAgICAgICAgdmFyIG1pblNwYWNlMiA9IGJyYW5jaE5vZGVCb3VuZGFyeTJbMl07XG5cbiAgICAgICAgICAvL2NvbnNvbGUubG9nKG5vZGUxLmlkLCBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hOb2RlczEsIG1heExldmVsKSwgbm9kZTIuaWQsXG4gICAgICAgICAgLy8gICAgICAgICAgICBnZXRCcmFuY2hCb3VuZGFyeShicmFuY2hOb2RlczIsIG1heExldmVsKSwgbWF4TGV2ZWwpO1xuICAgICAgICAgIHZhciBkaWZmQnJhbmNoID0gTWF0aC5hYnMobWF4MSAtIG1pbjIpO1xuICAgICAgICAgIGlmIChkaWZmQnJhbmNoID4gbm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBtYXgxIC0gbWluMiArIG5vZGVTcGFjaW5nO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA8IC1taW5TcGFjZTIgKyBub2RlU3BhY2luZykge1xuICAgICAgICAgICAgICBvZmZzZXQgPSAtbWluU3BhY2UyICsgbm9kZVNwYWNpbmc7XG4gICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJSRVNFVFRJTkcgT0ZGU0VUXCIsIG1heDEgLSBtaW4yICsgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZywgLW1pblNwYWNlMiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlNISUZUSU5HXCIsIG5vZGUyLmlkLCBvZmZzZXQpO1xuICAgICAgICAgICAgICBfdGhpczMuX3NoaWZ0QmxvY2sobm9kZTIuaWQsIG9mZnNldCk7XG4gICAgICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICBpZiAoY2VudGVyUGFyZW50ID09PSB0cnVlKSBfdGhpczMuX2NlbnRlclBhcmVudChub2RlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7fSlcbiAgICAgIH07XG5cbiAgICAgIHZhciBtaW5pbWl6ZUVkZ2VMZW5ndGggPSBmdW5jdGlvbiBtaW5pbWl6ZUVkZ2VMZW5ndGgoaXRlcmF0aW9ucywgbm9kZSkge1xuICAgICAgICAvL3dpbmRvdy5DQUxMQkFDS1MucHVzaCgoKSA9PiB7XG4gICAgICAgIC8vICBjb25zb2xlLmxvZyhcInRzXCIsbm9kZS5pZCk7XG4gICAgICAgIHZhciBub2RlSWQgPSBub2RlLmlkO1xuICAgICAgICB2YXIgYWxsRWRnZXMgPSBub2RlLmVkZ2VzO1xuICAgICAgICB2YXIgbm9kZUxldmVsID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZS5pZF07XG5cbiAgICAgICAgLy8gZ2F0aGVyIGNvbnN0YW50c1xuICAgICAgICB2YXIgQzIgPSBfdGhpczMub3B0aW9ucy5oaWVyYXJjaGljYWwubGV2ZWxTZXBhcmF0aW9uICogX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmxldmVsU2VwYXJhdGlvbjtcbiAgICAgICAgdmFyIHJlZmVyZW5jZU5vZGVzID0ge307XG4gICAgICAgIHZhciBhYm92ZUVkZ2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGFsbEVkZ2VzW2ldO1xuICAgICAgICAgIGlmIChlZGdlLnRvSWQgIT0gZWRnZS5mcm9tSWQpIHtcbiAgICAgICAgICAgIHZhciBvdGhlck5vZGUgPSBlZGdlLnRvSWQgPT0gbm9kZUlkID8gZWRnZS5mcm9tIDogZWRnZS50bztcbiAgICAgICAgICAgIHJlZmVyZW5jZU5vZGVzW2FsbEVkZ2VzW2ldLmlkXSA9IG90aGVyTm9kZTtcbiAgICAgICAgICAgIGlmIChfdGhpczMuaGllcmFyY2hpY2FsLmxldmVsc1tvdGhlck5vZGUuaWRdIDwgbm9kZUxldmVsKSB7XG4gICAgICAgICAgICAgIGFib3ZlRWRnZXMucHVzaChlZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkaWZmZXJlbnRpYXRlZCBzdW0gb2YgbGVuZ3RocyBiYXNlZCBvbiBvbmx5IG1vdmluZyBvbmUgbm9kZSBvdmVyIG9uZSBheGlzXG4gICAgICAgIHZhciBnZXRGeCA9IGZ1bmN0aW9uIGdldEZ4KHBvaW50LCBlZGdlcykge1xuICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGVkZ2VzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgIGlmIChyZWZlcmVuY2VOb2Rlc1tlZGdlc1tfaTJdLmlkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHZhciBhID0gX3RoaXMzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihyZWZlcmVuY2VOb2Rlc1tlZGdlc1tfaTJdLmlkXSkgLSBwb2ludDtcbiAgICAgICAgICAgICAgc3VtICs9IGEgLyBNYXRoLnNxcnQoYSAqIGEgKyBDMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gZG91Ymx5IGRpZmZlcmVudGlhdGVkIHN1bSBvZiBsZW5ndGhzIGJhc2VkIG9uIG9ubHkgbW92aW5nIG9uZSBub2RlIG92ZXIgb25lIGF4aXNcbiAgICAgICAgdmFyIGdldERGeCA9IGZ1bmN0aW9uIGdldERGeChwb2ludCwgZWRnZXMpIHtcbiAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBlZGdlcy5sZW5ndGg7IF9pMysrKSB7XG4gICAgICAgICAgICBpZiAocmVmZXJlbmNlTm9kZXNbZWRnZXNbX2kzXS5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB2YXIgYSA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24ocmVmZXJlbmNlTm9kZXNbZWRnZXNbX2kzXS5pZF0pIC0gcG9pbnQ7XG4gICAgICAgICAgICAgIHN1bSAtPSBDMiAqIE1hdGgucG93KGEgKiBhICsgQzIsIC0xLjUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZ2V0R3Vlc3MgPSBmdW5jdGlvbiBnZXRHdWVzcyhpdGVyYXRpb25zLCBlZGdlcykge1xuICAgICAgICAgIHZhciBndWVzcyA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZSk7XG4gICAgICAgICAgLy8gTmV3dG9uJ3MgbWV0aG9kIGZvciBvcHRpbWl6YXRpb25cbiAgICAgICAgICB2YXIgZ3Vlc3NNYXAgPSB7fTtcbiAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBpdGVyYXRpb25zOyBfaTQrKykge1xuICAgICAgICAgICAgdmFyIGZ4ID0gZ2V0RngoZ3Vlc3MsIGVkZ2VzKTtcbiAgICAgICAgICAgIHZhciBkZnggPSBnZXRERngoZ3Vlc3MsIGVkZ2VzKTtcblxuICAgICAgICAgICAgLy8gd2UgbGltaXQgdGhlIG1vdmVtZW50IHRvIGF2b2lkIGluc3RhYmlsaXR5LlxuICAgICAgICAgICAgdmFyIGxpbWl0ID0gNDA7XG4gICAgICAgICAgICB2YXIgcmF0aW8gPSBNYXRoLm1heCgtbGltaXQsIE1hdGgubWluKGxpbWl0LCBNYXRoLnJvdW5kKGZ4IC8gZGZ4KSkpO1xuICAgICAgICAgICAgZ3Vlc3MgPSBndWVzcyAtIHJhdGlvO1xuICAgICAgICAgICAgLy8gcmVkdWNlIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgIGlmIChndWVzc01hcFtndWVzc10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGd1ZXNzTWFwW2d1ZXNzXSA9IF9pNDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGd1ZXNzO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbW92ZUJyYW5jaCA9IGZ1bmN0aW9uIG1vdmVCcmFuY2goZ3Vlc3MpIHtcbiAgICAgICAgICAvLyBwb3NpdGlvbiBub2RlIGlmIHRoZXJlIGlzIHNwYWNlXG4gICAgICAgICAgdmFyIG5vZGVQb3NpdGlvbiA9IF90aGlzMy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZSk7XG5cbiAgICAgICAgICAvLyBjaGVjayBtb3ZhYmxlIGFyZWEgb2YgdGhlIGJyYW5jaFxuICAgICAgICAgIGlmIChicmFuY2hlc1tub2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgYnJhbmNoTm9kZXMgPSB7fTtcbiAgICAgICAgICAgIGdldEJyYW5jaE5vZGVzKG5vZGUsIGJyYW5jaE5vZGVzKTtcbiAgICAgICAgICAgIGJyYW5jaGVzW25vZGUuaWRdID0gYnJhbmNoTm9kZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBicmFuY2hCb3VuZGFyeSA9IGdldEJyYW5jaEJvdW5kYXJ5KGJyYW5jaGVzW25vZGUuaWRdKTtcbiAgICAgICAgICB2YXIgbWluU3BhY2VCcmFuY2ggPSBicmFuY2hCb3VuZGFyeVsyXTtcbiAgICAgICAgICB2YXIgbWF4U3BhY2VCcmFuY2ggPSBicmFuY2hCb3VuZGFyeVszXTtcbiAgICAgICAgICB2YXIgZGlmZiA9IGd1ZXNzIC0gbm9kZVBvc2l0aW9uO1xuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIGFsbG93ZWQgdG8gbW92ZSB0aGUgbm9kZTpcbiAgICAgICAgICB2YXIgYnJhbmNoT2Zmc2V0ID0gMDtcbiAgICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgIGJyYW5jaE9mZnNldCA9IE1hdGgubWluKGRpZmYsIG1heFNwYWNlQnJhbmNoIC0gX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpZmYgPCAwKSB7XG4gICAgICAgICAgICBicmFuY2hPZmZzZXQgPSAtTWF0aC5taW4oLWRpZmYsIG1pblNwYWNlQnJhbmNoIC0gX3RoaXMzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJyYW5jaE9mZnNldCAhPSAwKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwibW92aW5nIGJyYW5jaDpcIixicmFuY2hPZmZzZXQsIG1heFNwYWNlQnJhbmNoLCBtaW5TcGFjZUJyYW5jaClcbiAgICAgICAgICAgIF90aGlzMy5fc2hpZnRCbG9jayhub2RlLmlkLCBicmFuY2hPZmZzZXQpO1xuICAgICAgICAgICAgLy90aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG1vdmVOb2RlID0gZnVuY3Rpb24gbW92ZU5vZGUoZ3Vlc3MpIHtcbiAgICAgICAgICB2YXIgbm9kZVBvc2l0aW9uID0gX3RoaXMzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihub2RlKTtcblxuICAgICAgICAgIC8vIHBvc2l0aW9uIG5vZGUgaWYgdGhlcmUgaXMgc3BhY2VcbiAgICAgICAgICB2YXIgX3RoaXMzJF9nZXRTcGFjZUFyb3VuMyA9IF90aGlzMy5fZ2V0U3BhY2VBcm91bmROb2RlKG5vZGUpLFxuICAgICAgICAgICAgX3RoaXMzJF9nZXRTcGFjZUFyb3VuNCA9IF9zbGljZWRUb0FycmF5KF90aGlzMyRfZ2V0U3BhY2VBcm91bjMsIDIpLFxuICAgICAgICAgICAgbWluU3BhY2UgPSBfdGhpczMkX2dldFNwYWNlQXJvdW40WzBdLFxuICAgICAgICAgICAgbWF4U3BhY2UgPSBfdGhpczMkX2dldFNwYWNlQXJvdW40WzFdO1xuICAgICAgICAgIHZhciBkaWZmID0gZ3Vlc3MgLSBub2RlUG9zaXRpb247XG4gICAgICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIGFsbG93ZWQgdG8gbW92ZSB0aGUgbm9kZTpcbiAgICAgICAgICB2YXIgbmV3UG9zaXRpb24gPSBub2RlUG9zaXRpb247XG4gICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBuZXdQb3NpdGlvbiA9IE1hdGgubWluKG5vZGVQb3NpdGlvbiArIChtYXhTcGFjZSAtIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyksIGd1ZXNzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpZmYgPCAwKSB7XG4gICAgICAgICAgICBuZXdQb3NpdGlvbiA9IE1hdGgubWF4KG5vZGVQb3NpdGlvbiAtIChtaW5TcGFjZSAtIF90aGlzMy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyksIGd1ZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5ld1Bvc2l0aW9uICE9PSBub2RlUG9zaXRpb24pIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJtb3ZpbmcgTm9kZTpcIixkaWZmLCBtaW5TcGFjZSwgbWF4U3BhY2UpO1xuICAgICAgICAgICAgX3RoaXMzLmRpcmVjdGlvbi5zZXRQb3NpdGlvbihub2RlLCBuZXdQb3NpdGlvbik7XG4gICAgICAgICAgICAvL3RoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgICAgICAgICAgc3RpbGxTaGlmdGluZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZ3Vlc3MgPSBnZXRHdWVzcyhpdGVyYXRpb25zLCBhYm92ZUVkZ2VzKTtcbiAgICAgICAgbW92ZUJyYW5jaChndWVzcyk7XG4gICAgICAgIGd1ZXNzID0gZ2V0R3Vlc3MoaXRlcmF0aW9ucywgYWxsRWRnZXMpO1xuICAgICAgICBtb3ZlTm9kZShndWVzcyk7XG4gICAgICAgIC8vfSlcbiAgICAgIH07XG5cbiAgICAgIC8vIG1ldGhvZCB0byByZW1vdmUgd2hpdGVzcGFjZSBiZXR3ZWVuIGJyYW5jaGVzLiBCZWNhdXNlIHdlIGRvIGJvdHRvbSB1cCwgd2UgY2FuIGNlbnRlciB0aGUgcGFyZW50cy5cbiAgICAgIHZhciBtaW5pbWl6ZUVkZ2VMZW5ndGhCb3R0b21VcCA9IGZ1bmN0aW9uIG1pbmltaXplRWRnZUxlbmd0aEJvdHRvbVVwKGl0ZXJhdGlvbnMpIHtcbiAgICAgICAgdmFyIGxldmVscyA9IF90aGlzMy5oaWVyYXJjaGljYWwuZ2V0TGV2ZWxzKCk7XG4gICAgICAgIGxldmVscyA9IF9yZXZlcnNlSW5zdGFuY2VQcm9wZXJ0eShsZXZlbHMpLmNhbGwobGV2ZWxzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICBzdGlsbFNoaWZ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tqXTtcbiAgICAgICAgICAgIHZhciBsZXZlbE5vZGVzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5kaXN0cmlidXRpb25PcmRlcmluZ1tsZXZlbF07XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxldmVsTm9kZXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgbWluaW1pemVFZGdlTGVuZ3RoKDEwMDAsIGxldmVsTm9kZXNba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RpbGxTaGlmdGluZyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkZJTklTSEVEIG1pbmltaXplRWRnZUxlbmd0aEJvdHRvbVVwIElOIFwiICsgaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIG1ldGhvZCB0byByZW1vdmUgd2hpdGVzcGFjZSBiZXR3ZWVuIGJyYW5jaGVzLiBCZWNhdXNlIHdlIGRvIGJvdHRvbSB1cCwgd2UgY2FuIGNlbnRlciB0aGUgcGFyZW50cy5cbiAgICAgIHZhciBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAgPSBmdW5jdGlvbiBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAoaXRlcmF0aW9ucykge1xuICAgICAgICB2YXIgbGV2ZWxzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5nZXRMZXZlbHMoKTtcbiAgICAgICAgbGV2ZWxzID0gX3JldmVyc2VJbnN0YW5jZVByb3BlcnR5KGxldmVscykuY2FsbChsZXZlbHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAgIHN0aWxsU2hpZnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzaGlmdEVsZW1lbnRzQ2xvc2VyKGJyYW5jaFNoaWZ0Q2FsbGJhY2ssIGxldmVscywgdHJ1ZSk7XG4gICAgICAgICAgaWYgKHN0aWxsU2hpZnRpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJGSU5JU0hFRCBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAgSU4gXCIgKyAoaSsxKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIGNlbnRlciBhbGwgcGFyZW50c1xuICAgICAgdmFyIGNlbnRlckFsbFBhcmVudHMgPSBmdW5jdGlvbiBjZW50ZXJBbGxQYXJlbnRzKCkge1xuICAgICAgICBmb3IgKHZhciBub2RlSWQgaW4gX3RoaXMzLmJvZHkubm9kZXMpIHtcbiAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF90aGlzMy5ib2R5Lm5vZGVzLCBub2RlSWQpKSBfdGhpczMuX2NlbnRlclBhcmVudChfdGhpczMuYm9keS5ub2Rlc1tub2RlSWRdKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gY2VudGVyIGFsbCBwYXJlbnRzXG4gICAgICB2YXIgY2VudGVyQWxsUGFyZW50c0JvdHRvbVVwID0gZnVuY3Rpb24gY2VudGVyQWxsUGFyZW50c0JvdHRvbVVwKCkge1xuICAgICAgICB2YXIgbGV2ZWxzID0gX3RoaXMzLmhpZXJhcmNoaWNhbC5nZXRMZXZlbHMoKTtcbiAgICAgICAgbGV2ZWxzID0gX3JldmVyc2VJbnN0YW5jZVByb3BlcnR5KGxldmVscykuY2FsbChsZXZlbHMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBsZXZlbCA9IGxldmVsc1tpXTtcbiAgICAgICAgICB2YXIgbGV2ZWxOb2RlcyA9IF90aGlzMy5oaWVyYXJjaGljYWwuZGlzdHJpYnV0aW9uT3JkZXJpbmdbbGV2ZWxdO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGV2ZWxOb2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgX3RoaXMzLl9jZW50ZXJQYXJlbnQobGV2ZWxOb2Rlc1tqXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyB0aGUgYWN0dWFsIHdvcmsgaXMgZG9uZSBoZXJlLlxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuYmxvY2tTaGlmdGluZyA9PT0gdHJ1ZSkge1xuICAgICAgICBzaGlmdEJyYW5jaGVzQ2xvc2VyQm90dG9tVXAoNSk7XG4gICAgICAgIGNlbnRlckFsbFBhcmVudHMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWluaW1pemUgZWRnZSBsZW5ndGhcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmVkZ2VNaW5pbWl6YXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgbWluaW1pemVFZGdlTGVuZ3RoQm90dG9tVXAoMjApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwucGFyZW50Q2VudHJhbGl6YXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgY2VudGVyQWxsUGFyZW50c0JvdHRvbVVwKCk7XG4gICAgICB9XG4gICAgICBzaGlmdFRyZWVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBnaXZlcyB0aGUgc3BhY2UgYXJvdW5kIHRoZSBub2RlLiBJRiBhIG1hcCBpcyBzdXBwbGllZCwgaXQgd2lsbCBvbmx5IGNoZWNrIGFnYWluc3Qgbm9kZXMgTk9UIGluIHRoZSBtYXAuXG4gICAgICogVGhpcyBpcyB1c2VkIHRvIG9ubHkgZ2V0IHRoZSBkaXN0YW5jZXMgdG8gbm9kZXMgb3V0c2lkZSBvZiBhIGJyYW5jaC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7e05vZGUuaWQ6IHZpcy5Ob2RlfX0gbWFwXG4gICAgICogQHJldHVybnMge251bWJlcltdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFNwYWNlQXJvdW5kTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3BhY2VBcm91bmROb2RlKG5vZGUsIG1hcCkge1xuICAgICAgdmFyIHVzZU1hcCA9IHRydWU7XG4gICAgICBpZiAobWFwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdXNlTWFwID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbGV2ZWwgPSB0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZS5pZF07XG4gICAgICBpZiAobGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmhpZXJhcmNoaWNhbC5kaXN0cmlidXRpb25JbmRleFtub2RlLmlkXTtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZSk7XG4gICAgICAgIHZhciBvcmRlcmluZyA9IHRoaXMuaGllcmFyY2hpY2FsLmRpc3RyaWJ1dGlvbk9yZGVyaW5nW2xldmVsXTtcbiAgICAgICAgdmFyIG1pblNwYWNlID0gMWU5O1xuICAgICAgICB2YXIgbWF4U3BhY2UgPSAxZTk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gMCkge1xuICAgICAgICAgIHZhciBwcmV2Tm9kZSA9IG9yZGVyaW5nW2luZGV4IC0gMV07XG4gICAgICAgICAgaWYgKHVzZU1hcCA9PT0gdHJ1ZSAmJiBtYXBbcHJldk5vZGUuaWRdID09PSB1bmRlZmluZWQgfHwgdXNlTWFwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIHByZXZQb3MgPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbihwcmV2Tm9kZSk7XG4gICAgICAgICAgICBtaW5TcGFjZSA9IHBvc2l0aW9uIC0gcHJldlBvcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ICE9IG9yZGVyaW5nLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICB2YXIgbmV4dE5vZGUgPSBvcmRlcmluZ1tpbmRleCArIDFdO1xuICAgICAgICAgIGlmICh1c2VNYXAgPT09IHRydWUgJiYgbWFwW25leHROb2RlLmlkXSA9PT0gdW5kZWZpbmVkIHx8IHVzZU1hcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhciBuZXh0UG9zID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obmV4dE5vZGUpO1xuICAgICAgICAgICAgbWF4U3BhY2UgPSBNYXRoLm1pbihtYXhTcGFjZSwgbmV4dFBvcyAtIHBvc2l0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFttaW5TcGFjZSwgbWF4U3BhY2VdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFswLCAwXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSB1c2UgdGhpcyBtZXRob2QgdG8gY2VudGVyIGEgcGFyZW50IG5vZGUgYW5kIGNoZWNrIGlmIGl0IGRvZXMgbm90IGNyb3NzIG90aGVyIG5vZGVzIHdoZW4gaXQgZG9lcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NlbnRlclBhcmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2VudGVyUGFyZW50KG5vZGUpIHtcbiAgICAgIGlmICh0aGlzLmhpZXJhcmNoaWNhbC5wYXJlbnRSZWZlcmVuY2Vbbm9kZS5pZF0pIHtcbiAgICAgICAgdmFyIHBhcmVudHMgPSB0aGlzLmhpZXJhcmNoaWNhbC5wYXJlbnRSZWZlcmVuY2Vbbm9kZS5pZF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwYXJlbnRJZCA9IHBhcmVudHNbaV07XG4gICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbcGFyZW50SWRdO1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuaGllcmFyY2hpY2FsLmNoaWxkcmVuUmVmZXJlbmNlW3BhcmVudElkXTtcbiAgICAgICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSByYW5nZSBvZiB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvbiA9IHRoaXMuX2dldENlbnRlclBvc2l0aW9uKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKHBhcmVudE5vZGUpO1xuICAgICAgICAgICAgdmFyIF90aGlzJF9nZXRTcGFjZUFyb3VuZCA9IHRoaXMuX2dldFNwYWNlQXJvdW5kTm9kZShwYXJlbnROb2RlKSxcbiAgICAgICAgICAgICAgX3RoaXMkX2dldFNwYWNlQXJvdW5kMiA9IF9zbGljZWRUb0FycmF5KF90aGlzJF9nZXRTcGFjZUFyb3VuZCwgMiksXG4gICAgICAgICAgICAgIG1pblNwYWNlID0gX3RoaXMkX2dldFNwYWNlQXJvdW5kMlswXSxcbiAgICAgICAgICAgICAgbWF4U3BhY2UgPSBfdGhpcyRfZ2V0U3BhY2VBcm91bmQyWzFdO1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBwb3NpdGlvbiAtIG5ld1Bvc2l0aW9uO1xuICAgICAgICAgICAgaWYgKGRpZmYgPCAwICYmIE1hdGguYWJzKGRpZmYpIDwgbWF4U3BhY2UgLSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nIHx8IGRpZmYgPiAwICYmIE1hdGguYWJzKGRpZmYpIDwgbWluU3BhY2UgLSB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLm5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKHBhcmVudE5vZGUsIG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHBsYWNlcyB0aGUgbm9kZXMgb24gdGhlIGNhbnZhcyBiYXNlZCBvbiB0aGUgaGllcmFyY2hpYWwgZGlzdHJpYnV0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGRpc3RyaWJ1dGlvbiB8IG9idGFpbmVkIGJ5IHRoZSBmdW5jdGlvbiB0aGlzLl9nZXREaXN0cmlidXRpb24oKVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BsYWNlTm9kZXNCeUhpZXJhcmNoeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGxhY2VOb2Rlc0J5SGllcmFyY2h5KGRpc3RyaWJ1dGlvbikge1xuICAgICAgdGhpcy5wb3NpdGlvbmVkTm9kZXMgPSB7fTtcbiAgICAgIC8vIHN0YXJ0IHBsYWNpbmcgYWxsIHRoZSBsZXZlbCAwIG5vZGVzIGZpcnN0LiBUaGVuIHJlY3Vyc2l2ZWx5IHBvc2l0aW9uIHRoZWlyIGJyYW5jaGVzLlxuICAgICAgZm9yICh2YXIgbGV2ZWwgaW4gZGlzdHJpYnV0aW9uKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGlzdHJpYnV0aW9uLCBsZXZlbCkpIHtcbiAgICAgICAgICB2YXIgX2NvbnRleHQ7XG4gICAgICAgICAgLy8gc29ydCBub2RlcyBpbiBsZXZlbCBieSBwb3NpdGlvbjpcbiAgICAgICAgICB2YXIgbm9kZUFycmF5ID0gX09iamVjdCRrZXlzKGRpc3RyaWJ1dGlvbltsZXZlbF0pO1xuICAgICAgICAgIG5vZGVBcnJheSA9IHRoaXMuX2luZGV4QXJyYXlUb05vZGVzKG5vZGVBcnJheSk7XG4gICAgICAgICAgX3NvcnRJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0ID0gdGhpcy5kaXJlY3Rpb24pLmNhbGwoX2NvbnRleHQsIG5vZGVBcnJheSk7XG4gICAgICAgICAgdmFyIGhhbmRsZWROb2RlQ291bnQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZUFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVBcnJheVtpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uZWROb2Rlc1tub2RlLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHZhciBzcGFjaW5nID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZztcbiAgICAgICAgICAgICAgdmFyIHBvcyA9IHNwYWNpbmcgKiBoYW5kbGVkTm9kZUNvdW50O1xuICAgICAgICAgICAgICAvLyBXZSBnZXQgdGhlIFggb3IgWSB2YWx1ZXMgd2UgbmVlZCBhbmQgc3RvcmUgdGhlbSBpbiBwb3MgYW5kIHByZXZpb3VzUG9zLlxuICAgICAgICAgICAgICAvLyBUaGUgZ2V0IGFuZCBzZXQgbWFrZSBzdXJlIHdlIGdldCBYIG9yIFlcbiAgICAgICAgICAgICAgaWYgKGhhbmRsZWROb2RlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgcG9zID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24obm9kZUFycmF5W2kgLSAxXSkgKyBzcGFjaW5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uLnNldFBvc2l0aW9uKG5vZGUsIHBvcywgbGV2ZWwpO1xuICAgICAgICAgICAgICB0aGlzLl92YWxpZGF0ZVBvc2l0aW9uQW5kQ29udGludWUobm9kZSwgbGV2ZWwsIHBvcyk7XG4gICAgICAgICAgICAgIGhhbmRsZWROb2RlQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGEgcmVjdXJzaXZlbHkgY2FsbGVkIGZ1bmN0aW9uIHRvIGVudW1lcmF0ZSB0aGUgYnJhbmNoZXMgZnJvbSB0aGUgbGFyZ2VzdCBodWJzIGFuZCBwbGFjZSB0aGUgbm9kZXNcbiAgICAgKiBvbiBhIFggcG9zaXRpb24gdGhhdCBlbnN1cmVzIHRoZXJlIHdpbGwgYmUgbm8gb3ZlcmxhcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gcGFyZW50SWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFyZW50TGV2ZWxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9wbGFjZUJyYW5jaE5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wbGFjZUJyYW5jaE5vZGVzKHBhcmVudElkLCBwYXJlbnRMZXZlbCkge1xuICAgICAgdmFyIF9jb250ZXh0MjtcbiAgICAgIHZhciBjaGlsZFJlZiA9IHRoaXMuaGllcmFyY2hpY2FsLmNoaWxkcmVuUmVmZXJlbmNlW3BhcmVudElkXTtcblxuICAgICAgLy8gaWYgdGhpcyBpcyBub3QgYSBwYXJlbnQsIGNhbmNlbCB0aGUgcGxhY2luZy4gVGhpcyBjYW4gaGFwcGVuIHdpdGggbXVsdGlwbGUgcGFyZW50cyB0byBvbmUgY2hpbGQuXG4gICAgICBpZiAoY2hpbGRSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGdldCBhIGxpc3Qgb2YgY2hpbGROb2Rlc1xuICAgICAgdmFyIGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRSZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hpbGROb2Rlcy5wdXNoKHRoaXMuYm9keS5ub2Rlc1tjaGlsZFJlZltpXV0pO1xuICAgICAgfVxuXG4gICAgICAvLyB1c2UgdGhlIHBvc2l0aW9ucyB0byBvcmRlciB0aGUgbm9kZXMuXG4gICAgICBfc29ydEluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQyID0gdGhpcy5kaXJlY3Rpb24pLmNhbGwoX2NvbnRleHQyLCBjaGlsZE5vZGVzKTtcblxuICAgICAgLy8gcG9zaXRpb24gdGhlIGNoaWxkTm9kZXNcbiAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBfaTUrKykge1xuICAgICAgICB2YXIgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tfaTVdO1xuICAgICAgICB2YXIgY2hpbGROb2RlTGV2ZWwgPSB0aGlzLmhpZXJhcmNoaWNhbC5sZXZlbHNbY2hpbGROb2RlLmlkXTtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGNoaWxkIG5vZGUgaXMgYmVsb3cgdGhlIHBhcmVudCBub2RlIGFuZCBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIHBvc2l0aW9uZWQuXG4gICAgICAgIGlmIChjaGlsZE5vZGVMZXZlbCA+IHBhcmVudExldmVsICYmIHRoaXMucG9zaXRpb25lZE5vZGVzW2NoaWxkTm9kZS5pZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGdldCB0aGUgYW1vdW50IG9mIHNwYWNlIHJlcXVpcmVkIGZvciB0aGlzIG5vZGUuIElmIHBhcmVudCB0aGUgd2lkdGggaXMgYmFzZWQgb24gdGhlIGFtb3VudCBvZiBjaGlsZHJlbi5cbiAgICAgICAgICB2YXIgc3BhY2luZyA9IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmc7XG4gICAgICAgICAgdmFyIHBvcyA9IHZvaWQgMDtcblxuICAgICAgICAgIC8vIHdlIGdldCB0aGUgWCBvciBZIHZhbHVlcyB3ZSBuZWVkIGFuZCBzdG9yZSB0aGVtIGluIHBvcyBhbmQgcHJldmlvdXNQb3MuXG4gICAgICAgICAgLy8gVGhlIGdldCBhbmQgc2V0IG1ha2Ugc3VyZSB3ZSBnZXQgWCBvciBZXG4gICAgICAgICAgaWYgKF9pNSA9PT0gMCkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5kaXJlY3Rpb24uZ2V0UG9zaXRpb24odGhpcy5ib2R5Lm5vZGVzW3BhcmVudElkXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKGNoaWxkTm9kZXNbX2k1IC0gMV0pICsgc3BhY2luZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5kaXJlY3Rpb24uc2V0UG9zaXRpb24oY2hpbGROb2RlLCBwb3MsIGNoaWxkTm9kZUxldmVsKTtcbiAgICAgICAgICB0aGlzLl92YWxpZGF0ZVBvc2l0aW9uQW5kQ29udGludWUoY2hpbGROb2RlLCBjaGlsZE5vZGVMZXZlbCwgcG9zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gY2VudGVyIHRoZSBwYXJlbnQgbm9kZXMuXG4gICAgICB2YXIgY2VudGVyID0gdGhpcy5fZ2V0Q2VudGVyUG9zaXRpb24oY2hpbGROb2Rlcyk7XG4gICAgICB0aGlzLmRpcmVjdGlvbi5zZXRQb3NpdGlvbih0aGlzLmJvZHkubm9kZXNbcGFyZW50SWRdLCBjZW50ZXIsIHBhcmVudExldmVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBjaGVja3MgZm9yIG92ZXJsYXAgYW5kIGlmIHJlcXVpcmVkIHNoaWZ0cyB0aGUgYnJhbmNoLiBJdCBhbHNvIGtlZXBzIHJlY29yZHMgb2YgcG9zaXRpb25lZCBub2Rlcy5cbiAgICAgKiBGaW5hbGx5IGl0IHdpbGwgY2FsbCBfcGxhY2VCcmFuY2hOb2RlcyB0byBwbGFjZSB0aGUgYnJhbmNoIG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3ZhbGlkYXRlUG9zaXRpb25BbmRDb250aW51ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdmFsaWRhdGVQb3NpdGlvbkFuZENvbnRpbnVlKG5vZGUsIGxldmVsLCBwb3MpIHtcbiAgICAgIC8vIFRoaXMgbWV0aG9kIG9ubHkgd29ya3MgZm9yIGZvcm1hbCB0cmVlcyBhbmQgZm9ybWFsIGZvcmVzdHNcbiAgICAgIC8vIEVhcmx5IGV4aXQgaWYgdGhpcyBpcyBub3QgdGhlIGNhc2VcbiAgICAgIGlmICghdGhpcy5oaWVyYXJjaGljYWwuaXNUcmVlKSByZXR1cm47XG5cbiAgICAgIC8vIGlmIG92ZXJsYXAgaGFzIGJlZW4gZGV0ZWN0ZWQsIHdlIHNoaWZ0IHRoZSBicmFuY2hcbiAgICAgIGlmICh0aGlzLmxhc3ROb2RlT25MZXZlbFtsZXZlbF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgcHJldmlvdXNQb3MgPSB0aGlzLmRpcmVjdGlvbi5nZXRQb3NpdGlvbih0aGlzLmJvZHkubm9kZXNbdGhpcy5sYXN0Tm9kZU9uTGV2ZWxbbGV2ZWxdXSk7XG4gICAgICAgIGlmIChwb3MgLSBwcmV2aW91c1BvcyA8IHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwubm9kZVNwYWNpbmcpIHtcbiAgICAgICAgICB2YXIgZGlmZiA9IHByZXZpb3VzUG9zICsgdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5ub2RlU3BhY2luZyAtIHBvcztcbiAgICAgICAgICB2YXIgc2hhcmVkUGFyZW50ID0gdGhpcy5fZmluZENvbW1vblBhcmVudCh0aGlzLmxhc3ROb2RlT25MZXZlbFtsZXZlbF0sIG5vZGUuaWQpO1xuICAgICAgICAgIHRoaXMuX3NoaWZ0QmxvY2soc2hhcmVkUGFyZW50LndpdGhDaGlsZCwgZGlmZik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdE5vZGVPbkxldmVsW2xldmVsXSA9IG5vZGUuaWQ7IC8vIHN0b3JlIGNoYW5nZSBpbiBwb3NpdGlvbi5cbiAgICAgIHRoaXMucG9zaXRpb25lZE5vZGVzW25vZGUuaWRdID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3BsYWNlQnJhbmNoTm9kZXMobm9kZS5pZCwgbGV2ZWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY2VpdmVzIGFuIGFycmF5IHdpdGggbm9kZSBpbmRpY2VzIGFuZCByZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIGFjdHVhbCBub2RlIHJlZmVyZW5jZXMuXG4gICAgICogVXNlZCBmb3Igc29ydGluZyBiYXNlZCBvbiBub2RlIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5LjxOb2RlLmlkPn0gaWRBcnJheVxuICAgICAqIEByZXR1cm5zIHtBcnJheS48Tm9kZT59XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2luZGV4QXJyYXlUb05vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbmRleEFycmF5VG9Ob2RlcyhpZEFycmF5KSB7XG4gICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheS5wdXNoKHRoaXMuYm9keS5ub2Rlc1tpZEFycmF5W2ldXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBnZXQgdGhlIGRpc3RyaWJ1dGlvbiBvZiBsZXZlbHMgYmFzZWQgb24gaHVic2l6ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9nZXREaXN0cmlidXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpc3RyaWJ1dGlvbigpIHtcbiAgICAgIHZhciBkaXN0cmlidXRpb24gPSB7fTtcbiAgICAgIHZhciBub2RlSWQsIG5vZGU7XG5cbiAgICAgIC8vIHdlIGZpeCBZIGJlY2F1c2UgdGhlIGhpZXJhcmNoeSBpcyB2ZXJ0aWNhbCxcbiAgICAgIC8vIHdlIGZpeCBYIHNvIHdlIGRvIG5vdCBnaXZlIGEgbm9kZSBhbiB4IHBvc2l0aW9uIGZvciBhIHNlY29uZCB0aW1lLlxuICAgICAgLy8gdGhlIGZpeCBvZiBYIGlzIHJlbW92ZWQgYWZ0ZXIgdGhlIHggdmFsdWUgaGFzIGJlZW4gc2V0LlxuICAgICAgZm9yIChub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLCBub2RlSWQpKSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgIHZhciBsZXZlbCA9IHRoaXMuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlSWRdID09PSB1bmRlZmluZWQgPyAwIDogdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGVJZF07XG4gICAgICAgICAgdGhpcy5kaXJlY3Rpb24uZml4KG5vZGUsIGxldmVsKTtcbiAgICAgICAgICBpZiAoZGlzdHJpYnV0aW9uW2xldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkaXN0cmlidXRpb25bbGV2ZWxdID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIGRpc3RyaWJ1dGlvbltsZXZlbF1bbm9kZUlkXSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkaXN0cmlidXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBhY3RpdmUgKGkuZS4gdmlzaWJsZSkgZWRnZXMgZm9yIHRoaXMgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAgICogQHJldHVybnMge0FycmF5Ljx2aXMuRWRnZT59IEFycmF5IG9mIGVkZ2UgaW5zdGFuY2VzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QWN0aXZlRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEFjdGl2ZUVkZ2VzKG5vZGUpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgZm9yRWFjaCQxKG5vZGUuZWRnZXMsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHZhciBfY29udGV4dDM7XG4gICAgICAgIGlmIChfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQzID0gX3RoaXM0LmJvZHkuZWRnZUluZGljZXMpLmNhbGwoX2NvbnRleHQzLCBlZGdlLmlkKSAhPT0gLTEpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChlZGdlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgaHVic2l6ZXMgZm9yIGFsbCBhY3RpdmUgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEh1YlNpemVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRIdWJTaXplcygpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgdmFyIGh1YlNpemVzID0ge307XG4gICAgICB2YXIgbm9kZUlkcyA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcztcbiAgICAgIGZvckVhY2gkMShub2RlSWRzLCBmdW5jdGlvbiAobm9kZUlkKSB7XG4gICAgICAgIHZhciBub2RlID0gX3RoaXM1LmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgdmFyIGh1YlNpemUgPSBfdGhpczUuX2dldEFjdGl2ZUVkZ2VzKG5vZGUpLmxlbmd0aDtcbiAgICAgICAgaHViU2l6ZXNbaHViU2l6ZV0gPSB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE1ha2UgYW4gYXJyYXkgb2YgdGhlIHNpemUgc29ydGVkIGRlc2NlbmRpbmdcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvckVhY2gkMShodWJTaXplcywgZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goTnVtYmVyKHNpemUpKTtcbiAgICAgIH0pO1xuICAgICAgX3NvcnRJbnN0YW5jZVByb3BlcnR5KHJlc3VsdCkuY2FsbChyZXN1bHQsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBiIC0gYTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIGFsbG9jYXRlcyBub2RlcyBpbiBsZXZlbHMgYmFzZWQgb24gdGhlIHJlY3Vyc2l2ZSBicmFuY2hpbmcgZnJvbSB0aGUgbGFyZ2VzdCBodWJzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZGV0ZXJtaW5lTGV2ZWxzQnlIdWJzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXRlcm1pbmVMZXZlbHNCeUh1YnNpemUoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICAgIHZhciBsZXZlbERvd25zdHJlYW0gPSBmdW5jdGlvbiBsZXZlbERvd25zdHJlYW0obm9kZUEsIG5vZGVCKSB7XG4gICAgICAgIF90aGlzNi5oaWVyYXJjaGljYWwubGV2ZWxEb3duc3RyZWFtKG5vZGVBLCBub2RlQik7XG4gICAgICB9O1xuICAgICAgdmFyIGh1YlNpemVzID0gdGhpcy5fZ2V0SHViU2l6ZXMoKTtcbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICB2YXIgaHViU2l6ZSA9IGh1YlNpemVzW2ldO1xuICAgICAgICBpZiAoaHViU2l6ZSA9PT0gMCkgcmV0dXJuIDE7IC8vIGJyZWFrXG4gICAgICAgIGZvckVhY2gkMShfdGhpczYuYm9keS5ub2RlSW5kaWNlcywgZnVuY3Rpb24gKG5vZGVJZCkge1xuICAgICAgICAgIHZhciBub2RlID0gX3RoaXM2LmJvZHkubm9kZXNbbm9kZUlkXTtcbiAgICAgICAgICBpZiAoaHViU2l6ZSA9PT0gX3RoaXM2Ll9nZXRBY3RpdmVFZGdlcyhub2RlKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIF90aGlzNi5fY3Jhd2xOZXR3b3JrKGxldmVsRG93bnN0cmVhbSwgbm9kZUlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaHViU2l6ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKF9sb29wKCkpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRPRE86IHJlbGVhc2UgZmVhdHVyZVxuICAgICAqIFRPRE86IERldGVybWluZSBpZiB0aGlzIGZlYXR1cmUgaXMgbmVlZGVkIGF0IGFsbFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZGV0ZXJtaW5lTGV2ZWxzQ3VzdG9tQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RldGVybWluZUxldmVsc0N1c3RvbUNhbGxiYWNrKCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG4gICAgICB2YXIgbWluTGV2ZWwgPSAxMDAwMDA7XG5cbiAgICAgIC8vIFRPRE86IHRoaXMgc2hvdWxkIGNvbWUgZnJvbSBvcHRpb25zLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzIC0tIFRoaXMgc2hvdWxkIGV2ZW50dWFsbHkgYmUgaW1wbGVtZW50ZWQgd2l0aCB0aGVzZSBwYXJhbWV0ZXJzIHVzZWQuXG4gICAgICB2YXIgY3VzdG9tQ2FsbGJhY2sgPSBmdW5jdGlvbiBjdXN0b21DYWxsYmFjayhub2RlQSwgbm9kZUIsIGVkZ2UpIHt9O1xuXG4gICAgICAvLyBUT0RPOiBwZXJoYXBzIG1vdmUgdG8gSGllcmFyY2hpY2FsU3RhdHVzLlxuICAgICAgLy8gICAgICAgQnV0IEkgY3VycmVudGx5IGRvbid0IHNlZSB0aGUgcG9pbnQsIHRoaXMgbWV0aG9kIGlzIG5vdCB1c2VkLlxuICAgICAgdmFyIGxldmVsQnlEaXJlY3Rpb24gPSBmdW5jdGlvbiBsZXZlbEJ5RGlyZWN0aW9uKG5vZGVBLCBub2RlQiwgZWRnZSkge1xuICAgICAgICB2YXIgbGV2ZWxBID0gX3RoaXM3LmhpZXJhcmNoaWNhbC5sZXZlbHNbbm9kZUEuaWRdO1xuICAgICAgICAvLyBzZXQgaW5pdGlhbCBsZXZlbFxuICAgICAgICBpZiAobGV2ZWxBID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsZXZlbEEgPSBfdGhpczcuaGllcmFyY2hpY2FsLmxldmVsc1tub2RlQS5pZF0gPSBtaW5MZXZlbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlmZiA9IGN1c3RvbUNhbGxiYWNrKE5ldHdvcmtVdGlsLmNsb25lT3B0aW9ucyhub2RlQSwgXCJub2RlXCIpLCBOZXR3b3JrVXRpbC5jbG9uZU9wdGlvbnMobm9kZUIsIFwibm9kZVwiKSwgTmV0d29ya1V0aWwuY2xvbmVPcHRpb25zKGVkZ2UsIFwiZWRnZVwiKSk7XG4gICAgICAgIF90aGlzNy5oaWVyYXJjaGljYWwubGV2ZWxzW25vZGVCLmlkXSA9IGxldmVsQSArIGRpZmY7XG4gICAgICB9O1xuICAgICAgdGhpcy5fY3Jhd2xOZXR3b3JrKGxldmVsQnlEaXJlY3Rpb24pO1xuICAgICAgdGhpcy5oaWVyYXJjaGljYWwuc2V0TWluTGV2ZWxUb1plcm8odGhpcy5ib2R5Lm5vZGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGxvY2F0ZSBub2RlcyBpbiBsZXZlbHMgYmFzZWQgb24gdGhlIGRpcmVjdGlvbiBvZiB0aGUgZWRnZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9kZXRlcm1pbmVMZXZlbHNEaXJlY3RlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGV0ZXJtaW5lTGV2ZWxzRGlyZWN0ZWQoKSB7XG4gICAgICB2YXIgX2NvbnRleHQ0LFxuICAgICAgICBfdGhpczggPSB0aGlzO1xuICAgICAgdmFyIG5vZGVzID0gX3JlZHVjZUluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQ0ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzKS5jYWxsKF9jb250ZXh0NCwgZnVuY3Rpb24gKGFjYywgaWQpIHtcbiAgICAgICAgYWNjLnNldChpZCwgX3RoaXM4LmJvZHkubm9kZXNbaWRdKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIG5ldyBfTWFwKCkpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWVyYXJjaGljYWwuc2hha2VUb3dhcmRzID09PSBcInJvb3RzXCIpIHtcbiAgICAgICAgdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzID0gZmlsbExldmVsc0J5RGlyZWN0aW9uUm9vdHMobm9kZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaWVyYXJjaGljYWwubGV2ZWxzID0gZmlsbExldmVsc0J5RGlyZWN0aW9uTGVhdmVzKG5vZGVzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGllcmFyY2hpY2FsLnNldE1pbkxldmVsVG9aZXJvKHRoaXMuYm9keS5ub2Rlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBib29ra2VlcGluZyBvZiBwYXJlbnQgYW5kIGNoaWxkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2VuZXJhdGVNYXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dlbmVyYXRlTWFwKCkge1xuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG4gICAgICB2YXIgZmlsbEluUmVsYXRpb25zID0gZnVuY3Rpb24gZmlsbEluUmVsYXRpb25zKHBhcmVudE5vZGUsIGNoaWxkTm9kZSkge1xuICAgICAgICBpZiAoX3RoaXM5LmhpZXJhcmNoaWNhbC5sZXZlbHNbY2hpbGROb2RlLmlkXSA+IF90aGlzOS5oaWVyYXJjaGljYWwubGV2ZWxzW3BhcmVudE5vZGUuaWRdKSB7XG4gICAgICAgICAgX3RoaXM5LmhpZXJhcmNoaWNhbC5hZGRSZWxhdGlvbihwYXJlbnROb2RlLmlkLCBjaGlsZE5vZGUuaWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5fY3Jhd2xOZXR3b3JrKGZpbGxJblJlbGF0aW9ucyk7XG4gICAgICB0aGlzLmhpZXJhcmNoaWNhbC5jaGVja0lmVHJlZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyYXdsIG92ZXIgdGhlIGVudGlyZSBuZXR3b3JrIGFuZCB1c2UgYSBjYWxsYmFjayBvbiBlYWNoIG5vZGUgY291cGxlIHRoYXQgaXMgY29ubmVjdGVkIHRvIGVhY2ggb3RoZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9ZnVuY3Rpb24oKXt9XSAgICAgICAgICB8IHdpbGwgcmVjZWl2ZSBub2RlQSwgbm9kZUIgYW5kIHRoZSBjb25uZWN0aW5nIGVkZ2UuIEEgYW5kIEIgYXJlIGRpc3RpbmN0LlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gc3RhcnRpbmdOb2RlSWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jcmF3bE5ldHdvcmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyYXdsTmV0d29yaygpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcbiAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZnVuY3Rpb24gKCkge307XG4gICAgICB2YXIgc3RhcnRpbmdOb2RlSWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBwcm9ncmVzcyA9IHt9O1xuICAgICAgdmFyIGNyYXdsZXIgPSBmdW5jdGlvbiBjcmF3bGVyKG5vZGUsIHRyZWUpIHtcbiAgICAgICAgaWYgKHByb2dyZXNzW25vZGUuaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBfdGhpczEwLmhpZXJhcmNoaWNhbC5zZXRUcmVlSW5kZXgobm9kZSwgdHJlZSk7XG4gICAgICAgICAgcHJvZ3Jlc3Nbbm9kZS5pZF0gPSB0cnVlO1xuICAgICAgICAgIHZhciBjaGlsZE5vZGU7XG4gICAgICAgICAgdmFyIGVkZ2VzID0gX3RoaXMxMC5fZ2V0QWN0aXZlRWRnZXMobm9kZSk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgICAgICAgIGlmIChlZGdlLmNvbm5lY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICBpZiAoZWRnZS50b0lkID09IG5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgJz09PScgYmVjYXVzZSBpZCdzIGNhbiBiZSBzdHJpbmcgYW5kIG51bWVyaWNcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBlZGdlLmZyb207XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gZWRnZS50bztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobm9kZS5pZCAhPSBjaGlsZE5vZGUuaWQpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgJyE9PScgYmVjYXVzZSBpZCdzIGNhbiBiZSBzdHJpbmcgYW5kIG51bWVyaWNcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhub2RlLCBjaGlsZE5vZGUsIGVkZ2UpO1xuICAgICAgICAgICAgICAgIGNyYXdsZXIoY2hpbGROb2RlLCB0cmVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmIChzdGFydGluZ05vZGVJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIENyYXdsIG92ZXIgYWxsIG5vZGVzXG4gICAgICAgIHZhciB0cmVlSW5kZXggPSAwOyAvLyBTZXJ2ZXMgdG8gcGFzcyBhIHVuaXF1ZSBpZCBmb3IgdGhlIGN1cnJlbnQgZGlzdGluY3QgdHJlZVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGVJZCA9IHRoaXMuYm9keS5ub2RlSW5kaWNlc1tpXTtcbiAgICAgICAgICBpZiAocHJvZ3Jlc3Nbbm9kZUlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tub2RlSWRdO1xuICAgICAgICAgICAgY3Jhd2xlcihub2RlLCB0cmVlSW5kZXgpO1xuICAgICAgICAgICAgdHJlZUluZGV4ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmF3bCBmcm9tIHRoZSBnaXZlbiBzdGFydGluZyBub2RlXG4gICAgICAgIHZhciBfbm9kZTIgPSB0aGlzLmJvZHkubm9kZXNbc3RhcnRpbmdOb2RlSWRdO1xuICAgICAgICBpZiAoX25vZGUyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm9kZSBub3QgZm91bmQ6XCIsIHN0YXJ0aW5nTm9kZUlkKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3Jhd2xlcihfbm9kZTIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNoaWZ0IGEgYnJhbmNoIGEgY2VydGFpbiBkaXN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBwYXJlbnRJZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaWZmXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfc2hpZnRCbG9ja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hpZnRCbG9jayhwYXJlbnRJZCwgZGlmZikge1xuICAgICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuICAgICAgdmFyIHByb2dyZXNzID0ge307XG4gICAgICB2YXIgc2hpZnRlciA9IGZ1bmN0aW9uIHNoaWZ0ZXIocGFyZW50SWQpIHtcbiAgICAgICAgaWYgKHByb2dyZXNzW3BhcmVudElkXSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcm9ncmVzc1twYXJlbnRJZF0gPSB0cnVlO1xuICAgICAgICBfdGhpczExLmRpcmVjdGlvbi5zaGlmdChwYXJlbnRJZCwgZGlmZik7XG4gICAgICAgIHZhciBjaGlsZFJlZiA9IF90aGlzMTEuaGllcmFyY2hpY2FsLmNoaWxkcmVuUmVmZXJlbmNlW3BhcmVudElkXTtcbiAgICAgICAgaWYgKGNoaWxkUmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkUmVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzaGlmdGVyKGNoaWxkUmVmW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzaGlmdGVyKHBhcmVudElkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgY29tbW9uIHBhcmVudCBiZXR3ZWVuIGJyYW5jaGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBjaGlsZEFcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IGNoaWxkQlxuICAgICAqIEByZXR1cm5zIHt7Zm91bmRQYXJlbnQsIHdpdGhDaGlsZH19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZmluZENvbW1vblBhcmVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZmluZENvbW1vblBhcmVudChjaGlsZEEsIGNoaWxkQikge1xuICAgICAgdmFyIF90aGlzMTIgPSB0aGlzO1xuICAgICAgdmFyIHBhcmVudHMgPSB7fTtcbiAgICAgIHZhciBpdGVyYXRlUGFyZW50cyA9IGZ1bmN0aW9uIGl0ZXJhdGVQYXJlbnRzKHBhcmVudHMsIGNoaWxkKSB7XG4gICAgICAgIHZhciBwYXJlbnRSZWYgPSBfdGhpczEyLmhpZXJhcmNoaWNhbC5wYXJlbnRSZWZlcmVuY2VbY2hpbGRdO1xuICAgICAgICBpZiAocGFyZW50UmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudFJlZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHBhcmVudFJlZltpXTtcbiAgICAgICAgICAgIHBhcmVudHNbcGFyZW50XSA9IHRydWU7XG4gICAgICAgICAgICBpdGVyYXRlUGFyZW50cyhwYXJlbnRzLCBwYXJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBmaW5kUGFyZW50ID0gZnVuY3Rpb24gZmluZFBhcmVudChwYXJlbnRzLCBjaGlsZCkge1xuICAgICAgICB2YXIgcGFyZW50UmVmID0gX3RoaXMxMi5oaWVyYXJjaGljYWwucGFyZW50UmVmZXJlbmNlW2NoaWxkXTtcbiAgICAgICAgaWYgKHBhcmVudFJlZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRSZWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBwYXJlbnRSZWZbaV07XG4gICAgICAgICAgICBpZiAocGFyZW50c1twYXJlbnRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmb3VuZFBhcmVudDogcGFyZW50LFxuICAgICAgICAgICAgICAgIHdpdGhDaGlsZDogY2hpbGRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBicmFuY2ggPSBmaW5kUGFyZW50KHBhcmVudHMsIHBhcmVudCk7XG4gICAgICAgICAgICBpZiAoYnJhbmNoLmZvdW5kUGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZm91bmRQYXJlbnQ6IG51bGwsXG4gICAgICAgICAgd2l0aENoaWxkOiBjaGlsZFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIGl0ZXJhdGVQYXJlbnRzKHBhcmVudHMsIGNoaWxkQSk7XG4gICAgICByZXR1cm4gZmluZFBhcmVudChwYXJlbnRzLCBjaGlsZEIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc3RyYXRlZ3kgcGF0dGVybiBmb3IgaGFuZGxpbmcgdGhlIGNvb3JkaW5hdGVzIGdpdmVuIHRoZSBjdXJyZW50IGRpcmVjdGlvbi5cbiAgICAgKlxuICAgICAqIFRoZSBpbmRpdmlkdWFsIGluc3RhbmNlcyBjb250YWluIGFsbCB0aGUgb3BlcmF0aW9ucyBhbmQgZGF0YSBzcGVjaWZpYyB0byBhIGxheW91dCBkaXJlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxldmVsXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZG9Ob3RVcGRhdGU9ZmFsc2VdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXREaXJlY3Rpb25TdHJhdGVneVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREaXJlY3Rpb25TdHJhdGVneSgpIHtcbiAgICAgIHZhciBpc1ZlcnRpY2FsID0gdGhpcy5vcHRpb25zLmhpZXJhcmNoaWNhbC5kaXJlY3Rpb24gPT09IFwiVURcIiB8fCB0aGlzLm9wdGlvbnMuaGllcmFyY2hpY2FsLmRpcmVjdGlvbiA9PT0gXCJEVVwiO1xuICAgICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBuZXcgVmVydGljYWxTdHJhdGVneSh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gbmV3IEhvcml6b250YWxTdHJhdGVneSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIGNlbnRlciBwb3NpdGlvbiBvZiBhIGJyYW5jaCBmcm9tIHRoZSBwYXNzZWQgbGlzdCBvZiBjaGlsZCBub2Rlc1xuICAgICAqXG4gICAgICogVGhpcyB0YWtlcyBpbnRvIGFjY291bnQgdGhlIHBvc2l0aW9ucyBvZiBhbGwgdGhlIGNoaWxkIG5vZGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZXx2aXMuTm9kZS5pZD59IGNoaWxkTm9kZXMgIEFycmF5IG9mIGVpdGhlciBjaGlsZCBub2RlcyBvciBub2RlIGlkJ3NcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldENlbnRlclBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDZW50ZXJQb3NpdGlvbihjaGlsZE5vZGVzKSB7XG4gICAgICB2YXIgbWluUG9zID0gMWU5O1xuICAgICAgdmFyIG1heFBvcyA9IC0xZTk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGNoaWxkTm9kZXNbaV0uaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZXNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNoaWxkTm9kZUlkID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgICBjaGlsZE5vZGUgPSB0aGlzLmJvZHkubm9kZXNbY2hpbGROb2RlSWRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuZGlyZWN0aW9uLmdldFBvc2l0aW9uKGNoaWxkTm9kZSk7XG4gICAgICAgIG1pblBvcyA9IE1hdGgubWluKG1pblBvcywgcG9zaXRpb24pO1xuICAgICAgICBtYXhQb3MgPSBNYXRoLm1heChtYXhQb3MsIHBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwLjUgKiAobWluUG9zICsgbWF4UG9zKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIExheW91dEVuZ2luZTtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIF9TeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgX2dldEl0ZXJhdG9yTWV0aG9kKG8pIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChfQXJyYXkkaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyB2YXIgX2NvbnRleHQzMjsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gX3NsaWNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDMyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pKS5jYWxsKF9jb250ZXh0MzIsIDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIF9BcnJheSRmcm9tJDEobyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cblxuLyoqXG4gKiBDbGVhcnMgdGhlIHRvb2xiYXIgZGl2IGVsZW1lbnQgb2YgY2hpbGRyZW5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgTWFuaXB1bGF0aW9uU3lzdGVtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7Q2FudmFzfSBjYW52YXNcbiAgICogQHBhcmFtIHtTZWxlY3Rpb25IYW5kbGVyfSBzZWxlY3Rpb25IYW5kbGVyXG4gICAqIEBwYXJhbSB7SW50ZXJhY3Rpb25IYW5kbGVyfSBpbnRlcmFjdGlvbkhhbmRsZXJcbiAgICovXG4gIGZ1bmN0aW9uIE1hbmlwdWxhdGlvblN5c3RlbShib2R5LCBjYW52YXMsIHNlbGVjdGlvbkhhbmRsZXIsIGludGVyYWN0aW9uSGFuZGxlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICBfY29udGV4dCxcbiAgICAgIF9jb250ZXh0MjtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFuaXB1bGF0aW9uU3lzdGVtKTtcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlciA9IHNlbGVjdGlvbkhhbmRsZXI7XG4gICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIgPSBpbnRlcmFjdGlvbkhhbmRsZXI7XG4gICAgdGhpcy5lZGl0TW9kZSA9IGZhbHNlO1xuICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZWRpdE1vZGVEaXYgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jbG9zZURpdiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kb21FdmVudExpc3RlbmVyQ2xlYW51cFF1ZXVlID0gW107XG4gICAgdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9ucyA9IHt9O1xuICAgIHRoaXMudGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnMgPSBbXTtcbiAgICB0aGlzLnRvdWNoVGltZSA9IDA7XG4gICAgdGhpcy50ZW1wb3JhcnlJZHMgPSB7XG4gICAgICBub2RlczogW10sXG4gICAgICBlZGdlczogW11cbiAgICB9O1xuICAgIHRoaXMuZ3VpRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuaW5Nb2RlID0gZmFsc2U7XG4gICAgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGluaXRpYWxseUFjdGl2ZTogZmFsc2UsXG4gICAgICBhZGROb2RlOiB0cnVlLFxuICAgICAgYWRkRWRnZTogdHJ1ZSxcbiAgICAgIGVkaXROb2RlOiB1bmRlZmluZWQsXG4gICAgICBlZGl0RWRnZTogdHJ1ZSxcbiAgICAgIGRlbGV0ZU5vZGU6IHRydWUsXG4gICAgICBkZWxldGVFZGdlOiB0cnVlLFxuICAgICAgY29udHJvbE5vZGVTdHlsZToge1xuICAgICAgICBzaGFwZTogXCJkb3RcIixcbiAgICAgICAgc2l6ZTogNixcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiBcIiNmZjAwMDBcIixcbiAgICAgICAgICBib3JkZXI6IFwiIzNjM2MzY1wiLFxuICAgICAgICAgIGhpZ2hsaWdodDoge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogXCIjMDdmOTY4XCIsXG4gICAgICAgICAgICBib3JkZXI6IFwiIzNjM2MzY1wiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBib3JkZXJXaWR0aDogMixcbiAgICAgICAgYm9yZGVyV2lkdGhTZWxlY3RlZDogMlxuICAgICAgfVxuICAgIH07XG4gICAgX09iamVjdCRhc3NpZ24odGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcbiAgICB0aGlzLmJvZHkuZW1pdHRlci5vbihcImRlc3Ryb3lcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX2NsZWFuKCk7XG4gICAgfSk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfZGF0YUNoYW5nZWRcIiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQgPSB0aGlzLl9yZXN0b3JlKS5jYWxsKF9jb250ZXh0LCB0aGlzKSk7XG4gICAgdGhpcy5ib2R5LmVtaXR0ZXIub24oXCJfcmVzZXREYXRhXCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MiA9IHRoaXMuX3Jlc3RvcmUpLmNhbGwoX2NvbnRleHQyLCB0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogSWYgc29tZXRoaW5nIGNoYW5nZXMgaW4gdGhlIGRhdGEgZHVyaW5nIGVkaXRpbmcsIHN3aXRjaCBiYWNrIHRvIHRoZSBpbml0aWFsIGRhdGFtYW5pcHVsYXRpb24gc3RhdGUgYW5kIGNsb3NlIGFsbCBlZGl0IG1vZGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKE1hbmlwdWxhdGlvblN5c3RlbSwgW3tcbiAgICBrZXk6IFwiX3Jlc3RvcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc3RvcmUoKSB7XG4gICAgICBpZiAodGhpcy5pbk1vZGUgIT09IGZhbHNlKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5pdGlhbGx5QWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIE9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGFsbE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsT3B0aW9uc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldE9wdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zLCBhbGxPcHRpb25zLCBnbG9iYWxPcHRpb25zKSB7XG4gICAgICBpZiAoYWxsT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhbGxPcHRpb25zLmxvY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmxvY2FsZSA9IGFsbE9wdGlvbnMubG9jYWxlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5sb2NhbGUgPSBnbG9iYWxPcHRpb25zLmxvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxsT3B0aW9ucy5sb2NhbGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubG9jYWxlcyA9IGFsbE9wdGlvbnMubG9jYWxlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wdGlvbnMubG9jYWxlcyA9IGdsb2JhbE9wdGlvbnMubG9jYWxlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmVuYWJsZWQgPSBvcHRpb25zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICBkZWVwRXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbml0aWFsbHlBY3RpdmUgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmVkaXRNb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXR1cCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGVkaXQtbW9kZS4gRHJhd3MgdGhlIERPTSByZXF1aXJlZCBhbmQgY2xlYW5zIHVwIGFmdGVyIGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9nZ2xlRWRpdE1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlRWRpdE1vZGUoKSB7XG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgRWRpdCBNb2RlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZW5hYmxlRWRpdE1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlRWRpdE1vZGUoKSB7XG4gICAgICB0aGlzLmVkaXRNb2RlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2NsZWFuKCk7XG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIHRoaXMuY2xvc2VEaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIEVkaXQgTW9kZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRpc2FibGVFZGl0TW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgICB0aGlzLmVkaXRNb2RlID0gZmFsc2U7XG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgaWYgKHRoaXMuZ3VpRW5hYmxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIHRoaXMuY2xvc2VEaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB0aGlzLmVkaXRNb2RlRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUVkaXRCdXR0b24oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBtYWluIHRvb2xiYXIuIFJlbW92ZXMgZnVuY3Rpb25zIGJvdW5kIHRvIHRoZSBzZWxlY3QgZXZlbnQuIEJpbmRzIGFsbCB0aGUgYnV0dG9ucyBvZiB0aGUgdG9vbGJhci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd01hbmlwdWxhdG9yVG9vbGJhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93TWFuaXB1bGF0b3JUb29sYmFyKCkge1xuICAgICAgLy8gcmVzdG9yZSB0aGUgc3RhdGUgb2YgYW55IGJvdW5kIGZ1bmN0aW9ucyBvciBldmVudHMsIHJlbW92ZSBjb250cm9sIG5vZGVzLCByZXN0b3JlIHBoeXNpY3NcbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIC8vIHJlc2V0IGdsb2JhbCB2YXJpYWJsZXNcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NID0ge307XG5cbiAgICAgIC8vIGlmIHRoZSBndWkgaXMgZW5hYmxlZCwgZHJhdyBhbGwgZWxlbWVudHMuXG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBfY29udGV4dDMsIF9jb250ZXh0NDtcbiAgICAgICAgLy8gYSBfcmVzdG9yZSB3aWxsIGhpZGUgdGhlc2UgbWVudXNcbiAgICAgICAgdGhpcy5lZGl0TW9kZSA9IHRydWU7XG4gICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIHRoaXMuY2xvc2VEaXYuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgdmFyIHNlbGVjdGVkTm9kZUNvdW50ID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkTm9kZUNvdW50KCk7XG4gICAgICAgIHZhciBzZWxlY3RlZEVkZ2VDb3VudCA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VDb3VudCgpO1xuICAgICAgICB2YXIgc2VsZWN0ZWRUb3RhbENvdW50ID0gc2VsZWN0ZWROb2RlQ291bnQgKyBzZWxlY3RlZEVkZ2VDb3VudDtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgICAgICB2YXIgbmVlZFNlcGVyYXRvciA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFkZE5vZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlQWRkTm9kZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICAgIG5lZWRTZXBlcmF0b3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWRkRWRnZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkU2VwZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY3JlYXRlQWRkRWRnZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3RlZE5vZGVDb3VudCA9PT0gMSAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmVkaXROb2RlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlU2VwZXJhdG9yKDIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkU2VwZXJhdG9yID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fY3JlYXRlRWRpdE5vZGVCdXR0b24obG9jYWxlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZEVkZ2VDb3VudCA9PT0gMSAmJiBzZWxlY3RlZE5vZGVDb3VudCA9PT0gMCAmJiB0aGlzLm9wdGlvbnMuZWRpdEVkZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKG5lZWRTZXBlcmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmVlZFNlcGVyYXRvciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2NyZWF0ZUVkaXRFZGdlQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgYnV0dG9uc1xuICAgICAgICBpZiAoc2VsZWN0ZWRUb3RhbENvdW50ICE9PSAwKSB7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZUNvdW50ID4gMCAmJiB0aGlzLm9wdGlvbnMuZGVsZXRlTm9kZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGlmIChuZWVkU2VwZXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcig0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZURlbGV0ZUJ1dHRvbihsb2NhbGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWROb2RlQ291bnQgPT09IDAgJiYgdGhpcy5vcHRpb25zLmRlbGV0ZUVkZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAobmVlZFNlcGVyYXRvciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVEZWxldGVCdXR0b24obG9jYWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiaW5kIHRoZSBjbG9zZSBidXR0b25cbiAgICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHModGhpcy5jbG9zZURpdiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQzID0gdGhpcy50b2dnbGVFZGl0TW9kZSkuY2FsbChfY29udGV4dDMsIHRoaXMpKTtcblxuICAgICAgICAvLyByZWZyZXNoIHRoaXMgYmFyIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gc2VsZWN0ZWRcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZEV2ZW50KFwic2VsZWN0XCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0NCA9IHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcikuY2FsbChfY29udGV4dDQsIHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVkcmF3IHRvIHNob3cgYW55IHBvc3NpYmxlIGNoYW5nZXNcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSB0aGUgdG9vbGJhciBmb3IgYWRkaW5nIE5vZGVzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTm9kZU1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTm9kZU1vZGUoKSB7XG4gICAgICB2YXIgX2NvbnRleHQ2O1xuICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc250IGFscmVhZHkuXG4gICAgICBpZiAodGhpcy5lZGl0TW9kZSAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlc3RvcmUgdGhlIHN0YXRlIG9mIGFueSBib3VuZCBmdW5jdGlvbnMgb3IgZXZlbnRzLCByZW1vdmUgY29udHJvbCBub2RlcywgcmVzdG9yZSBwaHlzaWNzXG4gICAgICB0aGlzLl9jbGVhbigpO1xuICAgICAgdGhpcy5pbk1vZGUgPSBcImFkZE5vZGVcIjtcbiAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0NTtcbiAgICAgICAgdmFyIGxvY2FsZSA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTSA9IHt9O1xuICAgICAgICB0aGlzLl9jcmVhdGVCYWNrQnV0dG9uKGxvY2FsZSk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVNlcGVyYXRvcigpO1xuICAgICAgICB0aGlzLl9jcmVhdGVEZXNjcmlwdGlvbihsb2NhbGVbXCJhZGREZXNjcmlwdGlvblwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiYWRkRGVzY3JpcHRpb25cIl0pO1xuXG4gICAgICAgIC8vIGJpbmQgdGhlIGNsb3NlIGJ1dHRvblxuICAgICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyh0aGlzLmNsb3NlRGl2LCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDUgPSB0aGlzLnRvZ2dsZUVkaXRNb2RlKS5jYWxsKF9jb250ZXh0NSwgdGhpcykpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZEV2ZW50KFwiY2xpY2tcIiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQ2ID0gdGhpcy5fcGVyZm9ybUFkZE5vZGUpLmNhbGwoX2NvbnRleHQ2LCB0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY2FsbCB0aGUgYm91bmQgZnVuY3Rpb24gdG8gaGFuZGxlIHRoZSBlZGl0aW5nIG9mIHRoZSBub2RlLiBUaGUgbm9kZSBoYXMgdG8gYmUgc2VsZWN0ZWQuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZWRpdE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdE5vZGUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGd1aSwgZW5hYmxlIGVkaXQgbW9kZSBpZiBpdCB3YXNudCBhbHJlYWR5LlxuICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgIHZhciBub2RlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkTm9kZXMoKVswXTtcbiAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5pbk1vZGUgPSBcImVkaXROb2RlXCI7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmVkaXROb2RlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZGVlcEV4dGVuZCh7fSwgbm9kZS5vcHRpb25zLCBmYWxzZSk7XG4gICAgICAgICAgICBkYXRhLnggPSBub2RlLng7XG4gICAgICAgICAgICBkYXRhLnkgPSBub2RlLnk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVkaXROb2RlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZWRpdE5vZGUoZGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluYWxpemVkRGF0YSAhPT0gbnVsbCAmJiBmaW5hbGl6ZWREYXRhICE9PSB1bmRlZmluZWQgJiYgX3RoaXMyLmluTW9kZSA9PT0gXCJlZGl0Tm9kZVwiKSB7XG4gICAgICAgICAgICAgICAgICAvLyBpZiBmb3Igd2hhdGV2ZXIgcmVhc29uIHRoZSBtb2RlIGhhcyBjaGFuZ2VzIChkdWUgdG8gZGF0YXNldCBjaGFuZ2UpIGRpc3JlZ2FyZCB0aGUgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzMi5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLnVwZGF0ZShmaW5hbGl6ZWREYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMyLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZnVuY3Rpb24gZm9yIGVkaXQgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLCBjYWxsYmFjaylcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdW1wiZWRpdENsdXN0ZXJFcnJvclwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZWRpdENsdXN0ZXJFcnJvclwiXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZ1bmN0aW9uIGhhcyBiZWVuIGNvbmZpZ3VyZWQgdG8gaGFuZGxlIHRoZSBlZGl0aW5nIG9mIG5vZGVzLlwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIHRoZSB0b29sYmFyIHRvIGNvbm5lY3Qgbm9kZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGRFZGdlTW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFZGdlTW9kZSgpIHtcbiAgICAgIHZhciBfY29udGV4dDgsIF9jb250ZXh0OSwgX2NvbnRleHQxMCwgX2NvbnRleHQxMSwgX2NvbnRleHQxMjtcbiAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGd1aSwgZW5hYmxlIGVkaXQgbW9kZSBpZiBpdCB3YXNudCBhbHJlYWR5LlxuICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgIHRoaXMuaW5Nb2RlID0gXCJhZGRFZGdlXCI7XG4gICAgICBpZiAodGhpcy5ndWlFbmFibGVkID09PSB0cnVlKSB7XG4gICAgICAgIHZhciBfY29udGV4dDc7XG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET00gPSB7fTtcbiAgICAgICAgdGhpcy5fY3JlYXRlQmFja0J1dHRvbihsb2NhbGUpO1xuICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlRGVzY3JpcHRpb24obG9jYWxlW1wiZWRnZURlc2NyaXB0aW9uXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJlZGdlRGVzY3JpcHRpb25cIl0pO1xuXG4gICAgICAgIC8vIGJpbmQgdGhlIGNsb3NlIGJ1dHRvblxuICAgICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyh0aGlzLmNsb3NlRGl2LCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDcgPSB0aGlzLnRvZ2dsZUVkaXRNb2RlKS5jYWxsKF9jb250ZXh0NywgdGhpcykpO1xuICAgICAgfVxuXG4gICAgICAvLyB0ZW1wb3JhcmlseSBvdmVybG9hZCBmdW5jdGlvbnNcbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uVG91Y2hcIiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQ4ID0gdGhpcy5faGFuZGxlQ29ubmVjdCkuY2FsbChfY29udGV4dDgsIHRoaXMpKTtcbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uRHJhZ0VuZFwiLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDkgPSB0aGlzLl9maW5pc2hDb25uZWN0KS5jYWxsKF9jb250ZXh0OSwgdGhpcykpO1xuICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25EcmFnXCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MTAgPSB0aGlzLl9kcmFnQ29udHJvbE5vZGUpLmNhbGwoX2NvbnRleHQxMCwgdGhpcykpO1xuICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25SZWxlYXNlXCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MTEgPSB0aGlzLl9maW5pc2hDb25uZWN0KS5jYWxsKF9jb250ZXh0MTEsIHRoaXMpKTtcbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uRHJhZ1N0YXJ0XCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MTIgPSB0aGlzLl9kcmFnU3RhcnRFZGdlKS5jYWxsKF9jb250ZXh0MTIsIHRoaXMpKTtcbiAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uSG9sZFwiLCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIHRoZSB0b29sYmFyIHRvIGVkaXQgZWRnZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJlZGl0RWRnZU1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdEVkZ2VNb2RlKCkge1xuICAgICAgLy8gd2hlbiB1c2luZyB0aGUgZ3VpLCBlbmFibGUgZWRpdCBtb2RlIGlmIGl0IHdhc24ndCBhbHJlYWR5LlxuICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgIHRoaXMuaW5Nb2RlID0gXCJlZGl0RWRnZVwiO1xuICAgICAgaWYgKF90eXBlb2YodGhpcy5vcHRpb25zLmVkaXRFZGdlKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLmVkaXRFZGdlLmVkaXRXaXRob3V0RHJhZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlSWRzKClbMF07XG4gICAgICAgIGlmICh0aGlzLmVkZ2VCZWluZ0VkaXRlZElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLmVkZ2VCZWluZ0VkaXRlZElkXTtcbiAgICAgICAgICB0aGlzLl9wZXJmb3JtRWRpdEVkZ2UoZWRnZS5mcm9tLmlkLCBlZGdlLnRvLmlkKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MTM7XG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET00gPSB7fTtcbiAgICAgICAgdGhpcy5fY3JlYXRlQmFja0J1dHRvbihsb2NhbGUpO1xuICAgICAgICB0aGlzLl9jcmVhdGVTZXBlcmF0b3IoKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlRGVzY3JpcHRpb24obG9jYWxlW1wiZWRpdEVkZ2VEZXNjcmlwdGlvblwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZWRpdEVkZ2VEZXNjcmlwdGlvblwiXSk7XG5cbiAgICAgICAgLy8gYmluZCB0aGUgY2xvc2UgYnV0dG9uXG4gICAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKHRoaXMuY2xvc2VEaXYsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MTMgPSB0aGlzLnRvZ2dsZUVkaXRNb2RlKS5jYWxsKF9jb250ZXh0MTMsIHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlSWRzKClbMF07XG4gICAgICBpZiAodGhpcy5lZGdlQmVpbmdFZGl0ZWRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfY29udGV4dDE0LCBfY29udGV4dDE1LCBfY29udGV4dDE2LCBfY29udGV4dDE3O1xuICAgICAgICB2YXIgX2VkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZF07XG5cbiAgICAgICAgLy8gY3JlYXRlIGNvbnRyb2wgbm9kZXNcbiAgICAgICAgdmFyIGNvbnRyb2xOb2RlRnJvbSA9IHRoaXMuX2dldE5ld1RhcmdldE5vZGUoX2VkZ2UuZnJvbS54LCBfZWRnZS5mcm9tLnkpO1xuICAgICAgICB2YXIgY29udHJvbE5vZGVUbyA9IHRoaXMuX2dldE5ld1RhcmdldE5vZGUoX2VkZ2UudG8ueCwgX2VkZ2UudG8ueSk7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzLnB1c2goY29udHJvbE5vZGVGcm9tLmlkKTtcbiAgICAgICAgdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMucHVzaChjb250cm9sTm9kZVRvLmlkKTtcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVzW2NvbnRyb2xOb2RlRnJvbS5pZF0gPSBjb250cm9sTm9kZUZyb207XG4gICAgICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5wdXNoKGNvbnRyb2xOb2RlRnJvbS5pZCk7XG4gICAgICAgIHRoaXMuYm9keS5ub2Rlc1tjb250cm9sTm9kZVRvLmlkXSA9IGNvbnRyb2xOb2RlVG87XG4gICAgICAgIHRoaXMuYm9keS5ub2RlSW5kaWNlcy5wdXNoKGNvbnRyb2xOb2RlVG8uaWQpO1xuXG4gICAgICAgIC8vIHRlbXBvcmFyaWx5IG92ZXJsb2FkIFVJIGZ1bmN0aW9ucywgY2xlYW5lZCB1cCBhdXRvbWF0aWNhbGx5IGJlY2F1c2Ugb2YgX3RlbXBvcmFyeUJpbmRVSVxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvblRvdWNoXCIsIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MTQgPSB0aGlzLl9jb250cm9sTm9kZVRvdWNoKS5jYWxsKF9jb250ZXh0MTQsIHRoaXMpKTsgLy8gdXNlZCB0byBnZXQgdGhlIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uVGFwXCIsIGZ1bmN0aW9uICgpIHt9KTsgLy8gZGlzYWJsZWRcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25Ib2xkXCIsIGZ1bmN0aW9uICgpIHt9KTsgLy8gZGlzYWJsZWRcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZFVJKFwib25EcmFnU3RhcnRcIiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxNSA9IHRoaXMuX2NvbnRyb2xOb2RlRHJhZ1N0YXJ0KS5jYWxsKF9jb250ZXh0MTUsIHRoaXMpKTsgLy8gdXNlZCB0byBzZWxlY3QgY29udHJvbCBub2RlXG4gICAgICAgIHRoaXMuX3RlbXBvcmFyeUJpbmRVSShcIm9uRHJhZ1wiLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDE2ID0gdGhpcy5fY29udHJvbE5vZGVEcmFnKS5jYWxsKF9jb250ZXh0MTYsIHRoaXMpKTsgLy8gdXNlZCB0byBkcmFnIGNvbnRyb2wgbm9kZVxuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbkRyYWdFbmRcIiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQxNyA9IHRoaXMuX2NvbnRyb2xOb2RlRHJhZ0VuZCkuY2FsbChfY29udGV4dDE3LCB0aGlzKSk7IC8vIHVzZWQgdG8gY29ubmVjdCBvciByZXZlcnQgY29udHJvbCBub2Rlc1xuICAgICAgICB0aGlzLl90ZW1wb3JhcnlCaW5kVUkoXCJvbk1vdXNlTW92ZVwiLCBmdW5jdGlvbiAoKSB7fSk7IC8vIGRpc2FibGVkXG5cbiAgICAgICAgLy8gY3JlYXRlIGZ1bmN0aW9uIHRvIHBvc2l0aW9uIGNvbnRyb2wgbm9kZXMgY29ycmVjdGx5IG9uIG1vdmVtZW50XG4gICAgICAgIC8vIGF1dG9tYXRpY2FsbHkgY2xlYW5lZCB1cCBiZWNhdXNlIHdlIHVzZSB0aGUgdGVtcG9yYXJ5IGJpbmRcbiAgICAgICAgdGhpcy5fdGVtcG9yYXJ5QmluZEV2ZW50KFwiYmVmb3JlRHJhd2luZ1wiLCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IF9lZGdlLmVkZ2VUeXBlLmZpbmRCb3JkZXJQb3NpdGlvbnMoY3R4KTtcbiAgICAgICAgICBpZiAoY29udHJvbE5vZGVGcm9tLnNlbGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udHJvbE5vZGVGcm9tLnggPSBwb3NpdGlvbnMuZnJvbS54O1xuICAgICAgICAgICAgY29udHJvbE5vZGVGcm9tLnkgPSBwb3NpdGlvbnMuZnJvbS55O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29udHJvbE5vZGVUby5zZWxlY3RlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRyb2xOb2RlVG8ueCA9IHBvc2l0aW9ucy50by54O1xuICAgICAgICAgICAgY29udHJvbE5vZGVUby55ID0gcG9zaXRpb25zLnRvLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkZWxldGUgZXZlcnl0aGluZyBpbiB0aGUgc2VsZWN0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVsZXRlU2VsZWN0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlU2VsZWN0ZWQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIC8vIHdoZW4gdXNpbmcgdGhlIGd1aSwgZW5hYmxlIGVkaXQgbW9kZSBpZiBpdCB3YXNudCBhbHJlYWR5LlxuICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyByZXN0b3JlIHRoZSBzdGF0ZSBvZiBhbnkgYm91bmQgZnVuY3Rpb25zIG9yIGV2ZW50cywgcmVtb3ZlIGNvbnRyb2wgbm9kZXMsIHJlc3RvcmUgcGh5c2ljc1xuICAgICAgdGhpcy5fY2xlYW4oKTtcbiAgICAgIHRoaXMuaW5Nb2RlID0gXCJkZWxldGVcIjtcbiAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkTm9kZUlkcygpO1xuICAgICAgdmFyIHNlbGVjdGVkRWRnZXMgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0ZWRFZGdlSWRzKCk7XG4gICAgICB2YXIgZGVsZXRlRnVuY3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoc2VsZWN0ZWROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbc2VsZWN0ZWROb2Rlc1tpXV0uaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgICBhbGVydCh0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXVtcImRlbGV0ZUNsdXN0ZXJFcnJvclwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZGVsZXRlQ2x1c3RlckVycm9yXCJdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZGVsZXRlTm9kZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZGVsZXRlRnVuY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGVsZXRlTm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZEVkZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZGVsZXRlRWRnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgZGVsZXRlRnVuY3Rpb24gPSB0aGlzLm9wdGlvbnMuZGVsZXRlRWRnZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBkZWxldGVGdW5jdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgIG5vZGVzOiBzZWxlY3RlZE5vZGVzLFxuICAgICAgICAgIGVkZ2VzOiBzZWxlY3RlZEVkZ2VzXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWxldGVGdW5jdGlvbi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBkZWxldGVGdW5jdGlvbihkYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgIT09IG51bGwgJiYgZmluYWxpemVkRGF0YSAhPT0gdW5kZWZpbmVkICYmIF90aGlzMy5pbk1vZGUgPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF90aGlzMy5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnJlbW92ZShmaW5hbGl6ZWREYXRhLmVkZ2VzKTtcbiAgICAgICAgICAgICAgX3RoaXMzLmJvZHkuZGF0YS5ub2Rlcy5nZXREYXRhU2V0KCkucmVtb3ZlKGZpbmFsaXplZERhdGEubm9kZXMpO1xuICAgICAgICAgICAgICBfdGhpczMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIik7XG4gICAgICAgICAgICAgIF90aGlzMy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpczMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIik7XG4gICAgICAgICAgICAgIF90aGlzMy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZ1bmN0aW9uIGZvciBkZWxldGUgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLCBjYWxsYmFjaylcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS5yZW1vdmUoc2VsZWN0ZWRFZGdlcyk7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLm5vZGVzLmdldERhdGFTZXQoKS5yZW1vdmUoc2VsZWN0ZWROb2Rlcyk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJzdGFydFNpbXVsYXRpb25cIik7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBQUklWQVRFICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi8vXG5cbiAgICAvKipcbiAgICAgKiBkcmF3IG9yIHJlbW92ZSB0aGUgRE9NXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zZXR1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXAoKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gRW5hYmxlIHRoZSBHVUlcbiAgICAgICAgdGhpcy5ndWlFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY3JlYXRlV3JhcHBlcnMoKTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlRWRpdEJ1dHRvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW1vdmVNYW5pcHVsYXRpb25ET00oKTtcblxuICAgICAgICAvLyBkaXNhYmxlIHRoZSBndWlcbiAgICAgICAgdGhpcy5ndWlFbmFibGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIHRoZSBkaXYgb3ZlcmxheXMgdGhhdCBjb250YWluIHRoZSBET01cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVdyYXBwZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVXcmFwcGVycygpIHtcbiAgICAgIC8vIGxvYWQgdGhlIG1hbmlwdWxhdG9yIEhUTUwgZWxlbWVudHMuIEFsbCBzdHlsaW5nIGRvbmUgaW4gY3NzLlxuICAgICAgaWYgKHRoaXMubWFuaXB1bGF0aW9uRGl2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5jbGFzc05hbWUgPSBcInZpcy1tYW5pcHVsYXRpb25cIjtcbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbnZhcy5mcmFtZS5hcHBlbmRDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRpdik7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnRhaW5lciBmb3IgdGhlIGVkaXQgYnV0dG9uLlxuICAgICAgaWYgKHRoaXMuZWRpdE1vZGVEaXYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmVkaXRNb2RlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5lZGl0TW9kZURpdi5jbGFzc05hbWUgPSBcInZpcy1lZGl0LW1vZGVcIjtcbiAgICAgICAgaWYgKHRoaXMuZWRpdE1vZGUgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmVkaXRNb2RlRGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVkaXRNb2RlRGl2LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5lZGl0TW9kZURpdik7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnRhaW5lciBmb3IgdGhlIGNsb3NlIGRpdiBidXR0b25cbiAgICAgIGlmICh0aGlzLmNsb3NlRGl2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIF90aGlzJG9wdGlvbnMkbG9jYWxlcywgX3RoaXMkb3B0aW9ucyRsb2NhbGVzMjtcbiAgICAgICAgdGhpcy5jbG9zZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgIHRoaXMuY2xvc2VEaXYuY2xhc3NOYW1lID0gXCJ2aXMtY2xvc2VcIjtcbiAgICAgICAgdGhpcy5jbG9zZURpdi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIChfdGhpcyRvcHRpb25zJGxvY2FsZXMgPSAoX3RoaXMkb3B0aW9ucyRsb2NhbGVzMiA9IHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdKSA9PT0gbnVsbCB8fCBfdGhpcyRvcHRpb25zJGxvY2FsZXMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zJGxvY2FsZXMyW1wiY2xvc2VcIl0pICE9PSBudWxsICYmIF90aGlzJG9wdGlvbnMkbG9jYWxlcyAhPT0gdm9pZCAwID8gX3RoaXMkb3B0aW9ucyRsb2NhbGVzIDogdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImNsb3NlXCJdKTtcbiAgICAgICAgdGhpcy5jbG9zZURpdi5zdHlsZS5kaXNwbGF5ID0gdGhpcy5tYW5pcHVsYXRpb25EaXYuc3R5bGUuZGlzcGxheTtcbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUuYXBwZW5kQ2hpbGQodGhpcy5jbG9zZURpdik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2VuZXJhdGUgYSBuZXcgdGFyZ2V0IG5vZGUuIFVzZWQgZm9yIGNyZWF0aW5nIG5ldyBlZGdlcyBhbmQgZWRpdGluZyBlZGdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHtOb2RlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldE5ld1RhcmdldE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE5ld1RhcmdldE5vZGUoeCwgeSkge1xuICAgICAgdmFyIGNvbnRyb2xOb2RlU3R5bGUgPSBkZWVwRXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMuY29udHJvbE5vZGVTdHlsZSk7XG4gICAgICBjb250cm9sTm9kZVN0eWxlLmlkID0gXCJ0YXJnZXROb2RlXCIgKyB2NCgpO1xuICAgICAgY29udHJvbE5vZGVTdHlsZS5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIGNvbnRyb2xOb2RlU3R5bGUucGh5c2ljcyA9IGZhbHNlO1xuICAgICAgY29udHJvbE5vZGVTdHlsZS54ID0geDtcbiAgICAgIGNvbnRyb2xOb2RlU3R5bGUueSA9IHk7XG5cbiAgICAgIC8vIHdlIGhhdmUgdG8gZGVmaW5lIHRoZSBib3VuZGluZyBib3ggaW4gb3JkZXIgZm9yIHRoZSBub2RlcyB0byBiZSBkcmF3biBpbW1lZGlhdGVseVxuICAgICAgdmFyIG5vZGUgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmNyZWF0ZU5vZGUoY29udHJvbE5vZGVTdHlsZSk7XG4gICAgICBub2RlLnNoYXBlLmJvdW5kaW5nQm94ID0ge1xuICAgICAgICBsZWZ0OiB4LFxuICAgICAgICByaWdodDogeCxcbiAgICAgICAgdG9wOiB5LFxuICAgICAgICBib3R0b206IHlcbiAgICAgIH07XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIGVkaXQgYnV0dG9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUVkaXRCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVkaXRCdXR0b24oKSB7XG4gICAgICB2YXIgX2NvbnRleHQxODtcbiAgICAgIC8vIHJlc3RvcmUgZXZlcnl0aGluZyB0byBpdCdzIG9yaWdpbmFsIHN0YXRlIChpZiBhcHBsaWNhYmxlKVxuICAgICAgdGhpcy5fY2xlYW4oKTtcblxuICAgICAgLy8gcmVzZXQgdGhlIG1hbmlwdWxhdGlvbkRPTVxuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET00gPSB7fTtcblxuICAgICAgLy8gZW1wdHkgdGhlIGVkaXRNb2RlRGl2XG4gICAgICByZWN1cnNpdmVET01EZWxldGUodGhpcy5lZGl0TW9kZURpdik7XG5cbiAgICAgIC8vIGNyZWF0ZSB0aGUgY29udGVudHMgZm9yIHRoZSBlZGl0TW9kZSBidXR0b25cbiAgICAgIHZhciBsb2NhbGUgPSB0aGlzLm9wdGlvbnMubG9jYWxlc1t0aGlzLm9wdGlvbnMubG9jYWxlXTtcbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXCJlZGl0TW9kZVwiLCBcInZpcy1lZGl0IHZpcy1lZGl0LW1vZGVcIiwgbG9jYWxlW1wiZWRpdFwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZWRpdFwiXSk7XG4gICAgICB0aGlzLmVkaXRNb2RlRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICAgIC8vIGJpbmQgYSBoYW1tZXIgbGlzdGVuZXIgdG8gdGhlIGJ1dHRvbiwgY2FsbGluZyB0aGUgZnVuY3Rpb24gdG9nZ2xlRWRpdE1vZGUuXG4gICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyhidXR0b24sIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MTggPSB0aGlzLnRvZ2dsZUVkaXRNb2RlKS5jYWxsKF9jb250ZXh0MTgsIHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIGNsZWFucyB1cCBhZnRlciBldmVyeXRoaW5nIHRoaXMgbW9kdWxlIGRvZXMuIFRlbXBvcmFyeSBlbGVtZW50cywgZnVuY3Rpb25zIGFuZCBldmVudHMgYXJlIHJlbW92ZWQsIHBoeXNpY3MgcmVzdG9yZWQsIGhhbW1lcnMgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NsZWFuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbigpIHtcbiAgICAgIC8vIG5vdCBpbiBtb2RlXG4gICAgICB0aGlzLmluTW9kZSA9IGZhbHNlO1xuXG4gICAgICAvLyBfY2xlYW4gdGhlIGRpdnNcbiAgICAgIGlmICh0aGlzLmd1aUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgcmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMuZWRpdE1vZGVEaXYpO1xuICAgICAgICByZWN1cnNpdmVET01EZWxldGUodGhpcy5tYW5pcHVsYXRpb25EaXYpO1xuXG4gICAgICAgIC8vIHJlbW92ZXMgYWxsIHRoZSBiaW5kaW5ncyBhbmQgb3ZlcmxvYWRzXG4gICAgICAgIHRoaXMuX2NsZWFudXBET01FdmVudExpc3RlbmVycygpO1xuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgdGVtcG9yYXJ5IG5vZGVzIGFuZCBlZGdlc1xuICAgICAgdGhpcy5fY2xlYW51cFRlbXBvcmFyeU5vZGVzQW5kRWRnZXMoKTtcblxuICAgICAgLy8gcmVzdG9yZSBvdmVybG9hZGVkIFVJIGZ1bmN0aW9uc1xuICAgICAgdGhpcy5fdW5iaW5kVGVtcG9yYXJ5VUlzKCk7XG5cbiAgICAgIC8vIHJlbW92ZSB0aGUgdGVtcG9yYXJ5RXZlbnRGdW5jdGlvbnNcbiAgICAgIHRoaXMuX3VuYmluZFRlbXBvcmFyeUV2ZW50cygpO1xuXG4gICAgICAvLyByZXN0b3JlIHRoZSBwaHlzaWNzIGlmIHJlcXVpcmVkXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwicmVzdG9yZVBoeXNpY3NcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRWFjaCBkb20gZWxlbWVudCBoYXMgaXQncyBvd24gaGFtbWVyLiBUaGV5IGFyZSBzdG9yZWQgaW4gdGhpcy5tYW5pcHVsYXRpb25IYW1tZXJzLiBUaGlzIGNsZWFucyB0aGVtIHVwLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY2xlYW51cERPTUV2ZW50TGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhbnVwRE9NRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX2NvbnRleHQxOTtcbiAgICAgIC8vIF9jbGVhbiBET00gZXZlbnQgbGlzdGVuZXIgYmluZGluZ3NcbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihfc3BsaWNlSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDE5ID0gdGhpcy5fZG9tRXZlbnRMaXN0ZW5lckNsZWFudXBRdWV1ZSkuY2FsbChfY29udGV4dDE5LCAwKSksXG4gICAgICAgIF9zdGVwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBET00gZWxlbWVudHMgY3JlYXRlZCBieSB0aGlzIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZU1hbmlwdWxhdGlvbkRPTVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlTWFuaXB1bGF0aW9uRE9NKCkge1xuICAgICAgLy8gcmVtb3ZlcyBhbGwgdGhlIGJpbmRpbmdzIGFuZCBvdmVybG9hZHNcbiAgICAgIHRoaXMuX2NsZWFuKCk7XG5cbiAgICAgIC8vIGVtcHR5IHRoZSBtYW5pcHVsYXRpb24gZGl2c1xuICAgICAgcmVjdXJzaXZlRE9NRGVsZXRlKHRoaXMubWFuaXB1bGF0aW9uRGl2KTtcbiAgICAgIHJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLmVkaXRNb2RlRGl2KTtcbiAgICAgIHJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLmNsb3NlRGl2KTtcblxuICAgICAgLy8gcmVtb3ZlIHRoZSBtYW5pcHVsYXRpb24gZGl2c1xuICAgICAgaWYgKHRoaXMubWFuaXB1bGF0aW9uRGl2KSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMubWFuaXB1bGF0aW9uRGl2KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVkaXRNb2RlRGl2KSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmZyYW1lLnJlbW92ZUNoaWxkKHRoaXMuZWRpdE1vZGVEaXYpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY2xvc2VEaXYpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuZnJhbWUucmVtb3ZlQ2hpbGQodGhpcy5jbG9zZURpdik7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCB0aGUgcmVmZXJlbmNlcyB0byB1bmRlZmluZWRcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5lZGl0TW9kZURpdiA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuY2xvc2VEaXYgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3JlYXRlIGEgc2VwZXJhdG9yIGxpbmUuIHRoZSBpbmRleCBpcyB0byBkaWZmZXJlbnRpYXRlIGluIHRoZSBtYW5pcHVsYXRpb24gZG9tXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PTFdXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlU2VwZXJhdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVTZXBlcmF0b3IoKSB7XG4gICAgICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtcInNlcGVyYXRvckxpbmVEaXZcIiArIGluZGV4XSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtcInNlcGVyYXRvckxpbmVEaXZcIiArIGluZGV4XS5jbGFzc05hbWUgPSBcInZpcy1zZXBhcmF0b3ItbGluZVwiO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQodGhpcy5tYW5pcHVsYXRpb25ET01bXCJzZXBlcmF0b3JMaW5lRGl2XCIgKyBpbmRleF0pO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gICAgRE9NIGZ1bmN0aW9ucyBmb3IgYnV0dG9ucyAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9jYWxlfSBsb2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVBZGROb2RlQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVBZGROb2RlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgdmFyIF9jb250ZXh0MjA7XG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwiYWRkTm9kZVwiLCBcInZpcy1hZGRcIiwgbG9jYWxlW1wiYWRkTm9kZVwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiYWRkTm9kZVwiXSk7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHMoYnV0dG9uLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDIwID0gdGhpcy5hZGROb2RlTW9kZSkuY2FsbChfY29udGV4dDIwLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQWRkRWRnZUJ1dHRvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQWRkRWRnZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgIHZhciBfY29udGV4dDIxO1xuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihcImFkZEVkZ2VcIiwgXCJ2aXMtY29ubmVjdFwiLCBsb2NhbGVbXCJhZGRFZGdlXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJhZGRFZGdlXCJdKTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRGl2LmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICB0aGlzLl9iaW5kRWxlbWVudEV2ZW50cyhidXR0b24sIF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MjEgPSB0aGlzLmFkZEVkZ2VNb2RlKS5jYWxsKF9jb250ZXh0MjEsIHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9jYWxlfSBsb2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVFZGl0Tm9kZUJ1dHRvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlRWRpdE5vZGVCdXR0b24obG9jYWxlKSB7XG4gICAgICB2YXIgX2NvbnRleHQyMjtcbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXCJlZGl0Tm9kZVwiLCBcInZpcy1lZGl0XCIsIGxvY2FsZVtcImVkaXROb2RlXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJlZGl0Tm9kZVwiXSk7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHMoYnV0dG9uLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDIyID0gdGhpcy5lZGl0Tm9kZSkuY2FsbChfY29udGV4dDIyLCB0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xvY2FsZX0gbG9jYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlRWRpdEVkZ2VCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVkaXRFZGdlQnV0dG9uKGxvY2FsZSkge1xuICAgICAgdmFyIF9jb250ZXh0MjM7XG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKFwiZWRpdEVkZ2VcIiwgXCJ2aXMtZWRpdFwiLCBsb2NhbGVbXCJlZGl0RWRnZVwiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiZWRpdEVkZ2VcIl0pO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKGJ1dHRvbiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQyMyA9IHRoaXMuZWRpdEVkZ2VNb2RlKS5jYWxsKF9jb250ZXh0MjMsIHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TG9jYWxlfSBsb2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVEZWxldGVCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZURlbGV0ZUJ1dHRvbihsb2NhbGUpIHtcbiAgICAgIHZhciBfY29udGV4dDI0O1xuICAgICAgdmFyIGRlbGV0ZUJ0bkNsYXNzO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ydGwpIHtcbiAgICAgICAgZGVsZXRlQnRuQ2xhc3MgPSBcInZpcy1kZWxldGUtcnRsXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVCdG5DbGFzcyA9IFwidmlzLWRlbGV0ZVwiO1xuICAgICAgfVxuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihcImRlbGV0ZVwiLCBkZWxldGVCdG5DbGFzcywgbG9jYWxlW1wiZGVsXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJkZWxcIl0pO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25EaXYuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgIHRoaXMuX2JpbmRFbGVtZW50RXZlbnRzKGJ1dHRvbiwgX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQyNCA9IHRoaXMuZGVsZXRlU2VsZWN0ZWQpLmNhbGwoX2NvbnRleHQyNCwgdGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMb2NhbGV9IGxvY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUJhY2tCdXR0b25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUJhY2tCdXR0b24obG9jYWxlKSB7XG4gICAgICB2YXIgX2NvbnRleHQyNTtcbiAgICAgIHZhciBidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oXCJiYWNrXCIsIFwidmlzLWJhY2tcIiwgbG9jYWxlW1wiYmFja1wiXSB8fCB0aGlzLm9wdGlvbnMubG9jYWxlc1tcImVuXCJdW1wiYmFja1wiXSk7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgdGhpcy5fYmluZEVsZW1lbnRFdmVudHMoYnV0dG9uLCBfYmluZEluc3RhbmNlUHJvcGVydHkkMShfY29udGV4dDI1ID0gdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKS5jYWxsKF9jb250ZXh0MjUsIHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gaWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAgICogQHBhcmFtIHtsYWJlbH0gbGFiZWxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFiZWxDbGFzc05hbWVcbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlQnV0dG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVCdXR0b24oaWQsIGNsYXNzTmFtZSwgbGFiZWwpIHtcbiAgICAgIHZhciBsYWJlbENsYXNzTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJ2aXMtbGFiZWxcIjtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgXCJEaXZcIl0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkRpdlwiXS5jbGFzc05hbWUgPSBcInZpcy1idXR0b24gXCIgKyBjbGFzc05hbWU7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArIFwiTGFiZWxcIl0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkxhYmVsXCJdLmNsYXNzTmFtZSA9IGxhYmVsQ2xhc3NOYW1lO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkxhYmVsXCJdLmlubmVyVGV4dCA9IGxhYmVsO1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01baWQgKyBcIkRpdlwiXS5hcHBlbmRDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRPTVtpZCArIFwiTGFiZWxcIl0pO1xuICAgICAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uRE9NW2lkICsgXCJEaXZcIl07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xhYmVsfSBsYWJlbFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZURlc2NyaXB0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVEZXNjcmlwdGlvbihsYWJlbCkge1xuICAgICAgdGhpcy5tYW5pcHVsYXRpb25ET01bXCJkZXNjcmlwdGlvbkxhYmVsXCJdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRoaXMubWFuaXB1bGF0aW9uRE9NW1wiZGVzY3JpcHRpb25MYWJlbFwiXS5jbGFzc05hbWUgPSBcInZpcy1ub25lXCI7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRPTVtcImRlc2NyaXB0aW9uTGFiZWxcIl0uaW5uZXJUZXh0ID0gbGFiZWw7XG4gICAgICB0aGlzLm1hbmlwdWxhdGlvbkRpdi5hcHBlbmRDaGlsZCh0aGlzLm1hbmlwdWxhdGlvbkRPTVtcImRlc2NyaXB0aW9uTGFiZWxcIl0pO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVuZCBvZiBET00gZnVuY3Rpb25zIGZvciBidXR0b25zIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvKipcbiAgICAgKiB0aGlzIGJpbmRzIGFuIGV2ZW50IHVudGlsIGNsZWFudXAgYnkgdGhlIGNsZWFuIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG5ld0Z1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfdGVtcG9yYXJ5QmluZEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90ZW1wb3JhcnlCaW5kRXZlbnQoZXZlbnQsIG5ld0Z1bmN0aW9uKSB7XG4gICAgICB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zLnB1c2goe1xuICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgIGJvdW5kRnVuY3Rpb246IG5ld0Z1bmN0aW9uXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9uKGV2ZW50LCBuZXdGdW5jdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcyBvdmVycmlkZXMgYW4gVUkgZnVuY3Rpb24gdW50aWwgY2xlYW51cCBieSB0aGUgY2xlYW4gZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBVSWZ1bmN0aW9uTmFtZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG5ld0Z1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfdGVtcG9yYXJ5QmluZFVJXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90ZW1wb3JhcnlCaW5kVUkoVUlmdW5jdGlvbk5hbWUsIG5ld0Z1bmN0aW9uKSB7XG4gICAgICBpZiAodGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW1VJZnVuY3Rpb25OYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnNbVUlmdW5jdGlvbk5hbWVdID0gdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW1VJZnVuY3Rpb25OYW1lXTtcbiAgICAgICAgdGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzW1VJZnVuY3Rpb25OYW1lXSA9IG5ld0Z1bmN0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBVSSBmdW5jdGlvbiBkb2VzIG5vdCBleGlzdC4gVHlwbz8gWW91IHRyaWVkOiBcIiArIFVJZnVuY3Rpb25OYW1lICsgXCIgcG9zc2libGUgYXJlOiBcIiArIF9KU09OJHN0cmluZ2lmeShfT2JqZWN0JGtleXModGhpcy5ib2R5LmV2ZW50TGlzdGVuZXJzKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgdGhlIG92ZXJyaWRkZW4gVUkgZnVuY3Rpb25zIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfdW5iaW5kVGVtcG9yYXJ5VUlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91bmJpbmRUZW1wb3JhcnlVSXMoKSB7XG4gICAgICBmb3IgKHZhciBmdW5jdGlvbk5hbWUgaW4gdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9ucykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnMsIGZ1bmN0aW9uTmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmJvZHkuZXZlbnRMaXN0ZW5lcnNbZnVuY3Rpb25OYW1lXSA9IHRoaXMudGVtcG9yYXJ5VUlGdW5jdGlvbnNbZnVuY3Rpb25OYW1lXTtcbiAgICAgICAgICBkZWxldGUgdGhpcy50ZW1wb3JhcnlVSUZ1bmN0aW9uc1tmdW5jdGlvbk5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnRlbXBvcmFyeVVJRnVuY3Rpb25zID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5iaW5kIHRoZSBldmVudHMgY3JlYXRlZCBieSBfdGVtcG9yYXJ5QmluZEV2ZW50XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl91bmJpbmRUZW1wb3JhcnlFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VuYmluZFRlbXBvcmFyeUV2ZW50cygpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9uc1tpXS5ldmVudDtcbiAgICAgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSB0aGlzLnRlbXBvcmFyeUV2ZW50RnVuY3Rpb25zW2ldLmJvdW5kRnVuY3Rpb247XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLm9mZihldmVudE5hbWUsIGJvdW5kRnVuY3Rpb24pO1xuICAgICAgfVxuICAgICAgdGhpcy50ZW1wb3JhcnlFdmVudEZ1bmN0aW9ucyA9IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJpbmQgYW4gaGFtbWVyIGluc3RhbmNlIHRvIGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGRvbUVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBib3VuZEZ1bmN0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2JpbmRFbGVtZW50RXZlbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9iaW5kRWxlbWVudEV2ZW50cyhkb21FbGVtZW50LCBib3VuZEZ1bmN0aW9uKSB7XG4gICAgICAvLyBCaW5kIHRvdWNoIGV2ZW50cy5cbiAgICAgIHZhciBoYW1tZXIgPSBuZXcgSGFtbWVyKGRvbUVsZW1lbnQsIHt9KTtcbiAgICAgIG9uVG91Y2goaGFtbWVyLCBib3VuZEZ1bmN0aW9uKTtcbiAgICAgIHRoaXMuX2RvbUV2ZW50TGlzdGVuZXJDbGVhbnVwUXVldWUucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhhbW1lci5kZXN0cm95KCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQmluZCBrZXlib2FyZCBldmVudHMuXG4gICAgICB2YXIga2V5dXBMaXN0ZW5lciA9IGZ1bmN0aW9uIGtleXVwTGlzdGVuZXIoX3JlZikge1xuICAgICAgICB2YXIga2V5Q29kZSA9IF9yZWYua2V5Q29kZSxcbiAgICAgICAgICBrZXkgPSBfcmVmLmtleTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJFbnRlclwiIHx8IGtleSA9PT0gXCIgXCIgfHwga2V5Q29kZSA9PT0gMTMgfHwga2V5Q29kZSA9PT0gMzIpIHtcbiAgICAgICAgICBib3VuZEZ1bmN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBkb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBrZXl1cExpc3RlbmVyLCBmYWxzZSk7XG4gICAgICB0aGlzLl9kb21FdmVudExpc3RlbmVyQ2xlYW51cFF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICBkb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBrZXl1cExpc3RlbmVyLCBmYWxzZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOZWF0bHkgY2xlYW4gdXAgdGVtcG9yYXJ5IGVkZ2VzIGFuZCBub2Rlc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY2xlYW51cFRlbXBvcmFyeU5vZGVzQW5kRWRnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NsZWFudXBUZW1wb3JhcnlOb2Rlc0FuZEVkZ2VzKCkge1xuICAgICAgLy8gX2NsZWFuIHRlbXBvcmFyeSBlZGdlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRlbXBvcmFyeUlkcy5lZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgX2NvbnRleHQyNjtcbiAgICAgICAgdGhpcy5ib2R5LmVkZ2VzW3RoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzW2ldXS5kaXNjb25uZWN0KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJvZHkuZWRnZXNbdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbaV1dO1xuICAgICAgICB2YXIgaW5kZXhUZW1wRWRnZSA9IF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDI2ID0gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzKS5jYWxsKF9jb250ZXh0MjYsIHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzW2ldKTtcbiAgICAgICAgaWYgKGluZGV4VGVtcEVkZ2UgIT09IC0xKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0Mjc7XG4gICAgICAgICAgX3NwbGljZUluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQyNyA9IHRoaXMuYm9keS5lZGdlSW5kaWNlcykuY2FsbChfY29udGV4dDI3LCBpbmRleFRlbXBFZGdlLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBfY2xlYW4gdGVtcG9yYXJ5IG5vZGVzXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfY29udGV4dDI4O1xuICAgICAgICBkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW3RoaXMudGVtcG9yYXJ5SWRzLm5vZGVzW19pXV07XG4gICAgICAgIHZhciBpbmRleFRlbXBOb2RlID0gX2luZGV4T2ZJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0MjggPSB0aGlzLmJvZHkubm9kZUluZGljZXMpLmNhbGwoX2NvbnRleHQyOCwgdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbX2ldKTtcbiAgICAgICAgaWYgKGluZGV4VGVtcE5vZGUgIT09IC0xKSB7XG4gICAgICAgICAgdmFyIF9jb250ZXh0Mjk7XG4gICAgICAgICAgX3NwbGljZUluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQyOSA9IHRoaXMuYm9keS5ub2RlSW5kaWNlcykuY2FsbChfY29udGV4dDI5LCBpbmRleFRlbXBOb2RlLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy50ZW1wb3JhcnlJZHMgPSB7XG4gICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgZWRnZXM6IFtdXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFRElUIEVER0UgRlVOQ1RJT05TIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLy9cblxuICAgIC8qKlxuICAgICAqIHRoZSB0b3VjaCBpcyB1c2VkIHRvIGdldCB0aGUgcG9zaXRpb24gb2YgdGhlIGluaXRpYWwgY2xpY2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbnRyb2xOb2RlVG91Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnRyb2xOb2RlVG91Y2goZXZlbnQpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgdGhpcy5sYXN0VG91Y2ggPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uID0gX09iamVjdCRhc3NpZ24oe30sIHRoaXMuYm9keS52aWV3LnRyYW5zbGF0aW9uKTsgLy8gY29weSB0aGUgb2JqZWN0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhlIGRyYWcgc3RhcnQgaXMgdXNlZCB0byBtYXJrIG9uZSBvZiB0aGUgY29udHJvbCBub2RlcyBhcyBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbnRyb2xOb2RlRHJhZ1N0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb250cm9sTm9kZURyYWdTdGFydCgpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5sYXN0VG91Y2g7XG4gICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG4gICAgICB2YXIgZnJvbSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1swXV07XG4gICAgICB2YXIgdG8gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMV1dO1xuICAgICAgdmFyIGVkZ2UgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy5lZGdlQmVpbmdFZGl0ZWRJZF07XG4gICAgICB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgZnJvbVNlbGVjdCA9IGZyb20uaXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG4gICAgICB2YXIgdG9TZWxlY3QgPSB0by5pc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcbiAgICAgIGlmIChmcm9tU2VsZWN0ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9IGZyb207XG4gICAgICAgIGVkZ2UuZWRnZVR5cGUuZnJvbSA9IGZyb207XG4gICAgICB9IGVsc2UgaWYgKHRvU2VsZWN0ID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9IHRvO1xuICAgICAgICBlZGdlLmVkZ2VUeXBlLnRvID0gdG87XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIHVzZSB0aGUgc2VsZWN0aW9uIHRvIGZpbmQgdGhlIG5vZGUgdGhhdCBpcyBiZWluZyBkcmFnZ2VkLiBXZSBleHBsaWNpdGx5IHNlbGVjdCBpdCBoZXJlLlxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5zZWxlY3RPYmplY3QodGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRyYWdnaW5nIHRoZSBjb250cm9sIG5vZGVzIG9yIHRoZSBjYW52YXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbnRyb2xOb2RlRHJhZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29udHJvbE5vZGVEcmFnKGV2ZW50KSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZGlzYWJsZVBoeXNpY3NcIik7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdmFyIHBvcyA9IHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzKHBvaW50ZXIpO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS54ID0gcG9zLng7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZS55ID0gcG9zLnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlci5vbkRyYWcoZXZlbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29ubmVjdGluZyBvciByZXN0b3JpbmcgdGhlIGNvbnRyb2wgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSAgZXZlbnQgICBUaGUgZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jb250cm9sTm9kZURyYWdFbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NvbnRyb2xOb2RlRHJhZ0VuZChldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmJvZHkuZnVuY3Rpb25zLmdldFBvaW50ZXIoZXZlbnQuY2VudGVyKTtcbiAgICAgIHZhciBwb2ludGVyT2JqID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9wb2ludGVyVG9Qb3NpdGlvbk9iamVjdChwb2ludGVyKTtcbiAgICAgIHZhciBlZGdlID0gdGhpcy5ib2R5LmVkZ2VzW3RoaXMuZWRnZUJlaW5nRWRpdGVkSWRdO1xuICAgICAgLy8gaWYgdGhlIG5vZGUgdGhhdCB3YXMgZHJhZ2dlZCBpcyBub3QgYSBjb250cm9sIG5vZGUsIHJldHVyblxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRDb250cm9sTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gd2UgdXNlIHRoZSBzZWxlY3Rpb24gdG8gZmluZCB0aGUgbm9kZSB0aGF0IGlzIGJlaW5nIGRyYWdnZWQuIFdlIGV4cGxpY2l0bHkgREVzZWxlY3QgdGhlIGNvbnRyb2wgbm9kZSBoZXJlLlxuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG4gICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlSWRzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcbiAgICAgIHZhciBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgZm9yICh2YXIgaSA9IG92ZXJsYXBwaW5nTm9kZUlkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAob3ZlcmxhcHBpbmdOb2RlSWRzW2ldICE9PSB0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUuaWQpIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW292ZXJsYXBwaW5nTm9kZUlkc1tpXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHBlcmZvcm0gdGhlIGNvbm5lY3Rpb25cbiAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5zZWxlY3RlZENvbnRyb2xOb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKG5vZGUuaXNDbHVzdGVyID09PSB0cnVlKSB7XG4gICAgICAgICAgYWxlcnQodGhpcy5vcHRpb25zLmxvY2FsZXNbdGhpcy5vcHRpb25zLmxvY2FsZV1bXCJjcmVhdGVFZGdlRXJyb3JcIl0gfHwgdGhpcy5vcHRpb25zLmxvY2FsZXNbXCJlblwiXVtcImNyZWF0ZUVkZ2VFcnJvclwiXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGZyb20gPSB0aGlzLmJvZHkubm9kZXNbdGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF1dO1xuICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkQ29udHJvbE5vZGUuaWQgPT09IGZyb20uaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlcmZvcm1FZGl0RWRnZShub2RlLmlkLCBlZGdlLnRvLmlkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGVyZm9ybUVkaXRFZGdlKGVkZ2UuZnJvbS5pZCwgbm9kZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGdlLnVwZGF0ZUVkZ2VUeXBlKCk7XG4gICAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJyZXN0b3JlUGh5c2ljc1wiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFTkQgT0YgRURJVCBFREdFIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEFERCBFREdFIEZVTkNUSU9OUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG4gICAgLyoqXG4gICAgICogdGhlIGZ1bmN0aW9uIGJvdW5kIHRvIHRoZSBzZWxlY3Rpb24gZXZlbnQuIEl0IGNoZWNrcyBpZiB5b3Ugd2FudCB0byBjb25uZWN0IGEgY2x1c3RlciBhbmQgY2hhbmdlcyB0aGUgZGVzY3JpcHRpb25cbiAgICAgKiB0byB3YWxrIHRoZSB1c2VyIHRocm91Z2ggdGhlIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZUNvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUNvbm5lY3QoZXZlbnQpIHtcbiAgICAgIC8vIGNoZWNrIHRvIGF2b2lkIGRvdWJsZSBmaXJlaW5nIG9mIHRoaXMgZnVuY3Rpb24uXG4gICAgICBpZiAobmV3IERhdGUoKS52YWx1ZU9mKCkgLSB0aGlzLnRvdWNoVGltZSA+IDEwMCkge1xuICAgICAgICB0aGlzLmxhc3RUb3VjaCA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgICB0aGlzLmxhc3RUb3VjaC50cmFuc2xhdGlvbiA9IF9PYmplY3QkYXNzaWduKHt9LCB0aGlzLmJvZHkudmlldy50cmFuc2xhdGlvbik7IC8vIGNvcHkgdGhlIG9iamVjdFxuXG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyLmRyYWcucG9pbnRlciA9IHRoaXMubGFzdFRvdWNoOyAvLyBEcmFnIHBvaW50ZXIgaXMgbm90IHVwZGF0ZWQgd2hlbiBhZGRpbmcgZWRnZXNcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIuZHJhZy50cmFuc2xhdGlvbiA9IHRoaXMubGFzdFRvdWNoLnRyYW5zbGF0aW9uO1xuICAgICAgICB2YXIgcG9pbnRlciA9IHRoaXMubGFzdFRvdWNoO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXROb2RlQXQocG9pbnRlcik7XG4gICAgICAgIGlmIChub2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAobm9kZS5pc0NsdXN0ZXIgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGFsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdW1wiY3JlYXRlRWRnZUVycm9yXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJjcmVhdGVFZGdlRXJyb3JcIl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjcmVhdGUgYSBub2RlIHRoZSB0ZW1wb3JhcnkgbGluZSBjYW4gbG9vayBhdFxuICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSB0aGlzLl9nZXROZXdUYXJnZXROb2RlKG5vZGUueCwgbm9kZS55KTtcbiAgICAgICAgICAgIHRoaXMuYm9keS5ub2Rlc1t0YXJnZXROb2RlLmlkXSA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgICB0aGlzLmJvZHkubm9kZUluZGljZXMucHVzaCh0YXJnZXROb2RlLmlkKTtcblxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgdGVtcG9yYXJ5IGVkZ2VcbiAgICAgICAgICAgIHZhciBjb25uZWN0aW9uRWRnZSA9IHRoaXMuYm9keS5mdW5jdGlvbnMuY3JlYXRlRWRnZSh7XG4gICAgICAgICAgICAgIGlkOiBcImNvbm5lY3Rpb25FZGdlXCIgKyB2NCgpLFxuICAgICAgICAgICAgICBmcm9tOiBub2RlLmlkLFxuICAgICAgICAgICAgICB0bzogdGFyZ2V0Tm9kZS5pZCxcbiAgICAgICAgICAgICAgcGh5c2ljczogZmFsc2UsXG4gICAgICAgICAgICAgIHNtb290aDoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJjb250aW51b3VzXCIsXG4gICAgICAgICAgICAgICAgcm91bmRuZXNzOiAwLjVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZWRnZXNbY29ubmVjdGlvbkVkZ2UuaWRdID0gY29ubmVjdGlvbkVkZ2U7XG4gICAgICAgICAgICB0aGlzLmJvZHkuZWRnZUluZGljZXMucHVzaChjb25uZWN0aW9uRWRnZS5pZCk7XG4gICAgICAgICAgICB0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlcy5wdXNoKHRhcmdldE5vZGUuaWQpO1xuICAgICAgICAgICAgdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXMucHVzaChjb25uZWN0aW9uRWRnZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudG91Y2hUaW1lID0gbmV3IERhdGUoKS52YWx1ZU9mKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2RyYWdDb250cm9sTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhZ0NvbnRyb2xOb2RlKGV2ZW50KSB7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXMuYm9keS5mdW5jdGlvbnMuZ2V0UG9pbnRlcihldmVudC5jZW50ZXIpO1xuICAgICAgdmFyIHBvaW50ZXJPYmogPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuX3BvaW50ZXJUb1Bvc2l0aW9uT2JqZWN0KHBvaW50ZXIpO1xuICAgICAgLy8gcmVtZW1iZXIgdGhlIGVkZ2UgaWRcbiAgICAgIHZhciBjb25uZWN0RnJvbUlkID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHRoaXMudGVtcG9yYXJ5SWRzLmVkZ2VzWzBdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29ubmVjdEZyb21JZCA9IHRoaXMuYm9keS5lZGdlc1t0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1swXV0uZnJvbUlkO1xuICAgICAgfVxuXG4gICAgICAvLyBnZXQgdGhlIG92ZXJsYXBwaW5nIG5vZGUgYnV0IE5PVCB0aGUgdGVtcG9yYXJ5IG5vZGU7XG4gICAgICB2YXIgb3ZlcmxhcHBpbmdOb2RlSWRzID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLl9nZXRBbGxOb2Rlc092ZXJsYXBwaW5nV2l0aChwb2ludGVyT2JqKTtcbiAgICAgIHZhciBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgZm9yICh2YXIgaSA9IG92ZXJsYXBwaW5nTm9kZUlkcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgX2NvbnRleHQzMDtcbiAgICAgICAgLy8gaWYgdGhlIG5vZGUgaWQgaXMgTk9UIGEgdGVtcG9yYXJ5IG5vZGUsIGFjY2VwdCB0aGUgbm9kZS5cbiAgICAgICAgaWYgKF9pbmRleE9mSW5zdGFuY2VQcm9wZXJ0eShfY29udGV4dDMwID0gdGhpcy50ZW1wb3JhcnlJZHMubm9kZXMpLmNhbGwoX2NvbnRleHQzMCwgb3ZlcmxhcHBpbmdOb2RlSWRzW2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5ib2R5Lm5vZGVzW292ZXJsYXBwaW5nTm9kZUlkc1tpXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGV2ZW50LmNvbnRyb2xFZGdlID0ge1xuICAgICAgICBmcm9tOiBjb25uZWN0RnJvbUlkLFxuICAgICAgICB0bzogbm9kZSA/IG5vZGUuaWQgOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2VuZXJhdGVDbGlja0V2ZW50KFwiY29udHJvbE5vZGVEcmFnZ2luZ1wiLCBldmVudCwgcG9pbnRlcik7XG4gICAgICBpZiAodGhpcy50ZW1wb3JhcnlJZHMubm9kZXNbMF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRoaXMuYm9keS5ub2Rlc1t0aGlzLnRlbXBvcmFyeUlkcy5ub2Rlc1swXV07IC8vIHRoZXJlIGlzIG9ubHkgb25lIHRlbXAgbm9kZSBpbiB0aGUgYWRkIGVkZ2UgbW9kZS5cbiAgICAgICAgdGFyZ2V0Tm9kZS54ID0gdGhpcy5jYW52YXMuX1hjb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci54KTtcbiAgICAgICAgdGFyZ2V0Tm9kZS55ID0gdGhpcy5jYW52YXMuX1ljb252ZXJ0RE9NdG9DYW52YXMocG9pbnRlci55KTtcbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZWRyYXdcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlci5vbkRyYWcoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdGhlIG5ldyBlZGdlIHRvIHRoZSB0YXJnZXQgaWYgb25lIGV4aXN0cywgb3RoZXJ3aXNlIHJlbW92ZSB0ZW1wIGxpbmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9ICBldmVudCAgIFRoZSBldmVudFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmlzaENvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmlzaENvbm5lY3QoZXZlbnQpIHtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpcy5ib2R5LmZ1bmN0aW9ucy5nZXRQb2ludGVyKGV2ZW50LmNlbnRlcik7XG4gICAgICB2YXIgcG9pbnRlck9iaiA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fcG9pbnRlclRvUG9zaXRpb25PYmplY3QocG9pbnRlcik7XG5cbiAgICAgIC8vIHJlbWVtYmVyIHRoZSBlZGdlIGlkXG4gICAgICB2YXIgY29ubmVjdEZyb21JZCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0aGlzLnRlbXBvcmFyeUlkcy5lZGdlc1swXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbm5lY3RGcm9tSWQgPSB0aGlzLmJvZHkuZWRnZXNbdGhpcy50ZW1wb3JhcnlJZHMuZWRnZXNbMF1dLmZyb21JZDtcbiAgICAgIH1cblxuICAgICAgLy8gZ2V0IHRoZSBvdmVybGFwcGluZyBub2RlIGJ1dCBOT1QgdGhlIHRlbXBvcmFyeSBub2RlO1xuICAgICAgdmFyIG92ZXJsYXBwaW5nTm9kZUlkcyA9IHRoaXMuc2VsZWN0aW9uSGFuZGxlci5fZ2V0QWxsTm9kZXNPdmVybGFwcGluZ1dpdGgocG9pbnRlck9iaik7XG4gICAgICB2YXIgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgIGZvciAodmFyIGkgPSBvdmVybGFwcGluZ05vZGVJZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIF9jb250ZXh0MzE7XG4gICAgICAgIC8vIGlmIHRoZSBub2RlIGlkIGlzIE5PVCBhIHRlbXBvcmFyeSBub2RlLCBhY2NlcHQgdGhlIG5vZGUuXG4gICAgICAgIGlmIChfaW5kZXhPZkluc3RhbmNlUHJvcGVydHkoX2NvbnRleHQzMSA9IHRoaXMudGVtcG9yYXJ5SWRzLm5vZGVzKS5jYWxsKF9jb250ZXh0MzEsIG92ZXJsYXBwaW5nTm9kZUlkc1tpXSkgPT09IC0xKSB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuYm9keS5ub2Rlc1tvdmVybGFwcGluZ05vZGVJZHNbaV1dO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNsZWFuIHRlbXBvcmFyeSBub2RlcyBhbmQgZWRnZXMuXG4gICAgICB0aGlzLl9jbGVhbnVwVGVtcG9yYXJ5Tm9kZXNBbmRFZGdlcygpO1xuXG4gICAgICAvLyBwZXJmb3JtIHRoZSBjb25uZWN0aW9uXG4gICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChub2RlLmlzQ2x1c3RlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFsZXJ0KHRoaXMub3B0aW9ucy5sb2NhbGVzW3RoaXMub3B0aW9ucy5sb2NhbGVdW1wiY3JlYXRlRWRnZUVycm9yXCJdIHx8IHRoaXMub3B0aW9ucy5sb2NhbGVzW1wiZW5cIl1bXCJjcmVhdGVFZGdlRXJyb3JcIl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmJvZHkubm9kZXNbY29ubmVjdEZyb21JZF0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLmJvZHkubm9kZXNbbm9kZS5pZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fcGVyZm9ybUFkZEVkZ2UoY29ubmVjdEZyb21JZCwgbm9kZS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBldmVudC5jb250cm9sRWRnZSA9IHtcbiAgICAgICAgZnJvbTogY29ubmVjdEZyb21JZCxcbiAgICAgICAgdG86IG5vZGUgPyBub2RlLmlkIDogdW5kZWZpbmVkXG4gICAgICB9O1xuICAgICAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdlbmVyYXRlQ2xpY2tFdmVudChcImNvbnRyb2xOb2RlRHJhZ0VuZFwiLCBldmVudCwgcG9pbnRlcik7XG5cbiAgICAgIC8vIE5vIG5lZWQgdG8gZG8gX2dlbmVyYXRlY2xpY2tldmVudCgnZHJhZ0VuZCcpIGhlcmUsIHRoZSByZWd1bGFyIGRyYWdFbmQgZXZlbnQgZmlyZXMuXG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX3JlZHJhd1wiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZHJhZ1N0YXJ0RWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhZ1N0YXJ0RWRnZShldmVudCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzLmxhc3RUb3VjaDtcbiAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZW5lcmF0ZUNsaWNrRXZlbnQoXCJkcmFnU3RhcnRcIiwgZXZlbnQsIHBvaW50ZXIsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVORCBPRiBBREQgRURHRSBGVU5DVElPTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS8vXG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gUGVyZm9ybWluZyBhbGwgdGhlIGFjdHVhbCBkYXRhIG1hbmlwdWxhdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0vL1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5vZGUgb24gdGhlIHNwZWNpZmllZCBsb2NhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNsaWNrRGF0YVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BlcmZvcm1BZGROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtQWRkTm9kZShjbGlja0RhdGEpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0ge1xuICAgICAgICBpZDogdjQoKSxcbiAgICAgICAgeDogY2xpY2tEYXRhLnBvaW50ZXIuY2FudmFzLngsXG4gICAgICAgIHk6IGNsaWNrRGF0YS5wb2ludGVyLmNhbnZhcy55LFxuICAgICAgICBsYWJlbDogXCJuZXdcIlxuICAgICAgfTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmFkZE5vZGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFkZE5vZGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgdGhpcy5vcHRpb25zLmFkZE5vZGUoZGVmYXVsdERhdGEsIGZ1bmN0aW9uIChmaW5hbGl6ZWREYXRhKSB7XG4gICAgICAgICAgICBpZiAoZmluYWxpemVkRGF0YSAhPT0gbnVsbCAmJiBmaW5hbGl6ZWREYXRhICE9PSB1bmRlZmluZWQgJiYgX3RoaXM0LmluTW9kZSA9PT0gXCJhZGROb2RlXCIpIHtcbiAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgIF90aGlzNC5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLmFkZChmaW5hbGl6ZWREYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzNC5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZ1bmN0aW9uIGZvciBhZGQgZG9lcyBub3Qgc3VwcG9ydCB0d28gYXJndW1lbnRzIChkYXRhLGNhbGxiYWNrKVwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEubm9kZXMuZ2V0RGF0YVNldCgpLmFkZChkZWZhdWx0RGF0YSk7XG4gICAgICAgIHRoaXMuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNvbm5lY3QgdHdvIG5vZGVzIHdpdGggYSBuZXcgZWRnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZS5pZH0gc291cmNlTm9kZUlkXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSB0YXJnZXROb2RlSWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9wZXJmb3JtQWRkRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybUFkZEVkZ2Uoc291cmNlTm9kZUlkLCB0YXJnZXROb2RlSWQpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0ge1xuICAgICAgICBmcm9tOiBzb3VyY2VOb2RlSWQsXG4gICAgICAgIHRvOiB0YXJnZXROb2RlSWRcbiAgICAgIH07XG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hZGRFZGdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hZGRFZGdlLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgIHRoaXMub3B0aW9ucy5hZGRFZGdlKGRlZmF1bHREYXRhLCBmdW5jdGlvbiAoZmluYWxpemVkRGF0YSkge1xuICAgICAgICAgICAgaWYgKGZpbmFsaXplZERhdGEgIT09IG51bGwgJiYgZmluYWxpemVkRGF0YSAhPT0gdW5kZWZpbmVkICYmIF90aGlzNS5pbk1vZGUgPT09IFwiYWRkRWRnZVwiKSB7XG4gICAgICAgICAgICAgIC8vIGlmIGZvciB3aGF0ZXZlciByZWFzb24gdGhlIG1vZGUgaGFzIGNoYW5nZXMgKGR1ZSB0byBkYXRhc2V0IGNoYW5nZSkgZGlzcmVnYXJkIHRoZSBjYWxsYmFja1xuICAgICAgICAgICAgICBfdGhpczUuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS5hZGQoZmluYWxpemVkRGF0YSk7XG4gICAgICAgICAgICAgIF90aGlzNS5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG4gICAgICAgICAgICAgIF90aGlzNS5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGZ1bmN0aW9uIGZvciBjb25uZWN0IGRvZXMgbm90IHN1cHBvcnQgdHdvIGFyZ3VtZW50cyAoZGF0YSxjYWxsYmFjaylcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldERhdGFTZXQoKS5hZGQoZGVmYXVsdERhdGEpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgICAgdGhpcy5zaG93TWFuaXB1bGF0b3JUb29sYmFyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY29ubmVjdCB0d28gbm9kZXMgd2l0aCBhIG5ldyBlZGdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlLmlkfSBzb3VyY2VOb2RlSWRcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IHRhcmdldE5vZGVJZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BlcmZvcm1FZGl0RWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGVyZm9ybUVkaXRFZGdlKHNvdXJjZU5vZGVJZCwgdGFyZ2V0Tm9kZUlkKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICAgIHZhciBkZWZhdWx0RGF0YSA9IHtcbiAgICAgICAgaWQ6IHRoaXMuZWRnZUJlaW5nRWRpdGVkSWQsXG4gICAgICAgIGZyb206IHNvdXJjZU5vZGVJZCxcbiAgICAgICAgdG86IHRhcmdldE5vZGVJZCxcbiAgICAgICAgbGFiZWw6IHRoaXMuYm9keS5kYXRhLmVkZ2VzLmdldCh0aGlzLmVkZ2VCZWluZ0VkaXRlZElkKS5sYWJlbFxuICAgICAgfTtcbiAgICAgIHZhciBlZUZ1bmN0ID0gdGhpcy5vcHRpb25zLmVkaXRFZGdlO1xuICAgICAgaWYgKF90eXBlb2YoZWVGdW5jdCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZWVGdW5jdCA9IGVlRnVuY3QuZWRpdFdpdGhvdXREcmFnO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBlZUZ1bmN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGVlRnVuY3QubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgZWVGdW5jdChkZWZhdWx0RGF0YSwgZnVuY3Rpb24gKGZpbmFsaXplZERhdGEpIHtcbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZWREYXRhID09PSBudWxsIHx8IGZpbmFsaXplZERhdGEgPT09IHVuZGVmaW5lZCB8fCBfdGhpczYuaW5Nb2RlICE9PSBcImVkaXRFZGdlXCIpIHtcbiAgICAgICAgICAgICAgLy8gaWYgZm9yIHdoYXRldmVyIHJlYXNvbiB0aGUgbW9kZSBoYXMgY2hhbmdlcyAoZHVlIHRvIGRhdGFzZXQgY2hhbmdlKSBkaXNyZWdhcmQgdGhlIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIF90aGlzNi5ib2R5LmVkZ2VzW2RlZmF1bHREYXRhLmlkXS51cGRhdGVFZGdlVHlwZSgpO1xuICAgICAgICAgICAgICBfdGhpczYuYm9keS5lbWl0dGVyLmVtaXQoXCJfcmVkcmF3XCIpO1xuICAgICAgICAgICAgICBfdGhpczYuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXM2LmJvZHkuZGF0YS5lZGdlcy5nZXREYXRhU2V0KCkudXBkYXRlKGZpbmFsaXplZERhdGEpO1xuICAgICAgICAgICAgICBfdGhpczYuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgICAgICAgICBfdGhpczYuc2hvd01hbmlwdWxhdG9yVG9vbGJhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBmdW5jdGlvbiBmb3IgZWRpdCBkb2VzIG5vdCBzdXBwb3J0IHR3byBhcmd1bWVudHMgKGRhdGEsIGNhbGxiYWNrKVwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib2R5LmRhdGEuZWRnZXMuZ2V0RGF0YVNldCgpLnVwZGF0ZShkZWZhdWx0RGF0YSk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlci51bnNlbGVjdEFsbCgpO1xuICAgICAgICB0aGlzLnNob3dNYW5pcHVsYXRvclRvb2xiYXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE1hbmlwdWxhdGlvblN5c3RlbTtcbn0oKTtcblxuLyoqXHJcbiAqIFRoaXMgb2JqZWN0IGNvbnRhaW5zIGFsbCBwb3NzaWJsZSBvcHRpb25zLiBJdCB3aWxsIGNoZWNrIGlmIHRoZSB0eXBlcyBhcmUgY29ycmVjdCwgaWYgcmVxdWlyZWQgaWYgdGhlIG9wdGlvbiBpcyBvbmVcclxuICogb2YgdGhlIGFsbG93ZWQgdmFsdWVzLlxyXG4gKlxyXG4gKiBfX2FueV9fIG1lYW5zIHRoYXQgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IGRvZXMgbm90IG1hdHRlci5cclxuICogX190eXBlX18gaXMgYSByZXF1aXJlZCBmaWVsZCBmb3IgYWxsIG9iamVjdHMgYW5kIGNvbnRhaW5zIHRoZSBhbGxvd2VkIHR5cGVzIG9mIGFsbCBvYmplY3RzXHJcbiAqL1xudmFyIHN0cmluZyA9IFwic3RyaW5nXCI7XG52YXIgYm9vbCA9IFwiYm9vbGVhblwiO1xudmFyIG51bWJlciA9IFwibnVtYmVyXCI7XG52YXIgYXJyYXkgPSBcImFycmF5XCI7XG52YXIgb2JqZWN0ID0gXCJvYmplY3RcIjsgLy8gc2hvdWxkIG9ubHkgYmUgaW4gYSBfX3R5cGVfXyBwcm9wZXJ0eVxudmFyIGRvbSA9IFwiZG9tXCI7XG52YXIgYW55ID0gXCJhbnlcIjtcbi8vIExpc3Qgb2YgZW5kcG9pbnRzXG52YXIgZW5kUG9pbnRzID0gW1wiYXJyb3dcIiwgXCJiYXJcIiwgXCJib3hcIiwgXCJjaXJjbGVcIiwgXCJjcm93XCIsIFwiY3VydmVcIiwgXCJkaWFtb25kXCIsIFwiaW1hZ2VcIiwgXCJpbnZfY3VydmVcIiwgXCJpbnZfdHJpYW5nbGVcIiwgXCJ0cmlhbmdsZVwiLCBcInZlZVwiXTtcbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvbiAtLSBUaGUgX18qX18gZm9ybWF0IGlzIHVzZWQgdG8gcHJldmVudCBjb2xsaXNpb25zIHdpdGggYWN0dWFsIG9wdGlvbiBuYW1lcy4gKi9cbnZhciBub2RlT3B0aW9ucyA9IHtcbiAgYm9yZGVyV2lkdGg6IHtcbiAgICBudW1iZXI6IG51bWJlclxuICB9LFxuICBib3JkZXJXaWR0aFNlbGVjdGVkOiB7XG4gICAgbnVtYmVyOiBudW1iZXIsXG4gICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gIH0sXG4gIGJyb2tlbkltYWdlOiB7XG4gICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gIH0sXG4gIGNob3Nlbjoge1xuICAgIGxhYmVsOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgbm9kZToge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9XG4gIH0sXG4gIGNvbG9yOiB7XG4gICAgYm9yZGVyOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgYmFja2dyb3VuZDoge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIGhpZ2hsaWdodDoge1xuICAgICAgYm9yZGVyOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfVxuICAgIH0sXG4gICAgaG92ZXI6IHtcbiAgICAgIGJvcmRlcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfVxuICB9LFxuICBvcGFjaXR5OiB7XG4gICAgbnVtYmVyOiBudW1iZXIsXG4gICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gIH0sXG4gIGZpeGVkOiB7XG4gICAgeDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgeToge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH1cbiAgfSxcbiAgZm9udDoge1xuICAgIGFsaWduOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgY29sb3I6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBzaXplOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgZmFjZToge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIGJhY2tncm91bmQ6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBzdHJva2VXaWR0aDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHN0cm9rZUNvbG9yOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgdmFkanVzdDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIG11bHRpOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIGJvbGQ6IHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGZhY2U6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBtb2Q6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICB2YWRqdXN0OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9XG4gICAgfSxcbiAgICBib2xkaXRhbDoge1xuICAgICAgY29sb3I6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZmFjZToge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIG1vZDoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHZhZGp1c3Q6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH1cbiAgICB9LFxuICAgIGl0YWw6IHtcbiAgICAgIGNvbG9yOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgc2l6ZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGZhY2U6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBtb2Q6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICB2YWRqdXN0OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9XG4gICAgfSxcbiAgICBtb25vOiB7XG4gICAgICBjb2xvcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBmYWNlOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgbW9kOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgdmFkanVzdDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfVxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9XG4gIH0sXG4gIGdyb3VwOiB7XG4gICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgbnVtYmVyOiBudW1iZXIsXG4gICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gIH0sXG4gIGhlaWdodENvbnN0cmFpbnQ6IHtcbiAgICBtaW5pbXVtOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgdmFsaWduOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfVxuICB9LFxuICBoaWRkZW46IHtcbiAgICBib29sZWFuOiBib29sXG4gIH0sXG4gIGljb246IHtcbiAgICBmYWNlOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZ1xuICAgIH0sXG4gICAgY29kZToge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIHNpemU6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBjb2xvcjoge1xuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIHdlaWdodDoge1xuICAgICAgc3RyaW5nOiBzdHJpbmcsXG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgfVxuICB9LFxuICBpZDoge1xuICAgIHN0cmluZzogc3RyaW5nLFxuICAgIG51bWJlcjogbnVtYmVyXG4gIH0sXG4gIGltYWdlOiB7XG4gICAgc2VsZWN0ZWQ6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gICAgfSxcbiAgICB1bnNlbGVjdGVkOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9XG4gIH0sXG4gIGltYWdlUGFkZGluZzoge1xuICAgIHRvcDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfVxuICB9LFxuICBsYWJlbDoge1xuICAgIHN0cmluZzogc3RyaW5nLFxuICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICB9LFxuICBsYWJlbEhpZ2hsaWdodEJvbGQ6IHtcbiAgICBib29sZWFuOiBib29sXG4gIH0sXG4gIGxldmVsOiB7XG4gICAgbnVtYmVyOiBudW1iZXIsXG4gICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gIH0sXG4gIG1hcmdpbjoge1xuICAgIHRvcDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfVxuICB9LFxuICBtYXNzOiB7XG4gICAgbnVtYmVyOiBudW1iZXJcbiAgfSxcbiAgcGh5c2ljczoge1xuICAgIGJvb2xlYW46IGJvb2xcbiAgfSxcbiAgc2NhbGluZzoge1xuICAgIG1pbjoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIG1heDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBtaW46IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBtYXg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBtYXhWaXNpYmxlOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZHJhd1RocmVzaG9sZDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICBjdXN0b21TY2FsaW5nRnVuY3Rpb246IHtcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH1cbiAgfSxcbiAgc2hhZG93OiB7XG4gICAgZW5hYmxlZDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgY29sb3I6IHtcbiAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgfSxcbiAgICBzaXplOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgeDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHk6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBib29sZWFuOiBib29sXG4gICAgfVxuICB9LFxuICBzaGFwZToge1xuICAgIHN0cmluZzogW1wiY3VzdG9tXCIsIFwiZWxsaXBzZVwiLCBcImNpcmNsZVwiLCBcImRhdGFiYXNlXCIsIFwiYm94XCIsIFwidGV4dFwiLCBcImltYWdlXCIsIFwiY2lyY3VsYXJJbWFnZVwiLCBcImRpYW1vbmRcIiwgXCJkb3RcIiwgXCJzdGFyXCIsIFwidHJpYW5nbGVcIiwgXCJ0cmlhbmdsZURvd25cIiwgXCJzcXVhcmVcIiwgXCJpY29uXCIsIFwiaGV4YWdvblwiXVxuICB9LFxuICBjdHhSZW5kZXJlcjoge1xuICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAgc2hhcGVQcm9wZXJ0aWVzOiB7XG4gICAgYm9yZGVyRGFzaGVzOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgYXJyYXk6IGFycmF5XG4gICAgfSxcbiAgICBib3JkZXJSYWRpdXM6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBpbnRlcnBvbGF0aW9uOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICB1c2VJbWFnZVNpemU6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHVzZUJvcmRlcldpdGhJbWFnZToge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgY29vcmRpbmF0ZU9yaWdpbjoge1xuICAgICAgc3RyaW5nOiBbXCJjZW50ZXJcIiwgXCJ0b3AtbGVmdFwiXVxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgfVxuICB9LFxuICBzaXplOiB7XG4gICAgbnVtYmVyOiBudW1iZXJcbiAgfSxcbiAgdGl0bGU6IHtcbiAgICBzdHJpbmc6IHN0cmluZyxcbiAgICBkb206IGRvbSxcbiAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgfSxcbiAgdmFsdWU6IHtcbiAgICBudW1iZXI6IG51bWJlcixcbiAgICB1bmRlZmluZWQ6IFwidW5kZWZpbmVkXCJcbiAgfSxcbiAgd2lkdGhDb25zdHJhaW50OiB7XG4gICAgbWluaW11bToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIG1heGltdW06IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9XG4gIH0sXG4gIHg6IHtcbiAgICBudW1iZXI6IG51bWJlclxuICB9LFxuICB5OiB7XG4gICAgbnVtYmVyOiBudW1iZXJcbiAgfSxcbiAgX190eXBlX186IHtcbiAgICBvYmplY3Q6IG9iamVjdFxuICB9XG59O1xudmFyIGFsbE9wdGlvbnMgPSB7XG4gIGNvbmZpZ3VyZToge1xuICAgIGVuYWJsZWQ6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGZpbHRlcjoge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgYXJyYXk6IGFycmF5LFxuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgY29udGFpbmVyOiB7XG4gICAgICBkb206IGRvbVxuICAgIH0sXG4gICAgc2hvd0J1dHRvbjoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIHN0cmluZzogc3RyaW5nLFxuICAgICAgYXJyYXk6IGFycmF5LFxuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH1cbiAgfSxcbiAgZWRnZXM6IHtcbiAgICBhcnJvd3M6IHtcbiAgICAgIHRvOiB7XG4gICAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICBib29sZWFuOiBib29sXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlRmFjdG9yOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIHN0cmluZzogZW5kUG9pbnRzXG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlSGVpZ2h0OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2VXaWR0aDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHNyYzoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbWlkZGxlOiB7XG4gICAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICBib29sZWFuOiBib29sXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlRmFjdG9yOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZToge1xuICAgICAgICAgIHN0cmluZzogZW5kUG9pbnRzXG4gICAgICAgIH0sXG4gICAgICAgIGltYWdlV2lkdGg6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBpbWFnZUhlaWdodDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHNyYzoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZnJvbToge1xuICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgICB9LFxuICAgICAgICBzY2FsZUZhY3Rvcjoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtcbiAgICAgICAgICBzdHJpbmc6IGVuZFBvaW50c1xuICAgICAgICB9LFxuICAgICAgICBpbWFnZVdpZHRoOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgaW1hZ2VIZWlnaHQ6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBzcmM6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIHN0cmluZzogW1wiZnJvbVwiLCBcInRvXCIsIFwibWlkZGxlXCJdLFxuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgZW5kUG9pbnRPZmZzZXQ6IHtcbiAgICAgIGZyb206IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICB0bzoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfVxuICAgIH0sXG4gICAgYXJyb3dTdHJpa2V0aHJvdWdoOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kOiB7XG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBjb2xvcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBkYXNoZXM6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgICAgYXJyYXk6IGFycmF5XG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH1cbiAgICB9LFxuICAgIGNob3Nlbjoge1xuICAgICAgbGFiZWw6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgICAgfSxcbiAgICAgIGVkZ2U6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICBjb2xvcjoge1xuICAgICAgY29sb3I6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBob3Zlcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIGluaGVyaXQ6IHtcbiAgICAgICAgc3RyaW5nOiBbXCJmcm9tXCIsIFwidG9cIiwgXCJib3RoXCJdLFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgb3BhY2l0eToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfVxuICAgIH0sXG4gICAgZGFzaGVzOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgYXJyYXk6IGFycmF5XG4gICAgfSxcbiAgICBmb250OiB7XG4gICAgICBjb2xvcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBmYWNlOiB7XG4gICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICB9LFxuICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHN0cm9rZVdpZHRoOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3Ryb2tlQ29sb3I6IHtcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBhbGlnbjoge1xuICAgICAgICBzdHJpbmc6IFtcImhvcml6b250YWxcIiwgXCJ0b3BcIiwgXCJtaWRkbGVcIiwgXCJib3R0b21cIl1cbiAgICAgIH0sXG4gICAgICB2YWRqdXN0OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgbXVsdGk6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgIH0sXG4gICAgICBib2xkOiB7XG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIGZhY2U6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBtb2Q6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICB2YWRqdXN0OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYm9sZGl0YWw6IHtcbiAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgZmFjZToge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIG1vZDoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHZhZGp1c3Q6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpdGFsOiB7XG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIGZhY2U6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICBtb2Q6IHtcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9LFxuICAgICAgICB2YWRqdXN0OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgX190eXBlX186IHtcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbW9ubzoge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIHN0cmluZzogc3RyaW5nXG4gICAgICAgIH0sXG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBmYWNlOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgbW9kOiB7XG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfSxcbiAgICAgICAgdmFkanVzdDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfVxuICAgIH0sXG4gICAgaGlkZGVuOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBob3ZlcldpZHRoOiB7XG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiLFxuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGxhYmVsOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICAgIH0sXG4gICAgbGFiZWxIaWdobGlnaHRCb2xkOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBsZW5ndGg6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyLFxuICAgICAgdW5kZWZpbmVkOiBcInVuZGVmaW5lZFwiXG4gICAgfSxcbiAgICBwaHlzaWNzOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBzY2FsaW5nOiB7XG4gICAgICBtaW46IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBtYXg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiB7XG4gICAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgICB9LFxuICAgICAgICBtaW46IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBtYXg6IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBtYXhWaXNpYmxlOiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgZHJhd1RocmVzaG9sZDoge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY3VzdG9tU2NhbGluZ0Z1bmN0aW9uOiB7XG4gICAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0aW9uV2lkdGg6IHtcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCIsXG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgc2VsZlJlZmVyZW5jZVNpemU6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBzZWxmUmVmZXJlbmNlOiB7XG4gICAgICBzaXplOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgYW5nbGU6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICByZW5kZXJCZWhpbmRUaGVOb2RlOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgc2hhZG93OiB7XG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBjb2xvcjoge1xuICAgICAgICBzdHJpbmc6IHN0cmluZ1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICB4OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICBzbW9vdGg6IHtcbiAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIHR5cGU6IHtcbiAgICAgICAgc3RyaW5nOiBbXCJkeW5hbWljXCIsIFwiY29udGludW91c1wiLCBcImRpc2NyZXRlXCIsIFwiZGlhZ29uYWxDcm9zc1wiLCBcInN0cmFpZ2h0Q3Jvc3NcIiwgXCJob3Jpem9udGFsXCIsIFwidmVydGljYWxcIiwgXCJjdXJ2ZWRDV1wiLCBcImN1cnZlZENDV1wiLCBcImN1YmljQmV6aWVyXCJdXG4gICAgICB9LFxuICAgICAgcm91bmRuZXNzOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZm9yY2VEaXJlY3Rpb246IHtcbiAgICAgICAgc3RyaW5nOiBbXCJob3Jpem9udGFsXCIsIFwidmVydGljYWxcIiwgXCJub25lXCJdLFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH1cbiAgICB9LFxuICAgIHRpdGxlOiB7XG4gICAgICBzdHJpbmc6IHN0cmluZyxcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICAgIH0sXG4gICAgd2lkdGg6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICB3aWR0aENvbnN0cmFpbnQ6IHtcbiAgICAgIG1heGltdW06IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH1cbiAgICB9LFxuICAgIHZhbHVlOiB7XG4gICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIlxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgfVxuICB9LFxuICBncm91cHM6IHtcbiAgICB1c2VEZWZhdWx0R3JvdXBzOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBfX2FueV9fOiBub2RlT3B0aW9ucyxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICB9XG4gIH0sXG4gIGludGVyYWN0aW9uOiB7XG4gICAgZHJhZ05vZGVzOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBkcmFnVmlldzoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgaGlkZUVkZ2VzT25EcmFnOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBoaWRlRWRnZXNPblpvb206IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGhpZGVOb2Rlc09uRHJhZzoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgaG92ZXI6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGtleWJvYXJkOiB7XG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBzcGVlZDoge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHpvb206IHtcbiAgICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgICB9LFxuICAgICAgICBfX3R5cGVfXzoge1xuICAgICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBiaW5kVG9XaW5kb3c6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIGF1dG9Gb2N1czoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH1cbiAgICB9LFxuICAgIG11bHRpc2VsZWN0OiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBuYXZpZ2F0aW9uQnV0dG9uczoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgc2VsZWN0YWJsZToge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgc2VsZWN0Q29ubmVjdGVkRWRnZXM6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIGhvdmVyQ29ubmVjdGVkRWRnZXM6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHRvb2x0aXBEZWxheToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHpvb21WaWV3OiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICB6b29tU3BlZWQ6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICB9XG4gIH0sXG4gIGxheW91dDoge1xuICAgIHJhbmRvbVNlZWQ6IHtcbiAgICAgIHVuZGVmaW5lZDogXCJ1bmRlZmluZWRcIixcbiAgICAgIG51bWJlcjogbnVtYmVyLFxuICAgICAgc3RyaW5nOiBzdHJpbmdcbiAgICB9LFxuICAgIGltcHJvdmVkTGF5b3V0OiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBjbHVzdGVyVGhyZXNob2xkOiB7XG4gICAgICBudW1iZXI6IG51bWJlclxuICAgIH0sXG4gICAgaGllcmFyY2hpY2FsOiB7XG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBsZXZlbFNlcGFyYXRpb246IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBub2RlU3BhY2luZzoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHRyZWVTcGFjaW5nOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgYmxvY2tTaGlmdGluZzoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgZWRnZU1pbmltaXphdGlvbjoge1xuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9LFxuICAgICAgcGFyZW50Q2VudHJhbGl6YXRpb246IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIGRpcmVjdGlvbjoge1xuICAgICAgICBzdHJpbmc6IFtcIlVEXCIsIFwiRFVcIiwgXCJMUlwiLCBcIlJMXCJdXG4gICAgICB9LFxuICAgICAgc29ydE1ldGhvZDoge1xuICAgICAgICBzdHJpbmc6IFtcImh1YnNpemVcIiwgXCJkaXJlY3RlZFwiXVxuICAgICAgfSxcbiAgICAgIHNoYWtlVG93YXJkczoge1xuICAgICAgICBzdHJpbmc6IFtcImxlYXZlc1wiLCBcInJvb3RzXCJdXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH1cbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdFxuICAgIH1cbiAgfSxcbiAgbWFuaXB1bGF0aW9uOiB7XG4gICAgZW5hYmxlZDoge1xuICAgICAgYm9vbGVhbjogYm9vbFxuICAgIH0sXG4gICAgaW5pdGlhbGx5QWN0aXZlOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBhZGROb2RlOiB7XG4gICAgICBib29sZWFuOiBib29sLFxuICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgYWRkRWRnZToge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIGVkaXROb2RlOiB7XG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBlZGl0RWRnZToge1xuICAgICAgZWRpdFdpdGhvdXREcmFnOiB7XG4gICAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgICAgZnVuY3Rpb246IFwiZnVuY3Rpb25cIlxuICAgICAgfVxuICAgIH0sXG4gICAgZGVsZXRlTm9kZToge1xuICAgICAgYm9vbGVhbjogYm9vbCxcbiAgICAgIGZ1bmN0aW9uOiBcImZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIGRlbGV0ZUVkZ2U6IHtcbiAgICAgIGJvb2xlYW46IGJvb2wsXG4gICAgICBmdW5jdGlvbjogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBjb250cm9sTm9kZVN0eWxlOiBub2RlT3B0aW9ucyxcbiAgICBfX3R5cGVfXzoge1xuICAgICAgb2JqZWN0OiBvYmplY3QsXG4gICAgICBib29sZWFuOiBib29sXG4gICAgfVxuICB9LFxuICBub2Rlczogbm9kZU9wdGlvbnMsXG4gIHBoeXNpY3M6IHtcbiAgICBlbmFibGVkOiB7XG4gICAgICBib29sZWFuOiBib29sXG4gICAgfSxcbiAgICBiYXJuZXNIdXQ6IHtcbiAgICAgIHRoZXRhOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgY2VudHJhbEdyYXZpdHk6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBzcHJpbmdMZW5ndGg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBzcHJpbmdDb25zdGFudDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGRhbXBpbmc6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBhdm9pZE92ZXJsYXA6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgZm9yY2VBdGxhczJCYXNlZDoge1xuICAgICAgdGhldGE6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBjZW50cmFsR3Jhdml0eToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHNwcmluZ0xlbmd0aDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIHNwcmluZ0NvbnN0YW50OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgZGFtcGluZzoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGF2b2lkT3ZlcmxhcDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgICB9XG4gICAgfSxcbiAgICByZXB1bHNpb246IHtcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3ByaW5nTGVuZ3RoOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBub2RlRGlzdGFuY2U6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBkYW1waW5nOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIGhpZXJhcmNoaWNhbFJlcHVsc2lvbjoge1xuICAgICAgY2VudHJhbEdyYXZpdHk6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBzcHJpbmdMZW5ndGg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBzcHJpbmdDb25zdGFudDoge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIG5vZGVEaXN0YW5jZToge1xuICAgICAgICBudW1iZXI6IG51bWJlclxuICAgICAgfSxcbiAgICAgIGRhbXBpbmc6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBhdm9pZE92ZXJsYXA6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBfX3R5cGVfXzoge1xuICAgICAgICBvYmplY3Q6IG9iamVjdFxuICAgICAgfVxuICAgIH0sXG4gICAgbWF4VmVsb2NpdHk6IHtcbiAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgfSxcbiAgICBtaW5WZWxvY2l0eToge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIHNvbHZlcjoge1xuICAgICAgc3RyaW5nOiBbXCJiYXJuZXNIdXRcIiwgXCJyZXB1bHNpb25cIiwgXCJoaWVyYXJjaGljYWxSZXB1bHNpb25cIiwgXCJmb3JjZUF0bGFzMkJhc2VkXCJdXG4gICAgfSxcbiAgICBzdGFiaWxpemF0aW9uOiB7XG4gICAgICBlbmFibGVkOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBpdGVyYXRpb25zOiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgdXBkYXRlSW50ZXJ2YWw6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICBvbmx5RHluYW1pY0VkZ2VzOiB7XG4gICAgICAgIGJvb2xlYW46IGJvb2xcbiAgICAgIH0sXG4gICAgICBmaXQ6IHtcbiAgICAgICAgYm9vbGVhbjogYm9vbFxuICAgICAgfSxcbiAgICAgIF9fdHlwZV9fOiB7XG4gICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICBib29sZWFuOiBib29sXG4gICAgICB9XG4gICAgfSxcbiAgICB0aW1lc3RlcDoge1xuICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICB9LFxuICAgIGFkYXB0aXZlVGltZXN0ZXA6IHtcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9LFxuICAgIHdpbmQ6IHtcbiAgICAgIHg6IHtcbiAgICAgICAgbnVtYmVyOiBudW1iZXJcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIG51bWJlcjogbnVtYmVyXG4gICAgICB9LFxuICAgICAgX190eXBlX186IHtcbiAgICAgICAgb2JqZWN0OiBvYmplY3RcbiAgICAgIH1cbiAgICB9LFxuICAgIF9fdHlwZV9fOiB7XG4gICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgIGJvb2xlYW46IGJvb2xcbiAgICB9XG4gIH0sXG4gIC8vZ2xvYmFscyA6XG4gIGF1dG9SZXNpemU6IHtcbiAgICBib29sZWFuOiBib29sXG4gIH0sXG4gIGNsaWNrVG9Vc2U6IHtcbiAgICBib29sZWFuOiBib29sXG4gIH0sXG4gIGxvY2FsZToge1xuICAgIHN0cmluZzogc3RyaW5nXG4gIH0sXG4gIGxvY2FsZXM6IHtcbiAgICBfX2FueV9fOiB7XG4gICAgICBhbnk6IGFueVxuICAgIH0sXG4gICAgX190eXBlX186IHtcbiAgICAgIG9iamVjdDogb2JqZWN0XG4gICAgfVxuICB9LFxuICBoZWlnaHQ6IHtcbiAgICBzdHJpbmc6IHN0cmluZ1xuICB9LFxuICB3aWR0aDoge1xuICAgIHN0cmluZzogc3RyaW5nXG4gIH0sXG4gIF9fdHlwZV9fOiB7XG4gICAgb2JqZWN0OiBvYmplY3RcbiAgfVxufTtcbi8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uICovXG4vKipcclxuICogVGhpcyBwcm92aWRlcyByYW5nZXMsIGluaXRpYWwgdmFsdWVzLCBzdGVwcyBhbmQgZHJvcGRvd24gbWVudSBjaG9pY2VzIGZvciB0aGVcclxuICogY29uZmlndXJhdGlvbi5cclxuICpcclxuICogQHJlbWFya3NcclxuICogQ2hlY2tib3g6IGBib29sZWFuYFxyXG4gKiAgIFRoZSB2YWx1ZSBzdXBsbGllZCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluaXRpYWwgdmFsdWUuXHJcbiAqXHJcbiAqIFRleHQgZmllbGQ6IGBzdHJpbmdgXHJcbiAqICAgVGhlIHBhc3NlZCB0ZXh0IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5pdGlhbCB2YWx1ZS4gQW55IHRleHQgd2lsbCBiZVxyXG4gKiAgIGFjY2VwdGVkIGFmdGVyd2FyZHMuXHJcbiAqXHJcbiAqIE51bWJlciByYW5nZTogYFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdYFxyXG4gKiAgIFRoZSBtZWFuaW5ncyBhcmUgYFtpbml0aWFsIHZhbHVlLCBtaW4sIG1heCwgc3RlcF1gLlxyXG4gKlxyXG4gKiBEcm9wZG93bjogYFtFeGNsdWRlPHN0cmluZywgXCJjb2xvclwiPiwgLi4uKHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4pW11dYFxyXG4gKiAgIFRyYW5zbGF0aW9ucyBmb3IgcGVvcGxlIHdpdGggcG9vciB1bmRlcnN0YW5kaW5nIG9mIFR5cGVTY3JpcHQ6IHRoZSBmaXJzdFxyXG4gKiAgIHZhbHVlIGFsd2F5cyBoYXMgdG8gYmUgYSBzdHJpbmcgYnV0IG5ldmVyIGBcImNvbG9yXCJgLCB0aGUgcmVzdCBjYW4gYmUgYW55XHJcbiAqICAgY29tYmluYXRpb24gb2Ygc3RyaW5ncywgbnVtYmVycyBhbmQgYm9vbGVhbnMuXHJcbiAqXHJcbiAqIENvbG9yIHBpY2tlcjogYFtcImNvbG9yXCIsIHN0cmluZ11gXHJcbiAqICAgVGhlIGZpcnN0IHZhbHVlIHNheXMgdGhpcyB3aWxsIGJlIGEgY29sb3IgcGlja2VyIG5vdCBhIGRyb3Bkb3duIG1lbnUuIFRoZVxyXG4gKiAgIG5leHQgdmFsdWUgaXMgdGhlIGluaXRpYWwgY29sb3IuXHJcbiAqL1xudmFyIGNvbmZpZ3VyZU9wdGlvbnMgPSB7XG4gIG5vZGVzOiB7XG4gICAgYm9yZGVyV2lkdGg6IFsxLCAwLCAxMCwgMV0sXG4gICAgYm9yZGVyV2lkdGhTZWxlY3RlZDogWzIsIDAsIDEwLCAxXSxcbiAgICBjb2xvcjoge1xuICAgICAgYm9yZGVyOiBbXCJjb2xvclwiLCBcIiMyQjdDRTlcIl0sXG4gICAgICBiYWNrZ3JvdW5kOiBbXCJjb2xvclwiLCBcIiM5N0MyRkNcIl0sXG4gICAgICBoaWdobGlnaHQ6IHtcbiAgICAgICAgYm9yZGVyOiBbXCJjb2xvclwiLCBcIiMyQjdDRTlcIl0sXG4gICAgICAgIGJhY2tncm91bmQ6IFtcImNvbG9yXCIsIFwiI0QyRTVGRlwiXVxuICAgICAgfSxcbiAgICAgIGhvdmVyOiB7XG4gICAgICAgIGJvcmRlcjogW1wiY29sb3JcIiwgXCIjMkI3Q0U5XCJdLFxuICAgICAgICBiYWNrZ3JvdW5kOiBbXCJjb2xvclwiLCBcIiNEMkU1RkZcIl1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9wYWNpdHk6IFswLCAwLCAxLCAwLjFdLFxuICAgIGZpeGVkOiB7XG4gICAgICB4OiBmYWxzZSxcbiAgICAgIHk6IGZhbHNlXG4gICAgfSxcbiAgICBmb250OiB7XG4gICAgICBjb2xvcjogW1wiY29sb3JcIiwgXCIjMzQzNDM0XCJdLFxuICAgICAgc2l6ZTogWzE0LCAwLCAxMDAsIDFdLFxuICAgICAgZmFjZTogW1wiYXJpYWxcIiwgXCJ2ZXJkYW5hXCIsIFwidGFob21hXCJdLFxuICAgICAgYmFja2dyb3VuZDogW1wiY29sb3JcIiwgXCJub25lXCJdLFxuICAgICAgc3Ryb2tlV2lkdGg6IFswLCAwLCA1MCwgMV0sXG4gICAgICBzdHJva2VDb2xvcjogW1wiY29sb3JcIiwgXCIjZmZmZmZmXCJdXG4gICAgfSxcbiAgICAvL2dyb3VwOiAnc3RyaW5nJyxcbiAgICBoaWRkZW46IGZhbHNlLFxuICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDogdHJ1ZSxcbiAgICAvL2ljb246IHtcbiAgICAvLyAgZmFjZTogJ3N0cmluZycsICAvLydGb250QXdlc29tZScsXG4gICAgLy8gIGNvZGU6ICdzdHJpbmcnLCAgLy8nXFx1ZjAwNycsXG4gICAgLy8gIHNpemU6IFs1MCwgMCwgMjAwLCAxXSwgIC8vNTAsXG4gICAgLy8gIGNvbG9yOiBbJ2NvbG9yJywnIzJCN0NFOSddICAgLy8nI2FhMDBmZidcbiAgICAvL30sXG4gICAgLy9pbWFnZTogJ3N0cmluZycsIC8vIC0tPiBVUkxcbiAgICBwaHlzaWNzOiB0cnVlLFxuICAgIHNjYWxpbmc6IHtcbiAgICAgIG1pbjogWzEwLCAwLCAyMDAsIDFdLFxuICAgICAgbWF4OiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgbWluOiBbMTQsIDAsIDIwMCwgMV0sXG4gICAgICAgIG1heDogWzMwLCAwLCAyMDAsIDFdLFxuICAgICAgICBtYXhWaXNpYmxlOiBbMzAsIDAsIDIwMCwgMV0sXG4gICAgICAgIGRyYXdUaHJlc2hvbGQ6IFs1LCAwLCAyMCwgMV1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNoYWRvdzoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBjb2xvcjogXCJyZ2JhKDAsMCwwLDAuNSlcIixcbiAgICAgIHNpemU6IFsxMCwgMCwgMjAsIDFdLFxuICAgICAgeDogWzUsIC0zMCwgMzAsIDFdLFxuICAgICAgeTogWzUsIC0zMCwgMzAsIDFdXG4gICAgfSxcbiAgICBzaGFwZTogW1wiZWxsaXBzZVwiLCBcImJveFwiLCBcImNpcmNsZVwiLCBcImRhdGFiYXNlXCIsIFwiZGlhbW9uZFwiLCBcImRvdFwiLCBcInNxdWFyZVwiLCBcInN0YXJcIiwgXCJ0ZXh0XCIsIFwidHJpYW5nbGVcIiwgXCJ0cmlhbmdsZURvd25cIiwgXCJoZXhhZ29uXCJdLFxuICAgIHNoYXBlUHJvcGVydGllczoge1xuICAgICAgYm9yZGVyRGFzaGVzOiBmYWxzZSxcbiAgICAgIGJvcmRlclJhZGl1czogWzYsIDAsIDIwLCAxXSxcbiAgICAgIGludGVycG9sYXRpb246IHRydWUsXG4gICAgICB1c2VJbWFnZVNpemU6IGZhbHNlXG4gICAgfSxcbiAgICBzaXplOiBbMjUsIDAsIDIwMCwgMV1cbiAgfSxcbiAgZWRnZXM6IHtcbiAgICBhcnJvd3M6IHtcbiAgICAgIHRvOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBzY2FsZUZhY3RvcjogWzEsIDAsIDMsIDAuMDVdLFxuICAgICAgICB0eXBlOiBcImFycm93XCJcbiAgICAgIH0sXG4gICAgICBtaWRkbGU6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHNjYWxlRmFjdG9yOiBbMSwgMCwgMywgMC4wNV0sXG4gICAgICAgIHR5cGU6IFwiYXJyb3dcIlxuICAgICAgfSxcbiAgICAgIGZyb206IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHNjYWxlRmFjdG9yOiBbMSwgMCwgMywgMC4wNV0sXG4gICAgICAgIHR5cGU6IFwiYXJyb3dcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZW5kUG9pbnRPZmZzZXQ6IHtcbiAgICAgIGZyb206IFswLCAtMTAsIDEwLCAxXSxcbiAgICAgIHRvOiBbMCwgLTEwLCAxMCwgMV1cbiAgICB9LFxuICAgIGFycm93U3RyaWtldGhyb3VnaDogdHJ1ZSxcbiAgICBjb2xvcjoge1xuICAgICAgY29sb3I6IFtcImNvbG9yXCIsIFwiIzg0ODQ4NFwiXSxcbiAgICAgIGhpZ2hsaWdodDogW1wiY29sb3JcIiwgXCIjODQ4NDg0XCJdLFxuICAgICAgaG92ZXI6IFtcImNvbG9yXCIsIFwiIzg0ODQ4NFwiXSxcbiAgICAgIGluaGVyaXQ6IFtcImZyb21cIiwgXCJ0b1wiLCBcImJvdGhcIiwgdHJ1ZSwgZmFsc2VdLFxuICAgICAgb3BhY2l0eTogWzEsIDAsIDEsIDAuMDVdXG4gICAgfSxcbiAgICBkYXNoZXM6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIGNvbG9yOiBbXCJjb2xvclwiLCBcIiMzNDM0MzRcIl0sXG4gICAgICBzaXplOiBbMTQsIDAsIDEwMCwgMV0sXG4gICAgICBmYWNlOiBbXCJhcmlhbFwiLCBcInZlcmRhbmFcIiwgXCJ0YWhvbWFcIl0sXG4gICAgICBiYWNrZ3JvdW5kOiBbXCJjb2xvclwiLCBcIm5vbmVcIl0sXG4gICAgICBzdHJva2VXaWR0aDogWzIsIDAsIDUwLCAxXSxcbiAgICAgIHN0cm9rZUNvbG9yOiBbXCJjb2xvclwiLCBcIiNmZmZmZmZcIl0sXG4gICAgICBhbGlnbjogW1wiaG9yaXpvbnRhbFwiLCBcInRvcFwiLCBcIm1pZGRsZVwiLCBcImJvdHRvbVwiXVxuICAgIH0sXG4gICAgaGlkZGVuOiBmYWxzZSxcbiAgICBob3ZlcldpZHRoOiBbMS41LCAwLCA1LCAwLjFdLFxuICAgIGxhYmVsSGlnaGxpZ2h0Qm9sZDogdHJ1ZSxcbiAgICBwaHlzaWNzOiB0cnVlLFxuICAgIHNjYWxpbmc6IHtcbiAgICAgIG1pbjogWzEsIDAsIDEwMCwgMV0sXG4gICAgICBtYXg6IFsxNSwgMCwgMTAwLCAxXSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgIG1pbjogWzE0LCAwLCAyMDAsIDFdLFxuICAgICAgICBtYXg6IFszMCwgMCwgMjAwLCAxXSxcbiAgICAgICAgbWF4VmlzaWJsZTogWzMwLCAwLCAyMDAsIDFdLFxuICAgICAgICBkcmF3VGhyZXNob2xkOiBbNSwgMCwgMjAsIDFdXG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3Rpb25XaWR0aDogWzEuNSwgMCwgNSwgMC4xXSxcbiAgICBzZWxmUmVmZXJlbmNlU2l6ZTogWzIwLCAwLCAyMDAsIDFdLFxuICAgIHNlbGZSZWZlcmVuY2U6IHtcbiAgICAgIHNpemU6IFsyMCwgMCwgMjAwLCAxXSxcbiAgICAgIGFuZ2xlOiBbTWF0aC5QSSAvIDIsIC02ICogTWF0aC5QSSwgNiAqIE1hdGguUEksIE1hdGguUEkgLyA4XSxcbiAgICAgIHJlbmRlckJlaGluZFRoZU5vZGU6IHRydWVcbiAgICB9LFxuICAgIHNoYWRvdzoge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICBjb2xvcjogXCJyZ2JhKDAsMCwwLDAuNSlcIixcbiAgICAgIHNpemU6IFsxMCwgMCwgMjAsIDFdLFxuICAgICAgeDogWzUsIC0zMCwgMzAsIDFdLFxuICAgICAgeTogWzUsIC0zMCwgMzAsIDFdXG4gICAgfSxcbiAgICBzbW9vdGg6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICB0eXBlOiBbXCJkeW5hbWljXCIsIFwiY29udGludW91c1wiLCBcImRpc2NyZXRlXCIsIFwiZGlhZ29uYWxDcm9zc1wiLCBcInN0cmFpZ2h0Q3Jvc3NcIiwgXCJob3Jpem9udGFsXCIsIFwidmVydGljYWxcIiwgXCJjdXJ2ZWRDV1wiLCBcImN1cnZlZENDV1wiLCBcImN1YmljQmV6aWVyXCJdLFxuICAgICAgZm9yY2VEaXJlY3Rpb246IFtcImhvcml6b250YWxcIiwgXCJ2ZXJ0aWNhbFwiLCBcIm5vbmVcIl0sXG4gICAgICByb3VuZG5lc3M6IFswLjUsIDAsIDEsIDAuMDVdXG4gICAgfSxcbiAgICB3aWR0aDogWzEsIDAsIDMwLCAxXVxuICB9LFxuICBsYXlvdXQ6IHtcbiAgICAvL3JhbmRvbVNlZWQ6IFswLCAwLCA1MDAsIDFdLFxuICAgIC8vaW1wcm92ZWRMYXlvdXQ6IHRydWUsXG4gICAgaGllcmFyY2hpY2FsOiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGxldmVsU2VwYXJhdGlvbjogWzE1MCwgMjAsIDUwMCwgNV0sXG4gICAgICBub2RlU3BhY2luZzogWzEwMCwgMjAsIDUwMCwgNV0sXG4gICAgICB0cmVlU3BhY2luZzogWzIwMCwgMjAsIDUwMCwgNV0sXG4gICAgICBibG9ja1NoaWZ0aW5nOiB0cnVlLFxuICAgICAgZWRnZU1pbmltaXphdGlvbjogdHJ1ZSxcbiAgICAgIHBhcmVudENlbnRyYWxpemF0aW9uOiB0cnVlLFxuICAgICAgZGlyZWN0aW9uOiBbXCJVRFwiLCBcIkRVXCIsIFwiTFJcIiwgXCJSTFwiXSxcbiAgICAgIHNvcnRNZXRob2Q6IFtcImh1YnNpemVcIiwgXCJkaXJlY3RlZFwiXSxcbiAgICAgIHNoYWtlVG93YXJkczogW1wibGVhdmVzXCIsIFwicm9vdHNcIl0gLy8gbGVhdmVzLCByb290c1xuICAgIH1cbiAgfSxcblxuICBpbnRlcmFjdGlvbjoge1xuICAgIGRyYWdOb2RlczogdHJ1ZSxcbiAgICBkcmFnVmlldzogdHJ1ZSxcbiAgICBoaWRlRWRnZXNPbkRyYWc6IGZhbHNlLFxuICAgIGhpZGVFZGdlc09uWm9vbTogZmFsc2UsXG4gICAgaGlkZU5vZGVzT25EcmFnOiBmYWxzZSxcbiAgICBob3ZlcjogZmFsc2UsXG4gICAga2V5Ym9hcmQ6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgc3BlZWQ6IHtcbiAgICAgICAgeDogWzEwLCAwLCA0MCwgMV0sXG4gICAgICAgIHk6IFsxMCwgMCwgNDAsIDFdLFxuICAgICAgICB6b29tOiBbMC4wMiwgMCwgMC4xLCAwLjAwNV1cbiAgICAgIH0sXG4gICAgICBiaW5kVG9XaW5kb3c6IHRydWUsXG4gICAgICBhdXRvRm9jdXM6IHRydWVcbiAgICB9LFxuICAgIG11bHRpc2VsZWN0OiBmYWxzZSxcbiAgICBuYXZpZ2F0aW9uQnV0dG9uczogZmFsc2UsXG4gICAgc2VsZWN0YWJsZTogdHJ1ZSxcbiAgICBzZWxlY3RDb25uZWN0ZWRFZGdlczogdHJ1ZSxcbiAgICBob3ZlckNvbm5lY3RlZEVkZ2VzOiB0cnVlLFxuICAgIHRvb2x0aXBEZWxheTogWzMwMCwgMCwgMTAwMCwgMjVdLFxuICAgIHpvb21WaWV3OiB0cnVlLFxuICAgIHpvb21TcGVlZDogWzEsIDAuMSwgMiwgMC4xXVxuICB9LFxuICBtYW5pcHVsYXRpb246IHtcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICBpbml0aWFsbHlBY3RpdmU6IGZhbHNlXG4gIH0sXG4gIHBoeXNpY3M6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGJhcm5lc0h1dDoge1xuICAgICAgdGhldGE6IFswLjUsIDAuMSwgMSwgMC4wNV0sXG4gICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IFstMjAwMCwgLTMwMDAwLCAwLCA1MF0sXG4gICAgICBjZW50cmFsR3Jhdml0eTogWzAuMywgMCwgMTAsIDAuMDVdLFxuICAgICAgc3ByaW5nTGVuZ3RoOiBbOTUsIDAsIDUwMCwgNV0sXG4gICAgICBzcHJpbmdDb25zdGFudDogWzAuMDQsIDAsIDEuMiwgMC4wMDVdLFxuICAgICAgZGFtcGluZzogWzAuMDksIDAsIDEsIDAuMDFdLFxuICAgICAgYXZvaWRPdmVybGFwOiBbMCwgMCwgMSwgMC4wMV1cbiAgICB9LFxuICAgIGZvcmNlQXRsYXMyQmFzZWQ6IHtcbiAgICAgIHRoZXRhOiBbMC41LCAwLjEsIDEsIDAuMDVdLFxuICAgICAgZ3Jhdml0YXRpb25hbENvbnN0YW50OiBbLTUwLCAtNTAwLCAwLCAxXSxcbiAgICAgIGNlbnRyYWxHcmF2aXR5OiBbMC4wMSwgMCwgMSwgMC4wMDVdLFxuICAgICAgc3ByaW5nTGVuZ3RoOiBbOTUsIDAsIDUwMCwgNV0sXG4gICAgICBzcHJpbmdDb25zdGFudDogWzAuMDgsIDAsIDEuMiwgMC4wMDVdLFxuICAgICAgZGFtcGluZzogWzAuNCwgMCwgMSwgMC4wMV0sXG4gICAgICBhdm9pZE92ZXJsYXA6IFswLCAwLCAxLCAwLjAxXVxuICAgIH0sXG4gICAgcmVwdWxzaW9uOiB7XG4gICAgICBjZW50cmFsR3Jhdml0eTogWzAuMiwgMCwgMTAsIDAuMDVdLFxuICAgICAgc3ByaW5nTGVuZ3RoOiBbMjAwLCAwLCA1MDAsIDVdLFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IFswLjA1LCAwLCAxLjIsIDAuMDA1XSxcbiAgICAgIG5vZGVEaXN0YW5jZTogWzEwMCwgMCwgNTAwLCA1XSxcbiAgICAgIGRhbXBpbmc6IFswLjA5LCAwLCAxLCAwLjAxXVxuICAgIH0sXG4gICAgaGllcmFyY2hpY2FsUmVwdWxzaW9uOiB7XG4gICAgICBjZW50cmFsR3Jhdml0eTogWzAuMiwgMCwgMTAsIDAuMDVdLFxuICAgICAgc3ByaW5nTGVuZ3RoOiBbMTAwLCAwLCA1MDAsIDVdLFxuICAgICAgc3ByaW5nQ29uc3RhbnQ6IFswLjAxLCAwLCAxLjIsIDAuMDA1XSxcbiAgICAgIG5vZGVEaXN0YW5jZTogWzEyMCwgMCwgNTAwLCA1XSxcbiAgICAgIGRhbXBpbmc6IFswLjA5LCAwLCAxLCAwLjAxXSxcbiAgICAgIGF2b2lkT3ZlcmxhcDogWzAsIDAsIDEsIDAuMDFdXG4gICAgfSxcbiAgICBtYXhWZWxvY2l0eTogWzUwLCAwLCAxNTAsIDFdLFxuICAgIG1pblZlbG9jaXR5OiBbMC4xLCAwLjAxLCAwLjUsIDAuMDFdLFxuICAgIHNvbHZlcjogW1wiYmFybmVzSHV0XCIsIFwiZm9yY2VBdGxhczJCYXNlZFwiLCBcInJlcHVsc2lvblwiLCBcImhpZXJhcmNoaWNhbFJlcHVsc2lvblwiXSxcbiAgICB0aW1lc3RlcDogWzAuNSwgMC4wMSwgMSwgMC4wMV0sXG4gICAgd2luZDoge1xuICAgICAgeDogWzAsIC0xMCwgMTAsIDAuMV0sXG4gICAgICB5OiBbMCwgLTEwLCAxMCwgMC4xXVxuICAgIH1cbiAgICAvL2FkYXB0aXZlVGltZXN0ZXA6IHRydWVcbiAgfVxufTtcblxudmFyIGNvbmZpZ3VyYXRvckhpZGVPcHRpb24gPSBmdW5jdGlvbiBjb25maWd1cmF0b3JIaWRlT3B0aW9uKHBhcmVudFBhdGgsIG9wdGlvbk5hbWUsIG9wdGlvbnMpIHtcbiAgdmFyIF9jb250ZXh0O1xuICBpZiAoX2luY2x1ZGVzSW5zdGFuY2VQcm9wZXJ0eShwYXJlbnRQYXRoKS5jYWxsKHBhcmVudFBhdGgsIFwicGh5c2ljc1wiKSAmJiBfaW5jbHVkZXNJbnN0YW5jZVByb3BlcnR5KF9jb250ZXh0ID0gY29uZmlndXJlT3B0aW9ucy5waHlzaWNzLnNvbHZlcikuY2FsbChfY29udGV4dCwgb3B0aW9uTmFtZSkgJiYgb3B0aW9ucy5waHlzaWNzLnNvbHZlciAhPT0gb3B0aW9uTmFtZSAmJiBvcHRpb25OYW1lICE9PSBcIndpbmRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBvcHRpb25zID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdGFsbE9wdGlvbnM6IGFsbE9wdGlvbnMsXG5cdGNvbmZpZ3VyYXRvckhpZGVPcHRpb246IGNvbmZpZ3VyYXRvckhpZGVPcHRpb24sXG5cdGNvbmZpZ3VyZU9wdGlvbnM6IGNvbmZpZ3VyZU9wdGlvbnNcbn0pO1xuXG4vKipcbiAqICBUaGUgRmxveWTigJNXYXJzaGFsbCBhbGdvcml0aG0gaXMgYW4gYWxnb3JpdGhtIGZvciBmaW5kaW5nIHNob3J0ZXN0IHBhdGhzIGluXG4gKiAgYSB3ZWlnaHRlZCBncmFwaCB3aXRoIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIGVkZ2Ugd2VpZ2h0cyAoYnV0IHdpdGggbm8gbmVnYXRpdmVcbiAqICBjeWNsZXMpLiAtIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zsb3lk4oCTV2Fyc2hhbGxfYWxnb3JpdGhtXG4gKi9cbnZhciBGbG95ZFdhcnNoYWxsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGZ1bmN0aW9uIEZsb3lkV2Fyc2hhbGwoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZsb3lkV2Fyc2hhbGwpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBib2R5XG4gICAqIEBwYXJhbSB7QXJyYXkuPE5vZGU+fSBub2Rlc0FycmF5XG4gICAqIEBwYXJhbSB7QXJyYXkuPEVkZ2U+fSBlZGdlc0FycmF5XG4gICAqIEByZXR1cm5zIHt7fX1cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhGbG95ZFdhcnNoYWxsLCBbe1xuICAgIGtleTogXCJnZXREaXN0YW5jZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGlzdGFuY2VzKGJvZHksIG5vZGVzQXJyYXksIGVkZ2VzQXJyYXkpIHtcbiAgICAgIHZhciBEX21hdHJpeCA9IHt9O1xuICAgICAgdmFyIGVkZ2VzID0gYm9keS5lZGdlcztcblxuICAgICAgLy8gcHJlcGFyZSBtYXRyaXggd2l0aCBsYXJnZSBudW1iZXJzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc0FycmF5W2ldO1xuICAgICAgICB2YXIgY2VsbCA9IHt9O1xuICAgICAgICBEX21hdHJpeFtub2RlXSA9IGNlbGw7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXNBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNlbGxbbm9kZXNBcnJheVtqXV0gPSBpID09IGogPyAwIDogMWU5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHB1dCB0aGUgd2VpZ2h0cyBmb3IgdGhlIGVkZ2VzIGluLiBUaGlzIGFzc3VtZXMgdW5pZGlyZWN0aW9uYWxpdHkuXG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZWRnZXNBcnJheS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tlZGdlc0FycmF5W19pXV07XG4gICAgICAgIC8vIGVkZ2UgaGFzIHRvIGJlIGNvbm5lY3RlZCBpZiBpdCBjb3VudHMgdG8gdGhlIGRpc3RhbmNlcy4gSWYgaXQgaXMgY29ubmVjdGVkIHRvIGlubmVyIGNsdXN0ZXJzIGl0IHdpbGwgY3Jhc2ggc28gd2UgYWxzbyBjaGVjayBpZiBpdCBpcyBpbiB0aGUgRF9tYXRyaXhcbiAgICAgICAgaWYgKGVkZ2UuY29ubmVjdGVkID09PSB0cnVlICYmIERfbWF0cml4W2VkZ2UuZnJvbUlkXSAhPT0gdW5kZWZpbmVkICYmIERfbWF0cml4W2VkZ2UudG9JZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIERfbWF0cml4W2VkZ2UuZnJvbUlkXVtlZGdlLnRvSWRdID0gMTtcbiAgICAgICAgICBEX21hdHJpeFtlZGdlLnRvSWRdW2VkZ2UuZnJvbUlkXSA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBub2RlQ291bnQgPSBub2Rlc0FycmF5Lmxlbmd0aDtcblxuICAgICAgLy8gQWRhcHRlZCBGbG95ZFdhcnNoYWxsIGJhc2VkIG9uIHVuaWRpcmVjdGlvbmFsaXR5IHRvIGdyZWF0bHkgcmVkdWNlIGNvbXBsZXhpdHkuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IG5vZGVDb3VudDsgaysrKSB7XG4gICAgICAgIHZhciBrbm9kZSA9IG5vZGVzQXJyYXlba107XG4gICAgICAgIHZhciBrY29sbSA9IERfbWF0cml4W2tub2RlXTtcbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbm9kZUNvdW50IC0gMTsgX2kyKyspIHtcbiAgICAgICAgICB2YXIgaW5vZGUgPSBub2Rlc0FycmF5W19pMl07XG4gICAgICAgICAgdmFyIGljb2xtID0gRF9tYXRyaXhbaW5vZGVdO1xuICAgICAgICAgIGZvciAodmFyIF9qID0gX2kyICsgMTsgX2ogPCBub2RlQ291bnQ7IF9qKyspIHtcbiAgICAgICAgICAgIHZhciBqbm9kZSA9IG5vZGVzQXJyYXlbX2pdO1xuICAgICAgICAgICAgdmFyIGpjb2xtID0gRF9tYXRyaXhbam5vZGVdO1xuICAgICAgICAgICAgdmFyIHZhbCA9IE1hdGgubWluKGljb2xtW2pub2RlXSwgaWNvbG1ba25vZGVdICsga2NvbG1bam5vZGVdKTtcbiAgICAgICAgICAgIGljb2xtW2pub2RlXSA9IHZhbDtcbiAgICAgICAgICAgIGpjb2xtW2lub2RlXSA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBEX21hdHJpeDtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEZsb3lkV2Fyc2hhbGw7XG59KCk7XG5cbi8qKlxuICogS2FtYWRhS2F3YWkgcG9zaXRpb25zIHRoZSBub2RlcyBpbml0aWFsbHkgYmFzZWQgb25cbiAqXG4gKiBcIkFOIEFMR09SSVRITSBGT1IgRFJBV0lORyBHRU5FUkFMIFVORElSRUNURUQgR1JBUEhTXCJcbiAqIC0tIFRvbWloaXNhIEtBTUFEQSBhbmQgU2F0b3J1IEtBV0FJIGluIDE5ODlcbiAqXG4gKiBQb3NzaWJsZSBvcHRpbWl6YXRpb25zIGluIHRoZSBkaXN0YW5jZSBjYWxjdWxhdGlvbiBjYW4gYmUgaW1wbGVtZW50ZWQuXG4gKi9cbnZhciBLYW1hZGFLYXdhaSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gYm9keVxuICAgKiBAcGFyYW0ge251bWJlcn0gZWRnZUxlbmd0aFxuICAgKiBAcGFyYW0ge251bWJlcn0gZWRnZVN0cmVuZ3RoXG4gICAqL1xuICBmdW5jdGlvbiBLYW1hZGFLYXdhaShib2R5LCBlZGdlTGVuZ3RoLCBlZGdlU3RyZW5ndGgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgS2FtYWRhS2F3YWkpO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5zcHJpbmdMZW5ndGggPSBlZGdlTGVuZ3RoO1xuICAgIHRoaXMuc3ByaW5nQ29uc3RhbnQgPSBlZGdlU3RyZW5ndGg7XG4gICAgdGhpcy5kaXN0YW5jZVNvbHZlciA9IG5ldyBGbG95ZFdhcnNoYWxsKCk7XG4gIH1cblxuICAvKipcbiAgICogTm90IHN1cmUgaWYgbmVlZGVkIGJ1dCBjYW4gYmUgdXNlZCB0byB1cGRhdGUgdGhlIHNwcmluZyBsZW5ndGggYW5kIHNwcmluZyBjb25zdGFudFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKEthbWFkYUthd2FpLCBbe1xuICAgIGtleTogXCJzZXRPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3ByaW5nTGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5zcHJpbmdMZW5ndGggPSBvcHRpb25zLnNwcmluZ0xlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zcHJpbmdDb25zdGFudCkge1xuICAgICAgICAgIHRoaXMuc3ByaW5nQ29uc3RhbnQgPSBvcHRpb25zLnNwcmluZ0NvbnN0YW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gdGhlIHN5c3RlbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheS48Tm9kZT59IG5vZGVzQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5Ljx2aXMuRWRnZT59IGVkZ2VzQXJyYXlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpZ25vcmVDbHVzdGVycz1mYWxzZV1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzb2x2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzb2x2ZShub2Rlc0FycmF5LCBlZGdlc0FycmF5KSB7XG4gICAgICB2YXIgaWdub3JlQ2x1c3RlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgLy8gZ2V0IGRpc3RhbmNlIG1hdHJpeFxuICAgICAgdmFyIERfbWF0cml4ID0gdGhpcy5kaXN0YW5jZVNvbHZlci5nZXREaXN0YW5jZXModGhpcy5ib2R5LCBub2Rlc0FycmF5LCBlZGdlc0FycmF5KTsgLy8gZGlzdGFuY2UgbWF0cml4XG5cbiAgICAgIC8vIGdldCB0aGUgTCBNYXRyaXhcbiAgICAgIHRoaXMuX2NyZWF0ZUxfbWF0cml4KERfbWF0cml4KTtcblxuICAgICAgLy8gZ2V0IHRoZSBLIE1hdHJpeFxuICAgICAgdGhpcy5fY3JlYXRlS19tYXRyaXgoRF9tYXRyaXgpO1xuXG4gICAgICAvLyBpbml0aWFsIEUgTWF0cml4XG4gICAgICB0aGlzLl9jcmVhdGVFX21hdHJpeCgpO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgcG9zaXRpb25zXG4gICAgICB2YXIgdGhyZXNob2xkID0gMC4wMTtcbiAgICAgIHZhciBpbm5lclRocmVzaG9sZCA9IDE7XG4gICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICB2YXIgbWF4SXRlcmF0aW9ucyA9IE1hdGgubWF4KDEwMDAsIE1hdGgubWluKDEwICogdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLmxlbmd0aCwgNjAwMCkpO1xuICAgICAgdmFyIG1heElubmVySXRlcmF0aW9ucyA9IDU7XG4gICAgICB2YXIgbWF4RW5lcmd5ID0gMWU5O1xuICAgICAgdmFyIGhpZ2hFX25vZGVJZCA9IDAsXG4gICAgICAgIGRFX2R4ID0gMCxcbiAgICAgICAgZEVfZHkgPSAwLFxuICAgICAgICBkZWx0YV9tID0gMCxcbiAgICAgICAgc3ViSXRlcmF0aW9ucyA9IDA7XG4gICAgICB3aGlsZSAobWF4RW5lcmd5ID4gdGhyZXNob2xkICYmIGl0ZXJhdGlvbnMgPCBtYXhJdGVyYXRpb25zKSB7XG4gICAgICAgIGl0ZXJhdGlvbnMgKz0gMTtcbiAgICAgICAgdmFyIF90aGlzJF9nZXRIaWdoZXN0RW5lciA9IHRoaXMuX2dldEhpZ2hlc3RFbmVyZ3lOb2RlKGlnbm9yZUNsdXN0ZXJzKTtcbiAgICAgICAgdmFyIF90aGlzJF9nZXRIaWdoZXN0RW5lcjIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0SGlnaGVzdEVuZXIsIDQpO1xuICAgICAgICBoaWdoRV9ub2RlSWQgPSBfdGhpcyRfZ2V0SGlnaGVzdEVuZXIyWzBdO1xuICAgICAgICBtYXhFbmVyZ3kgPSBfdGhpcyRfZ2V0SGlnaGVzdEVuZXIyWzFdO1xuICAgICAgICBkRV9keCA9IF90aGlzJF9nZXRIaWdoZXN0RW5lcjJbMl07XG4gICAgICAgIGRFX2R5ID0gX3RoaXMkX2dldEhpZ2hlc3RFbmVyMlszXTtcbiAgICAgICAgZGVsdGFfbSA9IG1heEVuZXJneTtcbiAgICAgICAgc3ViSXRlcmF0aW9ucyA9IDA7XG4gICAgICAgIHdoaWxlIChkZWx0YV9tID4gaW5uZXJUaHJlc2hvbGQgJiYgc3ViSXRlcmF0aW9ucyA8IG1heElubmVySXRlcmF0aW9ucykge1xuICAgICAgICAgIHN1Ykl0ZXJhdGlvbnMgKz0gMTtcbiAgICAgICAgICB0aGlzLl9tb3ZlTm9kZShoaWdoRV9ub2RlSWQsIGRFX2R4LCBkRV9keSk7XG4gICAgICAgICAgdmFyIF90aGlzJF9nZXRFbmVyZ3kgPSB0aGlzLl9nZXRFbmVyZ3koaGlnaEVfbm9kZUlkKTtcbiAgICAgICAgICB2YXIgX3RoaXMkX2dldEVuZXJneTIgPSBfc2xpY2VkVG9BcnJheShfdGhpcyRfZ2V0RW5lcmd5LCAzKTtcbiAgICAgICAgICBkZWx0YV9tID0gX3RoaXMkX2dldEVuZXJneTJbMF07XG4gICAgICAgICAgZEVfZHggPSBfdGhpcyRfZ2V0RW5lcmd5MlsxXTtcbiAgICAgICAgICBkRV9keSA9IF90aGlzJF9nZXRFbmVyZ3kyWzJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBub2RlIHdpdGggdGhlIGhpZ2hlc3QgZW5lcmd5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlnbm9yZUNsdXN0ZXJzXG4gICAgICogQHJldHVybnMge251bWJlcltdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldEhpZ2hlc3RFbmVyZ3lOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRIaWdoZXN0RW5lcmd5Tm9kZShpZ25vcmVDbHVzdGVycykge1xuICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgbWF4RW5lcmd5ID0gMDtcbiAgICAgIHZhciBtYXhFbmVyZ3lOb2RlSWQgPSBub2Rlc0FycmF5WzBdO1xuICAgICAgdmFyIGRFX2R4X21heCA9IDAsXG4gICAgICAgIGRFX2R5X21heCA9IDA7XG4gICAgICBmb3IgKHZhciBub2RlSWR4ID0gMDsgbm9kZUlkeCA8IG5vZGVzQXJyYXkubGVuZ3RoOyBub2RlSWR4KyspIHtcbiAgICAgICAgdmFyIG0gPSBub2Rlc0FycmF5W25vZGVJZHhdO1xuICAgICAgICAvLyBieSBub3QgZXZhbHVhdGluZyBub2RlcyB3aXRoIHByZWRlZmluZWQgcG9zaXRpb25zIHdlIHNob3VsZCBvbmx5IG1vdmUgbm9kZXMgdGhhdCBoYXZlIG5vIHBvc2l0aW9ucy5cbiAgICAgICAgaWYgKG5vZGVzW21dLnByZWRlZmluZWRQb3NpdGlvbiAhPT0gdHJ1ZSB8fCBub2Rlc1ttXS5pc0NsdXN0ZXIgPT09IHRydWUgJiYgaWdub3JlQ2x1c3RlcnMgPT09IHRydWUgfHwgbm9kZXNbbV0ub3B0aW9ucy5maXhlZC54ICE9PSB0cnVlIHx8IG5vZGVzW21dLm9wdGlvbnMuZml4ZWQueSAhPT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciBfdGhpcyRfZ2V0RW5lcmd5MyA9IHRoaXMuX2dldEVuZXJneShtKSxcbiAgICAgICAgICAgIF90aGlzJF9nZXRFbmVyZ3k0ID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkX2dldEVuZXJneTMsIDMpLFxuICAgICAgICAgICAgZGVsdGFfbSA9IF90aGlzJF9nZXRFbmVyZ3k0WzBdLFxuICAgICAgICAgICAgZEVfZHggPSBfdGhpcyRfZ2V0RW5lcmd5NFsxXSxcbiAgICAgICAgICAgIGRFX2R5ID0gX3RoaXMkX2dldEVuZXJneTRbMl07XG4gICAgICAgICAgaWYgKG1heEVuZXJneSA8IGRlbHRhX20pIHtcbiAgICAgICAgICAgIG1heEVuZXJneSA9IGRlbHRhX207XG4gICAgICAgICAgICBtYXhFbmVyZ3lOb2RlSWQgPSBtO1xuICAgICAgICAgICAgZEVfZHhfbWF4ID0gZEVfZHg7XG4gICAgICAgICAgICBkRV9keV9tYXggPSBkRV9keTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBbbWF4RW5lcmd5Tm9kZUlkLCBtYXhFbmVyZ3ksIGRFX2R4X21heCwgZEVfZHlfbWF4XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGUgdGhlIGVuZXJneSBvZiBhIHNpbmdsZSBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGUuaWR9IG1cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RW5lcmd5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRFbmVyZ3kobSkge1xuICAgICAgdmFyIF90aGlzJEVfc3VtcyRtID0gX3NsaWNlZFRvQXJyYXkodGhpcy5FX3N1bXNbbV0sIDIpLFxuICAgICAgICBkRV9keCA9IF90aGlzJEVfc3VtcyRtWzBdLFxuICAgICAgICBkRV9keSA9IF90aGlzJEVfc3VtcyRtWzFdO1xuICAgICAgdmFyIGRlbHRhX20gPSBNYXRoLnNxcnQoTWF0aC5wb3coZEVfZHgsIDIpICsgTWF0aC5wb3coZEVfZHksIDIpKTtcbiAgICAgIHJldHVybiBbZGVsdGFfbSwgZEVfZHgsIGRFX2R5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtb3ZlIHRoZSBub2RlIGJhc2VkIG9uIGl0J3MgZW5lcmd5XG4gICAgICogdGhlIGR4IGFuZCBkeSBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBsaW5lYXIgc3lzdGVtIHByb3Bvc2VkIGJ5IEthbWFkYSBhbmQgS2F3YWlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRFX2R4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRFX2R5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfbW92ZU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX21vdmVOb2RlKG0sIGRFX2R4LCBkRV9keSkge1xuICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgZDJFX2R4MiA9IDA7XG4gICAgICB2YXIgZDJFX2R4ZHkgPSAwO1xuICAgICAgdmFyIGQyRV9keTIgPSAwO1xuICAgICAgdmFyIHhfbSA9IG5vZGVzW21dLng7XG4gICAgICB2YXIgeV9tID0gbm9kZXNbbV0ueTtcbiAgICAgIHZhciBrbSA9IHRoaXMuS19tYXRyaXhbbV07XG4gICAgICB2YXIgbG0gPSB0aGlzLkxfbWF0cml4W21dO1xuICAgICAgZm9yICh2YXIgaUlkeCA9IDA7IGlJZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgaUlkeCsrKSB7XG4gICAgICAgIHZhciBpID0gbm9kZXNBcnJheVtpSWR4XTtcbiAgICAgICAgaWYgKGkgIT09IG0pIHtcbiAgICAgICAgICB2YXIgeF9pID0gbm9kZXNbaV0ueDtcbiAgICAgICAgICB2YXIgeV9pID0gbm9kZXNbaV0ueTtcbiAgICAgICAgICB2YXIga21hdCA9IGttW2ldO1xuICAgICAgICAgIHZhciBsbWF0ID0gbG1baV07XG4gICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gMS4wIC8gTWF0aC5wb3coTWF0aC5wb3coeF9tIC0geF9pLCAyKSArIE1hdGgucG93KHlfbSAtIHlfaSwgMiksIDEuNSk7XG4gICAgICAgICAgZDJFX2R4MiArPSBrbWF0ICogKDEgLSBsbWF0ICogTWF0aC5wb3coeV9tIC0geV9pLCAyKSAqIGRlbm9taW5hdG9yKTtcbiAgICAgICAgICBkMkVfZHhkeSArPSBrbWF0ICogKGxtYXQgKiAoeF9tIC0geF9pKSAqICh5X20gLSB5X2kpICogZGVub21pbmF0b3IpO1xuICAgICAgICAgIGQyRV9keTIgKz0ga21hdCAqICgxIC0gbG1hdCAqIE1hdGgucG93KHhfbSAtIHhfaSwgMikgKiBkZW5vbWluYXRvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG1ha2UgdGhlIHZhcmlhYmxlIG5hbWVzIGVhc2llciB0byBtYWtlIHRoZSBzb2x2aW5nIG9mIHRoZSBsaW5lYXIgc3lzdGVtIGVhc2llciB0byByZWFkXG4gICAgICB2YXIgQSA9IGQyRV9keDIsXG4gICAgICAgIEIgPSBkMkVfZHhkeSxcbiAgICAgICAgQyA9IGRFX2R4LFxuICAgICAgICBEID0gZDJFX2R5MixcbiAgICAgICAgRSA9IGRFX2R5O1xuXG4gICAgICAvLyBzb2x2ZSB0aGUgbGluZWFyIHN5c3RlbSBmb3IgZHggYW5kIGR5XG4gICAgICB2YXIgZHkgPSAoQyAvIEEgKyBFIC8gQikgLyAoQiAvIEEgLSBEIC8gQik7XG4gICAgICB2YXIgZHggPSAtKEIgKiBkeSArIEMpIC8gQTtcblxuICAgICAgLy8gbW92ZSB0aGUgbm9kZVxuICAgICAgbm9kZXNbbV0ueCArPSBkeDtcbiAgICAgIG5vZGVzW21dLnkgKz0gZHk7XG5cbiAgICAgIC8vIFJlY2FsY3VsYXRlIEVfbWF0cml4IChzaG91bGQgYmUgaW5jcmVtZW50YWwpXG4gICAgICB0aGlzLl91cGRhdGVFX21hdHJpeChtKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIEwgbWF0cml4OiBlZGdlIGxlbmd0aCB0aW1lcyBzaG9ydGVzdCBwYXRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gRF9tYXRyaXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVMX21hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlTF9tYXRyaXgoRF9tYXRyaXgpIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIGVkZ2VMZW5ndGggPSB0aGlzLnNwcmluZ0xlbmd0aDtcbiAgICAgIHRoaXMuTF9tYXRyaXggPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLkxfbWF0cml4W25vZGVzQXJyYXlbaV1dID0ge307XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXNBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRoaXMuTF9tYXRyaXhbbm9kZXNBcnJheVtpXV1bbm9kZXNBcnJheVtqXV0gPSBlZGdlTGVuZ3RoICogRF9tYXRyaXhbbm9kZXNBcnJheVtpXV1bbm9kZXNBcnJheVtqXV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgdGhlIEsgbWF0cml4OiBzcHJpbmcgY29uc3RhbnRzIHRpbWVzIHNob3J0ZXN0IHBhdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBEX21hdHJpeFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUtfbWF0cml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVLX21hdHJpeChEX21hdHJpeCkge1xuICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgZWRnZVN0cmVuZ3RoID0gdGhpcy5zcHJpbmdDb25zdGFudDtcbiAgICAgIHRoaXMuS19tYXRyaXggPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLktfbWF0cml4W25vZGVzQXJyYXlbaV1dID0ge307XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXNBcnJheS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRoaXMuS19tYXRyaXhbbm9kZXNBcnJheVtpXV1bbm9kZXNBcnJheVtqXV0gPSBlZGdlU3RyZW5ndGggKiBNYXRoLnBvdyhEX21hdHJpeFtub2Rlc0FycmF5W2ldXVtub2Rlc0FycmF5W2pdXSwgLTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIENyZWF0ZSBtYXRyaXggd2l0aCBhbGwgZW5lcmdpZXMgYmV0d2VlbiBub2Rlc1xuICAgICAqXG4gICAgICogIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZUVfbWF0cml4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVFX21hdHJpeCgpIHtcbiAgICAgIHZhciBub2Rlc0FycmF5ID0gdGhpcy5ib2R5Lm5vZGVJbmRpY2VzO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ib2R5Lm5vZGVzO1xuICAgICAgdGhpcy5FX21hdHJpeCA9IHt9O1xuICAgICAgdGhpcy5FX3N1bXMgPSB7fTtcbiAgICAgIGZvciAodmFyIG1JZHggPSAwOyBtSWR4IDwgbm9kZXNBcnJheS5sZW5ndGg7IG1JZHgrKykge1xuICAgICAgICB0aGlzLkVfbWF0cml4W25vZGVzQXJyYXlbbUlkeF1dID0gW107XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfbUlkeCA9IDA7IF9tSWR4IDwgbm9kZXNBcnJheS5sZW5ndGg7IF9tSWR4KyspIHtcbiAgICAgICAgdmFyIG0gPSBub2Rlc0FycmF5W19tSWR4XTtcbiAgICAgICAgdmFyIHhfbSA9IG5vZGVzW21dLng7XG4gICAgICAgIHZhciB5X20gPSBub2Rlc1ttXS55O1xuICAgICAgICB2YXIgZEVfZHggPSAwO1xuICAgICAgICB2YXIgZEVfZHkgPSAwO1xuICAgICAgICBmb3IgKHZhciBpSWR4ID0gX21JZHg7IGlJZHggPCBub2Rlc0FycmF5Lmxlbmd0aDsgaUlkeCsrKSB7XG4gICAgICAgICAgdmFyIGkgPSBub2Rlc0FycmF5W2lJZHhdO1xuICAgICAgICAgIGlmIChpICE9PSBtKSB7XG4gICAgICAgICAgICB2YXIgeF9pID0gbm9kZXNbaV0ueDtcbiAgICAgICAgICAgIHZhciB5X2kgPSBub2Rlc1tpXS55O1xuICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gMS4wIC8gTWF0aC5zcXJ0KE1hdGgucG93KHhfbSAtIHhfaSwgMikgKyBNYXRoLnBvdyh5X20gLSB5X2ksIDIpKTtcbiAgICAgICAgICAgIHRoaXMuRV9tYXRyaXhbbV1baUlkeF0gPSBbdGhpcy5LX21hdHJpeFttXVtpXSAqICh4X20gLSB4X2kgLSB0aGlzLkxfbWF0cml4W21dW2ldICogKHhfbSAtIHhfaSkgKiBkZW5vbWluYXRvciksIHRoaXMuS19tYXRyaXhbbV1baV0gKiAoeV9tIC0geV9pIC0gdGhpcy5MX21hdHJpeFttXVtpXSAqICh5X20gLSB5X2kpICogZGVub21pbmF0b3IpXTtcbiAgICAgICAgICAgIHRoaXMuRV9tYXRyaXhbaV1bX21JZHhdID0gdGhpcy5FX21hdHJpeFttXVtpSWR4XTtcbiAgICAgICAgICAgIGRFX2R4ICs9IHRoaXMuRV9tYXRyaXhbbV1baUlkeF1bMF07XG4gICAgICAgICAgICBkRV9keSArPSB0aGlzLkVfbWF0cml4W21dW2lJZHhdWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL1N0b3JlIHN1bVxuICAgICAgICB0aGlzLkVfc3Vtc1ttXSA9IFtkRV9keCwgZEVfZHldO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBtZXRob2QsIGp1c3QgZG9pbmcgc2luZ2xlIGNvbHVtbiAocm93cyBhcmUgYXV0by11cGRhdGVkKSAodXBkYXRlIGFsbCBzdW1zKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVFX21hdHJpeFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlRV9tYXRyaXgobSkge1xuICAgICAgdmFyIG5vZGVzQXJyYXkgPSB0aGlzLmJvZHkubm9kZUluZGljZXM7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gICAgICB2YXIgY29sbSA9IHRoaXMuRV9tYXRyaXhbbV07XG4gICAgICB2YXIga2NvbG0gPSB0aGlzLktfbWF0cml4W21dO1xuICAgICAgdmFyIGxjb2xtID0gdGhpcy5MX21hdHJpeFttXTtcbiAgICAgIHZhciB4X20gPSBub2Rlc1ttXS54O1xuICAgICAgdmFyIHlfbSA9IG5vZGVzW21dLnk7XG4gICAgICB2YXIgZEVfZHggPSAwO1xuICAgICAgdmFyIGRFX2R5ID0gMDtcbiAgICAgIGZvciAodmFyIGlJZHggPSAwOyBpSWR4IDwgbm9kZXNBcnJheS5sZW5ndGg7IGlJZHgrKykge1xuICAgICAgICB2YXIgaSA9IG5vZGVzQXJyYXlbaUlkeF07XG4gICAgICAgIGlmIChpICE9PSBtKSB7XG4gICAgICAgICAgLy9LZWVwIG9sZCBlbmVyZ3kgdmFsdWUgZm9yIHN1bSBtb2RpZmljYXRpb24gYmVsb3dcbiAgICAgICAgICB2YXIgY2VsbCA9IGNvbG1baUlkeF07XG4gICAgICAgICAgdmFyIG9sZER4ID0gY2VsbFswXTtcbiAgICAgICAgICB2YXIgb2xkRHkgPSBjZWxsWzFdO1xuXG4gICAgICAgICAgLy9DYWxjIG5ldyBlbmVyZ3k6XG4gICAgICAgICAgdmFyIHhfaSA9IG5vZGVzW2ldLng7XG4gICAgICAgICAgdmFyIHlfaSA9IG5vZGVzW2ldLnk7XG4gICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gMS4wIC8gTWF0aC5zcXJ0KE1hdGgucG93KHhfbSAtIHhfaSwgMikgKyBNYXRoLnBvdyh5X20gLSB5X2ksIDIpKTtcbiAgICAgICAgICB2YXIgZHggPSBrY29sbVtpXSAqICh4X20gLSB4X2kgLSBsY29sbVtpXSAqICh4X20gLSB4X2kpICogZGVub21pbmF0b3IpO1xuICAgICAgICAgIHZhciBkeSA9IGtjb2xtW2ldICogKHlfbSAtIHlfaSAtIGxjb2xtW2ldICogKHlfbSAtIHlfaSkgKiBkZW5vbWluYXRvcik7XG4gICAgICAgICAgY29sbVtpSWR4XSA9IFtkeCwgZHldO1xuICAgICAgICAgIGRFX2R4ICs9IGR4O1xuICAgICAgICAgIGRFX2R5ICs9IGR5O1xuXG4gICAgICAgICAgLy9hZGQgbmV3IGVuZXJneSB0byBzdW0gb2YgZWFjaCBjb2x1bW5cbiAgICAgICAgICB2YXIgc3VtID0gdGhpcy5FX3N1bXNbaV07XG4gICAgICAgICAgc3VtWzBdICs9IGR4IC0gb2xkRHg7XG4gICAgICAgICAgc3VtWzFdICs9IGR5IC0gb2xkRHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vU3RvcmUgc3VtIGF0IC0xIGluZGV4XG4gICAgICB0aGlzLkVfc3Vtc1ttXSA9IFtkRV9keCwgZEVfZHldO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gS2FtYWRhS2F3YWk7XG59KCk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV0d29yayB2aXN1YWxpemF0aW9uLCBkaXNwbGF5aW5nIG5vZGVzIGFuZCBlZGdlcy5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRhaW5lciAgIFRoZSBET00gZWxlbWVudCBpbiB3aGljaCB0aGUgTmV0d29yayB3aWxsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSBjcmVhdGVkLiBOb3JtYWxseSBhIGRpdiBlbGVtZW50LlxuICogQHBhcmFtIHtvYmplY3R9IGRhdGEgICAgICAgICBBbiBvYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheX0gbm9kZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0FycmF5fSBlZGdlc1xuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgICAgICBPcHRpb25zXG4gKiBAY2xhc3MgTmV0d29ya1xuICovXG5mdW5jdGlvbiBOZXR3b3JrKGNvbnRhaW5lciwgZGF0YSwgb3B0aW9ucykge1xuICB2YXIgX2NvbnRleHQsXG4gICAgX2NvbnRleHQyLFxuICAgIF9jb250ZXh0MyxcbiAgICBfY29udGV4dDQsXG4gICAgX3RoaXMgPSB0aGlzO1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTmV0d29yaykpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJDb25zdHJ1Y3RvciBtdXN0IGJlIGNhbGxlZCB3aXRoIHRoZSBuZXcgb3BlcmF0b3JcIik7XG4gIH1cblxuICAvLyBzZXQgY29uc3RhbnQgdmFsdWVzXG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgIGxvY2FsZTogXCJlblwiLFxuICAgIGxvY2FsZXM6IGxvY2FsZXMsXG4gICAgY2xpY2tUb1VzZTogZmFsc2VcbiAgfTtcbiAgX09iamVjdCRhc3NpZ24odGhpcy5vcHRpb25zLCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAvKipcbiAgICogQ29udGFpbmVycyBmb3Igbm9kZXMgYW5kIGVkZ2VzLlxuICAgKlxuICAgKiAnZWRnZXMnIGFuZCAnbm9kZXMnIGNvbnRhaW4gdGhlIGZ1bGwgZGVmaW5pdGlvbnMgb2YgYWxsIHRoZSBuZXR3b3JrIGVsZW1lbnRzLlxuICAgKiAnbm9kZUluZGljZXMnIGFuZCAnZWRnZUluZGljZXMnIGNvbnRhaW4gdGhlIGlkJ3Mgb2YgdGhlIGFjdGl2ZSBlbGVtZW50cy5cbiAgICpcbiAgICogVGhlIGRpc3RpbmN0aW9uIGlzIGltcG9ydGFudCwgYmVjYXVzZSBhIGRlZmluZWQgbm9kZSBuZWVkIG5vdCBiZSBhY3RpdmUsIGkuZS5cbiAgICogdmlzaWJsZSBvbiB0aGUgY2FudmFzLiBUaGlzIGhhcHBlbnMgaW4gcGFydGljdWxhciB3aGVuIGNsdXN0ZXJzIGFyZSBkZWZpbmVkLCBpblxuICAgKiB0aGF0IGNhc2UgdGhlcmUgd2lsbCBiZSBub2RlcyBhbmQgZWRnZXMgbm90IGRpc3BsYXllZC5cbiAgICogVGhlIGJvdHRvbSBsaW5lIGlzIHRoYXQgYWxsIGNvZGUgd2l0aCBhY3Rpb25zIHJlbGF0ZWQgdG8gdmlzaWJpbGl0eSwgKm11c3QqIHVzZVxuICAgKiAnbm9kZUluZGljZXMnIGFuZCAnZWRnZUluZGljZXMnLCBub3QgJ25vZGVzJyBhbmQgJ2VkZ2VzJyBkaXJlY3RseS5cbiAgICovXG4gIHRoaXMuYm9keSA9IHtcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAvLyBTZWUgY29tbWVudCBhYm92ZSBmb3IgZm9sbG93aW5nIGZpZWxkc1xuICAgIG5vZGVzOiB7fSxcbiAgICBub2RlSW5kaWNlczogW10sXG4gICAgZWRnZXM6IHt9LFxuICAgIGVkZ2VJbmRpY2VzOiBbXSxcbiAgICBlbWl0dGVyOiB7XG4gICAgICBvbjogX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQgPSB0aGlzLm9uKS5jYWxsKF9jb250ZXh0LCB0aGlzKSxcbiAgICAgIG9mZjogX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQyID0gdGhpcy5vZmYpLmNhbGwoX2NvbnRleHQyLCB0aGlzKSxcbiAgICAgIGVtaXQ6IF9iaW5kSW5zdGFuY2VQcm9wZXJ0eSQxKF9jb250ZXh0MyA9IHRoaXMuZW1pdCkuY2FsbChfY29udGV4dDMsIHRoaXMpLFxuICAgICAgb25jZTogX2JpbmRJbnN0YW5jZVByb3BlcnR5JDEoX2NvbnRleHQ0ID0gdGhpcy5vbmNlKS5jYWxsKF9jb250ZXh0NCwgdGhpcylcbiAgICB9LFxuICAgIGV2ZW50TGlzdGVuZXJzOiB7XG4gICAgICBvblRhcDogZnVuY3Rpb24gb25UYXAoKSB7fSxcbiAgICAgIG9uVG91Y2g6IGZ1bmN0aW9uIG9uVG91Y2goKSB7fSxcbiAgICAgIG9uRG91YmxlVGFwOiBmdW5jdGlvbiBvbkRvdWJsZVRhcCgpIHt9LFxuICAgICAgb25Ib2xkOiBmdW5jdGlvbiBvbkhvbGQoKSB7fSxcbiAgICAgIG9uRHJhZ1N0YXJ0OiBmdW5jdGlvbiBvbkRyYWdTdGFydCgpIHt9LFxuICAgICAgb25EcmFnOiBmdW5jdGlvbiBvbkRyYWcoKSB7fSxcbiAgICAgIG9uRHJhZ0VuZDogZnVuY3Rpb24gb25EcmFnRW5kKCkge30sXG4gICAgICBvbk1vdXNlV2hlZWw6IGZ1bmN0aW9uIG9uTW91c2VXaGVlbCgpIHt9LFxuICAgICAgb25QaW5jaDogZnVuY3Rpb24gb25QaW5jaCgpIHt9LFxuICAgICAgb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIG9uTW91c2VNb3ZlKCkge30sXG4gICAgICBvblJlbGVhc2U6IGZ1bmN0aW9uIG9uUmVsZWFzZSgpIHt9LFxuICAgICAgb25Db250ZXh0OiBmdW5jdGlvbiBvbkNvbnRleHQoKSB7fVxuICAgIH0sXG4gICAgZGF0YToge1xuICAgICAgbm9kZXM6IG51bGwsXG4gICAgICAvLyBBIERhdGFTZXQgb3IgRGF0YVZpZXdcbiAgICAgIGVkZ2VzOiBudWxsIC8vIEEgRGF0YVNldCBvciBEYXRhVmlld1xuICAgIH0sXG5cbiAgICBmdW5jdGlvbnM6IHtcbiAgICAgIGNyZWF0ZU5vZGU6IGZ1bmN0aW9uIGNyZWF0ZU5vZGUoKSB7fSxcbiAgICAgIGNyZWF0ZUVkZ2U6IGZ1bmN0aW9uIGNyZWF0ZUVkZ2UoKSB7fSxcbiAgICAgIGdldFBvaW50ZXI6IGZ1bmN0aW9uIGdldFBvaW50ZXIoKSB7fVxuICAgIH0sXG4gICAgbW9kdWxlczoge30sXG4gICAgdmlldzoge1xuICAgICAgc2NhbGU6IDEsXG4gICAgICB0cmFuc2xhdGlvbjoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9XG4gICAgfSxcbiAgICBzZWxlY3Rpb25Cb3g6IHtcbiAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gYmluZCB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gIHRoaXMuYmluZEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgLy8gc2V0dGluZyB1cCBhbGwgbW9kdWxlc1xuICB0aGlzLmltYWdlcyA9IG5ldyBJbWFnZXMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICB9KTsgLy8gb2JqZWN0IHdpdGggaW1hZ2VzXG4gIHRoaXMuZ3JvdXBzID0gbmV3IEdyb3VwcygpOyAvLyBvYmplY3Qgd2l0aCBncm91cHNcbiAgdGhpcy5jYW52YXMgPSBuZXcgQ2FudmFzKHRoaXMuYm9keSk7IC8vIERPTSBoYW5kbGVyXG4gIHRoaXMuc2VsZWN0aW9uSGFuZGxlciA9IG5ldyBTZWxlY3Rpb25IYW5kbGVyKHRoaXMuYm9keSwgdGhpcy5jYW52YXMpOyAvLyBTZWxlY3Rpb24gaGFuZGxlclxuICB0aGlzLmludGVyYWN0aW9uSGFuZGxlciA9IG5ldyBJbnRlcmFjdGlvbkhhbmRsZXIodGhpcy5ib2R5LCB0aGlzLmNhbnZhcywgdGhpcy5zZWxlY3Rpb25IYW5kbGVyKTsgLy8gSW50ZXJhY3Rpb24gaGFuZGxlciBoYW5kbGVzIGFsbCB0aGUgaGFtbWVyIGJpbmRpbmdzICh0aGF0IGFyZSBib3VuZCBieSBjYW52YXMpLCBrZXlcbiAgdGhpcy52aWV3ID0gbmV3IFZpZXcodGhpcy5ib2R5LCB0aGlzLmNhbnZhcyk7IC8vIGNhbWVyYSBoYW5kbGVyLCBkb2VzIGFuaW1hdGlvbnMgYW5kIHpvb21zXG4gIHRoaXMucmVuZGVyZXIgPSBuZXcgQ2FudmFzUmVuZGVyZXIodGhpcy5ib2R5LCB0aGlzLmNhbnZhcyk7IC8vIHJlbmRlcmVyLCBzdGFydHMgcmVuZGVybG9vcCwgaGFzIGV2ZW50cyB0aGF0IG1vZHVsZXMgY2FuIGhvb2sgaW50b1xuICB0aGlzLnBoeXNpY3MgPSBuZXcgUGh5c2ljc0VuZ2luZSh0aGlzLmJvZHkpOyAvLyBwaHlzaWNzIGVuZ2luZSwgZG9lcyBhbGwgdGhlIHNpbXVsYXRpb25zXG4gIHRoaXMubGF5b3V0RW5naW5lID0gbmV3IExheW91dEVuZ2luZSh0aGlzLmJvZHkpOyAvLyBsYXlvdXQgZW5naW5lIGZvciBpbml0YWwgbGF5b3V0IGFuZCBoaWVyYXJjaGljYWwgbGF5b3V0XG4gIHRoaXMuY2x1c3RlcmluZyA9IG5ldyBDbHVzdGVyRW5naW5lKHRoaXMuYm9keSk7IC8vIGNsdXN0ZXJpbmcgYXBpXG4gIHRoaXMubWFuaXB1bGF0aW9uID0gbmV3IE1hbmlwdWxhdGlvblN5c3RlbSh0aGlzLmJvZHksIHRoaXMuY2FudmFzLCB0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyKTsgLy8gZGF0YSBtYW5pcHVsYXRpb24gc3lzdGVtXG5cbiAgdGhpcy5ub2Rlc0hhbmRsZXIgPSBuZXcgTm9kZXNIYW5kbGVyKHRoaXMuYm9keSwgdGhpcy5pbWFnZXMsIHRoaXMuZ3JvdXBzLCB0aGlzLmxheW91dEVuZ2luZSk7IC8vIEhhbmRsZSBhZGRpbmcsIGRlbGV0aW5nIGFuZCB1cGRhdGluZyBvZiBub2RlcyBhcyB3ZWxsIGFzIGdsb2JhbCBvcHRpb25zXG4gIHRoaXMuZWRnZXNIYW5kbGVyID0gbmV3IEVkZ2VzSGFuZGxlcih0aGlzLmJvZHksIHRoaXMuaW1hZ2VzLCB0aGlzLmdyb3Vwcyk7IC8vIEhhbmRsZSBhZGRpbmcsIGRlbGV0aW5nIGFuZCB1cGRhdGluZyBvZiBlZGdlcyBhcyB3ZWxsIGFzIGdsb2JhbCBvcHRpb25zXG5cbiAgdGhpcy5ib2R5Lm1vZHVsZXNbXCJrYW1hZGFLYXdhaVwiXSA9IG5ldyBLYW1hZGFLYXdhaSh0aGlzLmJvZHksIDE1MCwgMC4wNSk7IC8vIExheW91dGluZyBhbGdvcml0aG0uXG4gIHRoaXMuYm9keS5tb2R1bGVzW1wiY2x1c3RlcmluZ1wiXSA9IHRoaXMuY2x1c3RlcmluZztcblxuICAvLyBjcmVhdGUgdGhlIERPTSBlbGVtZW50c1xuICB0aGlzLmNhbnZhcy5fY3JlYXRlKCk7XG5cbiAgLy8gYXBwbHkgb3B0aW9uc1xuICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgLy8gbG9hZCBkYXRhICh0aGUgZGlzYWJsZSBzdGFydCB2YXJpYWJsZSB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBlbmFibGVkIGNsdXN0ZXJpbmcpXG4gIHRoaXMuc2V0RGF0YShkYXRhKTtcbn1cblxuLy8gRXh0ZW5kIE5ldHdvcmsgd2l0aCBhbiBFbWl0dGVyIG1peGluXG5FbWl0dGVyKE5ldHdvcmsucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXQgb3B0aW9uc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKi9cbk5ldHdvcmsucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICB2YXIgX3RoaXMyID0gdGhpcztcbiAgaWYgKG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICBvcHRpb25zID0gdW5kZWZpbmVkOyAvLyBUaGlzIGVuc3VyZXMgdGhhdCBvcHRpb25zIGhhbmRsaW5nIGRvZXNuJ3QgY3Jhc2ggaW4gdGhlIGhhbmRsaW5nXG4gIH1cblxuICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGVycm9yRm91bmQgPSBWYWxpZGF0b3IudmFsaWRhdGUob3B0aW9ucywgYWxsT3B0aW9ucyk7XG4gICAgaWYgKGVycm9yRm91bmQgPT09IHRydWUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCIlY0Vycm9ycyBoYXZlIGJlZW4gZm91bmQgaW4gdGhlIHN1cHBsaWVkIG9wdGlvbnMgb2JqZWN0LlwiLCBWQUxJREFUT1JfUFJJTlRfU1RZTEUpO1xuICAgIH1cblxuICAgIC8vIGNvcHkgdGhlIGdsb2JhbCBmaWVsZHMgb3ZlclxuICAgIHZhciBmaWVsZHMgPSBbXCJsb2NhbGVcIiwgXCJsb2NhbGVzXCIsIFwiY2xpY2tUb1VzZVwiXTtcbiAgICBzZWxlY3RpdmVEZWVwRXh0ZW5kKGZpZWxkcywgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIC8vIG5vcm1hbGl6ZSB0aGUgbG9jYWxlIG9yIHVzZSBFbmdsaXNoXG4gICAgaWYgKG9wdGlvbnMubG9jYWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdGlvbnMubG9jYWxlID0gbm9ybWFsaXplTGFuZ3VhZ2VDb2RlKG9wdGlvbnMubG9jYWxlcyB8fCB0aGlzLm9wdGlvbnMubG9jYWxlcywgb3B0aW9ucy5sb2NhbGUpO1xuICAgIH1cblxuICAgIC8vIHRoZSBoaWVyYXJjaGljYWwgc3lzdGVtIGNhbiBhZGFwdCB0aGUgZWRnZXMgYW5kIHRoZSBwaHlzaWNzIHRvIGl0J3Mgb3duIG9wdGlvbnMgYmVjYXVzZSBub3QgYWxsIGNvbWJpbmF0aW9ucyB3b3JrIHdpdGggdGhlIGhpZXJhcmljaGljYWwgc3lzdGVtLlxuICAgIG9wdGlvbnMgPSB0aGlzLmxheW91dEVuZ2luZS5zZXRPcHRpb25zKG9wdGlvbnMubGF5b3V0LCBvcHRpb25zKTtcbiAgICB0aGlzLmNhbnZhcy5zZXRPcHRpb25zKG9wdGlvbnMpOyAvLyBvcHRpb25zIGZvciBjYW52YXMgYXJlIGluIGdsb2JhbHNcblxuICAgIC8vIHBhc3MgdGhlIG9wdGlvbnMgdG8gdGhlIG1vZHVsZXNcbiAgICB0aGlzLmdyb3Vwcy5zZXRPcHRpb25zKG9wdGlvbnMuZ3JvdXBzKTtcbiAgICB0aGlzLm5vZGVzSGFuZGxlci5zZXRPcHRpb25zKG9wdGlvbnMubm9kZXMpO1xuICAgIHRoaXMuZWRnZXNIYW5kbGVyLnNldE9wdGlvbnMob3B0aW9ucy5lZGdlcyk7XG4gICAgdGhpcy5waHlzaWNzLnNldE9wdGlvbnMob3B0aW9ucy5waHlzaWNzKTtcbiAgICB0aGlzLm1hbmlwdWxhdGlvbi5zZXRPcHRpb25zKG9wdGlvbnMubWFuaXB1bGF0aW9uLCBvcHRpb25zLCB0aGlzLm9wdGlvbnMpOyAvLyBtYW5pcHVsYXRpb24gdXNlcyB0aGUgbG9jYWxlcyBpbiB0aGUgZ2xvYmFsc1xuXG4gICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIuc2V0T3B0aW9ucyhvcHRpb25zLmludGVyYWN0aW9uKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldE9wdGlvbnMob3B0aW9ucy5pbnRlcmFjdGlvbik7IC8vIG9wdGlvbnMgZm9yIHJlbmRlcmluZyBhcmUgaW4gaW50ZXJhY3Rpb25cbiAgICB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2V0T3B0aW9ucyhvcHRpb25zLmludGVyYWN0aW9uKTsgLy8gb3B0aW9ucyBmb3Igc2VsZWN0aW9uIGFyZSBpbiBpbnRlcmFjdGlvblxuXG4gICAgLy8gcmVsb2FkIHRoZSBzZXR0aW5ncyBvZiB0aGUgbm9kZXMgdG8gYXBwbHkgY2hhbmdlcyBpbiBncm91cHMgdGhhdCBhcmUgbm90IHJlZmVyZW5jZWQgYnkgcG9pbnRlci5cbiAgICBpZiAob3B0aW9ucy5ncm91cHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlZnJlc2hOb2Rlc1wiKTtcbiAgICB9XG4gICAgLy8gdGhlc2UgdHdvIGRvIG5vdCBoYXZlIG9wdGlvbnMgYXQgdGhlIG1vbWVudCwgaGVyZSBmb3IgY29tcGxldGVuZXNzXG4gICAgLy90aGlzLnZpZXcuc2V0T3B0aW9ucyhvcHRpb25zLnZpZXcpO1xuICAgIC8vdGhpcy5jbHVzdGVyaW5nLnNldE9wdGlvbnMob3B0aW9ucy5jbHVzdGVyaW5nKTtcblxuICAgIGlmIChcImNvbmZpZ3VyZVwiIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmICghdGhpcy5jb25maWd1cmF0b3IpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0b3IgPSBuZXcgQ29uZmlndXJhdG9yKHRoaXMsIHRoaXMuYm9keS5jb250YWluZXIsIGNvbmZpZ3VyZU9wdGlvbnMsIHRoaXMuY2FudmFzLnBpeGVsUmF0aW8sIGNvbmZpZ3VyYXRvckhpZGVPcHRpb24pO1xuICAgICAgfVxuICAgICAgdGhpcy5jb25maWd1cmF0b3Iuc2V0T3B0aW9ucyhvcHRpb25zLmNvbmZpZ3VyZSk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGNvbmZpZ3VyYXRpb24gc3lzdGVtIGlzIGVuYWJsZWQsIGNvcHkgYWxsIG9wdGlvbnMgYW5kIHB1dCB0aGVtIGludG8gdGhlIGNvbmZpZyBzeXN0ZW1cbiAgICBpZiAodGhpcy5jb25maWd1cmF0b3IgJiYgdGhpcy5jb25maWd1cmF0b3Iub3B0aW9ucy5lbmFibGVkID09PSB0cnVlKSB7XG4gICAgICB2YXIgbmV0d29ya09wdGlvbnMgPSB7XG4gICAgICAgIG5vZGVzOiB7fSxcbiAgICAgICAgZWRnZXM6IHt9LFxuICAgICAgICBsYXlvdXQ6IHt9LFxuICAgICAgICBpbnRlcmFjdGlvbjoge30sXG4gICAgICAgIG1hbmlwdWxhdGlvbjoge30sXG4gICAgICAgIHBoeXNpY3M6IHt9LFxuICAgICAgICBnbG9iYWw6IHt9XG4gICAgICB9O1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5ub2RlcywgdGhpcy5ub2Rlc0hhbmRsZXIub3B0aW9ucyk7XG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmVkZ2VzLCB0aGlzLmVkZ2VzSGFuZGxlci5vcHRpb25zKTtcbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMubGF5b3V0LCB0aGlzLmxheW91dEVuZ2luZS5vcHRpb25zKTtcbiAgICAgIC8vIGxvYWQgdGhlIHNlbGVjdGlvbkhhbmRsZXIgYW5kIHJlbmRlciBkZWZhdWx0IG9wdGlvbnMgaW4gdG8gdGhlIGludGVyYWN0aW9uIGdyb3VwXG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmludGVyYWN0aW9uLCB0aGlzLnNlbGVjdGlvbkhhbmRsZXIub3B0aW9ucyk7XG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLmludGVyYWN0aW9uLCB0aGlzLnJlbmRlcmVyLm9wdGlvbnMpO1xuICAgICAgZGVlcEV4dGVuZChuZXR3b3JrT3B0aW9ucy5pbnRlcmFjdGlvbiwgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXIub3B0aW9ucyk7XG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLm1hbmlwdWxhdGlvbiwgdGhpcy5tYW5pcHVsYXRpb24ub3B0aW9ucyk7XG4gICAgICBkZWVwRXh0ZW5kKG5ldHdvcmtPcHRpb25zLnBoeXNpY3MsIHRoaXMucGh5c2ljcy5vcHRpb25zKTtcblxuICAgICAgLy8gbG9hZCBnbG9iYWxzIGludG8gdGhlIGdsb2JhbCBvYmplY3RcbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuZ2xvYmFsLCB0aGlzLmNhbnZhcy5vcHRpb25zKTtcbiAgICAgIGRlZXBFeHRlbmQobmV0d29ya09wdGlvbnMuZ2xvYmFsLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgdGhpcy5jb25maWd1cmF0b3Iuc2V0TW9kdWxlT3B0aW9ucyhuZXR3b3JrT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIG5ldHdvcmsgZ2xvYmFsIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucy5jbGlja1RvVXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChvcHRpb25zLmNsaWNrVG9Vc2UgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aGlzLmFjdGl2YXRvciA9IG5ldyBBY3RpdmF0b3IodGhpcy5jYW52YXMuZnJhbWUpO1xuICAgICAgICAgIHRoaXMuYWN0aXZhdG9yLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5ib2R5LmVtaXR0ZXIuZW1pdChcImFjdGl2YXRlXCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmF0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRoaXMuYWN0aXZhdG9yLmRlc3Ryb3koKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5hY3RpdmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcImFjdGl2YXRlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiYWN0aXZhdGVcIik7XG4gICAgfVxuICAgIHRoaXMuY2FudmFzLnNldFNpemUoKTtcbiAgICAvLyBzdGFydCB0aGUgcGh5c2ljcyBzaW11bGF0aW9uLiBDYW4gYmUgc2FmZWx5IGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cbiAgICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgdmlzaWJsZSBub2RlcyBhbmQgZWRnZXMgbGlzdCB3aXRoIHRoZSBtb3N0IHJlY2VudCBub2RlIHN0YXRlLlxuICpcbiAqIFZpc2libGUgbm9kZXMgYXJlIHN0b3JlZCBpbiB0aGlzLmJvZHkubm9kZUluZGljZXMuXG4gKiBWaXNpYmxlIGVkZ2VzIGFyZSBzdG9yZWQgaW4gdGhpcy5ib2R5LmVkZ2VJbmRpY2VzLlxuICogQSBub2RlIG9yIGVkZ2VzIGlzIHZpc2libGUgaWYgaXQgaXMgbm90IGhpZGRlbiBvciBjbHVzdGVyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuTmV0d29yay5wcm90b3R5cGUuX3VwZGF0ZVZpc2libGVJbmRpY2VzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZXMgPSB0aGlzLmJvZHkubm9kZXM7XG4gIHZhciBlZGdlcyA9IHRoaXMuYm9keS5lZGdlcztcbiAgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzID0gW107XG4gIHRoaXMuYm9keS5lZGdlSW5kaWNlcyA9IFtdO1xuICBmb3IgKHZhciBub2RlSWQgaW4gbm9kZXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGVzLCBub2RlSWQpKSB7XG4gICAgICBpZiAoIXRoaXMuY2x1c3RlcmluZy5faXNDbHVzdGVyZWROb2RlKG5vZGVJZCkgJiYgbm9kZXNbbm9kZUlkXS5vcHRpb25zLmhpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5ib2R5Lm5vZGVJbmRpY2VzLnB1c2gobm9kZXNbbm9kZUlkXS5pZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGVkZ2VJZCBpbiBlZGdlcykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZWRnZXMsIGVkZ2VJZCkpIHtcbiAgICAgIHZhciBlZGdlID0gZWRnZXNbZWRnZUlkXTtcblxuICAgICAgLy8gSXQgY2FuIGhhcHBlbiB0aGF0IHRoaXMgaXMgZXhlY3V0ZWQgKmFmdGVyKiBhIG5vZGUgZWRnZSBoYXMgYmVlbiByZW1vdmVkLFxuICAgICAgLy8gYnV0ICpiZWZvcmUqIHRoZSBlZGdlIGl0c2VsZiBoYXMgYmVlbiByZW1vdmVkLiBUYWtpbmcgdGhpcyBpbnRvIGFjY291bnQuXG4gICAgICB2YXIgZnJvbU5vZGUgPSBub2Rlc1tlZGdlLmZyb21JZF07XG4gICAgICB2YXIgdG9Ob2RlID0gbm9kZXNbZWRnZS50b0lkXTtcbiAgICAgIHZhciBlZGdlTm9kZXNQcmVzZW50ID0gZnJvbU5vZGUgIT09IHVuZGVmaW5lZCAmJiB0b05vZGUgIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBpc1Zpc2libGUgPSAhdGhpcy5jbHVzdGVyaW5nLl9pc0NsdXN0ZXJlZEVkZ2UoZWRnZUlkKSAmJiBlZGdlLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZSAmJiBlZGdlTm9kZXNQcmVzZW50ICYmIGZyb21Ob2RlLm9wdGlvbnMuaGlkZGVuID09PSBmYWxzZSAmJlxuICAgICAgLy8gQWxzbyBoaWRkZW4gaWYgYW55IG9mIGl0cyBjb25uZWN0aW5nIG5vZGVzIGFyZSBoaWRkZW5cbiAgICAgIHRvTm9kZS5vcHRpb25zLmhpZGRlbiA9PT0gZmFsc2U7IC8vIGlkZW1cblxuICAgICAgaWYgKGlzVmlzaWJsZSkge1xuICAgICAgICB0aGlzLmJvZHkuZWRnZUluZGljZXMucHVzaChlZGdlLmlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQmluZCBhbGwgZXZlbnRzXG4gKi9cbk5ldHdvcmsucHJvdG90eXBlLmJpbmRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF90aGlzMyA9IHRoaXM7XG4gIC8vIFRoaXMgZXZlbnQgd2lsbCB0cmlnZ2VyIGEgcmVidWlsZGluZyBvZiB0aGUgY2FjaGUgZXZlcnl0aGluZy5cbiAgLy8gVXNlZCB3aGVuIG5vZGVzIG9yIGVkZ2VzIGhhdmUgYmVlbiBhZGRlZCBvciByZW1vdmVkLlxuICB0aGlzLmJvZHkuZW1pdHRlci5vbihcIl9kYXRhQ2hhbmdlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgX3RoaXMzLmVkZ2VzSGFuZGxlci5fdXBkYXRlU3RhdGUoKTtcbiAgICBfdGhpczMuYm9keS5lbWl0dGVyLmVtaXQoXCJfZGF0YVVwZGF0ZWRcIik7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgY2FsbGVkIHdoZW4gb3B0aW9ucyBvZiBFWElTVElORyBub2RlcyBvciBlZGdlcyBoYXZlIGNoYW5nZWQuXG4gIHRoaXMuYm9keS5lbWl0dGVyLm9uKFwiX2RhdGFVcGRhdGVkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBPcmRlciBpbXBvcnRhbnQgaW4gZm9sbG93aW5nIGJsb2NrXG4gICAgX3RoaXMzLmNsdXN0ZXJpbmcuX3VwZGF0ZVN0YXRlKCk7XG4gICAgX3RoaXMzLl91cGRhdGVWaXNpYmxlSW5kaWNlcygpO1xuICAgIF90aGlzMy5fdXBkYXRlVmFsdWVSYW5nZShfdGhpczMuYm9keS5ub2Rlcyk7XG4gICAgX3RoaXMzLl91cGRhdGVWYWx1ZVJhbmdlKF90aGlzMy5ib2R5LmVkZ2VzKTtcbiAgICAvLyBzdGFydCBzaW11bGF0aW9uIChjYW4gYmUgY2FsbGVkIHNhZmVseSwgZXZlbiBpZiBhbHJlYWR5IHJ1bm5pbmcpXG4gICAgX3RoaXMzLmJvZHkuZW1pdHRlci5lbWl0KFwic3RhcnRTaW11bGF0aW9uXCIpO1xuICAgIF90aGlzMy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXF1ZXN0UmVkcmF3XCIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogU2V0IG5vZGVzIGFuZCBlZGdlcywgYW5kIG9wdGlvbmFsbHkgb3B0aW9ucyBhcyB3ZWxsLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhICAgICAgICAgICAgICBPYmplY3QgY29udGFpbmluZyBwYXJhbWV0ZXJzOlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheSB8IERhdGFTZXQgfCBEYXRhVmlld30gW25vZGVzXSBBcnJheSB3aXRoIG5vZGVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0FycmF5IHwgRGF0YVNldCB8IERhdGFWaWV3fSBbZWRnZXNdIEFycmF5IHdpdGggZWRnZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBbZG90XSBTdHJpbmcgY29udGFpbmluZyBkYXRhIGluIERPVCBmb3JtYXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7U3RyaW5nfSBbZ2VwaGldIFN0cmluZyBjb250YWluaW5nIGRhdGEgaW4gZ2VwaGkgSlNPTiBmb3JtYXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7T3B0aW9uc30gW29wdGlvbnNdIE9iamVjdCB3aXRoIG9wdGlvbnNcbiAqL1xuTmV0d29yay5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIC8vIHJlc2V0IHRoZSBwaHlzaWNzIGVuZ2luZS5cbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcInJlc2V0UGh5c2ljc1wiKTtcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9yZXNldERhdGFcIik7XG5cbiAgLy8gdW5zZWxlY3QgYWxsIHRvIGVuc3VyZSBubyBzZWxlY3Rpb25zIGZyb20gb2xkIGRhdGEgYXJlIGNhcnJpZWQgb3Zlci5cbiAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsKCk7XG4gIGlmIChkYXRhICYmIGRhdGEuZG90ICYmIChkYXRhLm5vZGVzIHx8IGRhdGEuZWRnZXMpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdEYXRhIG11c3QgY29udGFpbiBlaXRoZXIgcGFyYW1ldGVyIFwiZG90XCIgb3IgJyArICcgcGFyYW1ldGVyIHBhaXIgXCJub2Rlc1wiIGFuZCBcImVkZ2VzXCIsIGJ1dCBub3QgYm90aC4nKTtcbiAgfVxuXG4gIC8vIHNldCBvcHRpb25zXG4gIHRoaXMuc2V0T3B0aW9ucyhkYXRhICYmIGRhdGEub3B0aW9ucyk7XG4gIC8vIHNldCBhbGwgZGF0YVxuICBpZiAoZGF0YSAmJiBkYXRhLmRvdCkge1xuICAgIGNvbnNvbGUud2FybihcIlRoZSBkb3QgcHJvcGVydHkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgc3RhdGljIGNvbnZlcnREb3QgbWV0aG9kIHRvIGNvbnZlcnQgRE9UIGludG8gdmlzLm5ldHdvcmsgZm9ybWF0IGFuZCB1c2UgdGhlIG5vcm1hbCBkYXRhIGZvcm1hdCB3aXRoIG5vZGVzIGFuZCBlZGdlcy4gVGhpcyBjb252ZXJ0ZXIgaXMgdXNlZCBsaWtlIHRoaXM6IHZhciBkYXRhID0gdmlzLm5ldHdvcmsuY29udmVydERvdChkb3RTdHJpbmcpO1wiKTtcbiAgICAvLyBwYXJzZSBET1QgZmlsZVxuICAgIHZhciBkb3REYXRhID0gRE9UVG9HcmFwaChkYXRhLmRvdCk7XG4gICAgdGhpcy5zZXREYXRhKGRvdERhdGEpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChkYXRhICYmIGRhdGEuZ2VwaGkpIHtcbiAgICAvLyBwYXJzZSBET1QgZmlsZVxuICAgIGNvbnNvbGUud2FybihcIlRoZSBnZXBoaSBwcm9wZXJ0eSBoYXMgYmVlbiBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSBzdGF0aWMgY29udmVydEdlcGhpIG1ldGhvZCB0byBjb252ZXJ0IGdlcGhpIGludG8gdmlzLm5ldHdvcmsgZm9ybWF0IGFuZCB1c2UgdGhlIG5vcm1hbCBkYXRhIGZvcm1hdCB3aXRoIG5vZGVzIGFuZCBlZGdlcy4gVGhpcyBjb252ZXJ0ZXIgaXMgdXNlZCBsaWtlIHRoaXM6IHZhciBkYXRhID0gdmlzLm5ldHdvcmsuY29udmVydEdlcGhpKGdlcGhpSnNvbik7XCIpO1xuICAgIHZhciBnZXBoaURhdGEgPSBwYXJzZUdlcGhpKGRhdGEuZ2VwaGkpO1xuICAgIHRoaXMuc2V0RGF0YShnZXBoaURhdGEpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5vZGVzSGFuZGxlci5zZXREYXRhKGRhdGEgJiYgZGF0YS5ub2RlcywgdHJ1ZSk7XG4gICAgdGhpcy5lZGdlc0hhbmRsZXIuc2V0RGF0YShkYXRhICYmIGRhdGEuZWRnZXMsIHRydWUpO1xuICB9XG5cbiAgLy8gZW1pdCBjaGFuZ2UgaW4gZGF0YVxuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiX2RhdGFDaGFuZ2VkXCIpO1xuXG4gIC8vIGVtaXQgZGF0YSBsb2FkZWRcbiAgdGhpcy5ib2R5LmVtaXR0ZXIuZW1pdChcIl9kYXRhTG9hZGVkXCIpO1xuXG4gIC8vIGZpbmQgYSBzdGFibGUgcG9zaXRpb24gb3Igc3RhcnQgYW5pbWF0aW5nIHRvIGEgc3RhYmxlIHBvc2l0aW9uXG4gIHRoaXMuYm9keS5lbWl0dGVyLmVtaXQoXCJpbml0UGh5c2ljc1wiKTtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGFsbCBiaW5kaW5ncyBvZiB0aGUgbmV0d29yaywgcmVtb3ZpbmcgaXQgZnVsbHkgZnJvbSB0aGUgbWVtb3J5IElGIHRoZSB2YXJpYWJsZSBpcyBzZXQgdG8gbnVsbCBhZnRlciBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uXG4gKiB2YXIgbmV0d29yayA9IG5ldyB2aXMuTmV0d29yayguLik7XG4gKiBuZXR3b3JrLmRlc3Ryb3koKTtcbiAqIG5ldHdvcmsgPSBudWxsO1xuICovXG5OZXR3b3JrLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmJvZHkuZW1pdHRlci5lbWl0KFwiZGVzdHJveVwiKTtcbiAgLy8gY2xlYXIgZXZlbnRzXG4gIHRoaXMuYm9keS5lbWl0dGVyLm9mZigpO1xuICB0aGlzLm9mZigpO1xuXG4gIC8vIGRlbGV0ZSBtb2R1bGVzXG4gIGRlbGV0ZSB0aGlzLmdyb3VwcztcbiAgZGVsZXRlIHRoaXMuY2FudmFzO1xuICBkZWxldGUgdGhpcy5zZWxlY3Rpb25IYW5kbGVyO1xuICBkZWxldGUgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXI7XG4gIGRlbGV0ZSB0aGlzLnZpZXc7XG4gIGRlbGV0ZSB0aGlzLnJlbmRlcmVyO1xuICBkZWxldGUgdGhpcy5waHlzaWNzO1xuICBkZWxldGUgdGhpcy5sYXlvdXRFbmdpbmU7XG4gIGRlbGV0ZSB0aGlzLmNsdXN0ZXJpbmc7XG4gIGRlbGV0ZSB0aGlzLm1hbmlwdWxhdGlvbjtcbiAgZGVsZXRlIHRoaXMubm9kZXNIYW5kbGVyO1xuICBkZWxldGUgdGhpcy5lZGdlc0hhbmRsZXI7XG4gIGRlbGV0ZSB0aGlzLmNvbmZpZ3VyYXRvcjtcbiAgZGVsZXRlIHRoaXMuaW1hZ2VzO1xuICBmb3IgKHZhciBub2RlSWQgaW4gdGhpcy5ib2R5Lm5vZGVzKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5ib2R5Lm5vZGVzLCBub2RlSWQpKSBjb250aW51ZTtcbiAgICBkZWxldGUgdGhpcy5ib2R5Lm5vZGVzW25vZGVJZF07XG4gIH1cbiAgZm9yICh2YXIgZWRnZUlkIGluIHRoaXMuYm9keS5lZGdlcykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYm9keS5lZGdlcywgZWRnZUlkKSkgY29udGludWU7XG4gICAgZGVsZXRlIHRoaXMuYm9keS5lZGdlc1tlZGdlSWRdO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHRoZSBjb250YWluZXIgYW5kIGV2ZXJ5dGhpbmcgaW5zaWRlIGl0IHJlY3Vyc2l2ZWx5XG4gIHJlY3Vyc2l2ZURPTURlbGV0ZSh0aGlzLmJvZHkuY29udGFpbmVyKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSB2YWx1ZXMgb2YgYWxsIG9iamVjdCBpbiB0aGUgZ2l2ZW4gYXJyYXkgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50XG4gKiB2YWx1ZSByYW5nZSBvZiB0aGUgb2JqZWN0cyBpbiB0aGUgYXJyYXkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9iaiAgICBBbiBvYmplY3QgY29udGFpbmluZyBhIHNldCBvZiBFZGdlcyBvciBOb2Rlc1xuICogICAgICAgICAgICAgICAgICAgICAgICBUaGUgb2JqZWN0cyBtdXN0IGhhdmUgYSBtZXRob2QgZ2V0VmFsdWUoKSBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWVSYW5nZShtaW4sIG1heCkuXG4gKiBAcHJpdmF0ZVxuICovXG5OZXR3b3JrLnByb3RvdHlwZS5fdXBkYXRlVmFsdWVSYW5nZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGlkO1xuXG4gIC8vIGRldGVybWluZSB0aGUgcmFuZ2Ugb2YgdGhlIG9iamVjdHNcbiAgdmFyIHZhbHVlTWluID0gdW5kZWZpbmVkO1xuICB2YXIgdmFsdWVNYXggPSB1bmRlZmluZWQ7XG4gIHZhciB2YWx1ZVRvdGFsID0gMDtcbiAgZm9yIChpZCBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaWQpKSB7XG4gICAgICB2YXIgdmFsdWUgPSBvYmpbaWRdLmdldFZhbHVlKCk7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZU1pbiA9IHZhbHVlTWluID09PSB1bmRlZmluZWQgPyB2YWx1ZSA6IE1hdGgubWluKHZhbHVlLCB2YWx1ZU1pbik7XG4gICAgICAgIHZhbHVlTWF4ID0gdmFsdWVNYXggPT09IHVuZGVmaW5lZCA/IHZhbHVlIDogTWF0aC5tYXgodmFsdWUsIHZhbHVlTWF4KTtcbiAgICAgICAgdmFsdWVUb3RhbCArPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBhZGp1c3QgdGhlIHJhbmdlIG9mIGFsbCBvYmplY3RzXG4gIGlmICh2YWx1ZU1pbiAhPT0gdW5kZWZpbmVkICYmIHZhbHVlTWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICBmb3IgKGlkIGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGlkKSkge1xuICAgICAgICBvYmpbaWRdLnNldFZhbHVlUmFuZ2UodmFsdWVNaW4sIHZhbHVlTWF4LCB2YWx1ZVRvdGFsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIE5ldHdvcmsgaXMgYWN0aXZlLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5OZXR3b3JrLnByb3RvdHlwZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICF0aGlzLmFjdGl2YXRvciB8fCB0aGlzLmFjdGl2YXRvci5hY3RpdmU7XG59O1xuTmV0d29yay5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2FudmFzLnNldFNpemUuYXBwbHkodGhpcy5jYW52YXMsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuY2FudmFzVG9ET00gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNhbnZhcy5jYW52YXNUb0RPTS5hcHBseSh0aGlzLmNhbnZhcywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5ET010b0NhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2FudmFzLkRPTXRvQ2FudmFzLmFwcGx5KHRoaXMuY2FudmFzLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBOb2RlcyBjYW4gYmUgaW4gY2x1c3RlcnMuIENsdXN0ZXJzIGNhbiBhbHNvIGJlIGluIGNsdXN0ZXJzLiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYW5kIGFycmF5IG9mXG4gKiBub2RlSWRzIHNob3dpbmcgd2hlcmUgdGhlIG5vZGUgaXMuXG4gKlxuICogSWYgYW55IG5vZGVJZCBpbiB0aGUgY2hhaW4sIGVzcGVjaWFsbHkgdGhlIGZpcnN0IHBhc3NlZCBpbiBhcyBhIHBhcmFtZXRlciwgaXMgbm90IHByZXNlbnQgaW5cbiAqIHRoZSBjdXJyZW50IG5vZGVzIGxpc3QsIGFuIGVtcHR5IGFycmF5IGlzIHJldHVybmVkLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBjbHVzdGVyICdBJyBjb250YWlucyBjbHVzdGVyICdCJyxcbiAqIGNsdXN0ZXIgJ0InIGNvbnRhaW5zIGNsdXN0ZXIgJ0MnLFxuICogY2x1c3RlciAnQycgY29udGFpbnMgbm9kZSAnZnJlZCcuXG4gKiBganNuZXR3b3JrLmNsdXN0ZXJpbmcuZmluZE5vZGUoJ2ZyZWQnKWAgd2lsbCByZXR1cm4gYFsnQScsJ0InLCdDJywnZnJlZCddYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5vZGVJZFxuICogQHJldHVybnMge0FycmF5fVxuICovXG5OZXR3b3JrLnByb3RvdHlwZS5maW5kTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5maW5kTm9kZS5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuaXNDbHVzdGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmlzQ2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUub3BlbkNsdXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcub3BlbkNsdXN0ZXIuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmNsdXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3Rlci5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0Tm9kZXNJbkNsdXN0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuZ2V0Tm9kZXNJbkNsdXN0ZXIuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmNsdXN0ZXJCeUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3RlckJ5Q29ubmVjdGlvbi5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuY2x1c3RlckJ5SHVic2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5jbHVzdGVyQnlIdWJzaXplLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS51cGRhdGVDbHVzdGVyZWROb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLnVwZGF0ZUNsdXN0ZXJlZE5vZGUuYXBwbHkodGhpcy5jbHVzdGVyaW5nLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldENsdXN0ZXJlZEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmdldENsdXN0ZXJlZEVkZ2VzLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXRCYXNlRWRnZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy5nZXRCYXNlRWRnZS5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0QmFzZUVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jbHVzdGVyaW5nLmdldEJhc2VFZGdlcy5hcHBseSh0aGlzLmNsdXN0ZXJpbmcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUudXBkYXRlRWRnZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY2x1c3RlcmluZy51cGRhdGVFZGdlLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgd2lsbCBjbHVzdGVyIGFsbCBub2RlcyB3aXRoIDEgZWRnZSB3aXRoIHRoZWlyIHJlc3BlY3RpdmUgY29ubmVjdGVkIG5vZGUuXG4gKiBUaGUgb3B0aW9ucyBvYmplY3QgaXMgZXhwbGFpbmVkIGluIGZ1bGwgPGEgZGF0YS1zY3JvbGw9XCJcIiBkYXRhLW9wdGlvbnM9XCJ7ICZxdW90O2Vhc2luZyZxdW90OzogJnF1b3Q7ZWFzZUluQ3ViaWMmcXVvdDsgfVwiIGhyZWY9XCIjb3B0aW9uc09iamVjdFwiPmJlbG93PC9hPi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5OZXR3b3JrLnByb3RvdHlwZS5jbHVzdGVyT3V0bGllcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmNsdXN0ZXJpbmcuY2x1c3Rlck91dGxpZXJzLmFwcGx5KHRoaXMuY2x1c3RlcmluZywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXRTZWVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5sYXlvdXRFbmdpbmUuZ2V0U2VlZC5hcHBseSh0aGlzLmxheW91dEVuZ2luZSwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5lbmFibGVFZGl0TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVuYWJsZUVkaXRNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmRpc2FibGVFZGl0TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmRpc2FibGVFZGl0TW9kZS5hcHBseSh0aGlzLm1hbmlwdWxhdGlvbiwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5hZGROb2RlTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmFkZE5vZGVNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmVkaXROb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZWRpdE5vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZWRpdE5vZGVNb2RlID0gZnVuY3Rpb24gKCkge1xuICBjb25zb2xlLndhcm4oXCJEZXByZWNhdGVkOiBQbGVhc2UgdXNlIGVkaXROb2RlIGluc3RlYWQgb2YgZWRpdE5vZGVNb2RlLlwiKTtcbiAgcmV0dXJuIHRoaXMubWFuaXB1bGF0aW9uLmVkaXROb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmFkZEVkZ2VNb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uYWRkRWRnZU1vZGUuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZWRpdEVkZ2VNb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZWRpdEVkZ2VNb2RlLmFwcGx5KHRoaXMubWFuaXB1bGF0aW9uLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmRlbGV0ZVNlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5tYW5pcHVsYXRpb24uZGVsZXRlU2VsZWN0ZWQuYXBwbHkodGhpcy5tYW5pcHVsYXRpb24sIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0UG9zaXRpb25zID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0UG9zaXRpb25zLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0UG9zaXRpb24uYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuc3RvcmVQb3NpdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5zdG9yZVBvc2l0aW9ucy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5tb3ZlTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLm1vdmVOb2RlLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ub2Rlc0hhbmRsZXIuZ2V0Qm91bmRpbmdCb3guYXBwbHkodGhpcy5ub2Rlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0Q29ubmVjdGVkTm9kZXMgPSBmdW5jdGlvbiAob2JqZWN0SWQpIHtcbiAgaWYgKHRoaXMuYm9keS5ub2Rlc1tvYmplY3RJZF0gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzSGFuZGxlci5nZXRDb25uZWN0ZWROb2Rlcy5hcHBseSh0aGlzLm5vZGVzSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlc0hhbmRsZXIuZ2V0Q29ubmVjdGVkTm9kZXMuYXBwbHkodGhpcy5lZGdlc0hhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIH1cbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXRDb25uZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZXNIYW5kbGVyLmdldENvbm5lY3RlZEVkZ2VzLmFwcGx5KHRoaXMubm9kZXNIYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLnN0YXJ0U2ltdWxhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucGh5c2ljcy5zdGFydFNpbXVsYXRpb24uYXBwbHkodGhpcy5waHlzaWNzLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLnN0b3BTaW11bGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5waHlzaWNzLnN0b3BTaW11bGF0aW9uLmFwcGx5KHRoaXMucGh5c2ljcywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5zdGFiaWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnBoeXNpY3Muc3RhYmlsaXplLmFwcGx5KHRoaXMucGh5c2ljcywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0U2VsZWN0aW9uLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5zZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2V0U2VsZWN0aW9uLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXRTZWxlY3RlZE5vZGVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldFNlbGVjdGVkTm9kZUlkcy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uSGFuZGxlci5nZXRTZWxlY3RlZEVkZ2VJZHMuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldE5vZGVBdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuZ2V0Tm9kZUF0LmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiBub2RlLmlkICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbm9kZS5pZDtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5nZXRFZGdlQXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBlZGdlID0gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmdldEVkZ2VBdC5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIsIGFyZ3VtZW50cyk7XG4gIGlmIChlZGdlICE9PSB1bmRlZmluZWQgJiYgZWRnZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGVkZ2UuaWQ7XG4gIH1cbiAgcmV0dXJuIGVkZ2U7XG59O1xuTmV0d29yay5wcm90b3R5cGUuc2VsZWN0Tm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNlbGVjdGlvbkhhbmRsZXIuc2VsZWN0Tm9kZXMuYXBwbHkodGhpcy5zZWxlY3Rpb25IYW5kbGVyLCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLnNlbGVjdEVkZ2VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnNlbGVjdEVkZ2VzLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS51bnNlbGVjdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLnVuc2VsZWN0QWxsLmFwcGx5KHRoaXMuc2VsZWN0aW9uSGFuZGxlciwgYXJndW1lbnRzKTtcbiAgdGhpcy5zZWxlY3Rpb25IYW5kbGVyLmNvbW1pdFdpdGhvdXRFbWl0dGluZy5hcHBseSh0aGlzLnNlbGVjdGlvbkhhbmRsZXIpO1xuICB0aGlzLnJlZHJhdygpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLnJlZHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucmVuZGVyZXIucmVkcmF3LmFwcGx5KHRoaXMucmVuZGVyZXIsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0U2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZpZXcuZ2V0U2NhbGUuYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmdldFZpZXdQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmlldy5nZXRWaWV3UG9zaXRpb24uYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmZpdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmlldy5maXQuYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmlldy5tb3ZlVG8uYXBwbHkodGhpcy52aWV3LCBhcmd1bWVudHMpO1xufTtcbk5ldHdvcmsucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52aWV3LmZvY3VzLmFwcGx5KHRoaXMudmlldywgYXJndW1lbnRzKTtcbn07XG5OZXR3b3JrLnByb3RvdHlwZS5yZWxlYXNlTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudmlldy5yZWxlYXNlTm9kZS5hcHBseSh0aGlzLnZpZXcsIGFyZ3VtZW50cyk7XG59O1xuTmV0d29yay5wcm90b3R5cGUuZ2V0T3B0aW9uc0Zyb21Db25maWd1cmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcHRpb25zID0ge307XG4gIGlmICh0aGlzLmNvbmZpZ3VyYXRvcikge1xuICAgIG9wdGlvbnMgPSB0aGlzLmNvbmZpZ3VyYXRvci5nZXRPcHRpb25zLmFwcGx5KHRoaXMuY29uZmlndXJhdG9yKTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn07XG5cbnZhciBwYXJzZURPVE5ldHdvcmsgPSBET1RUb0dyYXBoO1xuLy8gRGF0YVNldCwgdXRpbHMgZXRjLiBjYW4ndCBiZSByZWV4cG9ydGVkIGhlcmUgYmVjYXVzZSB0aGF0IHdvdWxkIGNhdXNlIHN0YWNrXG4vLyBvdmVyZmxvdyBpbiBVTUQgYnVpbGRzLiBUaGV5IGFsbCBleHBvcnQgdmlzIG5hbWVzcGFjZSB0aGVyZWZvcmUgcmVleHBvcnRpbmdcbi8vIGxlYWRzIHRvIGxvYWRpbmcgdmlzIHRvIGxvYWQgdmlzIHRvIGxvYWQgdmlz4oCmXG5cbmV4cG9ydCB7IE5ldHdvcmssIEltYWdlcyBhcyBOZXR3b3JrSW1hZ2VzLCBkb3RwYXJzZXIgYXMgbmV0d29ya0RPVFBhcnNlciwgZ2VwaGlQYXJzZXIgYXMgbmV0d29ya0dlcGhpUGFyc2VyLCBvcHRpb25zIGFzIG5ldHdvcmtPcHRpb25zLCBwYXJzZURPVE5ldHdvcmssIHBhcnNlR2VwaGkgYXMgcGFyc2VHZXBoaU5ldHdvcmsgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpcy1uZXR3b3JrLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/vis-network/peer/esm/vis-network.js\n");

/***/ })

};
;